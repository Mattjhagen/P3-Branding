{"version":3,"mappings":"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","names":["parseAbiItem","signature","abiItem","parseSignature","structs","parseStructs","length","i","signature_","isStructSignature","InvalidAbiItemError","parseAbiParameters","params","abiParameters","parameters","splitParameters","parseAbiParameter_","modifiers","k","InvalidAbiParametersError","FilterTypeNotSupportedError","BaseError","type","docsPath","encodeEventTopics","abi","eventName","args","item","getAbiItem","AbiEventNotFoundError","definition","formatAbiItem","toEventSelector","topics","indexedInputs","_a","param","args_","x","_","j","encodeArg","value","keccak256","toBytes","encodeAbiParameters","createFilterRequestScope","client","method","requestMap","_b","method_","id","status","transport","createContractEventFilter","address","fromBlock","strict","toBlock","getRequest","numberToHex","publicKeyToAddress","publicKey","checksumAddress","recoverPublicKey","hash","hashHex","isHex","toHex","secp256k1","__vitePreload","secp256k1$1","r","s","v","yParity","yParityOrV","recoveryBit","toRecoveryBit","hexToBigInt","signatureHex","size","hexToNumber","recoverAddress","hashAuthorization","chainId","nonce","to","concatHex","toRlp","hexToBytes","recoverAuthorizationAddress","authorization","EstimateGasExecutionError","cause","account","chain","data","gas","gasPrice","maxFeePerGas","maxPriorityFeePerGas","prettyArgs","prettyPrint","formatEther","formatGwei","getEstimateGasError","err","getNodeError","UnknownNodeError","BaseFeeScalarError","Eip1559FeesNotSupportedError","MaxFeePerGasTooLowError","BlockNotFoundError","blockHash","blockNumber","identifier","getBlock","blockTag","includeTransactions_","includeTransactions","blockNumberHex","block","_c","formatBlock","getGasPrice","estimateMaxPriorityFeePerGas","internal_estimateMaxPriorityFeePerGas","block_","request","getAction","maxPriorityFeePerGas_","maxPriorityFeePerGasHex","estimateFeesPerGas","internal_estimateFeesPerGas","baseFeeMultiplier","denominator","multiply","base","fees","baseFeePerGas","getTransactionCount","count","getChainId","chainIdHex","defaultParameters","eip1559NetworkCache","prepareTransactionRequest","account_","blobs","kzg","nonceManager","parseAccount","getBlock_","getChainId_","commitments","blobsToCommitments","versionedHashes","commitmentsToVersionedHashes","proofs","blobsToProofs","sidecars","toBlobSidecars","getTransactionType","isEip1559Network","gasPrice_","estimateGas","assertRequest","accessList","authorizationList","blobVersionedHashes","maxFeePerBlobGas","stateOverride","rest","rpcStateOverride","serializeStateOverride","chainFormat","formatTransactionRequest","extract","estimateContractGas","functionName","dataSuffix","encodeFunctionData","error","getContractError","decodeEventLog","strict_","argTopics","AbiEventSignatureEmptyTopicsError","AbiEventSignatureNotFoundError","name","inputs","isUnnamed","argIndex","topic","DecodeLogTopicsMismatch","decodeTopic","nonIndexedInputs","decodedData","decodeAbiParameters","AbiDecodingDataSizeTooSmallError","PositionOutOfBoundsError","DecodeLogDataMismatch","parseEventLogs","logs","log","event","includesArgs","matchArgs","isEqual","input","arg","isAddressEqual","index","key","getLogs","events_","events","formattedLogs","formatLog","getContractEvents","_0n","_1n","isBytes","a","abytes","abool","title","numberToHexUnpadded","num","hex","hasHexBuiltin","hexes","bytesToHex","bytes","asciis","asciiToBase16","ch","hl","al","array","ai","hi","n1","n2","char","bytesToNumberBE","bytesToNumberLE","numberToBytesBE","n","len","numberToBytesLE","ensureBytes","expectedLength","res","e","concatBytes","arrays","sum","pad","isPosBig","inRange","min","max","aInRange","bitLen","bitMask","u8n","u8fr","arr","createHmacDrbg","hashLen","qByteLen","hmacFn","reset","h","b","reseed","seed","gen","out","sl","pred","validatorFns","val","object","validateObject","validators","optValidators","checkField","fieldName","isOptional","checkVal","memoized","fn","map","computed","assertSize","size_","Bytes.size","Bytes.SizeOverflowError","charCodeMap","charCodeToBase16","options","dir","Bytes.SizeExceedsPaddingSizeError","paddedBytes","padEnd","trim","sliceLength","decoder","encoder","from","fromHex","fromArray","internal_hex.assertSize","Hex.padRight","hexString","nibbleLeft","internal.charCodeToBase16","nibbleRight","Errors.BaseError","fromString","internal.assertSize","padRight","internal.pad","slice","start","end","toBigInt","Hex.fromBytes","Hex.toBigInt","toBoolean","bytes_","trimLeft","InvalidBytesBooleanError","toNumber","Hex.toNumber","toString","trimRight","internal.trim","SizeOverflowError","givenSize","maxSize","SizeExceedsPaddingSizeError","targetSize","simulateContract","callRequest","calldata","call","result","decodeFunctionResult","minimizedAbi","listenersCache","cleanupCache","callbackCount","observe","observerId","callbacks","callbackId","getListeners","unsubscribe","listeners","cb","unwatch","cleanup","p","emit","listener","poll","emitOnBegin","initialWaitTime","interval","active","initialWait","wait","promiseCache","responseCache","getCache","cacheKey","buildCache","cache","promise","response","withCache","cacheTime","getBlockNumber","getFilterChanges","_client","filter","uninstallFilter","watchContractEvent","batch","onError","onLogs","poll_","pollingInterval","stringify","previousBlockNumber","initialized","InvalidInputRpcError","unsubscribe_","formatted","sendRawTransaction","serializedTransaction","isNullUniversalResolverError","ContractFunctionRevertedError","_d","_e","_f","encodedLabelToLabelhash","label","namehash","labels","hashFromEncodedLabel","hashed","stringToBytes","concat","encodeLabelhash","labelhash","packetToBytes","packet","offset","list","encoded","getEnsAddress","coinType","gatewayUrls","universalResolverAddress","getChainContractAddress","tlds","tld","functionData","addressResolverAbi","readContractParameters","universalResolverResolveAbi","localBatchGatewayUrl","readContract","EnsAvatarInvalidMetadataError","EnsAvatarInvalidNftUriError","reason","EnsAvatarUriResolutionError","uri","EnsAvatarUnsupportedNamespaceError","namespace","networkRegex","ipfsHashRegex","base64Regex","dataURIRegex","isImageUri","contentType","resolve","img","getGateway","custom","defaultGateway","resolveAvatarUri","isEncoded","ipfsGateway","arweaveGateway","networkRegexMatch","protocol","subpath","target","subtarget","isIPNS","isIPFS","replacedUri","parsedUri","getJsonImage","getMetadataAvatarUri","parseAvatarUri","resolvedURI","isOnChain","parseNftUri","uri_","reference","asset_namespace","tokenID","eip_namespace","chainID","erc_namespace","contractAddress","getNftTokenUri","nft","parseAvatarRecord","record","parseNftAvatarUri","nftUri","resolvedNftUri","encodedJson","decoded","uriTokenId","getEnsText","textResolverAbi","getEnsAvatar","assetGatewayUrls","getEnsName","universalResolverReverseAbi","readContractAction","getEnsResolver","resolverAddress","createAccessList","getCallError","createBlockFilter","createEventFilter","createPendingTransactionFilter","getBlobBaseFee","baseFee","getBlockTransactionCount","getCode","Eip712DomainNotFoundError","getEip712Domain","factory","factoryData","fields","version","verifyingContract","salt","extensions","formatFeeHistory","feeHistory","reward","getFeeHistory","blockCount","rewardPercentiles","getFilterLogs","verifyAuthorization","getAddress","presignMessagePrefix","toPrefixedMessage","message_","message","stringToHex","prefix","hashMessage","to_","InvalidDomainError","domain","InvalidPrimaryTypeError","primaryType","types","InvalidStructTypeError","validateTypedData","validateData","struct","integerMatch","integerRegex","_type","isAddress","InvalidAddressError","bytesMatch","bytesRegex","BytesSizeMismatchError","validateReference","getTypesForEIP712Domain","hashTypedData","parts","hashDomain","hashStruct","encodeData","encodedTypes","encodedValues","hashType","field","encodeField","encodedHashType","encodeType","unsortedDeps","findTypeDependencies","deps","t","primaryType_","results","match","parsedType","typeValuePairs","LruMap","firstKey","caches","checksum","as","noble_keccak256","Bytes.from","addressRegex","assert","InvalidInputError","InvalidChecksumError","Caches.checksum","hexAddress","Hash.keccak256","Bytes.fromString","characters","validate","arrayRegex","maxUint256","decodeParameter","cursor","staticPosition","arrayComponents","getArrayComponents","decodeArray","decodeTuple","decodeAddress","decodeBool","decodeBytes","decodeNumber","decodeString","AbiParameters.InvalidTypeError","sizeOfLength","sizeOfOffset","Address.checksum","Bytes.slice","Bytes.toNumber","startOfData","dynamicChild","hasDynamicChild","consumed","consumed_","Bytes.toBoolean","signed","Bytes.toBigInt","hasUnnamedChild","component","Bytes.toString","Bytes.trimLeft","prepareParameters","values","preparedParameters","prepareParameter","parameter_","parameter","encodeArray","encodeTuple","encodeAddress","encodeBoolean","encodeNumber","encodeBytes","encodeString","encode","staticSize","dynamic","Hex.size","staticParameters","dynamicParameters","dynamicSize","Hex.fromNumber","Hex.concat","Address.assert","Hex.padLeft","AbiParameters.InvalidArrayError","AbiParameters.ArrayLengthMismatchError","preparedParam","parametersize","bytesSize","value_","AbiParameters.BytesSizeMismatchError","Hex.fromBoolean","Hex.IntegerOutOfRangeError","hexValue","Hex.fromString","partsLength","Hex.slice","param_","matches","staticCursor","RecursiveReadLimitExceededError","position","NegativeOffsetError","position_","byte","oldPosition","create","recursiveReadLimit","limit","decode","Bytes.fromHex","Cursor.create","ZeroDataError","DataSizeTooSmallError","internal.decodeParameter","LengthMismatchError","internal.prepareParameters","internal.encode","encodePacked","isArray","intMatch","Solidity.integerRegex","baseType","bits","Solidity.bytesRegex","arrayMatch","Solidity.arrayRegex","childType","InvalidTypeError","abitype.parseAbiParameters","abitype.formatAbiParameters","ArrayLengthMismatchError","givenLength","expectedSize","InvalidArrayError","HMAC","Hash","_key","ahash","blockLen","clean","buf","aexists","oHash","iHash","finished","destroyed","outputLen","hmac","_2n","_3n","_4n","_5n","_8n","mod","pow2","power","modulo","invert","number","u","q","m","sqrt3mod4","Fp","p1div4","root","sqrt5mod8","p5div8","nv","tonelliShanks","P","Q","S","Z","_Fp","Field","FpLegendre","cc","Q1div2","M","c","R","t_tmp","exponent","FpSqrt","FIELD_FIELDS","validateField","initial","opts","FpPow","d","FpInvertBatch","nums","passZero","inverted","multipliedAcc","acc","invertedAcc","p1mod2","powered","yes","zero","no","nLength","nBitLength","anumber","_nBitLength","nByteLength","ORDER","isLE","redef","BITS","BYTES","sqrtP","f","lhs","rhs","lst","getFieldBytesLength","fieldOrder","bitLength","getMinHashLength","mapHashToField","fieldLen","minLen","reduced","constTimeNegate","condition","neg","validateW","W","calcWOpts","scalarBits","windows","windowSize","maxNumber","mask","shiftBy","calcOffsets","window","wOpts","wbits","nextN","offsetStart","isZero","isNeg","isNegF","validateMSMPoints","points","validateMSMScalars","scalars","pointPrecomputes","pointWindowSizes","getW","wNAF","elm","precomputes","wo","offsetF","transform","comp","prev","pippenger","fieldN","plength","slength","MASK","buckets","lastBits","scalar","resI","sumI","validateBasic","curve","validateSigVerOpts","validatePointOpts","endo","DERErr","DER","tag","E","dataLen","lenLen","pos","first","isLong","lengthBytes","int","tlv","seqBytes","seqLeftBytes","rBytes","rLeftBytes","sBytes","sLeftBytes","sig","rs","ss","seq","numToSizedHex","weierstrassPoints","CURVE","Fn","point","_isCompressed","fromBytes","tail","y","weierstrassEquation","x2","x3","isValidXY","left","right","_4a3","_27b2","isWithinCurveOrder","normPrivateKeyToScalar","lengths","wrapPrivateKey","N","aprjpoint","other","Point","toAffineMemo","iz","z","is0","ax","ay","zz","assertValidMemo","px","py","pz","toInv","privateKey","wnaf","X1","Y1","Z1","X2","Y2","Z2","U1","U2","b3","X3","Y3","Z3","t0","t1","t2","t3","t4","t5","sc","I","k1neg","k1","k2neg","k2","k1p","k2p","fake","f1p","f2p","G","mul","cofactor","isTorsionFree","clearCofactor","isCompressed","validateOpts","weierstrass","curveDef","CURVE_ORDER","compressedLen","uncompressedLen","modN","invN","cat","head","y2","sqrtError","suffix","isYOdd","cl","ul","isBiggerThanHalfOrder","HALF","normalizeS","slcNum","Signature","recovery","l","msgHash","rec","bits2int_modN","radj","ir","u1","u2","utils","getPublicKey","isProbPub","fpl","compLen","uncompLen","getSharedSecret","privateA","publicB","bits2int","delta","ORDER_MASK","int2octets","prepSig","defaultSigOpts","randomBytes","lowS","prehash","ent","h1int","seedArgs","k2sig","kBytes","ik","normS","defaultVerOpts","sign","privKey","C","verify","sg","format","isObj","_sig","derError","is","getHash","msgs","createCurve","defHash","secp256k1P","secp256k1N","divNearest","sqrtMod","_6n","_11n","_22n","_23n","_44n","_88n","b2","b6","b9","b11","b22","b44","b88","b176","b220","b223","Fpk1","a1","b1","a2","POW_2_128","c1","c2","sha256","recovered","MissingPropertiesError","Solidity.maxUint256","InvalidRError","InvalidSError","InvalidYParityError","InvalidSerializedSizeError","vToYParity","fromRpc","fromLegacy","InvalidVError","Hex.from","Json.stringify","Signature.extract","magicBytes","suffixParameters","AbiParameters.from","InvalidWrappedSignatureError","Signature.assert","unwrap","wrapped","suffixLength","auth","AbiParameters.decode","Authorization.from","formatStorageProof","storageProof","proof","formatProof","getProof","blockTag_","storageKeys","getStorageAt","slot","getTransaction","transaction","TransactionNotFoundError","formatTransaction","getTransactionConfirmations","transactionReceipt","transactionBlockNumber","getTransactionReceipt","receipt","TransactionReceiptNotFoundError","formatTransactionReceipt","simulateBlocks","blocks","returnFullTransactions","traceTransfers","validation","blockStateCalls","blockOverrides","BlockOverrides.toRpc","calls","call_","stateOverrides","gasUsed","AbiDecodingZeroDataError","RawContractError","normalizeSignature","current","level","valid","isArgOfType","abiParameter","argType","abiParameterType","Address.validate","getAmbiguousTypes","sourceParameters","targetParameters","parameterIndex","sourceParameter","targetParameter","prepare","abitype.parseAbiItem","getSignatureHash","fromAbi","isSelector","Hex.validate","abiItems","getSelector","NotFoundError","matchedAbiItem","internal.isArgOfType","ambiguousTypes","internal.getAmbiguousTypes","AmbiguityError","overloads","getSignature","abitype.formatAbiItem","internal.normalizeSignature","selector","abiConstructor","bytecode","AbiParameters.encode","AbiItem.from","AbiItem.NotFoundError","abiFunction","AbiItem.fromAbi","AbiItem.getSelector","ethAddress","zeroAddress","getBalanceCode","simulateCalls","traceAssetChanges","getBalanceData","AbiConstructor.encode","AbiConstructor.from","deploylessCallViaBytecodeBytecode","AbiFunction.encodeData","AbiFunction.from","assetAddresses","block_results","block_ethPre","block_assetsPre","block_ethPost","block_assetsPost","block_decimals","block_tokenURI","block_symbols","block_calls","ethPre","assetsPre","balancesPre","ethPost","assetsPost","balancesPost","decimals","symbols","tokenURI","changes","balancePost","balancePre","decimals_","symbol_","tokenURI_","token","change","wrap","serializeSignature","yParity_","verifyHash","verifierAddress","multicallAddress","SignatureErc8010.validate","verifyErc8010","verifyErc6492","VerificationError","authorization_ox","initData","SignatureErc8010.unwrap","verifyErc1271","multicall3Bytecode","multicall3Abi","erc1271Abi","wrappedSignature","SignatureErc6492.validate","SignatureErc6492.wrap","erc6492SignatureValidatorAbi","encodeDeployData","erc6492SignatureValidatorByteCode","CallExecutionError","hexToBool","ContractFunctionExecutionError","verifyMessage","verifyTypedData","watchBlockNumber","emitMissed","onBlockNumber","enablePolling","prevBlockNumber","waitForTransactionReceipt","checkReplacement","confirmations","onReplaced","retryCount","retryDelay","timeout","replacedTransaction","retrying","_unobserve","_unwatch","reject","withResolvers","timer","WaitForTransactionReceiptTimeoutError","blockNumber_","done","withRetry","replacementTransaction","err_","watchBlocks","onBlock","prevBlock","emitFetched","watchEvent","watchPendingTransactions","onTransactions","hashes","parseSiweMessage","scheme","statement","prefixRegex","expirationTime","issuedAt","notBefore","requestId","suffixRegex","resources","validateSiweMessage","time","verifySiweMessage","parsed","publicActions","getBalance","multicall","createPublicClient","createClient"],"ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117],"sources":["../../node_modules/viem/node_modules/abitype/dist/esm/human-readable/parseAbiItem.js","../../node_modules/viem/node_modules/abitype/dist/esm/human-readable/parseAbiParameters.js","../../node_modules/viem/_esm/errors/log.js","../../node_modules/viem/_esm/utils/abi/encodeEventTopics.js","../../node_modules/viem/_esm/utils/filters/createFilterRequestScope.js","../../node_modules/viem/_esm/actions/public/createContractEventFilter.js","../../node_modules/viem/_esm/accounts/utils/publicKeyToAddress.js","../../node_modules/viem/_esm/utils/signature/recoverPublicKey.js","../../node_modules/viem/_esm/utils/signature/recoverAddress.js","../../node_modules/viem/_esm/utils/authorization/hashAuthorization.js","../../node_modules/viem/_esm/utils/authorization/recoverAuthorizationAddress.js","../../node_modules/viem/_esm/errors/estimateGas.js","../../node_modules/viem/_esm/utils/errors/getEstimateGasError.js","../../node_modules/viem/_esm/errors/fee.js","../../node_modules/viem/_esm/errors/block.js","../../node_modules/viem/_esm/actions/public/getBlock.js","../../node_modules/viem/_esm/actions/public/getGasPrice.js","../../node_modules/viem/_esm/actions/public/estimateMaxPriorityFeePerGas.js","../../node_modules/viem/_esm/actions/public/estimateFeesPerGas.js","../../node_modules/viem/_esm/actions/public/getTransactionCount.js","../../node_modules/viem/_esm/actions/public/getChainId.js","../../node_modules/viem/_esm/actions/wallet/prepareTransactionRequest.js","../../node_modules/viem/_esm/actions/public/estimateGas.js","../../node_modules/viem/_esm/actions/public/estimateContractGas.js","../../node_modules/viem/_esm/utils/abi/decodeEventLog.js","../../node_modules/viem/_esm/utils/abi/parseEventLogs.js","../../node_modules/viem/_esm/actions/public/getLogs.js","../../node_modules/viem/_esm/actions/public/getContractEvents.js","../../node_modules/viem/node_modules/@noble/curves/esm/abstract/utils.js","../../node_modules/viem/node_modules/ox/_esm/core/internal/bytes.js","../../node_modules/viem/node_modules/ox/_esm/core/Bytes.js","../../node_modules/viem/_esm/actions/public/simulateContract.js","../../node_modules/viem/_esm/utils/observe.js","../../node_modules/viem/_esm/utils/poll.js","../../node_modules/viem/_esm/utils/promise/withCache.js","../../node_modules/viem/_esm/actions/public/getBlockNumber.js","../../node_modules/viem/_esm/actions/public/getFilterChanges.js","../../node_modules/viem/_esm/actions/public/uninstallFilter.js","../../node_modules/viem/_esm/actions/public/watchContractEvent.js","../../node_modules/viem/_esm/actions/wallet/sendRawTransaction.js","../../node_modules/viem/_esm/utils/ens/errors.js","../../node_modules/viem/_esm/utils/ens/encodedLabelToLabelhash.js","../../node_modules/viem/_esm/utils/ens/namehash.js","../../node_modules/viem/_esm/utils/ens/encodeLabelhash.js","../../node_modules/viem/_esm/utils/ens/labelhash.js","../../node_modules/viem/_esm/utils/ens/packetToBytes.js","../../node_modules/viem/_esm/actions/ens/getEnsAddress.js","../../node_modules/viem/_esm/errors/ens.js","../../node_modules/viem/_esm/utils/ens/avatar/utils.js","../../node_modules/viem/_esm/utils/ens/avatar/parseAvatarRecord.js","../../node_modules/viem/_esm/actions/ens/getEnsText.js","../../node_modules/viem/_esm/actions/ens/getEnsAvatar.js","../../node_modules/viem/_esm/actions/ens/getEnsName.js","../../node_modules/viem/_esm/actions/ens/getEnsResolver.js","../../node_modules/viem/_esm/actions/public/createAccessList.js","../../node_modules/viem/_esm/actions/public/createBlockFilter.js","../../node_modules/viem/_esm/actions/public/createEventFilter.js","../../node_modules/viem/_esm/actions/public/createPendingTransactionFilter.js","../../node_modules/viem/_esm/actions/public/getBlobBaseFee.js","../../node_modules/viem/_esm/actions/public/getBlockTransactionCount.js","../../node_modules/viem/_esm/actions/public/getCode.js","../../node_modules/viem/_esm/errors/eip712.js","../../node_modules/viem/_esm/actions/public/getEip712Domain.js","../../node_modules/viem/_esm/utils/formatters/feeHistory.js","../../node_modules/viem/_esm/actions/public/getFeeHistory.js","../../node_modules/viem/_esm/actions/public/getFilterLogs.js","../../node_modules/viem/_esm/utils/authorization/verifyAuthorization.js","../../node_modules/viem/_esm/constants/strings.js","../../node_modules/viem/_esm/utils/signature/toPrefixedMessage.js","../../node_modules/viem/_esm/utils/signature/hashMessage.js","../../node_modules/viem/_esm/errors/typedData.js","../../node_modules/viem/_esm/utils/typedData.js","../../node_modules/viem/_esm/utils/signature/hashTypedData.js","../../node_modules/viem/node_modules/ox/_esm/core/internal/lru.js","../../node_modules/viem/node_modules/ox/_esm/core/Caches.js","../../node_modules/viem/node_modules/ox/_esm/core/Hash.js","../../node_modules/viem/node_modules/ox/_esm/core/Address.js","../../node_modules/viem/node_modules/ox/_esm/core/Solidity.js","../../node_modules/viem/node_modules/ox/_esm/core/internal/abiParameters.js","../../node_modules/viem/node_modules/ox/_esm/core/internal/cursor.js","../../node_modules/viem/node_modules/ox/_esm/core/AbiParameters.js","../../node_modules/viem/node_modules/@noble/hashes/esm/hmac.js","../../node_modules/viem/node_modules/@noble/curves/esm/abstract/modular.js","../../node_modules/viem/node_modules/@noble/curves/esm/abstract/curve.js","../../node_modules/viem/node_modules/@noble/curves/esm/abstract/weierstrass.js","../../node_modules/viem/node_modules/@noble/curves/esm/_shortw_utils.js","../../node_modules/viem/node_modules/@noble/curves/esm/secp256k1.js","../../node_modules/viem/node_modules/ox/_esm/core/Signature.js","../../node_modules/viem/node_modules/ox/_esm/core/Authorization.js","../../node_modules/viem/node_modules/ox/_esm/erc8010/SignatureErc8010.js","../../node_modules/viem/_esm/utils/formatters/proof.js","../../node_modules/viem/_esm/actions/public/getProof.js","../../node_modules/viem/_esm/actions/public/getStorageAt.js","../../node_modules/viem/_esm/actions/public/getTransaction.js","../../node_modules/viem/_esm/actions/public/getTransactionConfirmations.js","../../node_modules/viem/_esm/actions/public/getTransactionReceipt.js","../../node_modules/viem/_esm/actions/public/simulateBlocks.js","../../node_modules/viem/node_modules/ox/_esm/core/internal/abiItem.js","../../node_modules/viem/node_modules/ox/_esm/core/AbiItem.js","../../node_modules/viem/node_modules/ox/_esm/core/AbiConstructor.js","../../node_modules/viem/node_modules/ox/_esm/core/AbiFunction.js","../../node_modules/viem/_esm/constants/address.js","../../node_modules/viem/_esm/actions/public/simulateCalls.js","../../node_modules/viem/node_modules/ox/_esm/erc6492/SignatureErc6492.js","../../node_modules/viem/_esm/utils/signature/serializeSignature.js","../../node_modules/viem/_esm/actions/public/verifyHash.js","../../node_modules/viem/_esm/actions/public/verifyMessage.js","../../node_modules/viem/_esm/actions/public/verifyTypedData.js","../../node_modules/viem/_esm/actions/public/watchBlockNumber.js","../../node_modules/viem/_esm/actions/public/waitForTransactionReceipt.js","../../node_modules/viem/_esm/actions/public/watchBlocks.js","../../node_modules/viem/_esm/actions/public/watchEvent.js","../../node_modules/viem/_esm/actions/public/watchPendingTransactions.js","../../node_modules/viem/_esm/utils/siwe/parseSiweMessage.js","../../node_modules/viem/_esm/utils/siwe/validateSiweMessage.js","../../node_modules/viem/_esm/actions/siwe/verifySiweMessage.js","../../node_modules/viem/_esm/clients/decorators/public.js","../../node_modules/viem/_esm/clients/createPublicClient.js"],"sourcesContent":["import { InvalidAbiItemError } from './errors/abiItem.js';\nimport { isStructSignature } from './runtime/signatures.js';\nimport { parseStructs } from './runtime/structs.js';\nimport { parseSignature } from './runtime/utils.js';\n/**\n * Parses human-readable ABI item (e.g. error, event, function) into {@link Abi} item\n *\n * @param signature - Human-readable ABI item\n * @returns Parsed {@link Abi} item\n *\n * @example\n * const abiItem = parseAbiItem('function balanceOf(address owner) view returns (uint256)')\n * //    ^? const abiItem: { name: \"balanceOf\"; type: \"function\"; stateMutability: \"view\";...\n *\n * @example\n * const abiItem = parseAbiItem([\n *   //  ^? const abiItem: { name: \"foo\"; type: \"function\"; stateMutability: \"view\"; inputs:...\n *   'function foo(Baz bar) view returns (string)',\n *   'struct Baz { string name; }',\n * ])\n */\nexport function parseAbiItem(signature) {\n    let abiItem;\n    if (typeof signature === 'string')\n        abiItem = parseSignature(signature);\n    else {\n        const structs = parseStructs(signature);\n        const length = signature.length;\n        for (let i = 0; i < length; i++) {\n            const signature_ = signature[i];\n            if (isStructSignature(signature_))\n                continue;\n            abiItem = parseSignature(signature_, structs);\n            break;\n        }\n    }\n    if (!abiItem)\n        throw new InvalidAbiItemError({ signature });\n    return abiItem;\n}\n//# sourceMappingURL=parseAbiItem.js.map","import { InvalidAbiParametersError } from './errors/abiParameter.js';\nimport { isStructSignature, modifiers } from './runtime/signatures.js';\nimport { parseStructs } from './runtime/structs.js';\nimport { splitParameters } from './runtime/utils.js';\nimport { parseAbiParameter as parseAbiParameter_ } from './runtime/utils.js';\n/**\n * Parses human-readable ABI parameters into {@link AbiParameter}s\n *\n * @param params - Human-readable ABI parameters\n * @returns Parsed {@link AbiParameter}s\n *\n * @example\n * const abiParameters = parseAbiParameters('address from, address to, uint256 amount')\n * //    ^? const abiParameters: [{ type: \"address\"; name: \"from\"; }, { type: \"address\";...\n *\n * @example\n * const abiParameters = parseAbiParameters([\n *   //  ^? const abiParameters: [{ type: \"tuple\"; components: [{ type: \"string\"; name:...\n *   'Baz bar',\n *   'struct Baz { string name; }',\n * ])\n */\nexport function parseAbiParameters(params) {\n    const abiParameters = [];\n    if (typeof params === 'string') {\n        const parameters = splitParameters(params);\n        const length = parameters.length;\n        for (let i = 0; i < length; i++) {\n            abiParameters.push(parseAbiParameter_(parameters[i], { modifiers }));\n        }\n    }\n    else {\n        const structs = parseStructs(params);\n        const length = params.length;\n        for (let i = 0; i < length; i++) {\n            const signature = params[i];\n            if (isStructSignature(signature))\n                continue;\n            const parameters = splitParameters(signature);\n            const length = parameters.length;\n            for (let k = 0; k < length; k++) {\n                abiParameters.push(parseAbiParameter_(parameters[k], { modifiers, structs }));\n            }\n        }\n    }\n    if (abiParameters.length === 0)\n        throw new InvalidAbiParametersError({ params });\n    return abiParameters;\n}\n//# sourceMappingURL=parseAbiParameters.js.map","import { BaseError } from './base.js';\nexport class FilterTypeNotSupportedError extends BaseError {\n    constructor(type) {\n        super(`Filter type \"${type}\" is not supported.`, {\n            name: 'FilterTypeNotSupportedError',\n        });\n    }\n}\n//# sourceMappingURL=log.js.map","import { AbiEventNotFoundError, } from '../../errors/abi.js';\nimport { FilterTypeNotSupportedError, } from '../../errors/log.js';\nimport { toBytes } from '../encoding/toBytes.js';\nimport { keccak256 } from '../hash/keccak256.js';\nimport { toEventSelector, } from '../hash/toEventSelector.js';\nimport { encodeAbiParameters, } from './encodeAbiParameters.js';\nimport { formatAbiItem } from './formatAbiItem.js';\nimport { getAbiItem } from './getAbiItem.js';\nconst docsPath = '/docs/contract/encodeEventTopics';\nexport function encodeEventTopics(parameters) {\n    const { abi, eventName, args } = parameters;\n    let abiItem = abi[0];\n    if (eventName) {\n        const item = getAbiItem({ abi, name: eventName });\n        if (!item)\n            throw new AbiEventNotFoundError(eventName, { docsPath });\n        abiItem = item;\n    }\n    if (abiItem.type !== 'event')\n        throw new AbiEventNotFoundError(undefined, { docsPath });\n    const definition = formatAbiItem(abiItem);\n    const signature = toEventSelector(definition);\n    let topics = [];\n    if (args && 'inputs' in abiItem) {\n        const indexedInputs = abiItem.inputs?.filter((param) => 'indexed' in param && param.indexed);\n        const args_ = Array.isArray(args)\n            ? args\n            : Object.values(args).length > 0\n                ? (indexedInputs?.map((x) => args[x.name]) ?? [])\n                : [];\n        if (args_.length > 0) {\n            topics =\n                indexedInputs?.map((param, i) => {\n                    if (Array.isArray(args_[i]))\n                        return args_[i].map((_, j) => encodeArg({ param, value: args_[i][j] }));\n                    return typeof args_[i] !== 'undefined' && args_[i] !== null\n                        ? encodeArg({ param, value: args_[i] })\n                        : null;\n                }) ?? [];\n        }\n    }\n    return [signature, ...topics];\n}\nfunction encodeArg({ param, value, }) {\n    if (param.type === 'string' || param.type === 'bytes')\n        return keccak256(toBytes(value));\n    if (param.type === 'tuple' || param.type.match(/^(.*)\\[(\\d+)?\\]$/))\n        throw new FilterTypeNotSupportedError(param.type);\n    return encodeAbiParameters([param], [value]);\n}\n//# sourceMappingURL=encodeEventTopics.js.map","/**\n * Scopes `request` to the filter ID. If the client is a fallback, it will\n * listen for responses and scope the child transport `request` function\n * to the successful filter ID.\n */\nexport function createFilterRequestScope(client, { method }) {\n    const requestMap = {};\n    if (client.transport.type === 'fallback')\n        client.transport.onResponse?.(({ method: method_, response: id, status, transport, }) => {\n            if (status === 'success' && method === method_)\n                requestMap[id] = transport.request;\n        });\n    return ((id) => requestMap[id] || client.request);\n}\n//# sourceMappingURL=createFilterRequestScope.js.map","import { encodeEventTopics, } from '../../utils/abi/encodeEventTopics.js';\nimport { numberToHex, } from '../../utils/encoding/toHex.js';\nimport { createFilterRequestScope } from '../../utils/filters/createFilterRequestScope.js';\n/**\n * Creates a Filter to retrieve event logs that can be used with [`getFilterChanges`](https://viem.sh/docs/actions/public/getFilterChanges) or [`getFilterLogs`](https://viem.sh/docs/actions/public/getFilterLogs).\n *\n * - Docs: https://viem.sh/docs/contract/createContractEventFilter\n *\n * @param client - Client to use\n * @param parameters - {@link CreateContractEventFilterParameters}\n * @returns [`Filter`](https://viem.sh/docs/glossary/types#filter). {@link CreateContractEventFilterReturnType}\n *\n * @example\n * import { createPublicClient, http, parseAbi } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { createContractEventFilter } from 'viem/contract'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const filter = await createContractEventFilter(client, {\n *   abi: parseAbi(['event Transfer(address indexed, address indexed, uint256)']),\n * })\n */\nexport async function createContractEventFilter(client, parameters) {\n    const { address, abi, args, eventName, fromBlock, strict, toBlock } = parameters;\n    const getRequest = createFilterRequestScope(client, {\n        method: 'eth_newFilter',\n    });\n    const topics = eventName\n        ? encodeEventTopics({\n            abi,\n            args,\n            eventName,\n        })\n        : undefined;\n    const id = await client.request({\n        method: 'eth_newFilter',\n        params: [\n            {\n                address,\n                fromBlock: typeof fromBlock === 'bigint' ? numberToHex(fromBlock) : fromBlock,\n                toBlock: typeof toBlock === 'bigint' ? numberToHex(toBlock) : toBlock,\n                topics,\n            },\n        ],\n    });\n    return {\n        abi,\n        args,\n        eventName,\n        id,\n        request: getRequest(id),\n        strict: Boolean(strict),\n        type: 'event',\n    };\n}\n//# sourceMappingURL=createContractEventFilter.js.map","import { checksumAddress, } from '../../utils/address/getAddress.js';\nimport { keccak256, } from '../../utils/hash/keccak256.js';\n/**\n * @description Converts an ECDSA public key to an address.\n *\n * @param publicKey The public key to convert.\n *\n * @returns The address.\n */\nexport function publicKeyToAddress(publicKey) {\n    const address = keccak256(`0x${publicKey.substring(4)}`).substring(26);\n    return checksumAddress(`0x${address}`);\n}\n//# sourceMappingURL=publicKeyToAddress.js.map","import { isHex } from '../data/isHex.js';\nimport { size } from '../data/size.js';\nimport { hexToBigInt, hexToNumber, } from '../encoding/fromHex.js';\nimport { toHex } from '../encoding/toHex.js';\nexport async function recoverPublicKey({ hash, signature, }) {\n    const hashHex = isHex(hash) ? hash : toHex(hash);\n    const { secp256k1 } = await import('@noble/curves/secp256k1');\n    const signature_ = (() => {\n        // typeof signature: `Signature`\n        if (typeof signature === 'object' && 'r' in signature && 's' in signature) {\n            const { r, s, v, yParity } = signature;\n            const yParityOrV = Number(yParity ?? v);\n            const recoveryBit = toRecoveryBit(yParityOrV);\n            return new secp256k1.Signature(hexToBigInt(r), hexToBigInt(s)).addRecoveryBit(recoveryBit);\n        }\n        // typeof signature: `Hex | ByteArray`\n        const signatureHex = isHex(signature) ? signature : toHex(signature);\n        if (size(signatureHex) !== 65)\n            throw new Error('invalid signature length');\n        const yParityOrV = hexToNumber(`0x${signatureHex.slice(130)}`);\n        const recoveryBit = toRecoveryBit(yParityOrV);\n        return secp256k1.Signature.fromCompact(signatureHex.substring(2, 130)).addRecoveryBit(recoveryBit);\n    })();\n    const publicKey = signature_\n        .recoverPublicKey(hashHex.substring(2))\n        .toHex(false);\n    return `0x${publicKey}`;\n}\nfunction toRecoveryBit(yParityOrV) {\n    if (yParityOrV === 0 || yParityOrV === 1)\n        return yParityOrV;\n    if (yParityOrV === 27)\n        return 0;\n    if (yParityOrV === 28)\n        return 1;\n    throw new Error('Invalid yParityOrV value');\n}\n//# sourceMappingURL=recoverPublicKey.js.map","import { publicKeyToAddress } from '../../accounts/utils/publicKeyToAddress.js';\nimport { recoverPublicKey } from './recoverPublicKey.js';\nexport async function recoverAddress({ hash, signature, }) {\n    return publicKeyToAddress(await recoverPublicKey({ hash, signature }));\n}\n//# sourceMappingURL=recoverAddress.js.map","import { concatHex } from '../data/concat.js';\nimport { hexToBytes } from '../encoding/toBytes.js';\nimport { numberToHex } from '../encoding/toHex.js';\nimport { toRlp } from '../encoding/toRlp.js';\nimport { keccak256 } from '../hash/keccak256.js';\n/**\n * Computes an Authorization hash in [EIP-7702 format](https://eips.ethereum.org/EIPS/eip-7702): `keccak256('0x05' || rlp([chain_id, address, nonce]))`.\n */\nexport function hashAuthorization(parameters) {\n    const { chainId, nonce, to } = parameters;\n    const address = parameters.contractAddress ?? parameters.address;\n    const hash = keccak256(concatHex([\n        '0x05',\n        toRlp([\n            chainId ? numberToHex(chainId) : '0x',\n            address,\n            nonce ? numberToHex(nonce) : '0x',\n        ]),\n    ]));\n    if (to === 'bytes')\n        return hexToBytes(hash);\n    return hash;\n}\n//# sourceMappingURL=hashAuthorization.js.map","import { recoverAddress, } from '../signature/recoverAddress.js';\nimport { hashAuthorization, } from './hashAuthorization.js';\nexport async function recoverAuthorizationAddress(parameters) {\n    const { authorization, signature } = parameters;\n    return recoverAddress({\n        hash: hashAuthorization(authorization),\n        signature: (signature ?? authorization),\n    });\n}\n//# sourceMappingURL=recoverAuthorizationAddress.js.map","import { formatEther } from '../utils/unit/formatEther.js';\nimport { formatGwei } from '../utils/unit/formatGwei.js';\nimport { BaseError } from './base.js';\nimport { prettyPrint } from './transaction.js';\nexport class EstimateGasExecutionError extends BaseError {\n    constructor(cause, { account, docsPath, chain, data, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value, }) {\n        const prettyArgs = prettyPrint({\n            from: account?.address,\n            to,\n            value: typeof value !== 'undefined' &&\n                `${formatEther(value)} ${chain?.nativeCurrency?.symbol || 'ETH'}`,\n            data,\n            gas,\n            gasPrice: typeof gasPrice !== 'undefined' && `${formatGwei(gasPrice)} gwei`,\n            maxFeePerGas: typeof maxFeePerGas !== 'undefined' &&\n                `${formatGwei(maxFeePerGas)} gwei`,\n            maxPriorityFeePerGas: typeof maxPriorityFeePerGas !== 'undefined' &&\n                `${formatGwei(maxPriorityFeePerGas)} gwei`,\n            nonce,\n        });\n        super(cause.shortMessage, {\n            cause,\n            docsPath,\n            metaMessages: [\n                ...(cause.metaMessages ? [...cause.metaMessages, ' '] : []),\n                'Estimate Gas Arguments:',\n                prettyArgs,\n            ].filter(Boolean),\n            name: 'EstimateGasExecutionError',\n        });\n        Object.defineProperty(this, \"cause\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.cause = cause;\n    }\n}\n//# sourceMappingURL=estimateGas.js.map","import { EstimateGasExecutionError, } from '../../errors/estimateGas.js';\nimport { UnknownNodeError } from '../../errors/node.js';\nimport { getNodeError, } from './getNodeError.js';\nexport function getEstimateGasError(err, { docsPath, ...args }) {\n    const cause = (() => {\n        const cause = getNodeError(err, args);\n        if (cause instanceof UnknownNodeError)\n            return err;\n        return cause;\n    })();\n    return new EstimateGasExecutionError(cause, {\n        docsPath,\n        ...args,\n    });\n}\n//# sourceMappingURL=getEstimateGasError.js.map","import { formatGwei } from '../utils/unit/formatGwei.js';\nimport { BaseError } from './base.js';\nexport class BaseFeeScalarError extends BaseError {\n    constructor() {\n        super('`baseFeeMultiplier` must be greater than 1.', {\n            name: 'BaseFeeScalarError',\n        });\n    }\n}\nexport class Eip1559FeesNotSupportedError extends BaseError {\n    constructor() {\n        super('Chain does not support EIP-1559 fees.', {\n            name: 'Eip1559FeesNotSupportedError',\n        });\n    }\n}\nexport class MaxFeePerGasTooLowError extends BaseError {\n    constructor({ maxPriorityFeePerGas }) {\n        super(`\\`maxFeePerGas\\` cannot be less than the \\`maxPriorityFeePerGas\\` (${formatGwei(maxPriorityFeePerGas)} gwei).`, { name: 'MaxFeePerGasTooLowError' });\n    }\n}\n//# sourceMappingURL=fee.js.map","import { BaseError } from './base.js';\nexport class BlockNotFoundError extends BaseError {\n    constructor({ blockHash, blockNumber, }) {\n        let identifier = 'Block';\n        if (blockHash)\n            identifier = `Block at hash \"${blockHash}\"`;\n        if (blockNumber)\n            identifier = `Block at number \"${blockNumber}\"`;\n        super(`${identifier} could not be found.`, { name: 'BlockNotFoundError' });\n    }\n}\n//# sourceMappingURL=block.js.map","import { BlockNotFoundError, } from '../../errors/block.js';\nimport { numberToHex, } from '../../utils/encoding/toHex.js';\nimport { formatBlock, } from '../../utils/formatters/block.js';\n/**\n * Returns information about a block at a block number, hash, or tag.\n *\n * - Docs: https://viem.sh/docs/actions/public/getBlock\n * - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/blocks_fetching-blocks\n * - JSON-RPC Methods:\n *   - Calls [`eth_getBlockByNumber`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getblockbynumber) for `blockNumber` & `blockTag`.\n *   - Calls [`eth_getBlockByHash`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getblockbyhash) for `blockHash`.\n *\n * @param client - Client to use\n * @param parameters - {@link GetBlockParameters}\n * @returns Information about the block. {@link GetBlockReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { getBlock } from 'viem/public'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const block = await getBlock(client)\n */\nexport async function getBlock(client, { blockHash, blockNumber, blockTag = client.experimental_blockTag ?? 'latest', includeTransactions: includeTransactions_, } = {}) {\n    const includeTransactions = includeTransactions_ ?? false;\n    const blockNumberHex = blockNumber !== undefined ? numberToHex(blockNumber) : undefined;\n    let block = null;\n    if (blockHash) {\n        block = await client.request({\n            method: 'eth_getBlockByHash',\n            params: [blockHash, includeTransactions],\n        }, { dedupe: true });\n    }\n    else {\n        block = await client.request({\n            method: 'eth_getBlockByNumber',\n            params: [blockNumberHex || blockTag, includeTransactions],\n        }, { dedupe: Boolean(blockNumberHex) });\n    }\n    if (!block)\n        throw new BlockNotFoundError({ blockHash, blockNumber });\n    const format = client.chain?.formatters?.block?.format || formatBlock;\n    return format(block);\n}\n//# sourceMappingURL=getBlock.js.map","/**\n * Returns the current price of gas (in wei).\n *\n * - Docs: https://viem.sh/docs/actions/public/getGasPrice\n * - JSON-RPC Methods: [`eth_gasPrice`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_gasprice)\n *\n * @param client - Client to use\n * @returns The gas price (in wei). {@link GetGasPriceReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { getGasPrice } from 'viem/public'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const gasPrice = await getGasPrice(client)\n */\nexport async function getGasPrice(client) {\n    const gasPrice = await client.request({\n        method: 'eth_gasPrice',\n    });\n    return BigInt(gasPrice);\n}\n//# sourceMappingURL=getGasPrice.js.map","import { Eip1559FeesNotSupportedError, } from '../../errors/fee.js';\nimport { hexToBigInt, } from '../../utils/encoding/fromHex.js';\nimport { getAction } from '../../utils/getAction.js';\nimport { getBlock } from './getBlock.js';\nimport { getGasPrice } from './getGasPrice.js';\n/**\n * Returns an estimate for the max priority fee per gas (in wei) for a\n * transaction to be likely included in the next block.\n * Defaults to [`chain.fees.defaultPriorityFee`](/docs/clients/chains#fees-defaultpriorityfee) if set.\n *\n * - Docs: https://viem.sh/docs/actions/public/estimateMaxPriorityFeePerGas\n *\n * @param client - Client to use\n * @returns An estimate (in wei) for the max priority fee per gas. {@link EstimateMaxPriorityFeePerGasReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { estimateMaxPriorityFeePerGas } from 'viem/actions'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const maxPriorityFeePerGas = await estimateMaxPriorityFeePerGas(client)\n * // 10000000n\n */\nexport async function estimateMaxPriorityFeePerGas(client, args) {\n    return internal_estimateMaxPriorityFeePerGas(client, args);\n}\nexport async function internal_estimateMaxPriorityFeePerGas(client, args) {\n    const { block: block_, chain = client.chain, request } = args || {};\n    try {\n        const maxPriorityFeePerGas = chain?.fees?.maxPriorityFeePerGas ?? chain?.fees?.defaultPriorityFee;\n        if (typeof maxPriorityFeePerGas === 'function') {\n            const block = block_ || (await getAction(client, getBlock, 'getBlock')({}));\n            const maxPriorityFeePerGas_ = await maxPriorityFeePerGas({\n                block,\n                client,\n                request,\n            });\n            if (maxPriorityFeePerGas_ === null)\n                throw new Error();\n            return maxPriorityFeePerGas_;\n        }\n        if (typeof maxPriorityFeePerGas !== 'undefined')\n            return maxPriorityFeePerGas;\n        const maxPriorityFeePerGasHex = await client.request({\n            method: 'eth_maxPriorityFeePerGas',\n        });\n        return hexToBigInt(maxPriorityFeePerGasHex);\n    }\n    catch {\n        // If the RPC Provider does not support `eth_maxPriorityFeePerGas`\n        // fall back to calculating it manually via `gasPrice - baseFeePerGas`.\n        // See: https://github.com/ethereum/pm/issues/328#:~:text=eth_maxPriorityFeePerGas%20after%20London%20will%20effectively%20return%20eth_gasPrice%20%2D%20baseFee\n        const [block, gasPrice] = await Promise.all([\n            block_\n                ? Promise.resolve(block_)\n                : getAction(client, getBlock, 'getBlock')({}),\n            getAction(client, getGasPrice, 'getGasPrice')({}),\n        ]);\n        if (typeof block.baseFeePerGas !== 'bigint')\n            throw new Eip1559FeesNotSupportedError();\n        const maxPriorityFeePerGas = gasPrice - block.baseFeePerGas;\n        if (maxPriorityFeePerGas < 0n)\n            return 0n;\n        return maxPriorityFeePerGas;\n    }\n}\n//# sourceMappingURL=estimateMaxPriorityFeePerGas.js.map","import { BaseFeeScalarError, Eip1559FeesNotSupportedError, } from '../../errors/fee.js';\nimport { getAction } from '../../utils/getAction.js';\nimport { internal_estimateMaxPriorityFeePerGas, } from './estimateMaxPriorityFeePerGas.js';\nimport { getBlock } from './getBlock.js';\nimport { getGasPrice } from './getGasPrice.js';\n/**\n * Returns an estimate for the fees per gas (in wei) for a\n * transaction to be likely included in the next block.\n * Defaults to [`chain.fees.estimateFeesPerGas`](/docs/clients/chains#fees-estimatefeespergas) if set.\n *\n * - Docs: https://viem.sh/docs/actions/public/estimateFeesPerGas\n *\n * @param client - Client to use\n * @param parameters - {@link EstimateFeesPerGasParameters}\n * @returns An estimate (in wei) for the fees per gas. {@link EstimateFeesPerGasReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { estimateFeesPerGas } from 'viem/actions'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const maxPriorityFeePerGas = await estimateFeesPerGas(client)\n * // { maxFeePerGas: ..., maxPriorityFeePerGas: ... }\n */\nexport async function estimateFeesPerGas(client, args) {\n    return internal_estimateFeesPerGas(client, args);\n}\nexport async function internal_estimateFeesPerGas(client, args) {\n    const { block: block_, chain = client.chain, request, type = 'eip1559', } = args || {};\n    const baseFeeMultiplier = await (async () => {\n        if (typeof chain?.fees?.baseFeeMultiplier === 'function')\n            return chain.fees.baseFeeMultiplier({\n                block: block_,\n                client,\n                request,\n            });\n        return chain?.fees?.baseFeeMultiplier ?? 1.2;\n    })();\n    if (baseFeeMultiplier < 1)\n        throw new BaseFeeScalarError();\n    const decimals = baseFeeMultiplier.toString().split('.')[1]?.length ?? 0;\n    const denominator = 10 ** decimals;\n    const multiply = (base) => (base * BigInt(Math.ceil(baseFeeMultiplier * denominator))) /\n        BigInt(denominator);\n    const block = block_\n        ? block_\n        : await getAction(client, getBlock, 'getBlock')({});\n    if (typeof chain?.fees?.estimateFeesPerGas === 'function') {\n        const fees = (await chain.fees.estimateFeesPerGas({\n            block: block_,\n            client,\n            multiply,\n            request,\n            type,\n        }));\n        if (fees !== null)\n            return fees;\n    }\n    if (type === 'eip1559') {\n        if (typeof block.baseFeePerGas !== 'bigint')\n            throw new Eip1559FeesNotSupportedError();\n        const maxPriorityFeePerGas = typeof request?.maxPriorityFeePerGas === 'bigint'\n            ? request.maxPriorityFeePerGas\n            : await internal_estimateMaxPriorityFeePerGas(client, {\n                block: block,\n                chain,\n                request,\n            });\n        const baseFeePerGas = multiply(block.baseFeePerGas);\n        const maxFeePerGas = request?.maxFeePerGas ?? baseFeePerGas + maxPriorityFeePerGas;\n        return {\n            maxFeePerGas,\n            maxPriorityFeePerGas,\n        };\n    }\n    const gasPrice = request?.gasPrice ??\n        multiply(await getAction(client, getGasPrice, 'getGasPrice')({}));\n    return {\n        gasPrice,\n    };\n}\n//# sourceMappingURL=estimateFeesPerGas.js.map","import { hexToNumber, } from '../../utils/encoding/fromHex.js';\nimport { numberToHex, } from '../../utils/encoding/toHex.js';\n/**\n * Returns the number of [Transactions](https://viem.sh/docs/glossary/terms#transaction) an Account has sent.\n *\n * - Docs: https://viem.sh/docs/actions/public/getTransactionCount\n * - JSON-RPC Methods: [`eth_getTransactionCount`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_gettransactioncount)\n *\n * @param client - Client to use\n * @param parameters - {@link GetTransactionCountParameters}\n * @returns The number of transactions an account has sent. {@link GetTransactionCountReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { getTransactionCount } from 'viem/public'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const transactionCount = await getTransactionCount(client, {\n *   address: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n * })\n */\nexport async function getTransactionCount(client, { address, blockTag = 'latest', blockNumber }) {\n    const count = await client.request({\n        method: 'eth_getTransactionCount',\n        params: [\n            address,\n            typeof blockNumber === 'bigint' ? numberToHex(blockNumber) : blockTag,\n        ],\n    }, {\n        dedupe: Boolean(blockNumber),\n    });\n    return hexToNumber(count);\n}\n//# sourceMappingURL=getTransactionCount.js.map","import { hexToNumber, } from '../../utils/encoding/fromHex.js';\n/**\n * Returns the chain ID associated with the current network.\n *\n * - Docs: https://viem.sh/docs/actions/public/getChainId\n * - JSON-RPC Methods: [`eth_chainId`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_chainid)\n *\n * @param client - Client to use\n * @returns The current chain ID. {@link GetChainIdReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { getChainId } from 'viem/public'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const chainId = await getChainId(client)\n * // 1\n */\nexport async function getChainId(client) {\n    const chainIdHex = await client.request({\n        method: 'eth_chainId',\n    }, { dedupe: true });\n    return hexToNumber(chainIdHex);\n}\n//# sourceMappingURL=getChainId.js.map","import { parseAccount, } from '../../accounts/utils/parseAccount.js';\nimport { internal_estimateFeesPerGas, } from '../../actions/public/estimateFeesPerGas.js';\nimport { estimateGas, } from '../../actions/public/estimateGas.js';\nimport { getBlock as getBlock_, } from '../../actions/public/getBlock.js';\nimport { getTransactionCount, } from '../../actions/public/getTransactionCount.js';\nimport { Eip1559FeesNotSupportedError, MaxFeePerGasTooLowError, } from '../../errors/fee.js';\nimport { blobsToCommitments } from '../../utils/blob/blobsToCommitments.js';\nimport { blobsToProofs } from '../../utils/blob/blobsToProofs.js';\nimport { commitmentsToVersionedHashes } from '../../utils/blob/commitmentsToVersionedHashes.js';\nimport { toBlobSidecars } from '../../utils/blob/toBlobSidecars.js';\nimport { getAction } from '../../utils/getAction.js';\nimport { assertRequest, } from '../../utils/transaction/assertRequest.js';\nimport { getTransactionType, } from '../../utils/transaction/getTransactionType.js';\nimport { getChainId as getChainId_ } from '../public/getChainId.js';\nexport const defaultParameters = [\n    'blobVersionedHashes',\n    'chainId',\n    'fees',\n    'gas',\n    'nonce',\n    'type',\n];\n/** @internal */\nexport const eip1559NetworkCache = /*#__PURE__*/ new Map();\n/**\n * Prepares a transaction request for signing.\n *\n * - Docs: https://viem.sh/docs/actions/wallet/prepareTransactionRequest\n *\n * @param args - {@link PrepareTransactionRequestParameters}\n * @returns The transaction request. {@link PrepareTransactionRequestReturnType}\n *\n * @example\n * import { createWalletClient, custom } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { prepareTransactionRequest } from 'viem/actions'\n *\n * const client = createWalletClient({\n *   chain: mainnet,\n *   transport: custom(window.ethereum),\n * })\n * const request = await prepareTransactionRequest(client, {\n *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: 1n,\n * })\n *\n * @example\n * // Account Hoisting\n * import { createWalletClient, http } from 'viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n * import { mainnet } from 'viem/chains'\n * import { prepareTransactionRequest } from 'viem/actions'\n *\n * const client = createWalletClient({\n *   account: privateKeyToAccount('0x'),\n *   chain: mainnet,\n *   transport: custom(window.ethereum),\n * })\n * const request = await prepareTransactionRequest(client, {\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: 1n,\n * })\n */\nexport async function prepareTransactionRequest(client, args) {\n    const { account: account_ = client.account, blobs, chain, gas, kzg, nonce, nonceManager, parameters = defaultParameters, type, } = args;\n    const account = account_ ? parseAccount(account_) : account_;\n    const request = { ...args, ...(account ? { from: account?.address } : {}) };\n    let block;\n    async function getBlock() {\n        if (block)\n            return block;\n        block = await getAction(client, getBlock_, 'getBlock')({ blockTag: 'latest' });\n        return block;\n    }\n    let chainId;\n    async function getChainId() {\n        if (chainId)\n            return chainId;\n        if (chain)\n            return chain.id;\n        if (typeof args.chainId !== 'undefined')\n            return args.chainId;\n        const chainId_ = await getAction(client, getChainId_, 'getChainId')({});\n        chainId = chainId_;\n        return chainId;\n    }\n    if (parameters.includes('nonce') && typeof nonce === 'undefined' && account) {\n        if (nonceManager) {\n            const chainId = await getChainId();\n            request.nonce = await nonceManager.consume({\n                address: account.address,\n                chainId,\n                client,\n            });\n        }\n        else {\n            request.nonce = await getAction(client, getTransactionCount, 'getTransactionCount')({\n                address: account.address,\n                blockTag: 'pending',\n            });\n        }\n    }\n    if ((parameters.includes('blobVersionedHashes') ||\n        parameters.includes('sidecars')) &&\n        blobs &&\n        kzg) {\n        const commitments = blobsToCommitments({ blobs, kzg });\n        if (parameters.includes('blobVersionedHashes')) {\n            const versionedHashes = commitmentsToVersionedHashes({\n                commitments,\n                to: 'hex',\n            });\n            request.blobVersionedHashes = versionedHashes;\n        }\n        if (parameters.includes('sidecars')) {\n            const proofs = blobsToProofs({ blobs, commitments, kzg });\n            const sidecars = toBlobSidecars({\n                blobs,\n                commitments,\n                proofs,\n                to: 'hex',\n            });\n            request.sidecars = sidecars;\n        }\n    }\n    if (parameters.includes('chainId'))\n        request.chainId = await getChainId();\n    if ((parameters.includes('fees') || parameters.includes('type')) &&\n        typeof type === 'undefined') {\n        try {\n            request.type = getTransactionType(request);\n        }\n        catch {\n            let isEip1559Network = eip1559NetworkCache.get(client.uid);\n            if (typeof isEip1559Network === 'undefined') {\n                const block = await getBlock();\n                isEip1559Network = typeof block?.baseFeePerGas === 'bigint';\n                eip1559NetworkCache.set(client.uid, isEip1559Network);\n            }\n            request.type = isEip1559Network ? 'eip1559' : 'legacy';\n        }\n    }\n    if (parameters.includes('fees')) {\n        // TODO(4844): derive blob base fees once https://github.com/ethereum/execution-apis/pull/486 is merged.\n        if (request.type !== 'legacy' && request.type !== 'eip2930') {\n            // EIP-1559 fees\n            if (typeof request.maxFeePerGas === 'undefined' ||\n                typeof request.maxPriorityFeePerGas === 'undefined') {\n                const block = await getBlock();\n                const { maxFeePerGas, maxPriorityFeePerGas } = await internal_estimateFeesPerGas(client, {\n                    block: block,\n                    chain,\n                    request: request,\n                });\n                if (typeof args.maxPriorityFeePerGas === 'undefined' &&\n                    args.maxFeePerGas &&\n                    args.maxFeePerGas < maxPriorityFeePerGas)\n                    throw new MaxFeePerGasTooLowError({\n                        maxPriorityFeePerGas,\n                    });\n                request.maxPriorityFeePerGas = maxPriorityFeePerGas;\n                request.maxFeePerGas = maxFeePerGas;\n            }\n        }\n        else {\n            // Legacy fees\n            if (typeof args.maxFeePerGas !== 'undefined' ||\n                typeof args.maxPriorityFeePerGas !== 'undefined')\n                throw new Eip1559FeesNotSupportedError();\n            if (typeof args.gasPrice === 'undefined') {\n                const block = await getBlock();\n                const { gasPrice: gasPrice_ } = await internal_estimateFeesPerGas(client, {\n                    block: block,\n                    chain,\n                    request: request,\n                    type: 'legacy',\n                });\n                request.gasPrice = gasPrice_;\n            }\n        }\n    }\n    if (parameters.includes('gas') && typeof gas === 'undefined')\n        request.gas = await getAction(client, estimateGas, 'estimateGas')({\n            ...request,\n            account: account\n                ? { address: account.address, type: 'json-rpc' }\n                : account,\n        });\n    assertRequest(request);\n    delete request.parameters;\n    return request;\n}\n//# sourceMappingURL=prepareTransactionRequest.js.map","import { parseAccount, } from '../../accounts/utils/parseAccount.js';\nimport { BaseError } from '../../errors/base.js';\nimport { recoverAuthorizationAddress, } from '../../utils/authorization/recoverAuthorizationAddress.js';\nimport { numberToHex, } from '../../utils/encoding/toHex.js';\nimport { getEstimateGasError, } from '../../utils/errors/getEstimateGasError.js';\nimport { extract } from '../../utils/formatters/extract.js';\nimport { formatTransactionRequest, } from '../../utils/formatters/transactionRequest.js';\nimport { serializeStateOverride } from '../../utils/stateOverride.js';\nimport { assertRequest, } from '../../utils/transaction/assertRequest.js';\nimport { prepareTransactionRequest, } from '../wallet/prepareTransactionRequest.js';\n/**\n * Estimates the gas necessary to complete a transaction without submitting it to the network.\n *\n * - Docs: https://viem.sh/docs/actions/public/estimateGas\n * - JSON-RPC Methods: [`eth_estimateGas`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_estimategas)\n *\n * @param client - Client to use\n * @param parameters - {@link EstimateGasParameters}\n * @returns The gas estimate (in gas units). {@link EstimateGasReturnType}\n *\n * @example\n * import { createPublicClient, http, parseEther } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { estimateGas } from 'viem/public'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const gasEstimate = await estimateGas(client, {\n *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: parseEther('1'),\n * })\n */\nexport async function estimateGas(client, args) {\n    const { account: account_ = client.account } = args;\n    const account = account_ ? parseAccount(account_) : undefined;\n    try {\n        const { accessList, authorizationList, blobs, blobVersionedHashes, blockNumber, blockTag, data, gas, gasPrice, maxFeePerBlobGas, maxFeePerGas, maxPriorityFeePerGas, nonce, value, stateOverride, ...rest } = (await prepareTransactionRequest(client, {\n            ...args,\n            parameters: \n            // Some RPC Providers do not compute versioned hashes from blobs. We will need\n            // to compute them.\n            account?.type === 'local' ? undefined : ['blobVersionedHashes'],\n        }));\n        const blockNumberHex = typeof blockNumber === 'bigint' ? numberToHex(blockNumber) : undefined;\n        const block = blockNumberHex || blockTag;\n        const rpcStateOverride = serializeStateOverride(stateOverride);\n        const to = await (async () => {\n            // If `to` exists on the parameters, use that.\n            if (rest.to)\n                return rest.to;\n            // If no `to` exists, and we are sending a EIP-7702 transaction, use the\n            // address of the first authorization in the list.\n            if (authorizationList && authorizationList.length > 0)\n                return await recoverAuthorizationAddress({\n                    authorization: authorizationList[0],\n                }).catch(() => {\n                    throw new BaseError('`to` is required. Could not infer from `authorizationList`');\n                });\n            // Otherwise, we are sending a deployment transaction.\n            return undefined;\n        })();\n        assertRequest(args);\n        const chainFormat = client.chain?.formatters?.transactionRequest?.format;\n        const format = chainFormat || formatTransactionRequest;\n        const request = format({\n            // Pick out extra data that might exist on the chain's transaction request type.\n            ...extract(rest, { format: chainFormat }),\n            from: account?.address,\n            accessList,\n            authorizationList,\n            blobs,\n            blobVersionedHashes,\n            data,\n            gas,\n            gasPrice,\n            maxFeePerBlobGas,\n            maxFeePerGas,\n            maxPriorityFeePerGas,\n            nonce,\n            to,\n            value,\n        });\n        return BigInt(await client.request({\n            method: 'eth_estimateGas',\n            params: rpcStateOverride\n                ? [\n                    request,\n                    block ?? client.experimental_blockTag ?? 'latest',\n                    rpcStateOverride,\n                ]\n                : block\n                    ? [request, block]\n                    : [request],\n        }));\n    }\n    catch (err) {\n        throw getEstimateGasError(err, {\n            ...args,\n            account,\n            chain: client.chain,\n        });\n    }\n}\n//# sourceMappingURL=estimateGas.js.map","import { parseAccount, } from '../../accounts/utils/parseAccount.js';\nimport { encodeFunctionData, } from '../../utils/abi/encodeFunctionData.js';\nimport { getContractError, } from '../../utils/errors/getContractError.js';\nimport { getAction } from '../../utils/getAction.js';\nimport { estimateGas, } from './estimateGas.js';\n/**\n * Estimates the gas required to successfully execute a contract write function call.\n *\n * - Docs: https://viem.sh/docs/contract/estimateContractGas\n *\n * Internally, uses a [Public Client](https://viem.sh/docs/clients/public) to call the [`estimateGas` action](https://viem.sh/docs/actions/public/estimateGas) with [ABI-encoded `data`](https://viem.sh/docs/contract/encodeFunctionData).\n *\n * @param client - Client to use\n * @param parameters - {@link EstimateContractGasParameters}\n * @returns The gas estimate (in wei). {@link EstimateContractGasReturnType}\n *\n * @example\n * import { createPublicClient, http, parseAbi } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { estimateContractGas } from 'viem/contract'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const gas = await estimateContractGas(client, {\n *   address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',\n *   abi: parseAbi(['function mint() public']),\n *   functionName: 'mint',\n *   account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',\n * })\n */\nexport async function estimateContractGas(client, parameters) {\n    const { abi, address, args, functionName, dataSuffix, ...request } = parameters;\n    const data = encodeFunctionData({\n        abi,\n        args,\n        functionName,\n    });\n    try {\n        const gas = await getAction(client, estimateGas, 'estimateGas')({\n            data: `${data}${dataSuffix ? dataSuffix.replace('0x', '') : ''}`,\n            to: address,\n            ...request,\n        });\n        return gas;\n    }\n    catch (error) {\n        const account = request.account ? parseAccount(request.account) : undefined;\n        throw getContractError(error, {\n            abi,\n            address,\n            args,\n            docsPath: '/docs/contract/estimateContractGas',\n            functionName,\n            sender: account?.address,\n        });\n    }\n}\n//# sourceMappingURL=estimateContractGas.js.map","import { AbiDecodingDataSizeTooSmallError, AbiEventSignatureEmptyTopicsError, AbiEventSignatureNotFoundError, DecodeLogDataMismatch, DecodeLogTopicsMismatch, } from '../../errors/abi.js';\nimport { PositionOutOfBoundsError } from '../../errors/cursor.js';\nimport { size } from '../data/size.js';\nimport { toEventSelector, } from '../hash/toEventSelector.js';\nimport { decodeAbiParameters, } from './decodeAbiParameters.js';\nimport { formatAbiItem } from './formatAbiItem.js';\nconst docsPath = '/docs/contract/decodeEventLog';\nexport function decodeEventLog(parameters) {\n    const { abi, data, strict: strict_, topics, } = parameters;\n    const strict = strict_ ?? true;\n    const [signature, ...argTopics] = topics;\n    if (!signature)\n        throw new AbiEventSignatureEmptyTopicsError({ docsPath });\n    const abiItem = abi.find((x) => x.type === 'event' &&\n        signature === toEventSelector(formatAbiItem(x)));\n    if (!(abiItem && 'name' in abiItem) || abiItem.type !== 'event')\n        throw new AbiEventSignatureNotFoundError(signature, { docsPath });\n    const { name, inputs } = abiItem;\n    const isUnnamed = inputs?.some((x) => !('name' in x && x.name));\n    const args = isUnnamed ? [] : {};\n    // Decode topics (indexed args).\n    const indexedInputs = inputs\n        .map((x, i) => [x, i])\n        .filter(([x]) => 'indexed' in x && x.indexed);\n    for (let i = 0; i < indexedInputs.length; i++) {\n        const [param, argIndex] = indexedInputs[i];\n        const topic = argTopics[i];\n        if (!topic)\n            throw new DecodeLogTopicsMismatch({\n                abiItem,\n                param: param,\n            });\n        args[isUnnamed ? argIndex : param.name || argIndex] = decodeTopic({\n            param,\n            value: topic,\n        });\n    }\n    // Decode data (non-indexed args).\n    const nonIndexedInputs = inputs.filter((x) => !('indexed' in x && x.indexed));\n    if (nonIndexedInputs.length > 0) {\n        if (data && data !== '0x') {\n            try {\n                const decodedData = decodeAbiParameters(nonIndexedInputs, data);\n                if (decodedData) {\n                    if (isUnnamed)\n                        for (let i = 0; i < inputs.length; i++)\n                            args[i] = args[i] ?? decodedData.shift();\n                    else\n                        for (let i = 0; i < nonIndexedInputs.length; i++)\n                            args[nonIndexedInputs[i].name] = decodedData[i];\n                }\n            }\n            catch (err) {\n                if (strict) {\n                    if (err instanceof AbiDecodingDataSizeTooSmallError ||\n                        err instanceof PositionOutOfBoundsError)\n                        throw new DecodeLogDataMismatch({\n                            abiItem,\n                            data: data,\n                            params: nonIndexedInputs,\n                            size: size(data),\n                        });\n                    throw err;\n                }\n            }\n        }\n        else if (strict) {\n            throw new DecodeLogDataMismatch({\n                abiItem,\n                data: '0x',\n                params: nonIndexedInputs,\n                size: 0,\n            });\n        }\n    }\n    return {\n        eventName: name,\n        args: Object.values(args).length > 0 ? args : undefined,\n    };\n}\nfunction decodeTopic({ param, value }) {\n    if (param.type === 'string' ||\n        param.type === 'bytes' ||\n        param.type === 'tuple' ||\n        param.type.match(/^(.*)\\[(\\d+)?\\]$/))\n        return value;\n    const decodedArg = decodeAbiParameters([param], value) || [];\n    return decodedArg[0];\n}\n//# sourceMappingURL=decodeEventLog.js.map","// TODO(v3): checksum address.\nimport { AbiEventSignatureNotFoundError, DecodeLogDataMismatch, DecodeLogTopicsMismatch, } from '../../errors/abi.js';\nimport { isAddressEqual } from '../address/isAddressEqual.js';\nimport { toBytes } from '../encoding/toBytes.js';\nimport { keccak256 } from '../hash/keccak256.js';\nimport { toEventSelector } from '../hash/toEventSelector.js';\nimport { decodeEventLog, } from './decodeEventLog.js';\n/**\n * Extracts & decodes logs matching the provided signature(s) (`abi` + optional `eventName`)\n * from a set of opaque logs.\n *\n * @param parameters - {@link ParseEventLogsParameters}\n * @returns The logs. {@link ParseEventLogsReturnType}\n *\n * @example\n * import { createClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { parseEventLogs } from 'viem/op-stack'\n *\n * const client = createClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n *\n * const receipt = await getTransactionReceipt(client, {\n *   hash: '0xec23b2ba4bc59ba61554507c1b1bc91649e6586eb2dd00c728e8ed0db8bb37ea',\n * })\n *\n * const logs = parseEventLogs({ logs: receipt.logs })\n * // [{ args: { ... }, eventName: 'TransactionDeposited', ... }, ...]\n */\nexport function parseEventLogs(parameters) {\n    const { abi, args, logs, strict = true } = parameters;\n    const eventName = (() => {\n        if (!parameters.eventName)\n            return undefined;\n        if (Array.isArray(parameters.eventName))\n            return parameters.eventName;\n        return [parameters.eventName];\n    })();\n    return logs\n        .map((log) => {\n        try {\n            const abiItem = abi.find((abiItem) => abiItem.type === 'event' &&\n                log.topics[0] === toEventSelector(abiItem));\n            if (!abiItem)\n                return null;\n            const event = decodeEventLog({\n                ...log,\n                abi: [abiItem],\n                strict,\n            });\n            // Check that the decoded event name matches the provided event name.\n            if (eventName && !eventName.includes(event.eventName))\n                return null;\n            // Check that the decoded event args match the provided args.\n            if (!includesArgs({\n                args: event.args,\n                inputs: abiItem.inputs,\n                matchArgs: args,\n            }))\n                return null;\n            return { ...event, ...log };\n        }\n        catch (err) {\n            let eventName;\n            let isUnnamed;\n            if (err instanceof AbiEventSignatureNotFoundError)\n                return null;\n            if (err instanceof DecodeLogDataMismatch ||\n                err instanceof DecodeLogTopicsMismatch) {\n                // If strict mode is on, and log data/topics do not match event definition, skip.\n                if (strict)\n                    return null;\n                eventName = err.abiItem.name;\n                isUnnamed = err.abiItem.inputs?.some((x) => !('name' in x && x.name));\n            }\n            // Set args to empty if there is an error decoding (e.g. indexed/non-indexed params mismatch).\n            return { ...log, args: isUnnamed ? [] : {}, eventName };\n        }\n    })\n        .filter(Boolean);\n}\nfunction includesArgs(parameters) {\n    const { args, inputs, matchArgs } = parameters;\n    if (!matchArgs)\n        return true;\n    if (!args)\n        return false;\n    function isEqual(input, value, arg) {\n        try {\n            if (input.type === 'address')\n                return isAddressEqual(value, arg);\n            if (input.type === 'string' || input.type === 'bytes')\n                return keccak256(toBytes(value)) === arg;\n            return value === arg;\n        }\n        catch {\n            return false;\n        }\n    }\n    if (Array.isArray(args) && Array.isArray(matchArgs)) {\n        return matchArgs.every((value, index) => {\n            if (value === null || value === undefined)\n                return true;\n            const input = inputs[index];\n            if (!input)\n                return false;\n            const value_ = Array.isArray(value) ? value : [value];\n            return value_.some((value) => isEqual(input, value, args[index]));\n        });\n    }\n    if (typeof args === 'object' &&\n        !Array.isArray(args) &&\n        typeof matchArgs === 'object' &&\n        !Array.isArray(matchArgs))\n        return Object.entries(matchArgs).every(([key, value]) => {\n            if (value === null || value === undefined)\n                return true;\n            const input = inputs.find((input) => input.name === key);\n            if (!input)\n                return false;\n            const value_ = Array.isArray(value) ? value : [value];\n            return value_.some((value) => isEqual(input, value, args[key]));\n        });\n    return false;\n}\n//# sourceMappingURL=parseEventLogs.js.map","import { encodeEventTopics, } from '../../utils/abi/encodeEventTopics.js';\nimport { parseEventLogs } from '../../utils/abi/parseEventLogs.js';\nimport { numberToHex, } from '../../utils/encoding/toHex.js';\nimport { formatLog, } from '../../utils/formatters/log.js';\n/**\n * Returns a list of event logs matching the provided parameters.\n *\n * - Docs: https://viem.sh/docs/actions/public/getLogs\n * - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/logs_event-logs\n * - JSON-RPC Methods: [`eth_getLogs`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getlogs)\n *\n * @param client - Client to use\n * @param parameters - {@link GetLogsParameters}\n * @returns A list of event logs. {@link GetLogsReturnType}\n *\n * @example\n * import { createPublicClient, http, parseAbiItem } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { getLogs } from 'viem/public'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const logs = await getLogs(client)\n */\nexport async function getLogs(client, { address, blockHash, fromBlock, toBlock, event, events: events_, args, strict: strict_, } = {}) {\n    const strict = strict_ ?? false;\n    const events = events_ ?? (event ? [event] : undefined);\n    let topics = [];\n    if (events) {\n        const encoded = events.flatMap((event) => encodeEventTopics({\n            abi: [event],\n            eventName: event.name,\n            args: events_ ? undefined : args,\n        }));\n        // TODO: Clean up type casting\n        topics = [encoded];\n        if (event)\n            topics = topics[0];\n    }\n    let logs;\n    if (blockHash) {\n        logs = await client.request({\n            method: 'eth_getLogs',\n            params: [{ address, topics, blockHash }],\n        });\n    }\n    else {\n        logs = await client.request({\n            method: 'eth_getLogs',\n            params: [\n                {\n                    address,\n                    topics,\n                    fromBlock: typeof fromBlock === 'bigint' ? numberToHex(fromBlock) : fromBlock,\n                    toBlock: typeof toBlock === 'bigint' ? numberToHex(toBlock) : toBlock,\n                },\n            ],\n        });\n    }\n    const formattedLogs = logs.map((log) => formatLog(log));\n    if (!events)\n        return formattedLogs;\n    return parseEventLogs({\n        abi: events,\n        args: args,\n        logs: formattedLogs,\n        strict,\n    });\n}\n//# sourceMappingURL=getLogs.js.map","import { getAbiItem, } from '../../utils/abi/getAbiItem.js';\nimport { getAction } from '../../utils/getAction.js';\nimport { getLogs, } from './getLogs.js';\n/**\n * Returns a list of event logs emitted by a contract.\n *\n * - Docs: https://viem.sh/docs/contract/getContractEvents#getcontractevents\n * - JSON-RPC Methods: [`eth_getLogs`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getlogs)\n *\n * @param client - Client to use\n * @param parameters - {@link GetContractEventsParameters}\n * @returns A list of event logs. {@link GetContractEventsReturnType}\n *\n * @example\n * import { createClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { getContractEvents } from 'viem/public'\n * import { wagmiAbi } from './abi'\n *\n * const client = createClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const logs = await getContractEvents(client, {\n *  address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',\n *  abi: wagmiAbi,\n *  eventName: 'Transfer'\n * })\n */\nexport async function getContractEvents(client, parameters) {\n    const { abi, address, args, blockHash, eventName, fromBlock, toBlock, strict, } = parameters;\n    const event = eventName\n        ? getAbiItem({ abi, name: eventName })\n        : undefined;\n    const events = !event\n        ? abi.filter((x) => x.type === 'event')\n        : undefined;\n    return getAction(client, getLogs, 'getLogs')({\n        address,\n        args,\n        blockHash,\n        event,\n        events,\n        fromBlock,\n        toBlock,\n        strict,\n    });\n}\n//# sourceMappingURL=getContractEvents.js.map","/**\n * Hex, bytes and number utilities.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// 100 lines of code in the file are duplicated from noble-hashes (utils).\n// This is OK: `abstract` directory does not use noble-hashes.\n// User may opt-in into using different hashing library. This way, noble-hashes\n// won't be included into their bundle.\nconst _0n = /* @__PURE__ */ BigInt(0);\nconst _1n = /* @__PURE__ */ BigInt(1);\nexport function isBytes(a) {\n    return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');\n}\nexport function abytes(item) {\n    if (!isBytes(item))\n        throw new Error('Uint8Array expected');\n}\nexport function abool(title, value) {\n    if (typeof value !== 'boolean')\n        throw new Error(title + ' boolean expected, got ' + value);\n}\n// Used in weierstrass, der\nexport function numberToHexUnpadded(num) {\n    const hex = num.toString(16);\n    return hex.length & 1 ? '0' + hex : hex;\n}\nexport function hexToNumber(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    return hex === '' ? _0n : BigInt('0x' + hex); // Big Endian\n}\n// Built-in hex conversion https://caniuse.com/mdn-javascript_builtins_uint8array_fromhex\nconst hasHexBuiltin = \n// @ts-ignore\ntypeof Uint8Array.from([]).toHex === 'function' && typeof Uint8Array.fromHex === 'function';\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));\n/**\n * Convert byte array to hex string. Uses built-in function, when available.\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nexport function bytesToHex(bytes) {\n    abytes(bytes);\n    // @ts-ignore\n    if (hasHexBuiltin)\n        return bytes.toHex();\n    // pre-caching improves the speed 6x\n    let hex = '';\n    for (let i = 0; i < bytes.length; i++) {\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };\nfunction asciiToBase16(ch) {\n    if (ch >= asciis._0 && ch <= asciis._9)\n        return ch - asciis._0; // '2' => 50-48\n    if (ch >= asciis.A && ch <= asciis.F)\n        return ch - (asciis.A - 10); // 'B' => 66-(65-10)\n    if (ch >= asciis.a && ch <= asciis.f)\n        return ch - (asciis.a - 10); // 'b' => 98-(97-10)\n    return;\n}\n/**\n * Convert hex string to byte array. Uses built-in function, when available.\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nexport function hexToBytes(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    // @ts-ignore\n    if (hasHexBuiltin)\n        return Uint8Array.fromHex(hex);\n    const hl = hex.length;\n    const al = hl / 2;\n    if (hl % 2)\n        throw new Error('hex string expected, got unpadded hex of length ' + hl);\n    const array = new Uint8Array(al);\n    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n        const n1 = asciiToBase16(hex.charCodeAt(hi));\n        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n        if (n1 === undefined || n2 === undefined) {\n            const char = hex[hi] + hex[hi + 1];\n            throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n        }\n        array[ai] = n1 * 16 + n2; // multiply first octet, e.g. 'a3' => 10*16+3 => 160 + 3 => 163\n    }\n    return array;\n}\n// BE: Big Endian, LE: Little Endian\nexport function bytesToNumberBE(bytes) {\n    return hexToNumber(bytesToHex(bytes));\n}\nexport function bytesToNumberLE(bytes) {\n    abytes(bytes);\n    return hexToNumber(bytesToHex(Uint8Array.from(bytes).reverse()));\n}\nexport function numberToBytesBE(n, len) {\n    return hexToBytes(n.toString(16).padStart(len * 2, '0'));\n}\nexport function numberToBytesLE(n, len) {\n    return numberToBytesBE(n, len).reverse();\n}\n// Unpadded, rarely used\nexport function numberToVarBytesBE(n) {\n    return hexToBytes(numberToHexUnpadded(n));\n}\n/**\n * Takes hex string or Uint8Array, converts to Uint8Array.\n * Validates output length.\n * Will throw error for other types.\n * @param title descriptive title for an error e.g. 'private key'\n * @param hex hex string or Uint8Array\n * @param expectedLength optional, will compare to result array's length\n * @returns\n */\nexport function ensureBytes(title, hex, expectedLength) {\n    let res;\n    if (typeof hex === 'string') {\n        try {\n            res = hexToBytes(hex);\n        }\n        catch (e) {\n            throw new Error(title + ' must be hex string or Uint8Array, cause: ' + e);\n        }\n    }\n    else if (isBytes(hex)) {\n        // Uint8Array.from() instead of hash.slice() because node.js Buffer\n        // is instance of Uint8Array, and its slice() creates **mutable** copy\n        res = Uint8Array.from(hex);\n    }\n    else {\n        throw new Error(title + ' must be hex string or Uint8Array');\n    }\n    const len = res.length;\n    if (typeof expectedLength === 'number' && len !== expectedLength)\n        throw new Error(title + ' of length ' + expectedLength + ' expected, got ' + len);\n    return res;\n}\n/**\n * Copies several Uint8Arrays into one.\n */\nexport function concatBytes(...arrays) {\n    let sum = 0;\n    for (let i = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        abytes(a);\n        sum += a.length;\n    }\n    const res = new Uint8Array(sum);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        res.set(a, pad);\n        pad += a.length;\n    }\n    return res;\n}\n// Compares 2 u8a-s in kinda constant time\nexport function equalBytes(a, b) {\n    if (a.length !== b.length)\n        return false;\n    let diff = 0;\n    for (let i = 0; i < a.length; i++)\n        diff |= a[i] ^ b[i];\n    return diff === 0;\n}\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nexport function utf8ToBytes(str) {\n    if (typeof str !== 'string')\n        throw new Error('string expected');\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n// Is positive bigint\nconst isPosBig = (n) => typeof n === 'bigint' && _0n <= n;\nexport function inRange(n, min, max) {\n    return isPosBig(n) && isPosBig(min) && isPosBig(max) && min <= n && n < max;\n}\n/**\n * Asserts min <= n < max. NOTE: It's < max and not <= max.\n * @example\n * aInRange('x', x, 1n, 256n); // would assume x is in (1n..255n)\n */\nexport function aInRange(title, n, min, max) {\n    // Why min <= n < max and not a (min < n < max) OR b (min <= n <= max)?\n    // consider P=256n, min=0n, max=P\n    // - a for min=0 would require -1:          `inRange('x', x, -1n, P)`\n    // - b would commonly require subtraction:  `inRange('x', x, 0n, P - 1n)`\n    // - our way is the cleanest:               `inRange('x', x, 0n, P)\n    if (!inRange(n, min, max))\n        throw new Error('expected valid ' + title + ': ' + min + ' <= n < ' + max + ', got ' + n);\n}\n// Bit operations\n/**\n * Calculates amount of bits in a bigint.\n * Same as `n.toString(2).length`\n * TODO: merge with nLength in modular\n */\nexport function bitLen(n) {\n    let len;\n    for (len = 0; n > _0n; n >>= _1n, len += 1)\n        ;\n    return len;\n}\n/**\n * Gets single bit at position.\n * NOTE: first bit position is 0 (same as arrays)\n * Same as `!!+Array.from(n.toString(2)).reverse()[pos]`\n */\nexport function bitGet(n, pos) {\n    return (n >> BigInt(pos)) & _1n;\n}\n/**\n * Sets single bit at position.\n */\nexport function bitSet(n, pos, value) {\n    return n | ((value ? _1n : _0n) << BigInt(pos));\n}\n/**\n * Calculate mask for N bits. Not using ** operator with bigints because of old engines.\n * Same as BigInt(`0b${Array(i).fill('1').join('')}`)\n */\nexport const bitMask = (n) => (_1n << BigInt(n)) - _1n;\n// DRBG\nconst u8n = (len) => new Uint8Array(len); // creates Uint8Array\nconst u8fr = (arr) => Uint8Array.from(arr); // another shortcut\n/**\n * Minimal HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n * @returns function that will call DRBG until 2nd arg returns something meaningful\n * @example\n *   const drbg = createHmacDRBG<Key>(32, 32, hmac);\n *   drbg(seed, bytesToKey); // bytesToKey must return Key or undefined\n */\nexport function createHmacDrbg(hashLen, qByteLen, hmacFn) {\n    if (typeof hashLen !== 'number' || hashLen < 2)\n        throw new Error('hashLen must be a number');\n    if (typeof qByteLen !== 'number' || qByteLen < 2)\n        throw new Error('qByteLen must be a number');\n    if (typeof hmacFn !== 'function')\n        throw new Error('hmacFn must be a function');\n    // Step B, Step C: set hashLen to 8*ceil(hlen/8)\n    let v = u8n(hashLen); // Minimal non-full-spec HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n    let k = u8n(hashLen); // Steps B and C of RFC6979 3.2: set hashLen, in our case always same\n    let i = 0; // Iterations counter, will throw when over 1000\n    const reset = () => {\n        v.fill(1);\n        k.fill(0);\n        i = 0;\n    };\n    const h = (...b) => hmacFn(k, v, ...b); // hmac(k)(v, ...values)\n    const reseed = (seed = u8n(0)) => {\n        // HMAC-DRBG reseed() function. Steps D-G\n        k = h(u8fr([0x00]), seed); // k = hmac(k || v || 0x00 || seed)\n        v = h(); // v = hmac(k || v)\n        if (seed.length === 0)\n            return;\n        k = h(u8fr([0x01]), seed); // k = hmac(k || v || 0x01 || seed)\n        v = h(); // v = hmac(k || v)\n    };\n    const gen = () => {\n        // HMAC-DRBG generate() function\n        if (i++ >= 1000)\n            throw new Error('drbg: tried 1000 values');\n        let len = 0;\n        const out = [];\n        while (len < qByteLen) {\n            v = h();\n            const sl = v.slice();\n            out.push(sl);\n            len += v.length;\n        }\n        return concatBytes(...out);\n    };\n    const genUntil = (seed, pred) => {\n        reset();\n        reseed(seed); // Steps D-G\n        let res = undefined; // Step H: grind until k is in [1..n-1]\n        while (!(res = pred(gen())))\n            reseed();\n        reset();\n        return res;\n    };\n    return genUntil;\n}\n// Validating curves and fields\nconst validatorFns = {\n    bigint: (val) => typeof val === 'bigint',\n    function: (val) => typeof val === 'function',\n    boolean: (val) => typeof val === 'boolean',\n    string: (val) => typeof val === 'string',\n    stringOrUint8Array: (val) => typeof val === 'string' || isBytes(val),\n    isSafeInteger: (val) => Number.isSafeInteger(val),\n    array: (val) => Array.isArray(val),\n    field: (val, object) => object.Fp.isValid(val),\n    hash: (val) => typeof val === 'function' && Number.isSafeInteger(val.outputLen),\n};\n// type Record<K extends string | number | symbol, T> = { [P in K]: T; }\nexport function validateObject(object, validators, optValidators = {}) {\n    const checkField = (fieldName, type, isOptional) => {\n        const checkVal = validatorFns[type];\n        if (typeof checkVal !== 'function')\n            throw new Error('invalid validator function');\n        const val = object[fieldName];\n        if (isOptional && val === undefined)\n            return;\n        if (!checkVal(val, object)) {\n            throw new Error('param ' + String(fieldName) + ' is invalid. Expected ' + type + ', got ' + val);\n        }\n    };\n    for (const [fieldName, type] of Object.entries(validators))\n        checkField(fieldName, type, false);\n    for (const [fieldName, type] of Object.entries(optValidators))\n        checkField(fieldName, type, true);\n    return object;\n}\n// validate type tests\n// const o: { a: number; b: number; c: number } = { a: 1, b: 5, c: 6 };\n// const z0 = validateObject(o, { a: 'isSafeInteger' }, { c: 'bigint' }); // Ok!\n// // Should fail type-check\n// const z1 = validateObject(o, { a: 'tmp' }, { c: 'zz' });\n// const z2 = validateObject(o, { a: 'isSafeInteger' }, { c: 'zz' });\n// const z3 = validateObject(o, { test: 'boolean', z: 'bug' });\n// const z4 = validateObject(o, { a: 'boolean', z: 'bug' });\n/**\n * throws not implemented error\n */\nexport const notImplemented = () => {\n    throw new Error('not implemented');\n};\n/**\n * Memoizes (caches) computation result.\n * Uses WeakMap: the value is going auto-cleaned by GC after last reference is removed.\n */\nexport function memoized(fn) {\n    const map = new WeakMap();\n    return (arg, ...args) => {\n        const val = map.get(arg);\n        if (val !== undefined)\n            return val;\n        const computed = fn(arg, ...args);\n        map.set(arg, computed);\n        return computed;\n    };\n}\n//# sourceMappingURL=utils.js.map","import * as Bytes from '../Bytes.js';\n/** @internal */\nexport function assertSize(bytes, size_) {\n    if (Bytes.size(bytes) > size_)\n        throw new Bytes.SizeOverflowError({\n            givenSize: Bytes.size(bytes),\n            maxSize: size_,\n        });\n}\n/** @internal */\nexport function assertStartOffset(value, start) {\n    if (typeof start === 'number' && start > 0 && start > Bytes.size(value) - 1)\n        throw new Bytes.SliceOffsetOutOfBoundsError({\n            offset: start,\n            position: 'start',\n            size: Bytes.size(value),\n        });\n}\n/** @internal */\nexport function assertEndOffset(value, start, end) {\n    if (typeof start === 'number' &&\n        typeof end === 'number' &&\n        Bytes.size(value) !== end - start) {\n        throw new Bytes.SliceOffsetOutOfBoundsError({\n            offset: end,\n            position: 'end',\n            size: Bytes.size(value),\n        });\n    }\n}\n/** @internal */\nexport const charCodeMap = {\n    zero: 48,\n    nine: 57,\n    A: 65,\n    F: 70,\n    a: 97,\n    f: 102,\n};\n/** @internal */\nexport function charCodeToBase16(char) {\n    if (char >= charCodeMap.zero && char <= charCodeMap.nine)\n        return char - charCodeMap.zero;\n    if (char >= charCodeMap.A && char <= charCodeMap.F)\n        return char - (charCodeMap.A - 10);\n    if (char >= charCodeMap.a && char <= charCodeMap.f)\n        return char - (charCodeMap.a - 10);\n    return undefined;\n}\n/** @internal */\nexport function pad(bytes, options = {}) {\n    const { dir, size = 32 } = options;\n    if (size === 0)\n        return bytes;\n    if (bytes.length > size)\n        throw new Bytes.SizeExceedsPaddingSizeError({\n            size: bytes.length,\n            targetSize: size,\n            type: 'Bytes',\n        });\n    const paddedBytes = new Uint8Array(size);\n    for (let i = 0; i < size; i++) {\n        const padEnd = dir === 'right';\n        paddedBytes[padEnd ? i : size - i - 1] =\n            bytes[padEnd ? i : bytes.length - i - 1];\n    }\n    return paddedBytes;\n}\n/** @internal */\nexport function trim(value, options = {}) {\n    const { dir = 'left' } = options;\n    let data = value;\n    let sliceLength = 0;\n    for (let i = 0; i < data.length - 1; i++) {\n        if (data[dir === 'left' ? i : data.length - i - 1].toString() === '0')\n            sliceLength++;\n        else\n            break;\n    }\n    data =\n        dir === 'left'\n            ? data.slice(sliceLength)\n            : data.slice(0, data.length - sliceLength);\n    return data;\n}\n//# sourceMappingURL=bytes.js.map","import { equalBytes } from '@noble/curves/abstract/utils';\nimport * as Errors from './Errors.js';\nimport * as Hex from './Hex.js';\nimport * as internal from './internal/bytes.js';\nimport * as internal_hex from './internal/hex.js';\nimport * as Json from './Json.js';\nconst decoder = /*#__PURE__*/ new TextDecoder();\nconst encoder = /*#__PURE__*/ new TextEncoder();\n/**\n * Asserts if the given value is {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.assert('abc')\n * // @error: Bytes.InvalidBytesTypeError:\n * // @error: Value `\"abc\"` of type `string` is an invalid Bytes value.\n * // @error: Bytes values must be of type `Uint8Array`.\n * ```\n *\n * @param value - Value to assert.\n */\nexport function assert(value) {\n    if (value instanceof Uint8Array)\n        return;\n    if (!value)\n        throw new InvalidBytesTypeError(value);\n    if (typeof value !== 'object')\n        throw new InvalidBytesTypeError(value);\n    if (!('BYTES_PER_ELEMENT' in value))\n        throw new InvalidBytesTypeError(value);\n    if (value.BYTES_PER_ELEMENT !== 1 || value.constructor.name !== 'Uint8Array')\n        throw new InvalidBytesTypeError(value);\n}\n/**\n * Concatenates two or more {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const bytes = Bytes.concat(\n *   Bytes.from([1]),\n *   Bytes.from([69]),\n *   Bytes.from([420, 69]),\n * )\n * // @log: Uint8Array [ 1, 69, 420, 69 ]\n * ```\n *\n * @param values - Values to concatenate.\n * @returns Concatenated {@link ox#Bytes.Bytes}.\n */\nexport function concat(...values) {\n    let length = 0;\n    for (const arr of values) {\n        length += arr.length;\n    }\n    const result = new Uint8Array(length);\n    for (let i = 0, index = 0; i < values.length; i++) {\n        const arr = values[i];\n        result.set(arr, index);\n        index += arr.length;\n    }\n    return result;\n}\n/**\n * Instantiates a {@link ox#Bytes.Bytes} value from a `Uint8Array`, a hex string, or an array of unsigned 8-bit integers.\n *\n * :::tip\n *\n * To instantiate from a **Boolean**, **String**, or **Number**, use one of the following:\n *\n * - `Bytes.fromBoolean`\n *\n * - `Bytes.fromString`\n *\n * - `Bytes.fromNumber`\n *\n * :::\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.from([255, 124, 5, 4])\n * // @log: Uint8Array([255, 124, 5, 4])\n *\n * const data = Bytes.from('0xdeadbeef')\n * // @log: Uint8Array([222, 173, 190, 239])\n * ```\n *\n * @param value - Value to convert.\n * @returns A {@link ox#Bytes.Bytes} instance.\n */\nexport function from(value) {\n    if (value instanceof Uint8Array)\n        return value;\n    if (typeof value === 'string')\n        return fromHex(value);\n    return fromArray(value);\n}\n/**\n * Converts an array of unsigned 8-bit integers into {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.fromArray([255, 124, 5, 4])\n * // @log: Uint8Array([255, 124, 5, 4])\n * ```\n *\n * @param value - Value to convert.\n * @returns A {@link ox#Bytes.Bytes} instance.\n */\nexport function fromArray(value) {\n    return value instanceof Uint8Array ? value : new Uint8Array(value);\n}\n/**\n * Encodes a boolean value into {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.fromBoolean(true)\n * // @log: Uint8Array([1])\n * ```\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.fromBoolean(true, { size: 32 })\n * // @log: Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1])\n * ```\n *\n * @param value - Boolean value to encode.\n * @param options - Encoding options.\n * @returns Encoded {@link ox#Bytes.Bytes}.\n */\nexport function fromBoolean(value, options = {}) {\n    const { size } = options;\n    const bytes = new Uint8Array(1);\n    bytes[0] = Number(value);\n    if (typeof size === 'number') {\n        internal.assertSize(bytes, size);\n        return padLeft(bytes, size);\n    }\n    return bytes;\n}\n/**\n * Encodes a {@link ox#Hex.Hex} value into {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.fromHex('0x48656c6c6f20776f726c6421')\n * // @log: Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33])\n * ```\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.fromHex('0x48656c6c6f20776f726c6421', { size: 32 })\n * // @log: Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])\n * ```\n *\n * @param value - {@link ox#Hex.Hex} value to encode.\n * @param options - Encoding options.\n * @returns Encoded {@link ox#Bytes.Bytes}.\n */\nexport function fromHex(value, options = {}) {\n    const { size } = options;\n    let hex = value;\n    if (size) {\n        internal_hex.assertSize(value, size);\n        hex = Hex.padRight(value, size);\n    }\n    let hexString = hex.slice(2);\n    if (hexString.length % 2)\n        hexString = `0${hexString}`;\n    const length = hexString.length / 2;\n    const bytes = new Uint8Array(length);\n    for (let index = 0, j = 0; index < length; index++) {\n        const nibbleLeft = internal.charCodeToBase16(hexString.charCodeAt(j++));\n        const nibbleRight = internal.charCodeToBase16(hexString.charCodeAt(j++));\n        if (nibbleLeft === undefined || nibbleRight === undefined) {\n            throw new Errors.BaseError(`Invalid byte sequence (\"${hexString[j - 2]}${hexString[j - 1]}\" in \"${hexString}\").`);\n        }\n        bytes[index] = nibbleLeft * 16 + nibbleRight;\n    }\n    return bytes;\n}\n/**\n * Encodes a number value into {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.fromNumber(420)\n * // @log: Uint8Array([1, 164])\n * ```\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.fromNumber(420, { size: 4 })\n * // @log: Uint8Array([0, 0, 1, 164])\n * ```\n *\n * @param value - Number value to encode.\n * @param options - Encoding options.\n * @returns Encoded {@link ox#Bytes.Bytes}.\n */\nexport function fromNumber(value, options) {\n    const hex = Hex.fromNumber(value, options);\n    return fromHex(hex);\n}\n/**\n * Encodes a string into {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.fromString('Hello world!')\n * // @log: Uint8Array([72, 101, 108, 108, 111, 32, 119, 111, 114, 108, 100, 33])\n * ```\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.fromString('Hello world!', { size: 32 })\n * // @log: Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])\n * ```\n *\n * @param value - String to encode.\n * @param options - Encoding options.\n * @returns Encoded {@link ox#Bytes.Bytes}.\n */\nexport function fromString(value, options = {}) {\n    const { size } = options;\n    const bytes = encoder.encode(value);\n    if (typeof size === 'number') {\n        internal.assertSize(bytes, size);\n        return padRight(bytes, size);\n    }\n    return bytes;\n}\n/**\n * Checks if two {@link ox#Bytes.Bytes} values are equal.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.isEqual(Bytes.from([1]), Bytes.from([1]))\n * // @log: true\n *\n * Bytes.isEqual(Bytes.from([1]), Bytes.from([2]))\n * // @log: false\n * ```\n *\n * @param bytesA - First {@link ox#Bytes.Bytes} value.\n * @param bytesB - Second {@link ox#Bytes.Bytes} value.\n * @returns `true` if the two values are equal, otherwise `false`.\n */\nexport function isEqual(bytesA, bytesB) {\n    return equalBytes(bytesA, bytesB);\n}\n/**\n * Pads a {@link ox#Bytes.Bytes} value to the left with zero bytes until it reaches the given `size` (default: 32 bytes).\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.padLeft(Bytes.from([1]), 4)\n * // @log: Uint8Array([0, 0, 0, 1])\n * ```\n *\n * @param value - {@link ox#Bytes.Bytes} value to pad.\n * @param size - Size to pad the {@link ox#Bytes.Bytes} value to.\n * @returns Padded {@link ox#Bytes.Bytes} value.\n */\nexport function padLeft(value, size) {\n    return internal.pad(value, { dir: 'left', size });\n}\n/**\n * Pads a {@link ox#Bytes.Bytes} value to the right with zero bytes until it reaches the given `size` (default: 32 bytes).\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.padRight(Bytes.from([1]), 4)\n * // @log: Uint8Array([1, 0, 0, 0])\n * ```\n *\n * @param value - {@link ox#Bytes.Bytes} value to pad.\n * @param size - Size to pad the {@link ox#Bytes.Bytes} value to.\n * @returns Padded {@link ox#Bytes.Bytes} value.\n */\nexport function padRight(value, size) {\n    return internal.pad(value, { dir: 'right', size });\n}\n/**\n * Generates random {@link ox#Bytes.Bytes} of the specified length.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const bytes = Bytes.random(32)\n * // @log: Uint8Array([... x32])\n * ```\n *\n * @param length - Length of the random {@link ox#Bytes.Bytes} to generate.\n * @returns Random {@link ox#Bytes.Bytes} of the specified length.\n */\nexport function random(length) {\n    return crypto.getRandomValues(new Uint8Array(length));\n}\n/**\n * Retrieves the size of a {@link ox#Bytes.Bytes} value.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.size(Bytes.from([1, 2, 3, 4]))\n * // @log: 4\n * ```\n *\n * @param value - {@link ox#Bytes.Bytes} value.\n * @returns Size of the {@link ox#Bytes.Bytes} value.\n */\nexport function size(value) {\n    return value.length;\n}\n/**\n * Returns a section of a {@link ox#Bytes.Bytes} value given a start/end bytes offset.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.slice(\n *   Bytes.from([1, 2, 3, 4, 5, 6, 7, 8, 9]),\n *   1,\n *   4,\n * )\n * // @log: Uint8Array([2, 3, 4])\n * ```\n *\n * @param value - The {@link ox#Bytes.Bytes} value.\n * @param start - Start offset.\n * @param end - End offset.\n * @param options - Slice options.\n * @returns Sliced {@link ox#Bytes.Bytes} value.\n */\nexport function slice(value, start, end, options = {}) {\n    const { strict } = options;\n    internal.assertStartOffset(value, start);\n    const value_ = value.slice(start, end);\n    if (strict)\n        internal.assertEndOffset(value_, start, end);\n    return value_;\n}\n/**\n * Decodes a {@link ox#Bytes.Bytes} into a bigint.\n *\n * @example\n * ```ts\n * import { Bytes } from 'ox'\n *\n * Bytes.toBigInt(Bytes.from([1, 164]))\n * // @log: 420n\n * ```\n *\n * @param bytes - The {@link ox#Bytes.Bytes} to decode.\n * @param options - Decoding options.\n * @returns Decoded bigint.\n */\nexport function toBigInt(bytes, options = {}) {\n    const { size } = options;\n    if (typeof size !== 'undefined')\n        internal.assertSize(bytes, size);\n    const hex = Hex.fromBytes(bytes, options);\n    return Hex.toBigInt(hex, options);\n}\n/**\n * Decodes a {@link ox#Bytes.Bytes} into a boolean.\n *\n * @example\n * ```ts\n * import { Bytes } from 'ox'\n *\n * Bytes.toBoolean(Bytes.from([1]))\n * // @log: true\n * ```\n *\n * @param bytes - The {@link ox#Bytes.Bytes} to decode.\n * @param options - Decoding options.\n * @returns Decoded boolean.\n */\nexport function toBoolean(bytes, options = {}) {\n    const { size } = options;\n    let bytes_ = bytes;\n    if (typeof size !== 'undefined') {\n        internal.assertSize(bytes_, size);\n        bytes_ = trimLeft(bytes_);\n    }\n    if (bytes_.length > 1 || bytes_[0] > 1)\n        throw new InvalidBytesBooleanError(bytes_);\n    return Boolean(bytes_[0]);\n}\n/**\n * Encodes a {@link ox#Bytes.Bytes} value into a {@link ox#Hex.Hex} value.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.toHex(Bytes.from([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33]))\n * // '0x48656c6c6f20576f726c6421'\n * ```\n *\n * @param value - The {@link ox#Bytes.Bytes} to decode.\n * @param options - Options.\n * @returns Decoded {@link ox#Hex.Hex} value.\n */\nexport function toHex(value, options = {}) {\n    return Hex.fromBytes(value, options);\n}\n/**\n * Decodes a {@link ox#Bytes.Bytes} into a number.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.toNumber(Bytes.from([1, 164]))\n * // @log: 420\n * ```\n */\nexport function toNumber(bytes, options = {}) {\n    const { size } = options;\n    if (typeof size !== 'undefined')\n        internal.assertSize(bytes, size);\n    const hex = Hex.fromBytes(bytes, options);\n    return Hex.toNumber(hex, options);\n}\n/**\n * Decodes a {@link ox#Bytes.Bytes} into a string.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.toString(Bytes.from([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33]))\n * // @log: 'Hello world'\n * ```\n *\n * @param bytes - The {@link ox#Bytes.Bytes} to decode.\n * @param options - Options.\n * @returns Decoded string.\n */\nexport function toString(bytes, options = {}) {\n    const { size } = options;\n    let bytes_ = bytes;\n    if (typeof size !== 'undefined') {\n        internal.assertSize(bytes_, size);\n        bytes_ = trimRight(bytes_);\n    }\n    return decoder.decode(bytes_);\n}\n/**\n * Trims leading zeros from a {@link ox#Bytes.Bytes} value.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.trimLeft(Bytes.from([0, 0, 0, 0, 1, 2, 3]))\n * // @log: Uint8Array([1, 2, 3])\n * ```\n *\n * @param value - {@link ox#Bytes.Bytes} value.\n * @returns Trimmed {@link ox#Bytes.Bytes} value.\n */\nexport function trimLeft(value) {\n    return internal.trim(value, { dir: 'left' });\n}\n/**\n * Trims trailing zeros from a {@link ox#Bytes.Bytes} value.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.trimRight(Bytes.from([1, 2, 3, 0, 0, 0, 0]))\n * // @log: Uint8Array([1, 2, 3])\n * ```\n *\n * @param value - {@link ox#Bytes.Bytes} value.\n * @returns Trimmed {@link ox#Bytes.Bytes} value.\n */\nexport function trimRight(value) {\n    return internal.trim(value, { dir: 'right' });\n}\n/**\n * Checks if the given value is {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.validate('0x')\n * // @log: false\n *\n * Bytes.validate(Bytes.from([1, 2, 3]))\n * // @log: true\n * ```\n *\n * @param value - Value to check.\n * @returns `true` if the value is {@link ox#Bytes.Bytes}, otherwise `false`.\n */\nexport function validate(value) {\n    try {\n        assert(value);\n        return true;\n    }\n    catch {\n        return false;\n    }\n}\n/**\n * Thrown when the bytes value cannot be represented as a boolean.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.toBoolean(Bytes.from([5]))\n * // @error: Bytes.InvalidBytesBooleanError: Bytes value `[5]` is not a valid boolean.\n * // @error: The bytes array must contain a single byte of either a `0` or `1` value.\n * ```\n */\nexport class InvalidBytesBooleanError extends Errors.BaseError {\n    constructor(bytes) {\n        super(`Bytes value \\`${bytes}\\` is not a valid boolean.`, {\n            metaMessages: [\n                'The bytes array must contain a single byte of either a `0` or `1` value.',\n            ],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Bytes.InvalidBytesBooleanError'\n        });\n    }\n}\n/**\n * Thrown when a value cannot be converted to bytes.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Bytes } from 'ox'\n *\n * Bytes.from('foo')\n * // @error: Bytes.InvalidBytesTypeError: Value `foo` of type `string` is an invalid Bytes value.\n * ```\n */\nexport class InvalidBytesTypeError extends Errors.BaseError {\n    constructor(value) {\n        super(`Value \\`${typeof value === 'object' ? Json.stringify(value) : value}\\` of type \\`${typeof value}\\` is an invalid Bytes value.`, {\n            metaMessages: ['Bytes values must be of type `Bytes`.'],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Bytes.InvalidBytesTypeError'\n        });\n    }\n}\n/**\n * Thrown when a size exceeds the maximum allowed size.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.fromString('Hello World!', { size: 8 })\n * // @error: Bytes.SizeOverflowError: Size cannot exceed `8` bytes. Given size: `12` bytes.\n * ```\n */\nexport class SizeOverflowError extends Errors.BaseError {\n    constructor({ givenSize, maxSize }) {\n        super(`Size cannot exceed \\`${maxSize}\\` bytes. Given size: \\`${givenSize}\\` bytes.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Bytes.SizeOverflowError'\n        });\n    }\n}\n/**\n * Thrown when a slice offset is out-of-bounds.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.slice(Bytes.from([1, 2, 3]), 4)\n * // @error: Bytes.SliceOffsetOutOfBoundsError: Slice starting at offset `4` is out-of-bounds (size: `3`).\n * ```\n */\nexport class SliceOffsetOutOfBoundsError extends Errors.BaseError {\n    constructor({ offset, position, size, }) {\n        super(`Slice ${position === 'start' ? 'starting' : 'ending'} at offset \\`${offset}\\` is out-of-bounds (size: \\`${size}\\`).`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Bytes.SliceOffsetOutOfBoundsError'\n        });\n    }\n}\n/**\n * Thrown when a the padding size exceeds the maximum allowed size.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.padLeft(Bytes.fromString('Hello World!'), 8)\n * // @error: [Bytes.SizeExceedsPaddingSizeError: Bytes size (`12`) exceeds padding size (`8`).\n * ```\n */\nexport class SizeExceedsPaddingSizeError extends Errors.BaseError {\n    constructor({ size, targetSize, type, }) {\n        super(`${type.charAt(0).toUpperCase()}${type\n            .slice(1)\n            .toLowerCase()} size (\\`${size}\\`) exceeds padding size (\\`${targetSize}\\`).`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Bytes.SizeExceedsPaddingSizeError'\n        });\n    }\n}\n//# sourceMappingURL=Bytes.js.map","import { parseAccount, } from '../../accounts/utils/parseAccount.js';\nimport { decodeFunctionResult, } from '../../utils/abi/decodeFunctionResult.js';\nimport { encodeFunctionData, } from '../../utils/abi/encodeFunctionData.js';\nimport { getContractError, } from '../../utils/errors/getContractError.js';\nimport { getAction } from '../../utils/getAction.js';\nimport { call } from './call.js';\n/**\n * Simulates/validates a contract interaction. This is useful for retrieving **return data** and **revert reasons** of contract write functions.\n *\n * - Docs: https://viem.sh/docs/contract/simulateContract\n * - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/contracts_writing-to-contracts\n *\n * This function does not require gas to execute and _**does not**_ change the state of the blockchain. It is almost identical to [`readContract`](https://viem.sh/docs/contract/readContract), but also supports contract write functions.\n *\n * Internally, uses a [Public Client](https://viem.sh/docs/clients/public) to call the [`call` action](https://viem.sh/docs/actions/public/call) with [ABI-encoded `data`](https://viem.sh/docs/contract/encodeFunctionData).\n *\n * @param client - Client to use\n * @param parameters - {@link SimulateContractParameters}\n * @returns The simulation result and write request. {@link SimulateContractReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { simulateContract } from 'viem/contract'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const result = await simulateContract(client, {\n *   address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',\n *   abi: parseAbi(['function mint(uint32) view returns (uint32)']),\n *   functionName: 'mint',\n *   args: ['69420'],\n *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n * })\n */\nexport async function simulateContract(client, parameters) {\n    const { abi, address, args, dataSuffix, functionName, ...callRequest } = parameters;\n    const account = callRequest.account\n        ? parseAccount(callRequest.account)\n        : client.account;\n    const calldata = encodeFunctionData({ abi, args, functionName });\n    try {\n        const { data } = await getAction(client, call, 'call')({\n            batch: false,\n            data: `${calldata}${dataSuffix ? dataSuffix.replace('0x', '') : ''}`,\n            to: address,\n            ...callRequest,\n            account,\n        });\n        const result = decodeFunctionResult({\n            abi,\n            args,\n            functionName,\n            data: data || '0x',\n        });\n        const minimizedAbi = abi.filter((abiItem) => 'name' in abiItem && abiItem.name === parameters.functionName);\n        return {\n            result,\n            request: {\n                abi: minimizedAbi,\n                address,\n                args,\n                dataSuffix,\n                functionName,\n                ...callRequest,\n                account,\n            },\n        };\n    }\n    catch (error) {\n        throw getContractError(error, {\n            abi,\n            address,\n            args,\n            docsPath: '/docs/contract/simulateContract',\n            functionName,\n            sender: account?.address,\n        });\n    }\n}\n//# sourceMappingURL=simulateContract.js.map","/** @internal */\nexport const listenersCache = /*#__PURE__*/ new Map();\n/** @internal */\nexport const cleanupCache = /*#__PURE__*/ new Map();\nlet callbackCount = 0;\n/**\n * @description Sets up an observer for a given function. If another function\n * is set up under the same observer id, the function will only be called once\n * for both instances of the observer.\n */\nexport function observe(observerId, callbacks, fn) {\n    const callbackId = ++callbackCount;\n    const getListeners = () => listenersCache.get(observerId) || [];\n    const unsubscribe = () => {\n        const listeners = getListeners();\n        listenersCache.set(observerId, listeners.filter((cb) => cb.id !== callbackId));\n    };\n    const unwatch = () => {\n        const listeners = getListeners();\n        if (!listeners.some((cb) => cb.id === callbackId))\n            return;\n        const cleanup = cleanupCache.get(observerId);\n        if (listeners.length === 1 && cleanup) {\n            const p = cleanup();\n            if (p instanceof Promise)\n                p.catch(() => { });\n        }\n        unsubscribe();\n    };\n    const listeners = getListeners();\n    listenersCache.set(observerId, [\n        ...listeners,\n        { id: callbackId, fns: callbacks },\n    ]);\n    if (listeners && listeners.length > 0)\n        return unwatch;\n    const emit = {};\n    for (const key in callbacks) {\n        emit[key] = ((...args) => {\n            const listeners = getListeners();\n            if (listeners.length === 0)\n                return;\n            for (const listener of listeners)\n                listener.fns[key]?.(...args);\n        });\n    }\n    const cleanup = fn(emit);\n    if (typeof cleanup === 'function')\n        cleanupCache.set(observerId, cleanup);\n    return unwatch;\n}\n//# sourceMappingURL=observe.js.map","import { wait } from './wait.js';\n/**\n * @description Polls a function at a specified interval.\n */\nexport function poll(fn, { emitOnBegin, initialWaitTime, interval }) {\n    let active = true;\n    const unwatch = () => (active = false);\n    const watch = async () => {\n        let data;\n        if (emitOnBegin)\n            data = await fn({ unpoll: unwatch });\n        const initialWait = (await initialWaitTime?.(data)) ?? interval;\n        await wait(initialWait);\n        const poll = async () => {\n            if (!active)\n                return;\n            await fn({ unpoll: unwatch });\n            await wait(interval);\n            poll();\n        };\n        poll();\n    };\n    watch();\n    return unwatch;\n}\n//# sourceMappingURL=poll.js.map","/** @internal */\nexport const promiseCache = /*#__PURE__*/ new Map();\n/** @internal */\nexport const responseCache = /*#__PURE__*/ new Map();\nexport function getCache(cacheKey) {\n    const buildCache = (cacheKey, cache) => ({\n        clear: () => cache.delete(cacheKey),\n        get: () => cache.get(cacheKey),\n        set: (data) => cache.set(cacheKey, data),\n    });\n    const promise = buildCache(cacheKey, promiseCache);\n    const response = buildCache(cacheKey, responseCache);\n    return {\n        clear: () => {\n            promise.clear();\n            response.clear();\n        },\n        promise,\n        response,\n    };\n}\n/**\n * @description Returns the result of a given promise, and caches the result for\n * subsequent invocations against a provided cache key.\n */\nexport async function withCache(fn, { cacheKey, cacheTime = Number.POSITIVE_INFINITY }) {\n    const cache = getCache(cacheKey);\n    // If a response exists in the cache, and it's not expired, return it\n    // and do not invoke the promise.\n    // If the max age is 0, the cache is disabled.\n    const response = cache.response.get();\n    if (response && cacheTime > 0) {\n        const age = Date.now() - response.created.getTime();\n        if (age < cacheTime)\n            return response.data;\n    }\n    let promise = cache.promise.get();\n    if (!promise) {\n        promise = fn();\n        // Store the promise in the cache so that subsequent invocations\n        // will wait for the same promise to resolve (deduping).\n        cache.promise.set(promise);\n    }\n    try {\n        const data = await promise;\n        // Store the response in the cache so that subsequent invocations\n        // will return the same response.\n        cache.response.set({ created: new Date(), data });\n        return data;\n    }\n    finally {\n        // Clear the promise cache so that subsequent invocations will\n        // invoke the promise again.\n        cache.promise.clear();\n    }\n}\n//# sourceMappingURL=withCache.js.map","import { getCache, withCache, } from '../../utils/promise/withCache.js';\nconst cacheKey = (id) => `blockNumber.${id}`;\n/** @internal */\nexport function getBlockNumberCache(id) {\n    return getCache(cacheKey(id));\n}\n/**\n * Returns the number of the most recent block seen.\n *\n * - Docs: https://viem.sh/docs/actions/public/getBlockNumber\n * - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/blocks_fetching-blocks\n * - JSON-RPC Methods: [`eth_blockNumber`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_blocknumber)\n *\n * @param client - Client to use\n * @param parameters - {@link GetBlockNumberParameters}\n * @returns The number of the block. {@link GetBlockNumberReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { getBlockNumber } from 'viem/public'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const blockNumber = await getBlockNumber(client)\n * // 69420n\n */\nexport async function getBlockNumber(client, { cacheTime = client.cacheTime } = {}) {\n    const blockNumberHex = await withCache(() => client.request({\n        method: 'eth_blockNumber',\n    }), { cacheKey: cacheKey(client.uid), cacheTime });\n    return BigInt(blockNumberHex);\n}\n//# sourceMappingURL=getBlockNumber.js.map","import { parseEventLogs } from '../../utils/abi/parseEventLogs.js';\nimport { formatLog, } from '../../utils/formatters/log.js';\n/**\n * Returns a list of logs or hashes based on a [Filter](/docs/glossary/terms#filter) since the last time it was called.\n *\n * - Docs: https://viem.sh/docs/actions/public/getFilterChanges\n * - JSON-RPC Methods: [`eth_getFilterChanges`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getfilterchanges)\n *\n * A Filter can be created from the following actions:\n *\n * - [`createBlockFilter`](https://viem.sh/docs/actions/public/createBlockFilter)\n * - [`createContractEventFilter`](https://viem.sh/docs/contract/createContractEventFilter)\n * - [`createEventFilter`](https://viem.sh/docs/actions/public/createEventFilter)\n * - [`createPendingTransactionFilter`](https://viem.sh/docs/actions/public/createPendingTransactionFilter)\n *\n * Depending on the type of filter, the return value will be different:\n *\n * - If the filter was created with `createContractEventFilter` or `createEventFilter`, it returns a list of logs.\n * - If the filter was created with `createPendingTransactionFilter`, it returns a list of transaction hashes.\n * - If the filter was created with `createBlockFilter`, it returns a list of block hashes.\n *\n * @param client - Client to use\n * @param parameters - {@link GetFilterChangesParameters}\n * @returns Logs or hashes. {@link GetFilterChangesReturnType}\n *\n * @example\n * // Blocks\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { createBlockFilter, getFilterChanges } from 'viem/public'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const filter = await createBlockFilter(client)\n * const hashes = await getFilterChanges(client, { filter })\n *\n * @example\n * // Contract Events\n * import { createPublicClient, http, parseAbi } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { createContractEventFilter, getFilterChanges } from 'viem/public'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const filter = await createContractEventFilter(client, {\n *   address: '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48',\n *   abi: parseAbi(['event Transfer(address indexed, address indexed, uint256)']),\n *   eventName: 'Transfer',\n * })\n * const logs = await getFilterChanges(client, { filter })\n *\n * @example\n * // Raw Events\n * import { createPublicClient, http, parseAbiItem } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { createEventFilter, getFilterChanges } from 'viem/public'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const filter = await createEventFilter(client, {\n *   address: '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48',\n *   event: parseAbiItem('event Transfer(address indexed, address indexed, uint256)'),\n * })\n * const logs = await getFilterChanges(client, { filter })\n *\n * @example\n * // Transactions\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { createPendingTransactionFilter, getFilterChanges } from 'viem/public'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const filter = await createPendingTransactionFilter(client)\n * const hashes = await getFilterChanges(client, { filter })\n */\nexport async function getFilterChanges(_client, { filter, }) {\n    const strict = 'strict' in filter && filter.strict;\n    const logs = await filter.request({\n        method: 'eth_getFilterChanges',\n        params: [filter.id],\n    });\n    if (typeof logs[0] === 'string')\n        return logs;\n    const formattedLogs = logs.map((log) => formatLog(log));\n    if (!('abi' in filter) || !filter.abi)\n        return formattedLogs;\n    return parseEventLogs({\n        abi: filter.abi,\n        logs: formattedLogs,\n        strict,\n    });\n}\n//# sourceMappingURL=getFilterChanges.js.map","/**\n * Destroys a [`Filter`](https://viem.sh/docs/glossary/types#filter).\n *\n * - Docs: https://viem.sh/docs/actions/public/uninstallFilter\n * - JSON-RPC Methods: [`eth_uninstallFilter`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_uninstallFilter)\n *\n * Destroys a Filter that was created from one of the following Actions:\n * - [`createBlockFilter`](https://viem.sh/docs/actions/public/createBlockFilter)\n * - [`createEventFilter`](https://viem.sh/docs/actions/public/createEventFilter)\n * - [`createPendingTransactionFilter`](https://viem.sh/docs/actions/public/createPendingTransactionFilter)\n *\n * @param client - Client to use\n * @param parameters - {@link UninstallFilterParameters}\n * @returns A boolean indicating if the Filter was successfully uninstalled. {@link UninstallFilterReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { createPendingTransactionFilter, uninstallFilter } from 'viem/public'\n *\n * const filter = await createPendingTransactionFilter(client)\n * const uninstalled = await uninstallFilter(client, { filter })\n * // true\n */\nexport async function uninstallFilter(_client, { filter }) {\n    return filter.request({\n        method: 'eth_uninstallFilter',\n        params: [filter.id],\n    });\n}\n//# sourceMappingURL=uninstallFilter.js.map","import { DecodeLogDataMismatch, DecodeLogTopicsMismatch, } from '../../errors/abi.js';\nimport { InvalidInputRpcError } from '../../errors/rpc.js';\nimport { decodeEventLog } from '../../utils/abi/decodeEventLog.js';\nimport { encodeEventTopics, } from '../../utils/abi/encodeEventTopics.js';\nimport { formatLog } from '../../utils/formatters/log.js';\nimport { getAction } from '../../utils/getAction.js';\nimport { observe } from '../../utils/observe.js';\nimport { poll } from '../../utils/poll.js';\nimport { stringify } from '../../utils/stringify.js';\nimport { createContractEventFilter } from './createContractEventFilter.js';\nimport { getBlockNumber } from './getBlockNumber.js';\nimport { getContractEvents, } from './getContractEvents.js';\nimport { getFilterChanges } from './getFilterChanges.js';\nimport { uninstallFilter } from './uninstallFilter.js';\n/**\n * Watches and returns emitted contract event logs.\n *\n * - Docs: https://viem.sh/docs/contract/watchContractEvent\n *\n * This Action will batch up all the event logs found within the [`pollingInterval`](https://viem.sh/docs/contract/watchContractEvent#pollinginterval-optional), and invoke them via [`onLogs`](https://viem.sh/docs/contract/watchContractEvent#onLogs).\n *\n * `watchContractEvent` will attempt to create an [Event Filter](https://viem.sh/docs/contract/createContractEventFilter) and listen to changes to the Filter per polling interval, however, if the RPC Provider does not support Filters (e.g. `eth_newFilter`), then `watchContractEvent` will fall back to using [`getLogs`](https://viem.sh/docs/actions/public/getLogs) instead.\n *\n * @param client - Client to use\n * @param parameters - {@link WatchContractEventParameters}\n * @returns A function that can be invoked to stop watching for new event logs. {@link WatchContractEventReturnType}\n *\n * @example\n * import { createPublicClient, http, parseAbi } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { watchContractEvent } from 'viem/contract'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const unwatch = watchContractEvent(client, {\n *   address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',\n *   abi: parseAbi(['event Transfer(address indexed from, address indexed to, uint256 value)']),\n *   eventName: 'Transfer',\n *   args: { from: '0xc961145a54C96E3aE9bAA048c4F4D6b04C13916b' },\n *   onLogs: (logs) => console.log(logs),\n * })\n */\nexport function watchContractEvent(client, parameters) {\n    const { abi, address, args, batch = true, eventName, fromBlock, onError, onLogs, poll: poll_, pollingInterval = client.pollingInterval, strict: strict_, } = parameters;\n    const enablePolling = (() => {\n        if (typeof poll_ !== 'undefined')\n            return poll_;\n        if (typeof fromBlock === 'bigint')\n            return true;\n        if (client.transport.type === 'webSocket' ||\n            client.transport.type === 'ipc')\n            return false;\n        if (client.transport.type === 'fallback' &&\n            (client.transport.transports[0].config.type === 'webSocket' ||\n                client.transport.transports[0].config.type === 'ipc'))\n            return false;\n        return true;\n    })();\n    const pollContractEvent = () => {\n        const strict = strict_ ?? false;\n        const observerId = stringify([\n            'watchContractEvent',\n            address,\n            args,\n            batch,\n            client.uid,\n            eventName,\n            pollingInterval,\n            strict,\n            fromBlock,\n        ]);\n        return observe(observerId, { onLogs, onError }, (emit) => {\n            let previousBlockNumber;\n            if (fromBlock !== undefined)\n                previousBlockNumber = fromBlock - 1n;\n            let filter;\n            let initialized = false;\n            const unwatch = poll(async () => {\n                if (!initialized) {\n                    try {\n                        filter = (await getAction(client, createContractEventFilter, 'createContractEventFilter')({\n                            abi,\n                            address,\n                            args: args,\n                            eventName: eventName,\n                            strict: strict,\n                            fromBlock,\n                        }));\n                    }\n                    catch { }\n                    initialized = true;\n                    return;\n                }\n                try {\n                    let logs;\n                    if (filter) {\n                        logs = await getAction(client, getFilterChanges, 'getFilterChanges')({ filter });\n                    }\n                    else {\n                        // If the filter doesn't exist, we will fall back to use `getLogs`.\n                        // The fall back exists because some RPC Providers do not support filters.\n                        // Fetch the block number to use for `getLogs`.\n                        const blockNumber = await getAction(client, getBlockNumber, 'getBlockNumber')({});\n                        // If the block number has changed, we will need to fetch the logs.\n                        // If the block number doesn't exist, we are yet to reach the first poll interval,\n                        // so do not emit any logs.\n                        if (previousBlockNumber && previousBlockNumber < blockNumber) {\n                            logs = await getAction(client, getContractEvents, 'getContractEvents')({\n                                abi,\n                                address,\n                                args,\n                                eventName,\n                                fromBlock: previousBlockNumber + 1n,\n                                toBlock: blockNumber,\n                                strict,\n                            });\n                        }\n                        else {\n                            logs = [];\n                        }\n                        previousBlockNumber = blockNumber;\n                    }\n                    if (logs.length === 0)\n                        return;\n                    if (batch)\n                        emit.onLogs(logs);\n                    else\n                        for (const log of logs)\n                            emit.onLogs([log]);\n                }\n                catch (err) {\n                    // If a filter has been set and gets uninstalled, providers will throw an InvalidInput error.\n                    // Reinitialize the filter when this occurs\n                    if (filter && err instanceof InvalidInputRpcError)\n                        initialized = false;\n                    emit.onError?.(err);\n                }\n            }, {\n                emitOnBegin: true,\n                interval: pollingInterval,\n            });\n            return async () => {\n                if (filter)\n                    await getAction(client, uninstallFilter, 'uninstallFilter')({ filter });\n                unwatch();\n            };\n        });\n    };\n    const subscribeContractEvent = () => {\n        const strict = strict_ ?? false;\n        const observerId = stringify([\n            'watchContractEvent',\n            address,\n            args,\n            batch,\n            client.uid,\n            eventName,\n            pollingInterval,\n            strict,\n        ]);\n        let active = true;\n        let unsubscribe = () => (active = false);\n        return observe(observerId, { onLogs, onError }, (emit) => {\n            ;\n            (async () => {\n                try {\n                    const transport = (() => {\n                        if (client.transport.type === 'fallback') {\n                            const transport = client.transport.transports.find((transport) => transport.config.type === 'webSocket' ||\n                                transport.config.type === 'ipc');\n                            if (!transport)\n                                return client.transport;\n                            return transport.value;\n                        }\n                        return client.transport;\n                    })();\n                    const topics = eventName\n                        ? encodeEventTopics({\n                            abi: abi,\n                            eventName: eventName,\n                            args,\n                        })\n                        : [];\n                    const { unsubscribe: unsubscribe_ } = await transport.subscribe({\n                        params: ['logs', { address, topics }],\n                        onData(data) {\n                            if (!active)\n                                return;\n                            const log = data.result;\n                            try {\n                                const { eventName, args } = decodeEventLog({\n                                    abi: abi,\n                                    data: log.data,\n                                    topics: log.topics,\n                                    strict: strict_,\n                                });\n                                const formatted = formatLog(log, {\n                                    args,\n                                    eventName: eventName,\n                                });\n                                emit.onLogs([formatted]);\n                            }\n                            catch (err) {\n                                let eventName;\n                                let isUnnamed;\n                                if (err instanceof DecodeLogDataMismatch ||\n                                    err instanceof DecodeLogTopicsMismatch) {\n                                    // If strict mode is on, and log data/topics do not match event definition, skip.\n                                    if (strict_)\n                                        return;\n                                    eventName = err.abiItem.name;\n                                    isUnnamed = err.abiItem.inputs?.some((x) => !('name' in x && x.name));\n                                }\n                                // Set args to empty if there is an error decoding (e.g. indexed/non-indexed params mismatch).\n                                const formatted = formatLog(log, {\n                                    args: isUnnamed ? [] : {},\n                                    eventName,\n                                });\n                                emit.onLogs([formatted]);\n                            }\n                        },\n                        onError(error) {\n                            emit.onError?.(error);\n                        },\n                    });\n                    unsubscribe = unsubscribe_;\n                    if (!active)\n                        unsubscribe();\n                }\n                catch (err) {\n                    onError?.(err);\n                }\n            })();\n            return () => unsubscribe();\n        });\n    };\n    return enablePolling ? pollContractEvent() : subscribeContractEvent();\n}\n//# sourceMappingURL=watchContractEvent.js.map","/**\n * Sends a **signed** transaction to the network\n *\n * - Docs: https://viem.sh/docs/actions/wallet/sendRawTransaction\n * - JSON-RPC Method: [`eth_sendRawTransaction`](https://ethereum.github.io/execution-apis/api-documentation/)\n *\n * @param client - Client to use\n * @param parameters - {@link SendRawTransactionParameters}\n * @returns The transaction hash. {@link SendRawTransactionReturnType}\n *\n * @example\n * import { createWalletClient, custom } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { sendRawTransaction } from 'viem/wallet'\n *\n * const client = createWalletClient({\n *   chain: mainnet,\n *   transport: custom(window.ethereum),\n * })\n *\n * const hash = await sendRawTransaction(client, {\n *   serializedTransaction: '0x02f850018203118080825208808080c080a04012522854168b27e5dc3d5839bab5e6b39e1a0ffd343901ce1622e3d64b48f1a04e00902ae0502c4728cbf12156290df99c3ed7de85b1dbfe20b5c36931733a33'\n * })\n */\nexport async function sendRawTransaction(client, { serializedTransaction }) {\n    return client.request({\n        method: 'eth_sendRawTransaction',\n        params: [serializedTransaction],\n    }, { retryCount: 0 });\n}\n//# sourceMappingURL=sendRawTransaction.js.map","import { BaseError } from '../../errors/base.js';\nimport { ContractFunctionRevertedError } from '../../errors/contract.js';\n/*\n * @description Checks if error is a valid null result UniversalResolver error\n */\nexport function isNullUniversalResolverError(err) {\n    if (!(err instanceof BaseError))\n        return false;\n    const cause = err.walk((e) => e instanceof ContractFunctionRevertedError);\n    if (!(cause instanceof ContractFunctionRevertedError))\n        return false;\n    if (cause.data?.errorName === 'HttpError')\n        return true;\n    if (cause.data?.errorName === 'ResolverError')\n        return true;\n    if (cause.data?.errorName === 'ResolverNotContract')\n        return true;\n    if (cause.data?.errorName === 'ResolverNotFound')\n        return true;\n    if (cause.data?.errorName === 'ReverseAddressMismatch')\n        return true;\n    if (cause.data?.errorName === 'UnsupportedResolverProfile')\n        return true;\n    return false;\n}\n//# sourceMappingURL=errors.js.map","import { isHex } from '../data/isHex.js';\nexport function encodedLabelToLabelhash(label) {\n    if (label.length !== 66)\n        return null;\n    if (label.indexOf('[') !== 0)\n        return null;\n    if (label.indexOf(']') !== 65)\n        return null;\n    const hash = `0x${label.slice(1, 65)}`;\n    if (!isHex(hash))\n        return null;\n    return hash;\n}\n//# sourceMappingURL=encodedLabelToLabelhash.js.map","import { concat } from '../data/concat.js';\nimport { stringToBytes, toBytes, } from '../encoding/toBytes.js';\nimport { bytesToHex } from '../encoding/toHex.js';\nimport { keccak256 } from '../hash/keccak256.js';\nimport { encodedLabelToLabelhash, } from './encodedLabelToLabelhash.js';\n/**\n * @description Hashes ENS name\n *\n * - Since ENS names prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS names](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `namehash`. You can use the built-in [`normalize`](https://viem.sh/docs/ens/utilities/normalize) function for this.\n *\n * @example\n * namehash('wevm.eth')\n * '0x08c85f2f4059e930c45a6aeff9dcd3bd95dc3c5c1cddef6a0626b31152248560'\n *\n * @link https://eips.ethereum.org/EIPS/eip-137\n */\nexport function namehash(name) {\n    let result = new Uint8Array(32).fill(0);\n    if (!name)\n        return bytesToHex(result);\n    const labels = name.split('.');\n    // Iterate in reverse order building up hash\n    for (let i = labels.length - 1; i >= 0; i -= 1) {\n        const hashFromEncodedLabel = encodedLabelToLabelhash(labels[i]);\n        const hashed = hashFromEncodedLabel\n            ? toBytes(hashFromEncodedLabel)\n            : keccak256(stringToBytes(labels[i]), 'bytes');\n        result = keccak256(concat([result, hashed]), 'bytes');\n    }\n    return bytesToHex(result);\n}\n//# sourceMappingURL=namehash.js.map","export function encodeLabelhash(hash) {\n    return `[${hash.slice(2)}]`;\n}\n//# sourceMappingURL=encodeLabelhash.js.map","import { stringToBytes, } from '../encoding/toBytes.js';\nimport { bytesToHex } from '../encoding/toHex.js';\nimport { keccak256 } from '../hash/keccak256.js';\nimport { encodedLabelToLabelhash, } from './encodedLabelToLabelhash.js';\n/**\n * @description Hashes ENS label\n *\n * - Since ENS labels prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS labels](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `labelhash`. You can use the built-in [`normalize`](https://viem.sh/docs/ens/utilities/normalize) function for this.\n *\n * @example\n * labelhash('eth')\n * '0x4f5b812789fc606be1b3b16908db13fc7a9adf7ca72641f84d75b47069d3d7f0'\n */\nexport function labelhash(label) {\n    const result = new Uint8Array(32).fill(0);\n    if (!label)\n        return bytesToHex(result);\n    return encodedLabelToLabelhash(label) || keccak256(stringToBytes(label));\n}\n//# sourceMappingURL=labelhash.js.map","import { stringToBytes, } from '../encoding/toBytes.js';\nimport { encodeLabelhash, } from './encodeLabelhash.js';\nimport { labelhash } from './labelhash.js';\n/*\n * @description Encodes a DNS packet into a ByteArray containing a UDP payload.\n *\n * @example\n * packetToBytes('awkweb.eth')\n * '0x0661776b7765620365746800'\n *\n * @see https://docs.ens.domains/resolution/names#dns\n *\n */\nexport function packetToBytes(packet) {\n    // strip leading and trailing `.`\n    const value = packet.replace(/^\\.|\\.$/gm, '');\n    if (value.length === 0)\n        return new Uint8Array(1);\n    const bytes = new Uint8Array(stringToBytes(value).byteLength + 2);\n    let offset = 0;\n    const list = value.split('.');\n    for (let i = 0; i < list.length; i++) {\n        let encoded = stringToBytes(list[i]);\n        // if the length is > 255, make the encoded label value a labelhash\n        // this is compatible with the universal resolver\n        if (encoded.byteLength > 255)\n            encoded = stringToBytes(encodeLabelhash(labelhash(list[i])));\n        bytes[offset] = encoded.length;\n        bytes.set(encoded, offset + 1);\n        offset += encoded.length + 1;\n    }\n    if (bytes.byteLength !== offset + 1)\n        return bytes.slice(0, offset + 1);\n    return bytes;\n}\n//# sourceMappingURL=packetToBytes.js.map","import { addressResolverAbi, universalResolverResolveAbi, } from '../../constants/abis.js';\nimport { decodeFunctionResult, } from '../../utils/abi/decodeFunctionResult.js';\nimport { encodeFunctionData, } from '../../utils/abi/encodeFunctionData.js';\nimport { getChainContractAddress, } from '../../utils/chain/getChainContractAddress.js';\nimport { trim } from '../../utils/data/trim.js';\nimport { toHex } from '../../utils/encoding/toHex.js';\nimport { isNullUniversalResolverError } from '../../utils/ens/errors.js';\nimport { localBatchGatewayUrl } from '../../utils/ens/localBatchGatewayRequest.js';\nimport { namehash } from '../../utils/ens/namehash.js';\nimport { packetToBytes, } from '../../utils/ens/packetToBytes.js';\nimport { getAction } from '../../utils/getAction.js';\nimport { readContract, } from '../public/readContract.js';\n/**\n * Gets address for ENS name.\n *\n * - Docs: https://viem.sh/docs/ens/actions/getEnsAddress\n * - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/ens\n *\n * Calls `resolve(bytes, bytes)` on ENS Universal Resolver Contract.\n *\n * Since ENS names prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS names](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `getEnsAddress`. You can use the built-in [`normalize`](https://viem.sh/docs/ens/utilities/normalize) function for this.\n *\n * @param client - Client to use\n * @param parameters - {@link GetEnsAddressParameters}\n * @returns Address for ENS name or `null` if not found. {@link GetEnsAddressReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { getEnsAddress, normalize } from 'viem/ens'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const ensAddress = await getEnsAddress(client, {\n *   name: normalize('wevm.eth'),\n * })\n * // '0xd2135CfB216b74109775236E36d4b433F1DF507B'\n */\nexport async function getEnsAddress(client, parameters) {\n    const { blockNumber, blockTag, coinType, name, gatewayUrls, strict } = parameters;\n    const { chain } = client;\n    const universalResolverAddress = (() => {\n        if (parameters.universalResolverAddress)\n            return parameters.universalResolverAddress;\n        if (!chain)\n            throw new Error('client chain not configured. universalResolverAddress is required.');\n        return getChainContractAddress({\n            blockNumber,\n            chain,\n            contract: 'ensUniversalResolver',\n        });\n    })();\n    const tlds = chain?.ensTlds;\n    if (tlds && !tlds.some((tld) => name.endsWith(tld)))\n        return null;\n    const args = (() => {\n        if (coinType != null)\n            return [namehash(name), BigInt(coinType)];\n        return [namehash(name)];\n    })();\n    try {\n        const functionData = encodeFunctionData({\n            abi: addressResolverAbi,\n            functionName: 'addr',\n            args,\n        });\n        const readContractParameters = {\n            address: universalResolverAddress,\n            abi: universalResolverResolveAbi,\n            functionName: 'resolveWithGateways',\n            args: [\n                toHex(packetToBytes(name)),\n                functionData,\n                gatewayUrls ?? [localBatchGatewayUrl],\n            ],\n            blockNumber,\n            blockTag,\n        };\n        const readContractAction = getAction(client, readContract, 'readContract');\n        const res = await readContractAction(readContractParameters);\n        if (res[0] === '0x')\n            return null;\n        const address = decodeFunctionResult({\n            abi: addressResolverAbi,\n            args,\n            functionName: 'addr',\n            data: res[0],\n        });\n        if (address === '0x')\n            return null;\n        if (trim(address) === '0x00')\n            return null;\n        return address;\n    }\n    catch (err) {\n        if (strict)\n            throw err;\n        if (isNullUniversalResolverError(err))\n            return null;\n        throw err;\n    }\n}\n//# sourceMappingURL=getEnsAddress.js.map","import { BaseError } from './base.js';\nexport class EnsAvatarInvalidMetadataError extends BaseError {\n    constructor({ data }) {\n        super('Unable to extract image from metadata. The metadata may be malformed or invalid.', {\n            metaMessages: [\n                '- Metadata must be a JSON object with at least an `image`, `image_url` or `image_data` property.',\n                '',\n                `Provided data: ${JSON.stringify(data)}`,\n            ],\n            name: 'EnsAvatarInvalidMetadataError',\n        });\n    }\n}\nexport class EnsAvatarInvalidNftUriError extends BaseError {\n    constructor({ reason }) {\n        super(`ENS NFT avatar URI is invalid. ${reason}`, {\n            name: 'EnsAvatarInvalidNftUriError',\n        });\n    }\n}\nexport class EnsAvatarUriResolutionError extends BaseError {\n    constructor({ uri }) {\n        super(`Unable to resolve ENS avatar URI \"${uri}\". The URI may be malformed, invalid, or does not respond with a valid image.`, { name: 'EnsAvatarUriResolutionError' });\n    }\n}\nexport class EnsAvatarUnsupportedNamespaceError extends BaseError {\n    constructor({ namespace }) {\n        super(`ENS NFT avatar namespace \"${namespace}\" is not supported. Must be \"erc721\" or \"erc1155\".`, { name: 'EnsAvatarUnsupportedNamespaceError' });\n    }\n}\nexport class EnsInvalidChainIdError extends BaseError {\n    constructor({ chainId }) {\n        super(`Invalid ENSIP-11 chainId: ${chainId}. Must be between 0 and 0x7fffffff, or 1.`, {\n            name: 'EnsInvalidChainIdError',\n        });\n    }\n}\n//# sourceMappingURL=ens.js.map","import { readContract, } from '../../../actions/public/readContract.js';\nimport { EnsAvatarInvalidMetadataError, EnsAvatarInvalidNftUriError, EnsAvatarUnsupportedNamespaceError, EnsAvatarUriResolutionError, } from '../../../errors/ens.js';\nconst networkRegex = /(?<protocol>https?:\\/\\/[^/]*|ipfs:\\/|ipns:\\/|ar:\\/)?(?<root>\\/)?(?<subpath>ipfs\\/|ipns\\/)?(?<target>[\\w\\-.]+)(?<subtarget>\\/.*)?/;\nconst ipfsHashRegex = /^(Qm[1-9A-HJ-NP-Za-km-z]{44,}|b[A-Za-z2-7]{58,}|B[A-Z2-7]{58,}|z[1-9A-HJ-NP-Za-km-z]{48,}|F[0-9A-F]{50,})(\\/(?<target>[\\w\\-.]+))?(?<subtarget>\\/.*)?$/;\nconst base64Regex = /^data:([a-zA-Z\\-/+]*);base64,([^\"].*)/;\nconst dataURIRegex = /^data:([a-zA-Z\\-/+]*)?(;[a-zA-Z0-9].*?)?(,)/;\n/** @internal */\nexport async function isImageUri(uri) {\n    try {\n        const res = await fetch(uri, { method: 'HEAD' });\n        // retrieve content type header to check if content is image\n        if (res.status === 200) {\n            const contentType = res.headers.get('content-type');\n            return contentType?.startsWith('image/');\n        }\n        return false;\n    }\n    catch (error) {\n        // if error is not cors related then fail\n        if (typeof error === 'object' && typeof error.response !== 'undefined') {\n            return false;\n        }\n        // fail in NodeJS, since the error is not cors but any other network issue\n        if (!Object.hasOwn(globalThis, 'Image'))\n            return false;\n        // in case of cors, use image api to validate if given url is an actual image\n        return new Promise((resolve) => {\n            const img = new Image();\n            img.onload = () => {\n                resolve(true);\n            };\n            img.onerror = () => {\n                resolve(false);\n            };\n            img.src = uri;\n        });\n    }\n}\n/** @internal */\nexport function getGateway(custom, defaultGateway) {\n    if (!custom)\n        return defaultGateway;\n    if (custom.endsWith('/'))\n        return custom.slice(0, -1);\n    return custom;\n}\nexport function resolveAvatarUri({ uri, gatewayUrls, }) {\n    const isEncoded = base64Regex.test(uri);\n    if (isEncoded)\n        return { uri, isOnChain: true, isEncoded };\n    const ipfsGateway = getGateway(gatewayUrls?.ipfs, 'https://ipfs.io');\n    const arweaveGateway = getGateway(gatewayUrls?.arweave, 'https://arweave.net');\n    const networkRegexMatch = uri.match(networkRegex);\n    const { protocol, subpath, target, subtarget = '', } = networkRegexMatch?.groups || {};\n    const isIPNS = protocol === 'ipns:/' || subpath === 'ipns/';\n    const isIPFS = protocol === 'ipfs:/' || subpath === 'ipfs/' || ipfsHashRegex.test(uri);\n    if (uri.startsWith('http') && !isIPNS && !isIPFS) {\n        let replacedUri = uri;\n        if (gatewayUrls?.arweave)\n            replacedUri = uri.replace(/https:\\/\\/arweave.net/g, gatewayUrls?.arweave);\n        return { uri: replacedUri, isOnChain: false, isEncoded: false };\n    }\n    if ((isIPNS || isIPFS) && target) {\n        return {\n            uri: `${ipfsGateway}/${isIPNS ? 'ipns' : 'ipfs'}/${target}${subtarget}`,\n            isOnChain: false,\n            isEncoded: false,\n        };\n    }\n    if (protocol === 'ar:/' && target) {\n        return {\n            uri: `${arweaveGateway}/${target}${subtarget || ''}`,\n            isOnChain: false,\n            isEncoded: false,\n        };\n    }\n    let parsedUri = uri.replace(dataURIRegex, '');\n    if (parsedUri.startsWith('<svg')) {\n        // if svg, base64 encode\n        parsedUri = `data:image/svg+xml;base64,${btoa(parsedUri)}`;\n    }\n    if (parsedUri.startsWith('data:') || parsedUri.startsWith('{')) {\n        return {\n            uri: parsedUri,\n            isOnChain: true,\n            isEncoded: false,\n        };\n    }\n    throw new EnsAvatarUriResolutionError({ uri });\n}\nexport function getJsonImage(data) {\n    // validation check for json data, must include one of theses properties\n    if (typeof data !== 'object' ||\n        (!('image' in data) && !('image_url' in data) && !('image_data' in data))) {\n        throw new EnsAvatarInvalidMetadataError({ data });\n    }\n    return data.image || data.image_url || data.image_data;\n}\nexport async function getMetadataAvatarUri({ gatewayUrls, uri, }) {\n    try {\n        const res = await fetch(uri).then((res) => res.json());\n        const image = await parseAvatarUri({\n            gatewayUrls,\n            uri: getJsonImage(res),\n        });\n        return image;\n    }\n    catch {\n        throw new EnsAvatarUriResolutionError({ uri });\n    }\n}\nexport async function parseAvatarUri({ gatewayUrls, uri, }) {\n    const { uri: resolvedURI, isOnChain } = resolveAvatarUri({ uri, gatewayUrls });\n    if (isOnChain)\n        return resolvedURI;\n    // check if resolvedURI is an image, if it is return the url\n    const isImage = await isImageUri(resolvedURI);\n    if (isImage)\n        return resolvedURI;\n    throw new EnsAvatarUriResolutionError({ uri });\n}\nexport function parseNftUri(uri_) {\n    let uri = uri_;\n    // parse valid nft spec (CAIP-22/CAIP-29)\n    // @see: https://github.com/ChainAgnostic/CAIPs/tree/master/CAIPs\n    if (uri.startsWith('did:nft:')) {\n        // convert DID to CAIP\n        uri = uri.replace('did:nft:', '').replace(/_/g, '/');\n    }\n    const [reference, asset_namespace, tokenID] = uri.split('/');\n    const [eip_namespace, chainID] = reference.split(':');\n    const [erc_namespace, contractAddress] = asset_namespace.split(':');\n    if (!eip_namespace || eip_namespace.toLowerCase() !== 'eip155')\n        throw new EnsAvatarInvalidNftUriError({ reason: 'Only EIP-155 supported' });\n    if (!chainID)\n        throw new EnsAvatarInvalidNftUriError({ reason: 'Chain ID not found' });\n    if (!contractAddress)\n        throw new EnsAvatarInvalidNftUriError({\n            reason: 'Contract address not found',\n        });\n    if (!tokenID)\n        throw new EnsAvatarInvalidNftUriError({ reason: 'Token ID not found' });\n    if (!erc_namespace)\n        throw new EnsAvatarInvalidNftUriError({ reason: 'ERC namespace not found' });\n    return {\n        chainID: Number.parseInt(chainID, 10),\n        namespace: erc_namespace.toLowerCase(),\n        contractAddress: contractAddress,\n        tokenID,\n    };\n}\nexport async function getNftTokenUri(client, { nft }) {\n    if (nft.namespace === 'erc721') {\n        return readContract(client, {\n            address: nft.contractAddress,\n            abi: [\n                {\n                    name: 'tokenURI',\n                    type: 'function',\n                    stateMutability: 'view',\n                    inputs: [{ name: 'tokenId', type: 'uint256' }],\n                    outputs: [{ name: '', type: 'string' }],\n                },\n            ],\n            functionName: 'tokenURI',\n            args: [BigInt(nft.tokenID)],\n        });\n    }\n    if (nft.namespace === 'erc1155') {\n        return readContract(client, {\n            address: nft.contractAddress,\n            abi: [\n                {\n                    name: 'uri',\n                    type: 'function',\n                    stateMutability: 'view',\n                    inputs: [{ name: '_id', type: 'uint256' }],\n                    outputs: [{ name: '', type: 'string' }],\n                },\n            ],\n            functionName: 'uri',\n            args: [BigInt(nft.tokenID)],\n        });\n    }\n    throw new EnsAvatarUnsupportedNamespaceError({ namespace: nft.namespace });\n}\n//# sourceMappingURL=utils.js.map","import { getJsonImage, getMetadataAvatarUri, getNftTokenUri, parseAvatarUri, parseNftUri, resolveAvatarUri, } from './utils.js';\n/*\n * @description Parses an ENS avatar record.\n *\n * @example\n * parseAvatarRecord('eip155:1/erc1155:0xb32979486938aa9694bfc898f35dbed459f44424/10063')\n * 'https://ipfs.io/ipfs/QmSP4nq9fnN9dAiCj42ug9Wa79rqmQerZXZch82VqpiH7U/image.gif'\n *\n * @see https://docs.ens.domains/web/avatars\n *\n */\nexport async function parseAvatarRecord(client, { gatewayUrls, record, }) {\n    if (/eip155:/i.test(record))\n        return parseNftAvatarUri(client, { gatewayUrls, record });\n    return parseAvatarUri({ uri: record, gatewayUrls });\n}\nasync function parseNftAvatarUri(client, { gatewayUrls, record, }) {\n    // parse NFT URI into properties\n    const nft = parseNftUri(record);\n    // fetch tokenURI from the NFT contract\n    const nftUri = await getNftTokenUri(client, { nft });\n    // resolve the URI from the fetched tokenURI\n    const { uri: resolvedNftUri, isOnChain, isEncoded, } = resolveAvatarUri({ uri: nftUri, gatewayUrls });\n    // if the resolved URI is on chain, return the data\n    if (isOnChain &&\n        (resolvedNftUri.includes('data:application/json;base64,') ||\n            resolvedNftUri.startsWith('{'))) {\n        const encodedJson = isEncoded\n            ? // if it is encoded, decode it\n                atob(resolvedNftUri.replace('data:application/json;base64,', ''))\n            : // if it isn't encoded assume it is a JSON string, but it could be anything (it will error if it is)\n                resolvedNftUri;\n        const decoded = JSON.parse(encodedJson);\n        return parseAvatarUri({ uri: getJsonImage(decoded), gatewayUrls });\n    }\n    let uriTokenId = nft.tokenID;\n    if (nft.namespace === 'erc1155')\n        uriTokenId = uriTokenId.replace('0x', '').padStart(64, '0');\n    return getMetadataAvatarUri({\n        gatewayUrls,\n        uri: resolvedNftUri.replace(/(?:0x)?{id}/, uriTokenId),\n    });\n}\n//# sourceMappingURL=parseAvatarRecord.js.map","import { textResolverAbi, universalResolverResolveAbi, } from '../../constants/abis.js';\nimport { decodeFunctionResult, } from '../../utils/abi/decodeFunctionResult.js';\nimport { encodeFunctionData, } from '../../utils/abi/encodeFunctionData.js';\nimport { getChainContractAddress, } from '../../utils/chain/getChainContractAddress.js';\nimport { toHex } from '../../utils/encoding/toHex.js';\nimport { isNullUniversalResolverError } from '../../utils/ens/errors.js';\nimport { localBatchGatewayUrl } from '../../utils/ens/localBatchGatewayRequest.js';\nimport { namehash } from '../../utils/ens/namehash.js';\nimport { packetToBytes, } from '../../utils/ens/packetToBytes.js';\nimport { getAction } from '../../utils/getAction.js';\nimport { readContract, } from '../public/readContract.js';\n/**\n * Gets a text record for specified ENS name.\n *\n * - Docs: https://viem.sh/docs/ens/actions/getEnsResolver\n * - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/ens\n *\n * Calls `resolve(bytes, bytes)` on ENS Universal Resolver Contract.\n *\n * Since ENS names prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS names](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `getEnsAddress`. You can use the built-in [`normalize`](https://viem.sh/docs/ens/utilities/normalize) function for this.\n *\n * @param client - Client to use\n * @param parameters - {@link GetEnsTextParameters}\n * @returns Address for ENS resolver. {@link GetEnsTextReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { getEnsText, normalize } from 'viem/ens'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const twitterRecord = await getEnsText(client, {\n *   name: normalize('wevm.eth'),\n *   key: 'com.twitter',\n * })\n * // 'wevm_dev'\n */\nexport async function getEnsText(client, parameters) {\n    const { blockNumber, blockTag, key, name, gatewayUrls, strict } = parameters;\n    const { chain } = client;\n    const universalResolverAddress = (() => {\n        if (parameters.universalResolverAddress)\n            return parameters.universalResolverAddress;\n        if (!chain)\n            throw new Error('client chain not configured. universalResolverAddress is required.');\n        return getChainContractAddress({\n            blockNumber,\n            chain,\n            contract: 'ensUniversalResolver',\n        });\n    })();\n    const tlds = chain?.ensTlds;\n    if (tlds && !tlds.some((tld) => name.endsWith(tld)))\n        return null;\n    try {\n        const readContractParameters = {\n            address: universalResolverAddress,\n            abi: universalResolverResolveAbi,\n            args: [\n                toHex(packetToBytes(name)),\n                encodeFunctionData({\n                    abi: textResolverAbi,\n                    functionName: 'text',\n                    args: [namehash(name), key],\n                }),\n                gatewayUrls ?? [localBatchGatewayUrl],\n            ],\n            functionName: 'resolveWithGateways',\n            blockNumber,\n            blockTag,\n        };\n        const readContractAction = getAction(client, readContract, 'readContract');\n        const res = await readContractAction(readContractParameters);\n        if (res[0] === '0x')\n            return null;\n        const record = decodeFunctionResult({\n            abi: textResolverAbi,\n            functionName: 'text',\n            data: res[0],\n        });\n        return record === '' ? null : record;\n    }\n    catch (err) {\n        if (strict)\n            throw err;\n        if (isNullUniversalResolverError(err))\n            return null;\n        throw err;\n    }\n}\n//# sourceMappingURL=getEnsText.js.map","import { parseAvatarRecord, } from '../../utils/ens/avatar/parseAvatarRecord.js';\nimport { getAction } from '../../utils/getAction.js';\nimport { getEnsText, } from './getEnsText.js';\n/**\n * Gets the avatar of an ENS name.\n *\n * - Docs: https://viem.sh/docs/ens/actions/getEnsAvatar\n * - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/ens\n *\n * Calls [`getEnsText`](https://viem.sh/docs/ens/actions/getEnsText) with `key` set to `'avatar'`.\n *\n * Since ENS names prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS names](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `getEnsAddress`. You can use the built-in [`normalize`](https://viem.sh/docs/ens/utilities/normalize) function for this.\n *\n * @param client - Client to use\n * @param parameters - {@link GetEnsAvatarParameters}\n * @returns Avatar URI or `null` if not found. {@link GetEnsAvatarReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { getEnsAvatar, normalize } from 'viem/ens'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const ensAvatar = await getEnsAvatar(client, {\n *   name: normalize('wevm.eth'),\n * })\n * // 'https://ipfs.io/ipfs/Qma8mnp6xV3J2cRNf3mTth5C8nV11CAnceVinc3y8jSbio'\n */\nexport async function getEnsAvatar(client, { blockNumber, blockTag, assetGatewayUrls, name, gatewayUrls, strict, universalResolverAddress, }) {\n    const record = await getAction(client, getEnsText, 'getEnsText')({\n        blockNumber,\n        blockTag,\n        key: 'avatar',\n        name,\n        universalResolverAddress,\n        gatewayUrls,\n        strict,\n    });\n    if (!record)\n        return null;\n    try {\n        return await parseAvatarRecord(client, {\n            record,\n            gatewayUrls: assetGatewayUrls,\n        });\n    }\n    catch {\n        return null;\n    }\n}\n//# sourceMappingURL=getEnsAvatar.js.map","import { universalResolverReverseAbi } from '../../constants/abis.js';\nimport { getChainContractAddress, } from '../../utils/chain/getChainContractAddress.js';\nimport { isNullUniversalResolverError } from '../../utils/ens/errors.js';\nimport { localBatchGatewayUrl } from '../../utils/ens/localBatchGatewayRequest.js';\nimport { getAction } from '../../utils/getAction.js';\nimport { readContract, } from '../public/readContract.js';\n/**\n * Gets primary name for specified address.\n *\n * - Docs: https://viem.sh/docs/ens/actions/getEnsName\n * - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/ens\n *\n * Calls `reverse(bytes)` on ENS Universal Resolver Contract to \"reverse resolve\" the address to the primary ENS name.\n *\n * @param client - Client to use\n * @param parameters - {@link GetEnsNameParameters}\n * @returns Name or `null` if not found. {@link GetEnsNameReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { getEnsName } from 'viem/ens'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const ensName = await getEnsName(client, {\n *   address: '0xd2135CfB216b74109775236E36d4b433F1DF507B',\n * })\n * // 'wevm.eth'\n */\nexport async function getEnsName(client, parameters) {\n    const { address, blockNumber, blockTag, coinType = 60n, gatewayUrls, strict, } = parameters;\n    const { chain } = client;\n    const universalResolverAddress = (() => {\n        if (parameters.universalResolverAddress)\n            return parameters.universalResolverAddress;\n        if (!chain)\n            throw new Error('client chain not configured. universalResolverAddress is required.');\n        return getChainContractAddress({\n            blockNumber,\n            chain,\n            contract: 'ensUniversalResolver',\n        });\n    })();\n    try {\n        const readContractParameters = {\n            address: universalResolverAddress,\n            abi: universalResolverReverseAbi,\n            args: [address, coinType, gatewayUrls ?? [localBatchGatewayUrl]],\n            functionName: 'reverseWithGateways',\n            blockNumber,\n            blockTag,\n        };\n        const readContractAction = getAction(client, readContract, 'readContract');\n        const [name] = await readContractAction(readContractParameters);\n        return name || null;\n    }\n    catch (err) {\n        if (strict)\n            throw err;\n        if (isNullUniversalResolverError(err))\n            return null;\n        throw err;\n    }\n}\n//# sourceMappingURL=getEnsName.js.map","import { getChainContractAddress, } from '../../utils/chain/getChainContractAddress.js';\nimport { toHex } from '../../utils/encoding/toHex.js';\nimport { packetToBytes, } from '../../utils/ens/packetToBytes.js';\nimport { getAction } from '../../utils/getAction.js';\nimport { readContract, } from '../public/readContract.js';\n/**\n * Gets resolver for ENS name.\n *\n * - Docs: https://viem.sh/docs/ens/actions/getEnsResolver\n * - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/ens\n *\n * Calls `findResolver(bytes)` on ENS Universal Resolver Contract to retrieve the resolver of an ENS name.\n *\n * Since ENS names prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS names](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `getEnsAddress`. You can use the built-in [`normalize`](https://viem.sh/docs/ens/utilities/normalize) function for this.\n *\n * @param client - Client to use\n * @param parameters - {@link GetEnsResolverParameters}\n * @returns Address for ENS resolver. {@link GetEnsResolverReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { getEnsResolver, normalize } from 'viem/ens'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const resolverAddress = await getEnsResolver(client, {\n *   name: normalize('wevm.eth'),\n * })\n * // '0x4976fb03C32e5B8cfe2b6cCB31c09Ba78EBaBa41'\n */\nexport async function getEnsResolver(client, parameters) {\n    const { blockNumber, blockTag, name } = parameters;\n    const { chain } = client;\n    const universalResolverAddress = (() => {\n        if (parameters.universalResolverAddress)\n            return parameters.universalResolverAddress;\n        if (!chain)\n            throw new Error('client chain not configured. universalResolverAddress is required.');\n        return getChainContractAddress({\n            blockNumber,\n            chain,\n            contract: 'ensUniversalResolver',\n        });\n    })();\n    const tlds = chain?.ensTlds;\n    if (tlds && !tlds.some((tld) => name.endsWith(tld)))\n        throw new Error(`${name} is not a valid ENS TLD (${tlds?.join(', ')}) for chain \"${chain.name}\" (id: ${chain.id}).`);\n    const [resolverAddress] = await getAction(client, readContract, 'readContract')({\n        address: universalResolverAddress,\n        abi: [\n            {\n                inputs: [{ type: 'bytes' }],\n                name: 'findResolver',\n                outputs: [\n                    { type: 'address' },\n                    { type: 'bytes32' },\n                    { type: 'uint256' },\n                ],\n                stateMutability: 'view',\n                type: 'function',\n            },\n        ],\n        functionName: 'findResolver',\n        args: [toHex(packetToBytes(name))],\n        blockNumber,\n        blockTag,\n    });\n    return resolverAddress;\n}\n//# sourceMappingURL=getEnsResolver.js.map","import { parseAccount, } from '../../accounts/utils/parseAccount.js';\nimport { numberToHex, } from '../../utils/encoding/toHex.js';\nimport { getCallError, } from '../../utils/errors/getCallError.js';\nimport { extract } from '../../utils/formatters/extract.js';\nimport { formatTransactionRequest, } from '../../utils/formatters/transactionRequest.js';\nimport { assertRequest } from '../../utils/transaction/assertRequest.js';\n/**\n * Creates an EIP-2930 access list.\n *\n * - Docs: https://viem.sh/docs/actions/public/createAccessList\n * - JSON-RPC Methods: `eth_createAccessList`\n *\n * @param client - Client to use\n * @param parameters - {@link CreateAccessListParameters}\n * @returns The access list. {@link CreateAccessListReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { createAccessList } from 'viem/public'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const data = await createAccessList(client, {\n *   account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',\n *   data: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2',\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n * })\n */\nexport async function createAccessList(client, args) {\n    const { account: account_ = client.account, blockNumber, blockTag = 'latest', blobs, data, gas, gasPrice, maxFeePerBlobGas, maxFeePerGas, maxPriorityFeePerGas, to, value, ...rest } = args;\n    const account = account_ ? parseAccount(account_) : undefined;\n    try {\n        assertRequest(args);\n        const blockNumberHex = typeof blockNumber === 'bigint' ? numberToHex(blockNumber) : undefined;\n        const block = blockNumberHex || blockTag;\n        const chainFormat = client.chain?.formatters?.transactionRequest?.format;\n        const format = chainFormat || formatTransactionRequest;\n        const request = format({\n            // Pick out extra data that might exist on the chain's transaction request type.\n            ...extract(rest, { format: chainFormat }),\n            from: account?.address,\n            blobs,\n            data,\n            gas,\n            gasPrice,\n            maxFeePerBlobGas,\n            maxFeePerGas,\n            maxPriorityFeePerGas,\n            to,\n            value,\n        });\n        const response = await client.request({\n            method: 'eth_createAccessList',\n            params: [request, block],\n        });\n        return {\n            accessList: response.accessList,\n            gasUsed: BigInt(response.gasUsed),\n        };\n    }\n    catch (err) {\n        throw getCallError(err, {\n            ...args,\n            account,\n            chain: client.chain,\n        });\n    }\n}\n//# sourceMappingURL=createAccessList.js.map","import { createFilterRequestScope } from '../../utils/filters/createFilterRequestScope.js';\n/**\n * Creates a [`Filter`](https://viem.sh/docs/glossary/types#filter) to listen for new block hashes that can be used with [`getFilterChanges`](https://viem.sh/docs/actions/public/getFilterChanges).\n *\n * - Docs: https://viem.sh/docs/actions/public/createBlockFilter\n * - JSON-RPC Methods: [`eth_newBlockFilter`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_newBlockFilter)\n *\n * @param client - Client to use\n * @returns [`Filter`](https://viem.sh/docs/glossary/types#filter). {@link CreateBlockFilterReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { createBlockFilter } from 'viem/public'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const filter = await createBlockFilter(client)\n * // { id: \"0x345a6572337856574a76364e457a4366\", type: 'block' }\n */\nexport async function createBlockFilter(client) {\n    const getRequest = createFilterRequestScope(client, {\n        method: 'eth_newBlockFilter',\n    });\n    const id = await client.request({\n        method: 'eth_newBlockFilter',\n    });\n    return { id, request: getRequest(id), type: 'block' };\n}\n//# sourceMappingURL=createBlockFilter.js.map","import { encodeEventTopics, } from '../../utils/abi/encodeEventTopics.js';\nimport { numberToHex, } from '../../utils/encoding/toHex.js';\nimport { createFilterRequestScope } from '../../utils/filters/createFilterRequestScope.js';\n/**\n * Creates a [`Filter`](https://viem.sh/docs/glossary/types#filter) to listen for new events that can be used with [`getFilterChanges`](https://viem.sh/docs/actions/public/getFilterChanges).\n *\n * - Docs: https://viem.sh/docs/actions/public/createEventFilter\n * - JSON-RPC Methods: [`eth_newFilter`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_newfilter)\n *\n * @param client - Client to use\n * @param parameters - {@link CreateEventFilterParameters}\n * @returns [`Filter`](https://viem.sh/docs/glossary/types#filter). {@link CreateEventFilterReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { createEventFilter } from 'viem/public'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const filter = await createEventFilter(client, {\n *   address: '0xfba3912ca04dd458c843e2ee08967fc04f3579c2',\n * })\n */\nexport async function createEventFilter(client, { address, args, event, events: events_, fromBlock, strict, toBlock, } = {}) {\n    const events = events_ ?? (event ? [event] : undefined);\n    const getRequest = createFilterRequestScope(client, {\n        method: 'eth_newFilter',\n    });\n    let topics = [];\n    if (events) {\n        const encoded = events.flatMap((event) => encodeEventTopics({\n            abi: [event],\n            eventName: event.name,\n            args,\n        }));\n        // TODO: Clean up type casting\n        topics = [encoded];\n        if (event)\n            topics = topics[0];\n    }\n    const id = await client.request({\n        method: 'eth_newFilter',\n        params: [\n            {\n                address,\n                fromBlock: typeof fromBlock === 'bigint' ? numberToHex(fromBlock) : fromBlock,\n                toBlock: typeof toBlock === 'bigint' ? numberToHex(toBlock) : toBlock,\n                ...(topics.length ? { topics } : {}),\n            },\n        ],\n    });\n    return {\n        abi: events,\n        args,\n        eventName: event ? event.name : undefined,\n        fromBlock,\n        id,\n        request: getRequest(id),\n        strict: Boolean(strict),\n        toBlock,\n        type: 'event',\n    };\n}\n//# sourceMappingURL=createEventFilter.js.map","import { createFilterRequestScope } from '../../utils/filters/createFilterRequestScope.js';\n/**\n * Creates a Filter to listen for new pending transaction hashes that can be used with [`getFilterChanges`](https://viem.sh/docs/actions/public/getFilterChanges).\n *\n * - Docs: https://viem.sh/docs/actions/public/createPendingTransactionFilter\n * - JSON-RPC Methods: [`eth_newPendingTransactionFilter`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_newpendingtransactionfilter)\n *\n * @param client - Client to use\n * @returns [`Filter`](https://viem.sh/docs/glossary/types#filter). {@link CreateBlockFilterReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { createPendingTransactionFilter } from 'viem/public'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const filter = await createPendingTransactionFilter(client)\n * // { id: \"0x345a6572337856574a76364e457a4366\", type: 'transaction' }\n */\nexport async function createPendingTransactionFilter(client) {\n    const getRequest = createFilterRequestScope(client, {\n        method: 'eth_newPendingTransactionFilter',\n    });\n    const id = await client.request({\n        method: 'eth_newPendingTransactionFilter',\n    });\n    return { id, request: getRequest(id), type: 'transaction' };\n}\n//# sourceMappingURL=createPendingTransactionFilter.js.map","/**\n * Returns the base fee per blob gas in wei.\n *\n * - Docs: https://viem.sh/docs/actions/public/getBlobBaseFee\n * - JSON-RPC Methods: [`eth_blobBaseFee`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_blobBaseFee)\n *\n * @param client - Client to use\n * @returns The blob base fee (in wei). {@link GetBlobBaseFeeReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { getBlobBaseFee } from 'viem/public'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const blobBaseFee = await getBlobBaseFee(client)\n */\nexport async function getBlobBaseFee(client) {\n    const baseFee = await client.request({\n        method: 'eth_blobBaseFee',\n    });\n    return BigInt(baseFee);\n}\n//# sourceMappingURL=getBlobBaseFee.js.map","import { hexToNumber, } from '../../utils/encoding/fromHex.js';\nimport { numberToHex, } from '../../utils/encoding/toHex.js';\n/**\n * Returns the number of Transactions at a block number, hash, or tag.\n *\n * - Docs: https://viem.sh/docs/actions/public/getBlockTransactionCount\n * - JSON-RPC Methods:\n *   - Calls [`eth_getBlockTransactionCountByNumber`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getblocktransactioncountbynumber) for `blockNumber` & `blockTag`.\n *   - Calls [`eth_getBlockTransactionCountByHash`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getblocktransactioncountbyhash) for `blockHash`.\n *\n * @param client - Client to use\n * @param parameters - {@link GetBlockTransactionCountParameters}\n * @returns The block transaction count. {@link GetBlockTransactionCountReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { getBlockTransactionCount } from 'viem/public'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const count = await getBlockTransactionCount(client)\n */\nexport async function getBlockTransactionCount(client, { blockHash, blockNumber, blockTag = 'latest', } = {}) {\n    const blockNumberHex = blockNumber !== undefined ? numberToHex(blockNumber) : undefined;\n    let count;\n    if (blockHash) {\n        count = await client.request({\n            method: 'eth_getBlockTransactionCountByHash',\n            params: [blockHash],\n        }, { dedupe: true });\n    }\n    else {\n        count = await client.request({\n            method: 'eth_getBlockTransactionCountByNumber',\n            params: [blockNumberHex || blockTag],\n        }, { dedupe: Boolean(blockNumberHex) });\n    }\n    return hexToNumber(count);\n}\n//# sourceMappingURL=getBlockTransactionCount.js.map","import { numberToHex, } from '../../utils/encoding/toHex.js';\n/**\n * Retrieves the bytecode at an address.\n *\n * - Docs: https://viem.sh/docs/contract/getCode\n * - JSON-RPC Methods: [`eth_getCode`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getcode)\n *\n * @param client - Client to use\n * @param parameters - {@link GetCodeParameters}\n * @returns The contract's bytecode. {@link GetCodeReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { getCode } from 'viem/contract'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const code = await getCode(client, {\n *   address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',\n * })\n */\nexport async function getCode(client, { address, blockNumber, blockTag = 'latest' }) {\n    const blockNumberHex = blockNumber !== undefined ? numberToHex(blockNumber) : undefined;\n    const hex = await client.request({\n        method: 'eth_getCode',\n        params: [address, blockNumberHex || blockTag],\n    }, { dedupe: Boolean(blockNumberHex) });\n    if (hex === '0x')\n        return undefined;\n    return hex;\n}\n//# sourceMappingURL=getCode.js.map","import { BaseError } from './base.js';\nexport class Eip712DomainNotFoundError extends BaseError {\n    constructor({ address }) {\n        super(`No EIP-712 domain found on contract \"${address}\".`, {\n            metaMessages: [\n                'Ensure that:',\n                `- The contract is deployed at the address \"${address}\".`,\n                '- `eip712Domain()` function exists on the contract.',\n                '- `eip712Domain()` function matches signature to ERC-5267 specification.',\n            ],\n            name: 'Eip712DomainNotFoundError',\n        });\n    }\n}\n//# sourceMappingURL=eip712.js.map","import { Eip712DomainNotFoundError, } from '../../errors/eip712.js';\nimport { getAction } from '../../utils/getAction.js';\nimport { readContract, } from './readContract.js';\n/**\n * Reads the EIP-712 domain from a contract, based on the ERC-5267 specification.\n *\n * @param client - A {@link Client} instance.\n * @param parameters - The parameters of the action. {@link GetEip712DomainParameters}\n * @returns The EIP-712 domain, fields, and extensions. {@link GetEip712DomainReturnType}\n *\n * @example\n * ```ts\n * import { createPublicClient, http, getEip712Domain } from 'viem'\n * import { mainnet } from 'viem/chains'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n *\n * const domain = await getEip712Domain(client, {\n *   address: '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48',\n * })\n * // {\n * //   domain: {\n * //     name: 'ExampleContract',\n * //     version: '1',\n * //     chainId: 1,\n * //     verifyingContract: '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48',\n * //   },\n * //   fields: '0x0f',\n * //   extensions: [],\n * // }\n * ```\n */\nexport async function getEip712Domain(client, parameters) {\n    const { address, factory, factoryData } = parameters;\n    try {\n        const [fields, name, version, chainId, verifyingContract, salt, extensions,] = await getAction(client, readContract, 'readContract')({\n            abi,\n            address,\n            functionName: 'eip712Domain',\n            factory,\n            factoryData,\n        });\n        return {\n            domain: {\n                name,\n                version,\n                chainId: Number(chainId),\n                verifyingContract,\n                salt,\n            },\n            extensions,\n            fields,\n        };\n    }\n    catch (e) {\n        const error = e;\n        if (error.name === 'ContractFunctionExecutionError' &&\n            error.cause.name === 'ContractFunctionZeroDataError') {\n            throw new Eip712DomainNotFoundError({ address });\n        }\n        throw error;\n    }\n}\nconst abi = [\n    {\n        inputs: [],\n        name: 'eip712Domain',\n        outputs: [\n            { name: 'fields', type: 'bytes1' },\n            { name: 'name', type: 'string' },\n            { name: 'version', type: 'string' },\n            { name: 'chainId', type: 'uint256' },\n            { name: 'verifyingContract', type: 'address' },\n            { name: 'salt', type: 'bytes32' },\n            { name: 'extensions', type: 'uint256[]' },\n        ],\n        stateMutability: 'view',\n        type: 'function',\n    },\n];\n//# sourceMappingURL=getEip712Domain.js.map","export function formatFeeHistory(feeHistory) {\n    return {\n        baseFeePerGas: feeHistory.baseFeePerGas.map((value) => BigInt(value)),\n        gasUsedRatio: feeHistory.gasUsedRatio,\n        oldestBlock: BigInt(feeHistory.oldestBlock),\n        reward: feeHistory.reward?.map((reward) => reward.map((value) => BigInt(value))),\n    };\n}\n//# sourceMappingURL=feeHistory.js.map","import { numberToHex, } from '../../utils/encoding/toHex.js';\nimport { formatFeeHistory, } from '../../utils/formatters/feeHistory.js';\n/**\n * Returns a collection of historical gas information.\n *\n * - Docs: https://viem.sh/docs/actions/public/getFeeHistory\n * - JSON-RPC Methods: [`eth_feeHistory`](https://docs.alchemy.com/reference/eth-feehistory)\n *\n * @param client - Client to use\n * @param parameters - {@link GetFeeHistoryParameters}\n * @returns The gas estimate (in wei). {@link GetFeeHistoryReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { getFeeHistory } from 'viem/public'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const feeHistory = await getFeeHistory(client, {\n *   blockCount: 4,\n *   rewardPercentiles: [25, 75],\n * })\n */\nexport async function getFeeHistory(client, { blockCount, blockNumber, blockTag = 'latest', rewardPercentiles, }) {\n    const blockNumberHex = typeof blockNumber === 'bigint' ? numberToHex(blockNumber) : undefined;\n    const feeHistory = await client.request({\n        method: 'eth_feeHistory',\n        params: [\n            numberToHex(blockCount),\n            blockNumberHex || blockTag,\n            rewardPercentiles,\n        ],\n    }, { dedupe: Boolean(blockNumberHex) });\n    return formatFeeHistory(feeHistory);\n}\n//# sourceMappingURL=getFeeHistory.js.map","import { parseEventLogs } from '../../utils/abi/parseEventLogs.js';\nimport { formatLog, } from '../../utils/formatters/log.js';\n/**\n * Returns a list of event logs since the filter was created.\n *\n * - Docs: https://viem.sh/docs/actions/public/getFilterLogs\n * - JSON-RPC Methods: [`eth_getFilterLogs`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getfilterlogs)\n *\n * `getFilterLogs` is only compatible with **event filters**.\n *\n * @param client - Client to use\n * @param parameters - {@link GetFilterLogsParameters}\n * @returns A list of event logs. {@link GetFilterLogsReturnType}\n *\n * @example\n * import { createPublicClient, http, parseAbiItem } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { createEventFilter, getFilterLogs } from 'viem/public'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const filter = await createEventFilter(client, {\n *   address: '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48',\n *   event: parseAbiItem('event Transfer(address indexed, address indexed, uint256)'),\n * })\n * const logs = await getFilterLogs(client, { filter })\n */\nexport async function getFilterLogs(_client, { filter, }) {\n    const strict = filter.strict ?? false;\n    const logs = await filter.request({\n        method: 'eth_getFilterLogs',\n        params: [filter.id],\n    });\n    const formattedLogs = logs.map((log) => formatLog(log));\n    if (!filter.abi)\n        return formattedLogs;\n    return parseEventLogs({\n        abi: filter.abi,\n        logs: formattedLogs,\n        strict,\n    });\n}\n//# sourceMappingURL=getFilterLogs.js.map","import { getAddress } from '../address/getAddress.js';\nimport { isAddressEqual, } from '../address/isAddressEqual.js';\nimport { recoverAuthorizationAddress, } from './recoverAuthorizationAddress.js';\n/**\n * Verify that an Authorization object was signed by the provided address.\n *\n * - Docs {@link https://viem.sh/docs/utilities/verifyAuthorization}\n *\n * @param parameters - {@link VerifyAuthorizationParameters}\n * @returns Whether or not the signature is valid. {@link VerifyAuthorizationReturnType}\n */\nexport async function verifyAuthorization({ address, authorization, signature, }) {\n    return isAddressEqual(getAddress(address), await recoverAuthorizationAddress({\n        authorization,\n        signature,\n    }));\n}\n//# sourceMappingURL=verifyAuthorization.js.map","export const presignMessagePrefix = '\\x19Ethereum Signed Message:\\n';\n//# sourceMappingURL=strings.js.map","import { presignMessagePrefix } from '../../constants/strings.js';\nimport { concat } from '../data/concat.js';\nimport { size } from '../data/size.js';\nimport { bytesToHex, stringToHex, } from '../encoding/toHex.js';\nexport function toPrefixedMessage(message_) {\n    const message = (() => {\n        if (typeof message_ === 'string')\n            return stringToHex(message_);\n        if (typeof message_.raw === 'string')\n            return message_.raw;\n        return bytesToHex(message_.raw);\n    })();\n    const prefix = stringToHex(`${presignMessagePrefix}${size(message)}`);\n    return concat([prefix, message]);\n}\n//# sourceMappingURL=toPrefixedMessage.js.map","import { keccak256 } from '../hash/keccak256.js';\nimport { toPrefixedMessage } from './toPrefixedMessage.js';\nexport function hashMessage(message, to_) {\n    return keccak256(toPrefixedMessage(message), to_);\n}\n//# sourceMappingURL=hashMessage.js.map","import { stringify } from '../utils/stringify.js';\nimport { BaseError } from './base.js';\nexport class InvalidDomainError extends BaseError {\n    constructor({ domain }) {\n        super(`Invalid domain \"${stringify(domain)}\".`, {\n            metaMessages: ['Must be a valid EIP-712 domain.'],\n        });\n    }\n}\nexport class InvalidPrimaryTypeError extends BaseError {\n    constructor({ primaryType, types, }) {\n        super(`Invalid primary type \\`${primaryType}\\` must be one of \\`${JSON.stringify(Object.keys(types))}\\`.`, {\n            docsPath: '/api/glossary/Errors#typeddatainvalidprimarytypeerror',\n            metaMessages: ['Check that the primary type is a key in `types`.'],\n        });\n    }\n}\nexport class InvalidStructTypeError extends BaseError {\n    constructor({ type }) {\n        super(`Struct type \"${type}\" is invalid.`, {\n            metaMessages: ['Struct type must not be a Solidity type.'],\n            name: 'InvalidStructTypeError',\n        });\n    }\n}\n//# sourceMappingURL=typedData.js.map","import { BytesSizeMismatchError } from '../errors/abi.js';\nimport { InvalidAddressError } from '../errors/address.js';\nimport { InvalidDomainError, InvalidPrimaryTypeError, InvalidStructTypeError, } from '../errors/typedData.js';\nimport { isAddress } from './address/isAddress.js';\nimport { size } from './data/size.js';\nimport { numberToHex } from './encoding/toHex.js';\nimport { bytesRegex, integerRegex } from './regex.js';\nimport { hashDomain, } from './signature/hashTypedData.js';\nimport { stringify } from './stringify.js';\nexport function serializeTypedData(parameters) {\n    const { domain: domain_, message: message_, primaryType, types, } = parameters;\n    const normalizeData = (struct, data_) => {\n        const data = { ...data_ };\n        for (const param of struct) {\n            const { name, type } = param;\n            if (type === 'address')\n                data[name] = data[name].toLowerCase();\n        }\n        return data;\n    };\n    const domain = (() => {\n        if (!types.EIP712Domain)\n            return {};\n        if (!domain_)\n            return {};\n        return normalizeData(types.EIP712Domain, domain_);\n    })();\n    const message = (() => {\n        if (primaryType === 'EIP712Domain')\n            return undefined;\n        return normalizeData(types[primaryType], message_);\n    })();\n    return stringify({ domain, message, primaryType, types });\n}\nexport function validateTypedData(parameters) {\n    const { domain, message, primaryType, types } = parameters;\n    const validateData = (struct, data) => {\n        for (const param of struct) {\n            const { name, type } = param;\n            const value = data[name];\n            const integerMatch = type.match(integerRegex);\n            if (integerMatch &&\n                (typeof value === 'number' || typeof value === 'bigint')) {\n                const [_type, base, size_] = integerMatch;\n                // If number cannot be cast to a sized hex value, it is out of range\n                // and will throw.\n                numberToHex(value, {\n                    signed: base === 'int',\n                    size: Number.parseInt(size_, 10) / 8,\n                });\n            }\n            if (type === 'address' && typeof value === 'string' && !isAddress(value))\n                throw new InvalidAddressError({ address: value });\n            const bytesMatch = type.match(bytesRegex);\n            if (bytesMatch) {\n                const [_type, size_] = bytesMatch;\n                if (size_ && size(value) !== Number.parseInt(size_, 10))\n                    throw new BytesSizeMismatchError({\n                        expectedSize: Number.parseInt(size_, 10),\n                        givenSize: size(value),\n                    });\n            }\n            const struct = types[type];\n            if (struct) {\n                validateReference(type);\n                validateData(struct, value);\n            }\n        }\n    };\n    // Validate domain types.\n    if (types.EIP712Domain && domain) {\n        if (typeof domain !== 'object')\n            throw new InvalidDomainError({ domain });\n        validateData(types.EIP712Domain, domain);\n    }\n    // Validate message types.\n    if (primaryType !== 'EIP712Domain') {\n        if (types[primaryType])\n            validateData(types[primaryType], message);\n        else\n            throw new InvalidPrimaryTypeError({ primaryType, types });\n    }\n}\nexport function getTypesForEIP712Domain({ domain, }) {\n    return [\n        typeof domain?.name === 'string' && { name: 'name', type: 'string' },\n        domain?.version && { name: 'version', type: 'string' },\n        (typeof domain?.chainId === 'number' ||\n            typeof domain?.chainId === 'bigint') && {\n            name: 'chainId',\n            type: 'uint256',\n        },\n        domain?.verifyingContract && {\n            name: 'verifyingContract',\n            type: 'address',\n        },\n        domain?.salt && { name: 'salt', type: 'bytes32' },\n    ].filter(Boolean);\n}\nexport function domainSeparator({ domain }) {\n    return hashDomain({\n        domain,\n        types: {\n            EIP712Domain: getTypesForEIP712Domain({ domain }),\n        },\n    });\n}\n/** @internal */\nfunction validateReference(type) {\n    // Struct type must not be a Solidity type.\n    if (type === 'address' ||\n        type === 'bool' ||\n        type === 'string' ||\n        type.startsWith('bytes') ||\n        type.startsWith('uint') ||\n        type.startsWith('int'))\n        throw new InvalidStructTypeError({ type });\n}\n//# sourceMappingURL=typedData.js.map","// Implementation forked and adapted from https://github.com/MetaMask/eth-sig-util/blob/main/src/sign-typed-data.ts\nimport { encodeAbiParameters, } from '../abi/encodeAbiParameters.js';\nimport { concat } from '../data/concat.js';\nimport { toHex } from '../encoding/toHex.js';\nimport { keccak256 } from '../hash/keccak256.js';\nimport { getTypesForEIP712Domain, validateTypedData, } from '../typedData.js';\nexport function hashTypedData(parameters) {\n    const { domain = {}, message, primaryType, } = parameters;\n    const types = {\n        EIP712Domain: getTypesForEIP712Domain({ domain }),\n        ...parameters.types,\n    };\n    // Need to do a runtime validation check on addresses, byte ranges, integer ranges, etc\n    // as we can't statically check this with TypeScript.\n    validateTypedData({\n        domain,\n        message,\n        primaryType,\n        types,\n    });\n    const parts = ['0x1901'];\n    if (domain)\n        parts.push(hashDomain({\n            domain,\n            types: types,\n        }));\n    if (primaryType !== 'EIP712Domain')\n        parts.push(hashStruct({\n            data: message,\n            primaryType,\n            types: types,\n        }));\n    return keccak256(concat(parts));\n}\nexport function hashDomain({ domain, types, }) {\n    return hashStruct({\n        data: domain,\n        primaryType: 'EIP712Domain',\n        types,\n    });\n}\nexport function hashStruct({ data, primaryType, types, }) {\n    const encoded = encodeData({\n        data,\n        primaryType,\n        types,\n    });\n    return keccak256(encoded);\n}\nfunction encodeData({ data, primaryType, types, }) {\n    const encodedTypes = [{ type: 'bytes32' }];\n    const encodedValues = [hashType({ primaryType, types })];\n    for (const field of types[primaryType]) {\n        const [type, value] = encodeField({\n            types,\n            name: field.name,\n            type: field.type,\n            value: data[field.name],\n        });\n        encodedTypes.push(type);\n        encodedValues.push(value);\n    }\n    return encodeAbiParameters(encodedTypes, encodedValues);\n}\nfunction hashType({ primaryType, types, }) {\n    const encodedHashType = toHex(encodeType({ primaryType, types }));\n    return keccak256(encodedHashType);\n}\nexport function encodeType({ primaryType, types, }) {\n    let result = '';\n    const unsortedDeps = findTypeDependencies({ primaryType, types });\n    unsortedDeps.delete(primaryType);\n    const deps = [primaryType, ...Array.from(unsortedDeps).sort()];\n    for (const type of deps) {\n        result += `${type}(${types[type]\n            .map(({ name, type: t }) => `${t} ${name}`)\n            .join(',')})`;\n    }\n    return result;\n}\nfunction findTypeDependencies({ primaryType: primaryType_, types, }, results = new Set()) {\n    const match = primaryType_.match(/^\\w*/u);\n    const primaryType = match?.[0];\n    if (results.has(primaryType) || types[primaryType] === undefined) {\n        return results;\n    }\n    results.add(primaryType);\n    for (const field of types[primaryType]) {\n        findTypeDependencies({ primaryType: field.type, types }, results);\n    }\n    return results;\n}\nfunction encodeField({ types, name, type, value, }) {\n    if (types[type] !== undefined) {\n        return [\n            { type: 'bytes32' },\n            keccak256(encodeData({ data: value, primaryType: type, types })),\n        ];\n    }\n    if (type === 'bytes') {\n        const prepend = value.length % 2 ? '0' : '';\n        value = `0x${prepend + value.slice(2)}`;\n        return [{ type: 'bytes32' }, keccak256(value)];\n    }\n    if (type === 'string')\n        return [{ type: 'bytes32' }, keccak256(toHex(value))];\n    if (type.lastIndexOf(']') === type.length - 1) {\n        const parsedType = type.slice(0, type.lastIndexOf('['));\n        const typeValuePairs = value.map((item) => encodeField({\n            name,\n            type: parsedType,\n            types,\n            value: item,\n        }));\n        return [\n            { type: 'bytes32' },\n            keccak256(encodeAbiParameters(typeValuePairs.map(([t]) => t), typeValuePairs.map(([, v]) => v))),\n        ];\n    }\n    return [{ type }, value];\n}\n//# sourceMappingURL=hashTypedData.js.map","/**\n * @internal\n *\n * Map with a LRU (Least recently used) policy.\n * @see https://en.wikipedia.org/wiki/Cache_replacement_policies#LRU\n */\nexport class LruMap extends Map {\n    constructor(size) {\n        super();\n        Object.defineProperty(this, \"maxSize\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.maxSize = size;\n    }\n    get(key) {\n        const value = super.get(key);\n        if (super.has(key) && value !== undefined) {\n            this.delete(key);\n            super.set(key, value);\n        }\n        return value;\n    }\n    set(key, value) {\n        super.set(key, value);\n        if (this.maxSize && this.size > this.maxSize) {\n            const firstKey = this.keys().next().value;\n            if (firstKey)\n                this.delete(firstKey);\n        }\n        return this;\n    }\n}\n//# sourceMappingURL=lru.js.map","import { LruMap } from './internal/lru.js';\nconst caches = {\n    checksum: /*#__PURE__*/ new LruMap(8192),\n};\nexport const checksum = caches.checksum;\n/**\n * Clears all global caches.\n *\n * @example\n * ```ts\n * import { Caches } from 'ox'\n * Caches.clear()\n * ```\n */\nexport function clear() {\n    for (const cache of Object.values(caches))\n        cache.clear();\n}\n//# sourceMappingURL=Caches.js.map","import { ripemd160 as noble_ripemd160 } from '@noble/hashes/ripemd160';\nimport { keccak_256 as noble_keccak256 } from '@noble/hashes/sha3';\nimport { sha256 as noble_sha256 } from '@noble/hashes/sha256';\nimport * as Bytes from './Bytes.js';\nimport * as Hex from './Hex.js';\n/**\n * Calculates the [Keccak256](https://en.wikipedia.org/wiki/SHA-3) hash of a {@link ox#Bytes.Bytes} or {@link ox#Hex.Hex} value.\n *\n * This function is a re-export of `keccak_256` from [`@noble/hashes`](https://github.com/paulmillr/noble-hashes), an audited & minimal JS hashing library.\n *\n * @example\n * ```ts twoslash\n * import { Hash } from 'ox'\n *\n * Hash.keccak256('0xdeadbeef')\n * // @log: '0xd4fd4e189132273036449fc9e11198c739161b4c0116a9a2dccdfa1c492006f1'\n * ```\n *\n * @example\n * ### Calculate Hash of a String\n *\n * ```ts twoslash\n * import { Hash, Hex } from 'ox'\n *\n * Hash.keccak256(Hex.fromString('hello world'))\n * // @log: '0x3ea2f1d0abf3fc66cf29eebb70cbd4e7fe762ef8a09bcc06c8edf641230afec0'\n * ```\n *\n * @example\n * ### Configure Return Type\n *\n * ```ts twoslash\n * import { Hash } from 'ox'\n *\n * Hash.keccak256('0xdeadbeef', { as: 'Bytes' })\n * // @log: Uint8Array [...]\n * ```\n *\n * @param value - {@link ox#Bytes.Bytes} or {@link ox#Hex.Hex} value.\n * @param options - Options.\n * @returns Keccak256 hash.\n */\nexport function keccak256(value, options = {}) {\n    const { as = typeof value === 'string' ? 'Hex' : 'Bytes' } = options;\n    const bytes = noble_keccak256(Bytes.from(value));\n    if (as === 'Bytes')\n        return bytes;\n    return Hex.fromBytes(bytes);\n}\n/**\n * Calculates the [Ripemd160](https://en.wikipedia.org/wiki/RIPEMD) hash of a {@link ox#Bytes.Bytes} or {@link ox#Hex.Hex} value.\n *\n * This function is a re-export of `ripemd160` from [`@noble/hashes`](https://github.com/paulmillr/noble-hashes), an audited & minimal JS hashing library.\n *\n * @example\n * ```ts twoslash\n * import { Hash } from 'ox'\n *\n * Hash.ripemd160('0xdeadbeef')\n * // '0x226821c2f5423e11fe9af68bd285c249db2e4b5a'\n * ```\n *\n * @param value - {@link ox#Bytes.Bytes} or {@link ox#Hex.Hex} value.\n * @param options - Options.\n * @returns Ripemd160 hash.\n */\nexport function ripemd160(value, options = {}) {\n    const { as = typeof value === 'string' ? 'Hex' : 'Bytes' } = options;\n    const bytes = noble_ripemd160(Bytes.from(value));\n    if (as === 'Bytes')\n        return bytes;\n    return Hex.fromBytes(bytes);\n}\n/**\n * Calculates the [Sha256](https://en.wikipedia.org/wiki/SHA-256) hash of a {@link ox#Bytes.Bytes} or {@link ox#Hex.Hex} value.\n *\n * This function is a re-export of `sha256` from [`@noble/hashes`](https://github.com/paulmillr/noble-hashes), an audited & minimal JS hashing library.\n *\n * @example\n * ```ts twoslash\n * import { Hash } from 'ox'\n *\n * Hash.sha256('0xdeadbeef')\n * // '0x5f78c33274e43fa9de5659265c1d917e25c03722dcb0b8d27db8d5feaa813953'\n * ```\n *\n * @param value - {@link ox#Bytes.Bytes} or {@link ox#Hex.Hex} value.\n * @param options - Options.\n * @returns Sha256 hash.\n */\nexport function sha256(value, options = {}) {\n    const { as = typeof value === 'string' ? 'Hex' : 'Bytes' } = options;\n    const bytes = noble_sha256(Bytes.from(value));\n    if (as === 'Bytes')\n        return bytes;\n    return Hex.fromBytes(bytes);\n}\n/**\n * Checks if a string is a valid hash value.\n *\n * @example\n * ```ts twoslash\n * import { Hash } from 'ox'\n *\n * Hash.validate('0x')\n * // @log: false\n *\n * Hash.validate('0x3ea2f1d0abf3fc66cf29eebb70cbd4e7fe762ef8a09bcc06c8edf641230afec0')\n * // @log: true\n * ```\n *\n * @param value - Value to check.\n * @returns Whether the value is a valid hash.\n */\nexport function validate(value) {\n    return Hex.validate(value) && Hex.size(value) === 32;\n}\n//# sourceMappingURL=Hash.js.map","import * as Bytes from './Bytes.js';\nimport * as Caches from './Caches.js';\nimport * as Errors from './Errors.js';\nimport * as Hash from './Hash.js';\nimport * as PublicKey from './PublicKey.js';\nconst addressRegex = /^0x[a-fA-F0-9]{40}$/;\n/**\n * Asserts that the given value is a valid {@link ox#Address.Address}.\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.assert('0xA0Cf798816D4b9b9866b5330EEa46a18382f251e')\n * ```\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.assert('0xdeadbeef')\n * // @error: InvalidAddressError: Address \"0xdeadbeef\" is invalid.\n * ```\n *\n * @param value - Value to assert if it is a valid address.\n * @param options - Assertion options.\n */\nexport function assert(value, options = {}) {\n    const { strict = true } = options;\n    if (!addressRegex.test(value))\n        throw new InvalidAddressError({\n            address: value,\n            cause: new InvalidInputError(),\n        });\n    if (strict) {\n        if (value.toLowerCase() === value)\n            return;\n        if (checksum(value) !== value)\n            throw new InvalidAddressError({\n                address: value,\n                cause: new InvalidChecksumError(),\n            });\n    }\n}\n/**\n * Computes the checksum address for the given {@link ox#Address.Address}.\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.checksum('0xa0cf798816d4b9b9866b5330eea46a18382f251e')\n * // @log: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e'\n * ```\n *\n * @param address - The address to compute the checksum for.\n * @returns The checksummed address.\n */\nexport function checksum(address) {\n    if (Caches.checksum.has(address))\n        return Caches.checksum.get(address);\n    assert(address, { strict: false });\n    const hexAddress = address.substring(2).toLowerCase();\n    const hash = Hash.keccak256(Bytes.fromString(hexAddress), { as: 'Bytes' });\n    const characters = hexAddress.split('');\n    for (let i = 0; i < 40; i += 2) {\n        if (hash[i >> 1] >> 4 >= 8 && characters[i]) {\n            characters[i] = characters[i].toUpperCase();\n        }\n        if ((hash[i >> 1] & 0x0f) >= 8 && characters[i + 1]) {\n            characters[i + 1] = characters[i + 1].toUpperCase();\n        }\n    }\n    const result = `0x${characters.join('')}`;\n    Caches.checksum.set(address, result);\n    return result;\n}\n/**\n * Converts a stringified address to a typed (checksummed) {@link ox#Address.Address}.\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.from('0xa0cf798816d4b9b9866b5330eea46a18382f251e')\n * // @log: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e'\n * ```\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.from('0xa0cf798816d4b9b9866b5330eea46a18382f251e', {\n *   checksum: false\n * })\n * // @log: '0xa0cf798816d4b9b9866b5330eea46a18382f251e'\n * ```\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.from('hello')\n * // @error: InvalidAddressError: Address \"0xa\" is invalid.\n * ```\n *\n * @param address - An address string to convert to a typed Address.\n * @param options - Conversion options.\n * @returns The typed Address.\n */\nexport function from(address, options = {}) {\n    const { checksum: checksumVal = false } = options;\n    assert(address);\n    if (checksumVal)\n        return checksum(address);\n    return address;\n}\n/**\n * Converts an ECDSA public key to an {@link ox#Address.Address}.\n *\n * @example\n * ```ts twoslash\n * import { Address, PublicKey } from 'ox'\n *\n * const publicKey = PublicKey.from(\n *   '0x048318535b54105d4a7aae60c08fc45f9687181b4fdfc625bd1a753fa7397fed753547f11ca8696646f2f3acb08e31016afac23e630c5d11f59f61fef57b0d2aa5',\n * )\n * const address = Address.fromPublicKey(publicKey)\n * // @log: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266'\n * ```\n *\n * @param publicKey - The ECDSA public key to convert to an {@link ox#Address.Address}.\n * @param options - Conversion options.\n * @returns The {@link ox#Address.Address} corresponding to the public key.\n */\nexport function fromPublicKey(publicKey, options = {}) {\n    const address = Hash.keccak256(`0x${PublicKey.toHex(publicKey).slice(4)}`).substring(26);\n    return from(`0x${address}`, options);\n}\n/**\n * Checks if two {@link ox#Address.Address} are equal.\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.isEqual(\n *   '0xa0cf798816d4b9b9866b5330eea46a18382f251e',\n *   '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e'\n * )\n * // @log: true\n * ```\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.isEqual(\n *   '0xa0cf798816d4b9b9866b5330eea46a18382f251e',\n *   '0xA0Cf798816D4b9b9866b5330EEa46a18382f251f'\n * )\n * // @log: false\n * ```\n *\n * @param addressA - The first address to compare.\n * @param addressB - The second address to compare.\n * @returns Whether the addresses are equal.\n */\nexport function isEqual(addressA, addressB) {\n    assert(addressA, { strict: false });\n    assert(addressB, { strict: false });\n    return addressA.toLowerCase() === addressB.toLowerCase();\n}\n/**\n * Checks if the given address is a valid {@link ox#Address.Address}.\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.validate('0xA0Cf798816D4b9b9866b5330EEa46a18382f251e')\n * // @log: true\n * ```\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.validate('0xdeadbeef')\n * // @log: false\n * ```\n *\n * @param address - Value to check if it is a valid address.\n * @param options - Check options.\n * @returns Whether the address is a valid address.\n */\nexport function validate(address, options = {}) {\n    const { strict = true } = options ?? {};\n    try {\n        assert(address, { strict });\n        return true;\n    }\n    catch {\n        return false;\n    }\n}\n/**\n * Thrown when an address is invalid.\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.from('0x123')\n * // @error: Address.InvalidAddressError: Address `0x123` is invalid.\n * ```\n */\nexport class InvalidAddressError extends Errors.BaseError {\n    constructor({ address, cause }) {\n        super(`Address \"${address}\" is invalid.`, {\n            cause,\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Address.InvalidAddressError'\n        });\n    }\n}\n/** Thrown when an address is not a 20 byte (40 hexadecimal character) value. */\nexport class InvalidInputError extends Errors.BaseError {\n    constructor() {\n        super('Address is not a 20 byte (40 hexadecimal character) value.');\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Address.InvalidInputError'\n        });\n    }\n}\n/** Thrown when an address does not match its checksum counterpart. */\nexport class InvalidChecksumError extends Errors.BaseError {\n    constructor() {\n        super('Address does not match its checksum counterpart.');\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Address.InvalidChecksumError'\n        });\n    }\n}\n//# sourceMappingURL=Address.js.map","export const arrayRegex = /^(.*)\\[([0-9]*)\\]$/;\n// `bytes<M>`: binary type of `M` bytes, `0 < M <= 32`\n// https://regexr.com/6va55\nexport const bytesRegex = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/;\n// `(u)int<M>`: (un)signed integer type of `M` bits, `0 < M <= 256`, `M % 8 == 0`\n// https://regexr.com/6v8hp\nexport const integerRegex = /^(u?int)(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/;\nexport const maxInt8 = 2n ** (8n - 1n) - 1n;\nexport const maxInt16 = 2n ** (16n - 1n) - 1n;\nexport const maxInt24 = 2n ** (24n - 1n) - 1n;\nexport const maxInt32 = 2n ** (32n - 1n) - 1n;\nexport const maxInt40 = 2n ** (40n - 1n) - 1n;\nexport const maxInt48 = 2n ** (48n - 1n) - 1n;\nexport const maxInt56 = 2n ** (56n - 1n) - 1n;\nexport const maxInt64 = 2n ** (64n - 1n) - 1n;\nexport const maxInt72 = 2n ** (72n - 1n) - 1n;\nexport const maxInt80 = 2n ** (80n - 1n) - 1n;\nexport const maxInt88 = 2n ** (88n - 1n) - 1n;\nexport const maxInt96 = 2n ** (96n - 1n) - 1n;\nexport const maxInt104 = 2n ** (104n - 1n) - 1n;\nexport const maxInt112 = 2n ** (112n - 1n) - 1n;\nexport const maxInt120 = 2n ** (120n - 1n) - 1n;\nexport const maxInt128 = 2n ** (128n - 1n) - 1n;\nexport const maxInt136 = 2n ** (136n - 1n) - 1n;\nexport const maxInt144 = 2n ** (144n - 1n) - 1n;\nexport const maxInt152 = 2n ** (152n - 1n) - 1n;\nexport const maxInt160 = 2n ** (160n - 1n) - 1n;\nexport const maxInt168 = 2n ** (168n - 1n) - 1n;\nexport const maxInt176 = 2n ** (176n - 1n) - 1n;\nexport const maxInt184 = 2n ** (184n - 1n) - 1n;\nexport const maxInt192 = 2n ** (192n - 1n) - 1n;\nexport const maxInt200 = 2n ** (200n - 1n) - 1n;\nexport const maxInt208 = 2n ** (208n - 1n) - 1n;\nexport const maxInt216 = 2n ** (216n - 1n) - 1n;\nexport const maxInt224 = 2n ** (224n - 1n) - 1n;\nexport const maxInt232 = 2n ** (232n - 1n) - 1n;\nexport const maxInt240 = 2n ** (240n - 1n) - 1n;\nexport const maxInt248 = 2n ** (248n - 1n) - 1n;\nexport const maxInt256 = 2n ** (256n - 1n) - 1n;\nexport const minInt8 = -(2n ** (8n - 1n));\nexport const minInt16 = -(2n ** (16n - 1n));\nexport const minInt24 = -(2n ** (24n - 1n));\nexport const minInt32 = -(2n ** (32n - 1n));\nexport const minInt40 = -(2n ** (40n - 1n));\nexport const minInt48 = -(2n ** (48n - 1n));\nexport const minInt56 = -(2n ** (56n - 1n));\nexport const minInt64 = -(2n ** (64n - 1n));\nexport const minInt72 = -(2n ** (72n - 1n));\nexport const minInt80 = -(2n ** (80n - 1n));\nexport const minInt88 = -(2n ** (88n - 1n));\nexport const minInt96 = -(2n ** (96n - 1n));\nexport const minInt104 = -(2n ** (104n - 1n));\nexport const minInt112 = -(2n ** (112n - 1n));\nexport const minInt120 = -(2n ** (120n - 1n));\nexport const minInt128 = -(2n ** (128n - 1n));\nexport const minInt136 = -(2n ** (136n - 1n));\nexport const minInt144 = -(2n ** (144n - 1n));\nexport const minInt152 = -(2n ** (152n - 1n));\nexport const minInt160 = -(2n ** (160n - 1n));\nexport const minInt168 = -(2n ** (168n - 1n));\nexport const minInt176 = -(2n ** (176n - 1n));\nexport const minInt184 = -(2n ** (184n - 1n));\nexport const minInt192 = -(2n ** (192n - 1n));\nexport const minInt200 = -(2n ** (200n - 1n));\nexport const minInt208 = -(2n ** (208n - 1n));\nexport const minInt216 = -(2n ** (216n - 1n));\nexport const minInt224 = -(2n ** (224n - 1n));\nexport const minInt232 = -(2n ** (232n - 1n));\nexport const minInt240 = -(2n ** (240n - 1n));\nexport const minInt248 = -(2n ** (248n - 1n));\nexport const minInt256 = -(2n ** (256n - 1n));\nexport const maxUint8 = 2n ** 8n - 1n;\nexport const maxUint16 = 2n ** 16n - 1n;\nexport const maxUint24 = 2n ** 24n - 1n;\nexport const maxUint32 = 2n ** 32n - 1n;\nexport const maxUint40 = 2n ** 40n - 1n;\nexport const maxUint48 = 2n ** 48n - 1n;\nexport const maxUint56 = 2n ** 56n - 1n;\nexport const maxUint64 = 2n ** 64n - 1n;\nexport const maxUint72 = 2n ** 72n - 1n;\nexport const maxUint80 = 2n ** 80n - 1n;\nexport const maxUint88 = 2n ** 88n - 1n;\nexport const maxUint96 = 2n ** 96n - 1n;\nexport const maxUint104 = 2n ** 104n - 1n;\nexport const maxUint112 = 2n ** 112n - 1n;\nexport const maxUint120 = 2n ** 120n - 1n;\nexport const maxUint128 = 2n ** 128n - 1n;\nexport const maxUint136 = 2n ** 136n - 1n;\nexport const maxUint144 = 2n ** 144n - 1n;\nexport const maxUint152 = 2n ** 152n - 1n;\nexport const maxUint160 = 2n ** 160n - 1n;\nexport const maxUint168 = 2n ** 168n - 1n;\nexport const maxUint176 = 2n ** 176n - 1n;\nexport const maxUint184 = 2n ** 184n - 1n;\nexport const maxUint192 = 2n ** 192n - 1n;\nexport const maxUint200 = 2n ** 200n - 1n;\nexport const maxUint208 = 2n ** 208n - 1n;\nexport const maxUint216 = 2n ** 216n - 1n;\nexport const maxUint224 = 2n ** 224n - 1n;\nexport const maxUint232 = 2n ** 232n - 1n;\nexport const maxUint240 = 2n ** 240n - 1n;\nexport const maxUint248 = 2n ** 248n - 1n;\nexport const maxUint256 = 2n ** 256n - 1n;\n//# sourceMappingURL=Solidity.js.map","import * as AbiParameters from '../AbiParameters.js';\nimport * as Address from '../Address.js';\nimport * as Bytes from '../Bytes.js';\nimport * as Errors from '../Errors.js';\nimport * as Hex from '../Hex.js';\nimport { integerRegex } from '../Solidity.js';\n/** @internal */\nexport function decodeParameter(cursor, param, options) {\n    const { checksumAddress, staticPosition } = options;\n    const arrayComponents = getArrayComponents(param.type);\n    if (arrayComponents) {\n        const [length, type] = arrayComponents;\n        return decodeArray(cursor, { ...param, type }, { checksumAddress, length, staticPosition });\n    }\n    if (param.type === 'tuple')\n        return decodeTuple(cursor, param, {\n            checksumAddress,\n            staticPosition,\n        });\n    if (param.type === 'address')\n        return decodeAddress(cursor, { checksum: checksumAddress });\n    if (param.type === 'bool')\n        return decodeBool(cursor);\n    if (param.type.startsWith('bytes'))\n        return decodeBytes(cursor, param, { staticPosition });\n    if (param.type.startsWith('uint') || param.type.startsWith('int'))\n        return decodeNumber(cursor, param);\n    if (param.type === 'string')\n        return decodeString(cursor, { staticPosition });\n    throw new AbiParameters.InvalidTypeError(param.type);\n}\nconst sizeOfLength = 32;\nconst sizeOfOffset = 32;\n/** @internal */\nexport function decodeAddress(cursor, options = {}) {\n    const { checksum = false } = options;\n    const value = cursor.readBytes(32);\n    const wrap = (address) => checksum ? Address.checksum(address) : address;\n    return [wrap(Hex.fromBytes(Bytes.slice(value, -20))), 32];\n}\n/** @internal */\nexport function decodeArray(cursor, param, options) {\n    const { checksumAddress, length, staticPosition } = options;\n    // If the length of the array is not known in advance (dynamic array),\n    // this means we will need to wonder off to the pointer and decode.\n    if (!length) {\n        // Dealing with a dynamic type, so get the offset of the array data.\n        const offset = Bytes.toNumber(cursor.readBytes(sizeOfOffset));\n        // Start is the static position of current slot + offset.\n        const start = staticPosition + offset;\n        const startOfData = start + sizeOfLength;\n        // Get the length of the array from the offset.\n        cursor.setPosition(start);\n        const length = Bytes.toNumber(cursor.readBytes(sizeOfLength));\n        // Check if the array has any dynamic children.\n        const dynamicChild = hasDynamicChild(param);\n        let consumed = 0;\n        const value = [];\n        for (let i = 0; i < length; ++i) {\n            // If any of the children is dynamic, then all elements will be offset pointer, thus size of one slot (32 bytes).\n            // Otherwise, elements will be the size of their encoding (consumed bytes).\n            cursor.setPosition(startOfData + (dynamicChild ? i * 32 : consumed));\n            const [data, consumed_] = decodeParameter(cursor, param, {\n                checksumAddress,\n                staticPosition: startOfData,\n            });\n            consumed += consumed_;\n            value.push(data);\n        }\n        // As we have gone wondering, restore to the original position + next slot.\n        cursor.setPosition(staticPosition + 32);\n        return [value, 32];\n    }\n    // If the length of the array is known in advance,\n    // and the length of an element deeply nested in the array is not known,\n    // we need to decode the offset of the array data.\n    if (hasDynamicChild(param)) {\n        // Dealing with dynamic types, so get the offset of the array data.\n        const offset = Bytes.toNumber(cursor.readBytes(sizeOfOffset));\n        // Start is the static position of current slot + offset.\n        const start = staticPosition + offset;\n        const value = [];\n        for (let i = 0; i < length; ++i) {\n            // Move cursor along to the next slot (next offset pointer).\n            cursor.setPosition(start + i * 32);\n            const [data] = decodeParameter(cursor, param, {\n                checksumAddress,\n                staticPosition: start,\n            });\n            value.push(data);\n        }\n        // As we have gone wondering, restore to the original position + next slot.\n        cursor.setPosition(staticPosition + 32);\n        return [value, 32];\n    }\n    // If the length of the array is known in advance and the array is deeply static,\n    // then we can just decode each element in sequence.\n    let consumed = 0;\n    const value = [];\n    for (let i = 0; i < length; ++i) {\n        const [data, consumed_] = decodeParameter(cursor, param, {\n            checksumAddress,\n            staticPosition: staticPosition + consumed,\n        });\n        consumed += consumed_;\n        value.push(data);\n    }\n    return [value, consumed];\n}\n/** @internal */\nexport function decodeBool(cursor) {\n    return [Bytes.toBoolean(cursor.readBytes(32), { size: 32 }), 32];\n}\n/** @internal */\nexport function decodeBytes(cursor, param, { staticPosition }) {\n    const [_, size] = param.type.split('bytes');\n    if (!size) {\n        // Dealing with dynamic types, so get the offset of the bytes data.\n        const offset = Bytes.toNumber(cursor.readBytes(32));\n        // Set position of the cursor to start of bytes data.\n        cursor.setPosition(staticPosition + offset);\n        const length = Bytes.toNumber(cursor.readBytes(32));\n        // If there is no length, we have zero data.\n        if (length === 0) {\n            // As we have gone wondering, restore to the original position + next slot.\n            cursor.setPosition(staticPosition + 32);\n            return ['0x', 32];\n        }\n        const data = cursor.readBytes(length);\n        // As we have gone wondering, restore to the original position + next slot.\n        cursor.setPosition(staticPosition + 32);\n        return [Hex.fromBytes(data), 32];\n    }\n    const value = Hex.fromBytes(cursor.readBytes(Number.parseInt(size, 10), 32));\n    return [value, 32];\n}\n/** @internal */\nexport function decodeNumber(cursor, param) {\n    const signed = param.type.startsWith('int');\n    const size = Number.parseInt(param.type.split('int')[1] || '256', 10);\n    const value = cursor.readBytes(32);\n    return [\n        size > 48\n            ? Bytes.toBigInt(value, { signed })\n            : Bytes.toNumber(value, { signed }),\n        32,\n    ];\n}\n/** @internal */\nexport function decodeTuple(cursor, param, options) {\n    const { checksumAddress, staticPosition } = options;\n    // Tuples can have unnamed components (i.e. they are arrays), so we must\n    // determine whether the tuple is named or unnamed. In the case of a named\n    // tuple, the value will be an object where each property is the name of the\n    // component. In the case of an unnamed tuple, the value will be an array.\n    const hasUnnamedChild = param.components.length === 0 || param.components.some(({ name }) => !name);\n    // Initialize the value to an object or an array, depending on whether the\n    // tuple is named or unnamed.\n    const value = hasUnnamedChild ? [] : {};\n    let consumed = 0;\n    // If the tuple has a dynamic child, we must first decode the offset to the\n    // tuple data.\n    if (hasDynamicChild(param)) {\n        // Dealing with dynamic types, so get the offset of the tuple data.\n        const offset = Bytes.toNumber(cursor.readBytes(sizeOfOffset));\n        // Start is the static position of referencing slot + offset.\n        const start = staticPosition + offset;\n        for (let i = 0; i < param.components.length; ++i) {\n            const component = param.components[i];\n            cursor.setPosition(start + consumed);\n            const [data, consumed_] = decodeParameter(cursor, component, {\n                checksumAddress,\n                staticPosition: start,\n            });\n            consumed += consumed_;\n            value[hasUnnamedChild ? i : component?.name] = data;\n        }\n        // As we have gone wondering, restore to the original position + next slot.\n        cursor.setPosition(staticPosition + 32);\n        return [value, 32];\n    }\n    // If the tuple has static children, we can just decode each component\n    // in sequence.\n    for (let i = 0; i < param.components.length; ++i) {\n        const component = param.components[i];\n        const [data, consumed_] = decodeParameter(cursor, component, {\n            checksumAddress,\n            staticPosition,\n        });\n        value[hasUnnamedChild ? i : component?.name] = data;\n        consumed += consumed_;\n    }\n    return [value, consumed];\n}\n/** @internal */\nexport function decodeString(cursor, { staticPosition }) {\n    // Get offset to start of string data.\n    const offset = Bytes.toNumber(cursor.readBytes(32));\n    // Start is the static position of current slot + offset.\n    const start = staticPosition + offset;\n    cursor.setPosition(start);\n    const length = Bytes.toNumber(cursor.readBytes(32));\n    // If there is no length, we have zero data (empty string).\n    if (length === 0) {\n        cursor.setPosition(staticPosition + 32);\n        return ['', 32];\n    }\n    const data = cursor.readBytes(length, 32);\n    const value = Bytes.toString(Bytes.trimLeft(data));\n    // As we have gone wondering, restore to the original position + next slot.\n    cursor.setPosition(staticPosition + 32);\n    return [value, 32];\n}\n/** @internal */\nexport function prepareParameters({ checksumAddress, parameters, values, }) {\n    const preparedParameters = [];\n    for (let i = 0; i < parameters.length; i++) {\n        preparedParameters.push(prepareParameter({\n            checksumAddress,\n            parameter: parameters[i],\n            value: values[i],\n        }));\n    }\n    return preparedParameters;\n}\n/** @internal */\nexport function prepareParameter({ checksumAddress = false, parameter: parameter_, value, }) {\n    const parameter = parameter_;\n    const arrayComponents = getArrayComponents(parameter.type);\n    if (arrayComponents) {\n        const [length, type] = arrayComponents;\n        return encodeArray(value, {\n            checksumAddress,\n            length,\n            parameter: {\n                ...parameter,\n                type,\n            },\n        });\n    }\n    if (parameter.type === 'tuple') {\n        return encodeTuple(value, {\n            checksumAddress,\n            parameter: parameter,\n        });\n    }\n    if (parameter.type === 'address') {\n        return encodeAddress(value, {\n            checksum: checksumAddress,\n        });\n    }\n    if (parameter.type === 'bool') {\n        return encodeBoolean(value);\n    }\n    if (parameter.type.startsWith('uint') || parameter.type.startsWith('int')) {\n        const signed = parameter.type.startsWith('int');\n        const [, , size = '256'] = integerRegex.exec(parameter.type) ?? [];\n        return encodeNumber(value, {\n            signed,\n            size: Number(size),\n        });\n    }\n    if (parameter.type.startsWith('bytes')) {\n        return encodeBytes(value, { type: parameter.type });\n    }\n    if (parameter.type === 'string') {\n        return encodeString(value);\n    }\n    throw new AbiParameters.InvalidTypeError(parameter.type);\n}\n/** @internal */\nexport function encode(preparedParameters) {\n    // 1. Compute the size of the static part of the parameters.\n    let staticSize = 0;\n    for (let i = 0; i < preparedParameters.length; i++) {\n        const { dynamic, encoded } = preparedParameters[i];\n        if (dynamic)\n            staticSize += 32;\n        else\n            staticSize += Hex.size(encoded);\n    }\n    // 2. Split the parameters into static and dynamic parts.\n    const staticParameters = [];\n    const dynamicParameters = [];\n    let dynamicSize = 0;\n    for (let i = 0; i < preparedParameters.length; i++) {\n        const { dynamic, encoded } = preparedParameters[i];\n        if (dynamic) {\n            staticParameters.push(Hex.fromNumber(staticSize + dynamicSize, { size: 32 }));\n            dynamicParameters.push(encoded);\n            dynamicSize += Hex.size(encoded);\n        }\n        else {\n            staticParameters.push(encoded);\n        }\n    }\n    // 3. Concatenate static and dynamic parts.\n    return Hex.concat(...staticParameters, ...dynamicParameters);\n}\n/** @internal */\nexport function encodeAddress(value, options) {\n    const { checksum = false } = options;\n    Address.assert(value, { strict: checksum });\n    return {\n        dynamic: false,\n        encoded: Hex.padLeft(value.toLowerCase()),\n    };\n}\n/** @internal */\nexport function encodeArray(value, options) {\n    const { checksumAddress, length, parameter } = options;\n    const dynamic = length === null;\n    if (!Array.isArray(value))\n        throw new AbiParameters.InvalidArrayError(value);\n    if (!dynamic && value.length !== length)\n        throw new AbiParameters.ArrayLengthMismatchError({\n            expectedLength: length,\n            givenLength: value.length,\n            type: `${parameter.type}[${length}]`,\n        });\n    let dynamicChild = false;\n    const preparedParameters = [];\n    for (let i = 0; i < value.length; i++) {\n        const preparedParam = prepareParameter({\n            checksumAddress,\n            parameter,\n            value: value[i],\n        });\n        if (preparedParam.dynamic)\n            dynamicChild = true;\n        preparedParameters.push(preparedParam);\n    }\n    if (dynamic || dynamicChild) {\n        const data = encode(preparedParameters);\n        if (dynamic) {\n            const length = Hex.fromNumber(preparedParameters.length, { size: 32 });\n            return {\n                dynamic: true,\n                encoded: preparedParameters.length > 0 ? Hex.concat(length, data) : length,\n            };\n        }\n        if (dynamicChild)\n            return { dynamic: true, encoded: data };\n    }\n    return {\n        dynamic: false,\n        encoded: Hex.concat(...preparedParameters.map(({ encoded }) => encoded)),\n    };\n}\n/** @internal */\nexport function encodeBytes(value, { type }) {\n    const [, parametersize] = type.split('bytes');\n    const bytesSize = Hex.size(value);\n    if (!parametersize) {\n        let value_ = value;\n        // If the size is not divisible by 32 bytes, pad the end\n        // with empty bytes to the ceiling 32 bytes.\n        if (bytesSize % 32 !== 0)\n            value_ = Hex.padRight(value_, Math.ceil((value.length - 2) / 2 / 32) * 32);\n        return {\n            dynamic: true,\n            encoded: Hex.concat(Hex.padLeft(Hex.fromNumber(bytesSize, { size: 32 })), value_),\n        };\n    }\n    if (bytesSize !== Number.parseInt(parametersize, 10))\n        throw new AbiParameters.BytesSizeMismatchError({\n            expectedSize: Number.parseInt(parametersize, 10),\n            value,\n        });\n    return { dynamic: false, encoded: Hex.padRight(value) };\n}\n/** @internal */\nexport function encodeBoolean(value) {\n    if (typeof value !== 'boolean')\n        throw new Errors.BaseError(`Invalid boolean value: \"${value}\" (type: ${typeof value}). Expected: \\`true\\` or \\`false\\`.`);\n    return { dynamic: false, encoded: Hex.padLeft(Hex.fromBoolean(value)) };\n}\n/** @internal */\nexport function encodeNumber(value, { signed, size }) {\n    if (typeof size === 'number') {\n        const max = 2n ** (BigInt(size) - (signed ? 1n : 0n)) - 1n;\n        const min = signed ? -max - 1n : 0n;\n        if (value > max || value < min)\n            throw new Hex.IntegerOutOfRangeError({\n                max: max.toString(),\n                min: min.toString(),\n                signed,\n                size: size / 8,\n                value: value.toString(),\n            });\n    }\n    return {\n        dynamic: false,\n        encoded: Hex.fromNumber(value, {\n            size: 32,\n            signed,\n        }),\n    };\n}\n/** @internal */\nexport function encodeString(value) {\n    const hexValue = Hex.fromString(value);\n    const partsLength = Math.ceil(Hex.size(hexValue) / 32);\n    const parts = [];\n    for (let i = 0; i < partsLength; i++) {\n        parts.push(Hex.padRight(Hex.slice(hexValue, i * 32, (i + 1) * 32)));\n    }\n    return {\n        dynamic: true,\n        encoded: Hex.concat(Hex.padRight(Hex.fromNumber(Hex.size(hexValue), { size: 32 })), ...parts),\n    };\n}\n/** @internal */\nexport function encodeTuple(value, options) {\n    const { checksumAddress, parameter } = options;\n    let dynamic = false;\n    const preparedParameters = [];\n    for (let i = 0; i < parameter.components.length; i++) {\n        const param_ = parameter.components[i];\n        const index = Array.isArray(value) ? i : param_.name;\n        const preparedParam = prepareParameter({\n            checksumAddress,\n            parameter: param_,\n            value: value[index],\n        });\n        preparedParameters.push(preparedParam);\n        if (preparedParam.dynamic)\n            dynamic = true;\n    }\n    return {\n        dynamic,\n        encoded: dynamic\n            ? encode(preparedParameters)\n            : Hex.concat(...preparedParameters.map(({ encoded }) => encoded)),\n    };\n}\n/** @internal */\nexport function getArrayComponents(type) {\n    const matches = type.match(/^(.*)\\[(\\d+)?\\]$/);\n    return matches\n        ? // Return `null` if the array is dynamic.\n            [matches[2] ? Number(matches[2]) : null, matches[1]]\n        : undefined;\n}\n/** @internal */\nexport function hasDynamicChild(param) {\n    const { type } = param;\n    if (type === 'string')\n        return true;\n    if (type === 'bytes')\n        return true;\n    if (type.endsWith('[]'))\n        return true;\n    if (type === 'tuple')\n        return param.components?.some(hasDynamicChild);\n    const arrayComponents = getArrayComponents(param.type);\n    if (arrayComponents &&\n        hasDynamicChild({\n            ...param,\n            type: arrayComponents[1],\n        }))\n        return true;\n    return false;\n}\n//# sourceMappingURL=abiParameters.js.map","import * as Errors from '../Errors.js';\nconst staticCursor = {\n    bytes: new Uint8Array(),\n    dataView: new DataView(new ArrayBuffer(0)),\n    position: 0,\n    positionReadCount: new Map(),\n    recursiveReadCount: 0,\n    recursiveReadLimit: Number.POSITIVE_INFINITY,\n    assertReadLimit() {\n        if (this.recursiveReadCount >= this.recursiveReadLimit)\n            throw new RecursiveReadLimitExceededError({\n                count: this.recursiveReadCount + 1,\n                limit: this.recursiveReadLimit,\n            });\n    },\n    assertPosition(position) {\n        if (position < 0 || position > this.bytes.length - 1)\n            throw new PositionOutOfBoundsError({\n                length: this.bytes.length,\n                position,\n            });\n    },\n    decrementPosition(offset) {\n        if (offset < 0)\n            throw new NegativeOffsetError({ offset });\n        const position = this.position - offset;\n        this.assertPosition(position);\n        this.position = position;\n    },\n    getReadCount(position) {\n        return this.positionReadCount.get(position || this.position) || 0;\n    },\n    incrementPosition(offset) {\n        if (offset < 0)\n            throw new NegativeOffsetError({ offset });\n        const position = this.position + offset;\n        this.assertPosition(position);\n        this.position = position;\n    },\n    inspectByte(position_) {\n        const position = position_ ?? this.position;\n        this.assertPosition(position);\n        return this.bytes[position];\n    },\n    inspectBytes(length, position_) {\n        const position = position_ ?? this.position;\n        this.assertPosition(position + length - 1);\n        return this.bytes.subarray(position, position + length);\n    },\n    inspectUint8(position_) {\n        const position = position_ ?? this.position;\n        this.assertPosition(position);\n        return this.bytes[position];\n    },\n    inspectUint16(position_) {\n        const position = position_ ?? this.position;\n        this.assertPosition(position + 1);\n        return this.dataView.getUint16(position);\n    },\n    inspectUint24(position_) {\n        const position = position_ ?? this.position;\n        this.assertPosition(position + 2);\n        return ((this.dataView.getUint16(position) << 8) +\n            this.dataView.getUint8(position + 2));\n    },\n    inspectUint32(position_) {\n        const position = position_ ?? this.position;\n        this.assertPosition(position + 3);\n        return this.dataView.getUint32(position);\n    },\n    pushByte(byte) {\n        this.assertPosition(this.position);\n        this.bytes[this.position] = byte;\n        this.position++;\n    },\n    pushBytes(bytes) {\n        this.assertPosition(this.position + bytes.length - 1);\n        this.bytes.set(bytes, this.position);\n        this.position += bytes.length;\n    },\n    pushUint8(value) {\n        this.assertPosition(this.position);\n        this.bytes[this.position] = value;\n        this.position++;\n    },\n    pushUint16(value) {\n        this.assertPosition(this.position + 1);\n        this.dataView.setUint16(this.position, value);\n        this.position += 2;\n    },\n    pushUint24(value) {\n        this.assertPosition(this.position + 2);\n        this.dataView.setUint16(this.position, value >> 8);\n        this.dataView.setUint8(this.position + 2, value & ~4294967040);\n        this.position += 3;\n    },\n    pushUint32(value) {\n        this.assertPosition(this.position + 3);\n        this.dataView.setUint32(this.position, value);\n        this.position += 4;\n    },\n    readByte() {\n        this.assertReadLimit();\n        this._touch();\n        const value = this.inspectByte();\n        this.position++;\n        return value;\n    },\n    readBytes(length, size) {\n        this.assertReadLimit();\n        this._touch();\n        const value = this.inspectBytes(length);\n        this.position += size ?? length;\n        return value;\n    },\n    readUint8() {\n        this.assertReadLimit();\n        this._touch();\n        const value = this.inspectUint8();\n        this.position += 1;\n        return value;\n    },\n    readUint16() {\n        this.assertReadLimit();\n        this._touch();\n        const value = this.inspectUint16();\n        this.position += 2;\n        return value;\n    },\n    readUint24() {\n        this.assertReadLimit();\n        this._touch();\n        const value = this.inspectUint24();\n        this.position += 3;\n        return value;\n    },\n    readUint32() {\n        this.assertReadLimit();\n        this._touch();\n        const value = this.inspectUint32();\n        this.position += 4;\n        return value;\n    },\n    get remaining() {\n        return this.bytes.length - this.position;\n    },\n    setPosition(position) {\n        const oldPosition = this.position;\n        this.assertPosition(position);\n        this.position = position;\n        return () => (this.position = oldPosition);\n    },\n    _touch() {\n        if (this.recursiveReadLimit === Number.POSITIVE_INFINITY)\n            return;\n        const count = this.getReadCount();\n        this.positionReadCount.set(this.position, count + 1);\n        if (count > 0)\n            this.recursiveReadCount++;\n    },\n};\n/** @internal */\nexport function create(bytes, { recursiveReadLimit = 8_192 } = {}) {\n    const cursor = Object.create(staticCursor);\n    cursor.bytes = bytes;\n    cursor.dataView = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);\n    cursor.positionReadCount = new Map();\n    cursor.recursiveReadLimit = recursiveReadLimit;\n    return cursor;\n}\n/** @internal */\nexport class NegativeOffsetError extends Errors.BaseError {\n    constructor({ offset }) {\n        super(`Offset \\`${offset}\\` cannot be negative.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Cursor.NegativeOffsetError'\n        });\n    }\n}\n/** @internal */\nexport class PositionOutOfBoundsError extends Errors.BaseError {\n    constructor({ length, position }) {\n        super(`Position \\`${position}\\` is out of bounds (\\`0 < position < ${length}\\`).`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Cursor.PositionOutOfBoundsError'\n        });\n    }\n}\n/** @internal */\nexport class RecursiveReadLimitExceededError extends Errors.BaseError {\n    constructor({ count, limit }) {\n        super(`Recursive read limit of \\`${limit}\\` exceeded (recursive read count: \\`${count}\\`).`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Cursor.RecursiveReadLimitExceededError'\n        });\n    }\n}\n//# sourceMappingURL=cursor.js.map","import * as abitype from 'abitype';\nimport * as Address from './Address.js';\nimport * as Bytes from './Bytes.js';\nimport * as Errors from './Errors.js';\nimport * as Hex from './Hex.js';\nimport * as internal from './internal/abiParameters.js';\nimport * as Cursor from './internal/cursor.js';\nimport * as Solidity from './Solidity.js';\n// eslint-disable-next-line jsdoc/require-jsdoc\nexport function decode(parameters, data, options = {}) {\n    const { as = 'Array', checksumAddress = false } = options;\n    const bytes = typeof data === 'string' ? Bytes.fromHex(data) : data;\n    const cursor = Cursor.create(bytes);\n    if (Bytes.size(bytes) === 0 && parameters.length > 0)\n        throw new ZeroDataError();\n    if (Bytes.size(bytes) && Bytes.size(bytes) < 32)\n        throw new DataSizeTooSmallError({\n            data: typeof data === 'string' ? data : Hex.fromBytes(data),\n            parameters: parameters,\n            size: Bytes.size(bytes),\n        });\n    let consumed = 0;\n    const values = as === 'Array' ? [] : {};\n    for (let i = 0; i < parameters.length; ++i) {\n        const param = parameters[i];\n        cursor.setPosition(consumed);\n        const [data, consumed_] = internal.decodeParameter(cursor, param, {\n            checksumAddress,\n            staticPosition: 0,\n        });\n        consumed += consumed_;\n        if (as === 'Array')\n            values.push(data);\n        else\n            values[param.name ?? i] = data;\n    }\n    return values;\n}\n/**\n * Encodes primitive values into ABI encoded data as per the [Application Binary Interface (ABI) Specification](https://docs.soliditylang.org/en/latest/abi-spec).\n *\n * @example\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * const data = AbiParameters.encode(\n *   AbiParameters.from(['string', 'uint', 'bool']),\n *   ['wagmi', 420n, true],\n * )\n * ```\n *\n * @example\n * ### JSON Parameters\n *\n * Specify **JSON ABI** Parameters as schema:\n *\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * const data = AbiParameters.encode(\n *   [\n *     { type: 'string', name: 'name' },\n *     { type: 'uint', name: 'age' },\n *     { type: 'bool', name: 'isOwner' },\n *   ],\n *   ['wagmi', 420n, true],\n * )\n * ```\n *\n * @param parameters - The set of ABI parameters to encode, in the shape of the `inputs` or `outputs` attribute of an ABI Item. These parameters must include valid [ABI types](https://docs.soliditylang.org/en/latest/types.html).\n * @param values - The set of primitive values that correspond to the ABI types defined in `parameters`.\n * @returns ABI encoded data.\n */\nexport function encode(parameters, values, options) {\n    const { checksumAddress = false } = options ?? {};\n    if (parameters.length !== values.length)\n        throw new LengthMismatchError({\n            expectedLength: parameters.length,\n            givenLength: values.length,\n        });\n    // Prepare the parameters to determine dynamic types to encode.\n    const preparedParameters = internal.prepareParameters({\n        checksumAddress,\n        parameters: parameters,\n        values: values,\n    });\n    const data = internal.encode(preparedParameters);\n    if (data.length === 0)\n        return '0x';\n    return data;\n}\n/**\n * Encodes an array of primitive values to a [packed ABI encoding](https://docs.soliditylang.org/en/latest/abi-spec.html#non-standard-packed-mode).\n *\n * @example\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * const encoded = AbiParameters.encodePacked(\n *   ['address', 'string'],\n *   ['0xd8da6bf26964af9d7eed9e03e53415d37aa96045', 'hello world'],\n * )\n * // @log: '0xd8da6bf26964af9d7eed9e03e53415d37aa9604568656c6c6f20776f726c64'\n * ```\n *\n * @param types - Set of ABI types to pack encode.\n * @param values - The set of primitive values that correspond to the ABI types defined in `types`.\n * @returns The encoded packed data.\n */\nexport function encodePacked(types, values) {\n    if (types.length !== values.length)\n        throw new LengthMismatchError({\n            expectedLength: types.length,\n            givenLength: values.length,\n        });\n    const data = [];\n    for (let i = 0; i < types.length; i++) {\n        const type = types[i];\n        const value = values[i];\n        data.push(encodePacked.encode(type, value));\n    }\n    return Hex.concat(...data);\n}\n(function (encodePacked) {\n    // eslint-disable-next-line jsdoc/require-jsdoc\n    function encode(type, value, isArray = false) {\n        if (type === 'address') {\n            const address = value;\n            Address.assert(address);\n            return Hex.padLeft(address.toLowerCase(), isArray ? 32 : 0);\n        }\n        if (type === 'string')\n            return Hex.fromString(value);\n        if (type === 'bytes')\n            return value;\n        if (type === 'bool')\n            return Hex.padLeft(Hex.fromBoolean(value), isArray ? 32 : 1);\n        const intMatch = type.match(Solidity.integerRegex);\n        if (intMatch) {\n            const [_type, baseType, bits = '256'] = intMatch;\n            const size = Number.parseInt(bits, 10) / 8;\n            return Hex.fromNumber(value, {\n                size: isArray ? 32 : size,\n                signed: baseType === 'int',\n            });\n        }\n        const bytesMatch = type.match(Solidity.bytesRegex);\n        if (bytesMatch) {\n            const [_type, size] = bytesMatch;\n            if (Number.parseInt(size, 10) !== (value.length - 2) / 2)\n                throw new BytesSizeMismatchError({\n                    expectedSize: Number.parseInt(size, 10),\n                    value: value,\n                });\n            return Hex.padRight(value, isArray ? 32 : 0);\n        }\n        const arrayMatch = type.match(Solidity.arrayRegex);\n        if (arrayMatch && Array.isArray(value)) {\n            const [_type, childType] = arrayMatch;\n            const data = [];\n            for (let i = 0; i < value.length; i++) {\n                data.push(encode(childType, value[i], true));\n            }\n            if (data.length === 0)\n                return '0x';\n            return Hex.concat(...data);\n        }\n        throw new InvalidTypeError(type);\n    }\n    encodePacked.encode = encode;\n})(encodePacked || (encodePacked = {}));\n/**\n * Formats {@link ox#AbiParameters.AbiParameters} into **Human Readable ABI Parameters**.\n *\n * @example\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * const formatted = AbiParameters.format([\n *   {\n *     name: 'spender',\n *     type: 'address',\n *   },\n *   {\n *     name: 'amount',\n *     type: 'uint256',\n *   },\n * ])\n *\n * formatted\n * //    ^?\n *\n *\n * ```\n *\n * @param parameters - The ABI Parameters to format.\n * @returns The formatted ABI Parameters  .\n */\nexport function format(parameters) {\n    return abitype.formatAbiParameters(parameters);\n}\n/**\n * Parses arbitrary **JSON ABI Parameters** or **Human Readable ABI Parameters** into typed {@link ox#AbiParameters.AbiParameters}.\n *\n * @example\n * ### JSON Parameters\n *\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * const parameters = AbiParameters.from([\n *   {\n *     name: 'spender',\n *     type: 'address',\n *   },\n *   {\n *     name: 'amount',\n *     type: 'uint256',\n *   },\n * ])\n *\n * parameters\n * //^?\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * ### Human Readable Parameters\n *\n * Human Readable ABI Parameters can be parsed into a typed {@link ox#AbiParameters.AbiParameters}:\n *\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * const parameters = AbiParameters.from('address spender, uint256 amount')\n *\n * parameters\n * //^?\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * It is possible to specify `struct`s along with your definitions:\n *\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * const parameters = AbiParameters.from([\n *   'struct Foo { address spender; uint256 amount; }', // [!code hl]\n *   'Foo foo, address bar',\n * ])\n *\n * parameters\n * //^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n *\n *\n * @param parameters - The ABI Parameters to parse.\n * @returns The typed ABI Parameters.\n */\nexport function from(parameters) {\n    if (Array.isArray(parameters) && typeof parameters[0] === 'string')\n        return abitype.parseAbiParameters(parameters);\n    if (typeof parameters === 'string')\n        return abitype.parseAbiParameters(parameters);\n    return parameters;\n}\n/**\n * Throws when the data size is too small for the given parameters.\n *\n * @example\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * AbiParameters.decode([{ type: 'uint256' }], '0x010f')\n * //                                               2 bytes\n * // @error: AbiParameters.DataSizeTooSmallError: Data size of 2 bytes is too small for given parameters.\n * // @error: Params: (uint256)\n * // @error: Data:   0x010f (2 bytes)\n * ```\n *\n * ### Solution\n *\n * Pass a valid data size.\n *\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * AbiParameters.decode([{ type: 'uint256' }], '0x00000000000000000000000000000000000000000000000000000000000010f')\n * //                                               32 bytes\n * ```\n */\nexport class DataSizeTooSmallError extends Errors.BaseError {\n    constructor({ data, parameters, size, }) {\n        super(`Data size of ${size} bytes is too small for given parameters.`, {\n            metaMessages: [\n                `Params: (${abitype.formatAbiParameters(parameters)})`,\n                `Data:   ${data} (${size} bytes)`,\n            ],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'AbiParameters.DataSizeTooSmallError'\n        });\n    }\n}\n/**\n * Throws when zero data is provided, but data is expected.\n *\n * @example\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * AbiParameters.decode([{ type: 'uint256' }], '0x')\n * //                                             zero data\n * // @error: AbiParameters.DataSizeTooSmallError: Data size of 2 bytes is too small for given parameters.\n * // @error: Params: (uint256)\n * // @error: Data:   0x010f (2 bytes)\n * ```\n *\n * ### Solution\n *\n * Pass valid data.\n *\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * AbiParameters.decode([{ type: 'uint256' }], '0x00000000000000000000000000000000000000000000000000000000000010f')\n * //                                               32 bytes\n * ```\n */\nexport class ZeroDataError extends Errors.BaseError {\n    constructor() {\n        super('Cannot decode zero data (\"0x\") with ABI parameters.');\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'AbiParameters.ZeroDataError'\n        });\n    }\n}\n/**\n * The length of the array value does not match the length specified in the corresponding ABI parameter.\n *\n * ### Example\n *\n * ```ts twoslash\n * // @noErrors\n * import { AbiParameters } from 'ox'\n * // ---cut---\n * AbiParameters.encode(AbiParameters.from('uint256[3]'), [[69n, 420n]])\n * //                                                expected: 3    length: 2\n * // @error: AbiParameters.ArrayLengthMismatchError: ABI encoding array length mismatch\n * // @error: for type `uint256[3]`. Expected: `3`. Given: `2`.\n * ```\n *\n * ### Solution\n *\n * Pass an array of the correct length.\n *\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n * // ---cut---\n * AbiParameters.encode(AbiParameters.from(['uint256[3]']), [[69n, 420n, 69n]])\n * //                                                           length: 3\n * ```\n */\nexport class ArrayLengthMismatchError extends Errors.BaseError {\n    constructor({ expectedLength, givenLength, type, }) {\n        super(`Array length mismatch for type \\`${type}\\`. Expected: \\`${expectedLength}\\`. Given: \\`${givenLength}\\`.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'AbiParameters.ArrayLengthMismatchError'\n        });\n    }\n}\n/**\n * The size of the bytes value does not match the size specified in the corresponding ABI parameter.\n *\n * ### Example\n *\n * ```ts twoslash\n * // @noErrors\n * import { AbiParameters } from 'ox'\n * // ---cut---\n * AbiParameters.encode(AbiParameters.from('bytes8'), [['0xdeadbeefdeadbeefdeadbeef']])\n * //                                             expected: 8 bytes    size: 12 bytes\n * // @error: BytesSizeMismatchError: Size of bytes \"0xdeadbeefdeadbeefdeadbeef\"\n * // @error: (bytes12) does not match expected size (bytes8).\n * ```\n *\n * ### Solution\n *\n * Pass a bytes value of the correct size.\n *\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n * // ---cut---\n * AbiParameters.encode(AbiParameters.from(['bytes8']), ['0xdeadbeefdeadbeef'])\n * //                                                         size: 8 bytes\n * ```\n */\nexport class BytesSizeMismatchError extends Errors.BaseError {\n    constructor({ expectedSize, value, }) {\n        super(`Size of bytes \"${value}\" (bytes${Hex.size(value)}) does not match expected size (bytes${expectedSize}).`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'AbiParameters.BytesSizeMismatchError'\n        });\n    }\n}\n/**\n * The length of the values to encode does not match the length of the ABI parameters.\n *\n * ### Example\n *\n * ```ts twoslash\n * // @noErrors\n * import { AbiParameters } from 'ox'\n * // ---cut---\n * AbiParameters.encode(AbiParameters.from(['string', 'uint256']), ['hello'])\n * // @error: LengthMismatchError: ABI encoding params/values length mismatch.\n * // @error: Expected length (params): 2\n * // @error: Given length (values): 1\n * ```\n *\n * ### Solution\n *\n * Pass the correct number of values to encode.\n *\n * ### Solution\n *\n * Pass a [valid ABI type](https://docs.soliditylang.org/en/develop/abi-spec.html#types).\n */\nexport class LengthMismatchError extends Errors.BaseError {\n    constructor({ expectedLength, givenLength, }) {\n        super([\n            'ABI encoding parameters/values length mismatch.',\n            `Expected length (parameters): ${expectedLength}`,\n            `Given length (values): ${givenLength}`,\n        ].join('\\n'));\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'AbiParameters.LengthMismatchError'\n        });\n    }\n}\n/**\n * The value provided is not a valid array as specified in the corresponding ABI parameter.\n *\n * ### Example\n *\n * ```ts twoslash\n * // @noErrors\n * import { AbiParameters } from 'ox'\n * // ---cut---\n * AbiParameters.encode(AbiParameters.from(['uint256[3]']), [69])\n * ```\n *\n * ### Solution\n *\n * Pass an array value.\n */\nexport class InvalidArrayError extends Errors.BaseError {\n    constructor(value) {\n        super(`Value \\`${value}\\` is not a valid array.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'AbiParameters.InvalidArrayError'\n        });\n    }\n}\n/**\n * Throws when the ABI parameter type is invalid.\n *\n * @example\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * AbiParameters.decode([{ type: 'lol' }], '0x00000000000000000000000000000000000000000000000000000000000010f')\n * //                               invalid type\n * // @error: AbiParameters.InvalidTypeError: Type `lol` is not a valid ABI Type.\n * ```\n */\nexport class InvalidTypeError extends Errors.BaseError {\n    constructor(type) {\n        super(`Type \\`${type}\\` is not a valid ABI Type.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'AbiParameters.InvalidTypeError'\n        });\n    }\n}\n//# sourceMappingURL=AbiParameters.js.map","/**\n * HMAC: RFC2104 message authentication code.\n * @module\n */\nimport { abytes, aexists, ahash, clean, Hash, toBytes } from \"./utils.js\";\nexport class HMAC extends Hash {\n    constructor(hash, _key) {\n        super();\n        this.finished = false;\n        this.destroyed = false;\n        ahash(hash);\n        const key = toBytes(_key);\n        this.iHash = hash.create();\n        if (typeof this.iHash.update !== 'function')\n            throw new Error('Expected instance of class which extends utils.Hash');\n        this.blockLen = this.iHash.blockLen;\n        this.outputLen = this.iHash.outputLen;\n        const blockLen = this.blockLen;\n        const pad = new Uint8Array(blockLen);\n        // blockLen can be bigger than outputLen\n        pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);\n        for (let i = 0; i < pad.length; i++)\n            pad[i] ^= 0x36;\n        this.iHash.update(pad);\n        // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone\n        this.oHash = hash.create();\n        // Undo internal XOR && apply outer XOR\n        for (let i = 0; i < pad.length; i++)\n            pad[i] ^= 0x36 ^ 0x5c;\n        this.oHash.update(pad);\n        clean(pad);\n    }\n    update(buf) {\n        aexists(this);\n        this.iHash.update(buf);\n        return this;\n    }\n    digestInto(out) {\n        aexists(this);\n        abytes(out, this.outputLen);\n        this.finished = true;\n        this.iHash.digestInto(out);\n        this.oHash.update(out);\n        this.oHash.digestInto(out);\n        this.destroy();\n    }\n    digest() {\n        const out = new Uint8Array(this.oHash.outputLen);\n        this.digestInto(out);\n        return out;\n    }\n    _cloneInto(to) {\n        // Create new instance without calling constructor since key already in state and we don't know it.\n        to || (to = Object.create(Object.getPrototypeOf(this), {}));\n        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;\n        to = to;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        to.blockLen = blockLen;\n        to.outputLen = outputLen;\n        to.oHash = oHash._cloneInto(to.oHash);\n        to.iHash = iHash._cloneInto(to.iHash);\n        return to;\n    }\n    clone() {\n        return this._cloneInto();\n    }\n    destroy() {\n        this.destroyed = true;\n        this.oHash.destroy();\n        this.iHash.destroy();\n    }\n}\n/**\n * HMAC: RFC2104 message authentication code.\n * @param hash - function that would be used e.g. sha256\n * @param key - message key\n * @param message - message data\n * @example\n * import { hmac } from '@noble/hashes/hmac';\n * import { sha256 } from '@noble/hashes/sha2';\n * const mac1 = hmac(sha256, 'key', 'message');\n */\nexport const hmac = (hash, key, message) => new HMAC(hash, key).update(message).digest();\nhmac.create = (hash, key) => new HMAC(hash, key);\n//# sourceMappingURL=hmac.js.map","/**\n * Utils for modular division and finite fields.\n * A finite field over 11 is integer number operations `mod 11`.\n * There is no division: it is replaced by modular multiplicative inverse.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { anumber } from '@noble/hashes/utils';\nimport { bitMask, bytesToNumberBE, bytesToNumberLE, ensureBytes, numberToBytesBE, numberToBytesLE, validateObject, } from \"./utils.js\";\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = /* @__PURE__ */ BigInt(2), _3n = /* @__PURE__ */ BigInt(3);\n// prettier-ignore\nconst _4n = /* @__PURE__ */ BigInt(4), _5n = /* @__PURE__ */ BigInt(5), _8n = /* @__PURE__ */ BigInt(8);\n// Calculates a modulo b\nexport function mod(a, b) {\n    const result = a % b;\n    return result >= _0n ? result : b + result;\n}\n/**\n * Efficiently raise num to power and do modular division.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n * TODO: remove.\n * @example\n * pow(2n, 6n, 11n) // 64n % 11n == 9n\n */\nexport function pow(num, power, modulo) {\n    return FpPow(Field(modulo), num, power);\n}\n/** Does `x^(2^power)` mod p. `pow2(30, 4)` == `30^(2^4)` */\nexport function pow2(x, power, modulo) {\n    let res = x;\n    while (power-- > _0n) {\n        res *= res;\n        res %= modulo;\n    }\n    return res;\n}\n/**\n * Inverses number over modulo.\n * Implemented using [Euclidean GCD](https://brilliant.org/wiki/extended-euclidean-algorithm/).\n */\nexport function invert(number, modulo) {\n    if (number === _0n)\n        throw new Error('invert: expected non-zero number');\n    if (modulo <= _0n)\n        throw new Error('invert: expected positive modulus, got ' + modulo);\n    // Fermat's little theorem \"CT-like\" version inv(n) = n^(m-2) mod m is 30x slower.\n    let a = mod(number, modulo);\n    let b = modulo;\n    // prettier-ignore\n    let x = _0n, y = _1n, u = _1n, v = _0n;\n    while (a !== _0n) {\n        // JIT applies optimization if those two lines follow each other\n        const q = b / a;\n        const r = b % a;\n        const m = x - u * q;\n        const n = y - v * q;\n        // prettier-ignore\n        b = a, a = r, x = u, y = v, u = m, v = n;\n    }\n    const gcd = b;\n    if (gcd !== _1n)\n        throw new Error('invert: does not exist');\n    return mod(x, modulo);\n}\n// Not all roots are possible! Example which will throw:\n// const NUM =\n// n = 72057594037927816n;\n// Fp = Field(BigInt('0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab'));\nfunction sqrt3mod4(Fp, n) {\n    const p1div4 = (Fp.ORDER + _1n) / _4n;\n    const root = Fp.pow(n, p1div4);\n    // Throw if root^2 != n\n    if (!Fp.eql(Fp.sqr(root), n))\n        throw new Error('Cannot find square root');\n    return root;\n}\nfunction sqrt5mod8(Fp, n) {\n    const p5div8 = (Fp.ORDER - _5n) / _8n;\n    const n2 = Fp.mul(n, _2n);\n    const v = Fp.pow(n2, p5div8);\n    const nv = Fp.mul(n, v);\n    const i = Fp.mul(Fp.mul(nv, _2n), v);\n    const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));\n    if (!Fp.eql(Fp.sqr(root), n))\n        throw new Error('Cannot find square root');\n    return root;\n}\n// TODO: Commented-out for now. Provide test vectors.\n// Tonelli is too slow for extension fields Fp2.\n// That means we can't use sqrt (c1, c2...) even for initialization constants.\n// if (P % _16n === _9n) return sqrt9mod16;\n// // prettier-ignore\n// function sqrt9mod16<T>(Fp: IField<T>, n: T, p7div16?: bigint) {\n//   if (p7div16 === undefined) p7div16 = (Fp.ORDER + BigInt(7)) / _16n;\n//   const c1 = Fp.sqrt(Fp.neg(Fp.ONE)); //  1. c1 = sqrt(-1) in F, i.e., (c1^2) == -1 in F\n//   const c2 = Fp.sqrt(c1);             //  2. c2 = sqrt(c1) in F, i.e., (c2^2) == c1 in F\n//   const c3 = Fp.sqrt(Fp.neg(c1));     //  3. c3 = sqrt(-c1) in F, i.e., (c3^2) == -c1 in F\n//   const c4 = p7div16;                 //  4. c4 = (q + 7) / 16        # Integer arithmetic\n//   let tv1 = Fp.pow(n, c4);            //  1. tv1 = x^c4\n//   let tv2 = Fp.mul(c1, tv1);          //  2. tv2 = c1 * tv1\n//   const tv3 = Fp.mul(c2, tv1);        //  3. tv3 = c2 * tv1\n//   let tv4 = Fp.mul(c3, tv1);          //  4. tv4 = c3 * tv1\n//   const e1 = Fp.eql(Fp.sqr(tv2), n);  //  5.  e1 = (tv2^2) == x\n//   const e2 = Fp.eql(Fp.sqr(tv3), n);  //  6.  e2 = (tv3^2) == x\n//   tv1 = Fp.cmov(tv1, tv2, e1); //  7. tv1 = CMOV(tv1, tv2, e1)  # Select tv2 if (tv2^2) == x\n//   tv2 = Fp.cmov(tv4, tv3, e2); //  8. tv2 = CMOV(tv4, tv3, e2)  # Select tv3 if (tv3^2) == x\n//   const e3 = Fp.eql(Fp.sqr(tv2), n);  //  9.  e3 = (tv2^2) == x\n//   return Fp.cmov(tv1, tv2, e3); // 10.  z = CMOV(tv1, tv2, e3) # Select the sqrt from tv1 and tv2\n// }\n/**\n * Tonelli-Shanks square root search algorithm.\n * 1. https://eprint.iacr.org/2012/685.pdf (page 12)\n * 2. Square Roots from 1; 24, 51, 10 to Dan Shanks\n * @param P field order\n * @returns function that takes field Fp (created from P) and number n\n */\nexport function tonelliShanks(P) {\n    // Initialization (precomputation).\n    if (P < BigInt(3))\n        throw new Error('sqrt is not defined for small field');\n    // Factor P - 1 = Q * 2^S, where Q is odd\n    let Q = P - _1n;\n    let S = 0;\n    while (Q % _2n === _0n) {\n        Q /= _2n;\n        S++;\n    }\n    // Find the first quadratic non-residue Z >= 2\n    let Z = _2n;\n    const _Fp = Field(P);\n    while (FpLegendre(_Fp, Z) === 1) {\n        // Basic primality test for P. After x iterations, chance of\n        // not finding quadratic non-residue is 2^x, so 2^1000.\n        if (Z++ > 1000)\n            throw new Error('Cannot find square root: probably non-prime P');\n    }\n    // Fast-path; usually done before Z, but we do \"primality test\".\n    if (S === 1)\n        return sqrt3mod4;\n    // Slow-path\n    // TODO: test on Fp2 and others\n    let cc = _Fp.pow(Z, Q); // c = z^Q\n    const Q1div2 = (Q + _1n) / _2n;\n    return function tonelliSlow(Fp, n) {\n        if (Fp.is0(n))\n            return n;\n        // Check if n is a quadratic residue using Legendre symbol\n        if (FpLegendre(Fp, n) !== 1)\n            throw new Error('Cannot find square root');\n        // Initialize variables for the main loop\n        let M = S;\n        let c = Fp.mul(Fp.ONE, cc); // c = z^Q, move cc from field _Fp into field Fp\n        let t = Fp.pow(n, Q); // t = n^Q, first guess at the fudge factor\n        let R = Fp.pow(n, Q1div2); // R = n^((Q+1)/2), first guess at the square root\n        // Main loop\n        // while t != 1\n        while (!Fp.eql(t, Fp.ONE)) {\n            if (Fp.is0(t))\n                return Fp.ZERO; // if t=0 return R=0\n            let i = 1;\n            // Find the smallest i >= 1 such that t^(2^i)  1 (mod P)\n            let t_tmp = Fp.sqr(t); // t^(2^1)\n            while (!Fp.eql(t_tmp, Fp.ONE)) {\n                i++;\n                t_tmp = Fp.sqr(t_tmp); // t^(2^2)...\n                if (i === M)\n                    throw new Error('Cannot find square root');\n            }\n            // Calculate the exponent for b: 2^(M - i - 1)\n            const exponent = _1n << BigInt(M - i - 1); // bigint is important\n            const b = Fp.pow(c, exponent); // b = 2^(M - i - 1)\n            // Update variables\n            M = i;\n            c = Fp.sqr(b); // c = b^2\n            t = Fp.mul(t, c); // t = (t * b^2)\n            R = Fp.mul(R, b); // R = R*b\n        }\n        return R;\n    };\n}\n/**\n * Square root for a finite field. Will try optimized versions first:\n *\n * 1. P  3 (mod 4)\n * 2. P  5 (mod 8)\n * 3. Tonelli-Shanks algorithm\n *\n * Different algorithms can give different roots, it is up to user to decide which one they want.\n * For example there is FpSqrtOdd/FpSqrtEven to choice root based on oddness (used for hash-to-curve).\n */\nexport function FpSqrt(P) {\n    // P  3 (mod 4) => n = n^((P+1)/4)\n    if (P % _4n === _3n)\n        return sqrt3mod4;\n    // P  5 (mod 8) => Atkin algorithm, page 10 of https://eprint.iacr.org/2012/685.pdf\n    if (P % _8n === _5n)\n        return sqrt5mod8;\n    // P  9 (mod 16) not implemented, see above\n    // Tonelli-Shanks algorithm\n    return tonelliShanks(P);\n}\n// Little-endian check for first LE bit (last BE bit);\nexport const isNegativeLE = (num, modulo) => (mod(num, modulo) & _1n) === _1n;\n// prettier-ignore\nconst FIELD_FIELDS = [\n    'create', 'isValid', 'is0', 'neg', 'inv', 'sqrt', 'sqr',\n    'eql', 'add', 'sub', 'mul', 'pow', 'div',\n    'addN', 'subN', 'mulN', 'sqrN'\n];\nexport function validateField(field) {\n    const initial = {\n        ORDER: 'bigint',\n        MASK: 'bigint',\n        BYTES: 'isSafeInteger',\n        BITS: 'isSafeInteger',\n    };\n    const opts = FIELD_FIELDS.reduce((map, val) => {\n        map[val] = 'function';\n        return map;\n    }, initial);\n    return validateObject(field, opts);\n}\n// Generic field functions\n/**\n * Same as `pow` but for Fp: non-constant-time.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n */\nexport function FpPow(Fp, num, power) {\n    if (power < _0n)\n        throw new Error('invalid exponent, negatives unsupported');\n    if (power === _0n)\n        return Fp.ONE;\n    if (power === _1n)\n        return num;\n    let p = Fp.ONE;\n    let d = num;\n    while (power > _0n) {\n        if (power & _1n)\n            p = Fp.mul(p, d);\n        d = Fp.sqr(d);\n        power >>= _1n;\n    }\n    return p;\n}\n/**\n * Efficiently invert an array of Field elements.\n * Exception-free. Will return `undefined` for 0 elements.\n * @param passZero map 0 to 0 (instead of undefined)\n */\nexport function FpInvertBatch(Fp, nums, passZero = false) {\n    const inverted = new Array(nums.length).fill(passZero ? Fp.ZERO : undefined);\n    // Walk from first to last, multiply them by each other MOD p\n    const multipliedAcc = nums.reduce((acc, num, i) => {\n        if (Fp.is0(num))\n            return acc;\n        inverted[i] = acc;\n        return Fp.mul(acc, num);\n    }, Fp.ONE);\n    // Invert last element\n    const invertedAcc = Fp.inv(multipliedAcc);\n    // Walk from last to first, multiply them by inverted each other MOD p\n    nums.reduceRight((acc, num, i) => {\n        if (Fp.is0(num))\n            return acc;\n        inverted[i] = Fp.mul(acc, inverted[i]);\n        return Fp.mul(acc, num);\n    }, invertedAcc);\n    return inverted;\n}\n// TODO: remove\nexport function FpDiv(Fp, lhs, rhs) {\n    return Fp.mul(lhs, typeof rhs === 'bigint' ? invert(rhs, Fp.ORDER) : Fp.inv(rhs));\n}\n/**\n * Legendre symbol.\n * Legendre constant is used to calculate Legendre symbol (a | p)\n * which denotes the value of a^((p-1)/2) (mod p).\n *\n * * (a | p)  1    if a is a square (mod p), quadratic residue\n * * (a | p)  -1   if a is not a square (mod p), quadratic non residue\n * * (a | p)  0    if a  0 (mod p)\n */\nexport function FpLegendre(Fp, n) {\n    // We can use 3rd argument as optional cache of this value\n    // but seems unneeded for now. The operation is very fast.\n    const p1mod2 = (Fp.ORDER - _1n) / _2n;\n    const powered = Fp.pow(n, p1mod2);\n    const yes = Fp.eql(powered, Fp.ONE);\n    const zero = Fp.eql(powered, Fp.ZERO);\n    const no = Fp.eql(powered, Fp.neg(Fp.ONE));\n    if (!yes && !zero && !no)\n        throw new Error('invalid Legendre symbol result');\n    return yes ? 1 : zero ? 0 : -1;\n}\n// This function returns True whenever the value x is a square in the field F.\nexport function FpIsSquare(Fp, n) {\n    const l = FpLegendre(Fp, n);\n    return l === 1;\n}\n// CURVE.n lengths\nexport function nLength(n, nBitLength) {\n    // Bit size, byte size of CURVE.n\n    if (nBitLength !== undefined)\n        anumber(nBitLength);\n    const _nBitLength = nBitLength !== undefined ? nBitLength : n.toString(2).length;\n    const nByteLength = Math.ceil(_nBitLength / 8);\n    return { nBitLength: _nBitLength, nByteLength };\n}\n/**\n * Initializes a finite field over prime.\n * Major performance optimizations:\n * * a) denormalized operations like mulN instead of mul\n * * b) same object shape: never add or remove keys\n * * c) Object.freeze\n * Fragile: always run a benchmark on a change.\n * Security note: operations don't check 'isValid' for all elements for performance reasons,\n * it is caller responsibility to check this.\n * This is low-level code, please make sure you know what you're doing.\n * @param ORDER prime positive bigint\n * @param bitLen how many bits the field consumes\n * @param isLE (def: false) if encoding / decoding should be in little-endian\n * @param redef optional faster redefinitions of sqrt and other methods\n */\nexport function Field(ORDER, bitLen, isLE = false, redef = {}) {\n    if (ORDER <= _0n)\n        throw new Error('invalid field: expected ORDER > 0, got ' + ORDER);\n    const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen);\n    if (BYTES > 2048)\n        throw new Error('invalid field: expected ORDER of <= 2048 bytes');\n    let sqrtP; // cached sqrtP\n    const f = Object.freeze({\n        ORDER,\n        isLE,\n        BITS,\n        BYTES,\n        MASK: bitMask(BITS),\n        ZERO: _0n,\n        ONE: _1n,\n        create: (num) => mod(num, ORDER),\n        isValid: (num) => {\n            if (typeof num !== 'bigint')\n                throw new Error('invalid field element: expected bigint, got ' + typeof num);\n            return _0n <= num && num < ORDER; // 0 is valid element, but it's not invertible\n        },\n        is0: (num) => num === _0n,\n        isOdd: (num) => (num & _1n) === _1n,\n        neg: (num) => mod(-num, ORDER),\n        eql: (lhs, rhs) => lhs === rhs,\n        sqr: (num) => mod(num * num, ORDER),\n        add: (lhs, rhs) => mod(lhs + rhs, ORDER),\n        sub: (lhs, rhs) => mod(lhs - rhs, ORDER),\n        mul: (lhs, rhs) => mod(lhs * rhs, ORDER),\n        pow: (num, power) => FpPow(f, num, power),\n        div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),\n        // Same as above, but doesn't normalize\n        sqrN: (num) => num * num,\n        addN: (lhs, rhs) => lhs + rhs,\n        subN: (lhs, rhs) => lhs - rhs,\n        mulN: (lhs, rhs) => lhs * rhs,\n        inv: (num) => invert(num, ORDER),\n        sqrt: redef.sqrt ||\n            ((n) => {\n                if (!sqrtP)\n                    sqrtP = FpSqrt(ORDER);\n                return sqrtP(f, n);\n            }),\n        toBytes: (num) => (isLE ? numberToBytesLE(num, BYTES) : numberToBytesBE(num, BYTES)),\n        fromBytes: (bytes) => {\n            if (bytes.length !== BYTES)\n                throw new Error('Field.fromBytes: expected ' + BYTES + ' bytes, got ' + bytes.length);\n            return isLE ? bytesToNumberLE(bytes) : bytesToNumberBE(bytes);\n        },\n        // TODO: we don't need it here, move out to separate fn\n        invertBatch: (lst) => FpInvertBatch(f, lst),\n        // We can't move this out because Fp6, Fp12 implement it\n        // and it's unclear what to return in there.\n        cmov: (a, b, c) => (c ? b : a),\n    });\n    return Object.freeze(f);\n}\nexport function FpSqrtOdd(Fp, elm) {\n    if (!Fp.isOdd)\n        throw new Error(\"Field doesn't have isOdd\");\n    const root = Fp.sqrt(elm);\n    return Fp.isOdd(root) ? root : Fp.neg(root);\n}\nexport function FpSqrtEven(Fp, elm) {\n    if (!Fp.isOdd)\n        throw new Error(\"Field doesn't have isOdd\");\n    const root = Fp.sqrt(elm);\n    return Fp.isOdd(root) ? Fp.neg(root) : root;\n}\n/**\n * \"Constant-time\" private key generation utility.\n * Same as mapKeyToField, but accepts less bytes (40 instead of 48 for 32-byte field).\n * Which makes it slightly more biased, less secure.\n * @deprecated use `mapKeyToField` instead\n */\nexport function hashToPrivateScalar(hash, groupOrder, isLE = false) {\n    hash = ensureBytes('privateHash', hash);\n    const hashLen = hash.length;\n    const minLen = nLength(groupOrder).nByteLength + 8;\n    if (minLen < 24 || hashLen < minLen || hashLen > 1024)\n        throw new Error('hashToPrivateScalar: expected ' + minLen + '-1024 bytes of input, got ' + hashLen);\n    const num = isLE ? bytesToNumberLE(hash) : bytesToNumberBE(hash);\n    return mod(num, groupOrder - _1n) + _1n;\n}\n/**\n * Returns total number of bytes consumed by the field element.\n * For example, 32 bytes for usual 256-bit weierstrass curve.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of field\n */\nexport function getFieldBytesLength(fieldOrder) {\n    if (typeof fieldOrder !== 'bigint')\n        throw new Error('field order must be bigint');\n    const bitLength = fieldOrder.toString(2).length;\n    return Math.ceil(bitLength / 8);\n}\n/**\n * Returns minimal amount of bytes that can be safely reduced\n * by field order.\n * Should be 2^-128 for 128-bit curve such as P256.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of target hash\n */\nexport function getMinHashLength(fieldOrder) {\n    const length = getFieldBytesLength(fieldOrder);\n    return length + Math.ceil(length / 2);\n}\n/**\n * \"Constant-time\" private key generation utility.\n * Can take (n + n/2) or more bytes of uniform input e.g. from CSPRNG or KDF\n * and convert them into private scalar, with the modulo bias being negligible.\n * Needs at least 48 bytes of input for 32-byte private key.\n * https://research.kudelskisecurity.com/2020/07/28/the-definitive-guide-to-modulo-bias-and-how-to-avoid-it/\n * FIPS 186-5, A.2 https://csrc.nist.gov/publications/detail/fips/186/5/final\n * RFC 9380, https://www.rfc-editor.org/rfc/rfc9380#section-5\n * @param hash hash output from SHA3 or a similar function\n * @param groupOrder size of subgroup - (e.g. secp256k1.CURVE.n)\n * @param isLE interpret hash bytes as LE num\n * @returns valid private scalar\n */\nexport function mapHashToField(key, fieldOrder, isLE = false) {\n    const len = key.length;\n    const fieldLen = getFieldBytesLength(fieldOrder);\n    const minLen = getMinHashLength(fieldOrder);\n    // No small numbers: need to understand bias story. No huge numbers: easier to detect JS timings.\n    if (len < 16 || len < minLen || len > 1024)\n        throw new Error('expected ' + minLen + '-1024 bytes of input, got ' + len);\n    const num = isLE ? bytesToNumberLE(key) : bytesToNumberBE(key);\n    // `mod(x, 11)` can sometimes produce 0. `mod(x, 10) + 1` is the same, but no 0\n    const reduced = mod(num, fieldOrder - _1n) + _1n;\n    return isLE ? numberToBytesLE(reduced, fieldLen) : numberToBytesBE(reduced, fieldLen);\n}\n//# sourceMappingURL=modular.js.map","/**\n * Methods for elliptic curve multiplication by scalars.\n * Contains wNAF, pippenger\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { nLength, validateField } from \"./modular.js\";\nimport { bitLen, bitMask, validateObject } from \"./utils.js\";\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nfunction constTimeNegate(condition, item) {\n    const neg = item.negate();\n    return condition ? neg : item;\n}\nfunction validateW(W, bits) {\n    if (!Number.isSafeInteger(W) || W <= 0 || W > bits)\n        throw new Error('invalid window size, expected [1..' + bits + '], got W=' + W);\n}\nfunction calcWOpts(W, scalarBits) {\n    validateW(W, scalarBits);\n    const windows = Math.ceil(scalarBits / W) + 1; // W=8 33. Not 32, because we skip zero\n    const windowSize = 2 ** (W - 1); // W=8 128. Not 256, because we skip zero\n    const maxNumber = 2 ** W; // W=8 256\n    const mask = bitMask(W); // W=8 255 == mask 0b11111111\n    const shiftBy = BigInt(W); // W=8 8\n    return { windows, windowSize, mask, maxNumber, shiftBy };\n}\nfunction calcOffsets(n, window, wOpts) {\n    const { windowSize, mask, maxNumber, shiftBy } = wOpts;\n    let wbits = Number(n & mask); // extract W bits.\n    let nextN = n >> shiftBy; // shift number by W bits.\n    // What actually happens here:\n    // const highestBit = Number(mask ^ (mask >> 1n));\n    // let wbits2 = wbits - 1; // skip zero\n    // if (wbits2 & highestBit) { wbits2 ^= Number(mask); // (~);\n    // split if bits > max: +224 => 256-32\n    if (wbits > windowSize) {\n        // we skip zero, which means instead of `>= size-1`, we do `> size`\n        wbits -= maxNumber; // -32, can be maxNumber - wbits, but then we need to set isNeg here.\n        nextN += _1n; // +256 (carry)\n    }\n    const offsetStart = window * windowSize;\n    const offset = offsetStart + Math.abs(wbits) - 1; // -1 because we skip zero\n    const isZero = wbits === 0; // is current window slice a 0?\n    const isNeg = wbits < 0; // is current window slice negative?\n    const isNegF = window % 2 !== 0; // fake random statement for noise\n    const offsetF = offsetStart; // fake offset for noise\n    return { nextN, offset, isZero, isNeg, isNegF, offsetF };\n}\nfunction validateMSMPoints(points, c) {\n    if (!Array.isArray(points))\n        throw new Error('array expected');\n    points.forEach((p, i) => {\n        if (!(p instanceof c))\n            throw new Error('invalid point at index ' + i);\n    });\n}\nfunction validateMSMScalars(scalars, field) {\n    if (!Array.isArray(scalars))\n        throw new Error('array of scalars expected');\n    scalars.forEach((s, i) => {\n        if (!field.isValid(s))\n            throw new Error('invalid scalar at index ' + i);\n    });\n}\n// Since points in different groups cannot be equal (different object constructor),\n// we can have single place to store precomputes.\n// Allows to make points frozen / immutable.\nconst pointPrecomputes = new WeakMap();\nconst pointWindowSizes = new WeakMap();\nfunction getW(P) {\n    return pointWindowSizes.get(P) || 1;\n}\n/**\n * Elliptic curve multiplication of Point by scalar. Fragile.\n * Scalars should always be less than curve order: this should be checked inside of a curve itself.\n * Creates precomputation tables for fast multiplication:\n * - private scalar is split by fixed size windows of W bits\n * - every window point is collected from window's table & added to accumulator\n * - since windows are different, same point inside tables won't be accessed more than once per calc\n * - each multiplication is 'Math.ceil(CURVE_ORDER / ) + 1' point additions (fixed for any scalar)\n * - +1 window is neccessary for wNAF\n * - wNAF reduces table size: 2x less memory + 2x faster generation, but 10% slower multiplication\n *\n * @todo Research returning 2d JS array of windows, instead of a single window.\n * This would allow windows to be in different memory locations\n */\nexport function wNAF(c, bits) {\n    return {\n        constTimeNegate,\n        hasPrecomputes(elm) {\n            return getW(elm) !== 1;\n        },\n        // non-const time multiplication ladder\n        unsafeLadder(elm, n, p = c.ZERO) {\n            let d = elm;\n            while (n > _0n) {\n                if (n & _1n)\n                    p = p.add(d);\n                d = d.double();\n                n >>= _1n;\n            }\n            return p;\n        },\n        /**\n         * Creates a wNAF precomputation window. Used for caching.\n         * Default window size is set by `utils.precompute()` and is equal to 8.\n         * Number of precomputed points depends on the curve size:\n         * 2^(1) * (Math.ceil( / ) + 1), where:\n         * -  is the window size\n         * -  is the bitlength of the curve order.\n         * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.\n         * @param elm Point instance\n         * @param W window size\n         * @returns precomputed point tables flattened to a single array\n         */\n        precomputeWindow(elm, W) {\n            const { windows, windowSize } = calcWOpts(W, bits);\n            const points = [];\n            let p = elm;\n            let base = p;\n            for (let window = 0; window < windows; window++) {\n                base = p;\n                points.push(base);\n                // i=1, bc we skip 0\n                for (let i = 1; i < windowSize; i++) {\n                    base = base.add(p);\n                    points.push(base);\n                }\n                p = base.double();\n            }\n            return points;\n        },\n        /**\n         * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.\n         * @param W window size\n         * @param precomputes precomputed tables\n         * @param n scalar (we don't check here, but should be less than curve order)\n         * @returns real and fake (for const-time) points\n         */\n        wNAF(W, precomputes, n) {\n            // Smaller version:\n            // https://github.com/paulmillr/noble-secp256k1/blob/47cb1669b6e506ad66b35fe7d76132ae97465da2/index.ts#L502-L541\n            // TODO: check the scalar is less than group order?\n            // wNAF behavior is undefined otherwise. But have to carefully remove\n            // other checks before wNAF. ORDER == bits here.\n            // Accumulators\n            let p = c.ZERO;\n            let f = c.BASE;\n            // This code was first written with assumption that 'f' and 'p' will never be infinity point:\n            // since each addition is multiplied by 2 ** W, it cannot cancel each other. However,\n            // there is negate now: it is possible that negated element from low value\n            // would be the same as high element, which will create carry into next window.\n            // It's not obvious how this can fail, but still worth investigating later.\n            const wo = calcWOpts(W, bits);\n            for (let window = 0; window < wo.windows; window++) {\n                // (n === _0n) is handled and not early-exited. isEven and offsetF are used for noise\n                const { nextN, offset, isZero, isNeg, isNegF, offsetF } = calcOffsets(n, window, wo);\n                n = nextN;\n                if (isZero) {\n                    // bits are 0: add garbage to fake point\n                    // Important part for const-time getPublicKey: add random \"noise\" point to f.\n                    f = f.add(constTimeNegate(isNegF, precomputes[offsetF]));\n                }\n                else {\n                    // bits are 1: add to result point\n                    p = p.add(constTimeNegate(isNeg, precomputes[offset]));\n                }\n            }\n            // Return both real and fake points: JIT won't eliminate f.\n            // At this point there is a way to F be infinity-point even if p is not,\n            // which makes it less const-time: around 1 bigint multiply.\n            return { p, f };\n        },\n        /**\n         * Implements ec unsafe (non const-time) multiplication using precomputed tables and w-ary non-adjacent form.\n         * @param W window size\n         * @param precomputes precomputed tables\n         * @param n scalar (we don't check here, but should be less than curve order)\n         * @param acc accumulator point to add result of multiplication\n         * @returns point\n         */\n        wNAFUnsafe(W, precomputes, n, acc = c.ZERO) {\n            const wo = calcWOpts(W, bits);\n            for (let window = 0; window < wo.windows; window++) {\n                if (n === _0n)\n                    break; // Early-exit, skip 0 value\n                const { nextN, offset, isZero, isNeg } = calcOffsets(n, window, wo);\n                n = nextN;\n                if (isZero) {\n                    // Window bits are 0: skip processing.\n                    // Move to next window.\n                    continue;\n                }\n                else {\n                    const item = precomputes[offset];\n                    acc = acc.add(isNeg ? item.negate() : item); // Re-using acc allows to save adds in MSM\n                }\n            }\n            return acc;\n        },\n        getPrecomputes(W, P, transform) {\n            // Calculate precomputes on a first run, reuse them after\n            let comp = pointPrecomputes.get(P);\n            if (!comp) {\n                comp = this.precomputeWindow(P, W);\n                if (W !== 1)\n                    pointPrecomputes.set(P, transform(comp));\n            }\n            return comp;\n        },\n        wNAFCached(P, n, transform) {\n            const W = getW(P);\n            return this.wNAF(W, this.getPrecomputes(W, P, transform), n);\n        },\n        wNAFCachedUnsafe(P, n, transform, prev) {\n            const W = getW(P);\n            if (W === 1)\n                return this.unsafeLadder(P, n, prev); // For W=1 ladder is ~x2 faster\n            return this.wNAFUnsafe(W, this.getPrecomputes(W, P, transform), n, prev);\n        },\n        // We calculate precomputes for elliptic curve point multiplication\n        // using windowed method. This specifies window size and\n        // stores precomputed values. Usually only base point would be precomputed.\n        setWindowSize(P, W) {\n            validateW(W, bits);\n            pointWindowSizes.set(P, W);\n            pointPrecomputes.delete(P);\n        },\n    };\n}\n/**\n * Pippenger algorithm for multi-scalar multiplication (MSM, Pa + Qb + Rc + ...).\n * 30x faster vs naive addition on L=4096, 10x faster than precomputes.\n * For N=254bit, L=1, it does: 1024 ADD + 254 DBL. For L=5: 1536 ADD + 254 DBL.\n * Algorithmically constant-time (for same L), even when 1 point + scalar, or when scalar = 0.\n * @param c Curve Point constructor\n * @param fieldN field over CURVE.N - important that it's not over CURVE.P\n * @param points array of L curve points\n * @param scalars array of L scalars (aka private keys / bigints)\n */\nexport function pippenger(c, fieldN, points, scalars) {\n    // If we split scalars by some window (let's say 8 bits), every chunk will only\n    // take 256 buckets even if there are 4096 scalars, also re-uses double.\n    // TODO:\n    // - https://eprint.iacr.org/2024/750.pdf\n    // - https://tches.iacr.org/index.php/TCHES/article/view/10287\n    // 0 is accepted in scalars\n    validateMSMPoints(points, c);\n    validateMSMScalars(scalars, fieldN);\n    const plength = points.length;\n    const slength = scalars.length;\n    if (plength !== slength)\n        throw new Error('arrays of points and scalars must have equal length');\n    // if (plength === 0) throw new Error('array must be of length >= 2');\n    const zero = c.ZERO;\n    const wbits = bitLen(BigInt(plength));\n    let windowSize = 1; // bits\n    if (wbits > 12)\n        windowSize = wbits - 3;\n    else if (wbits > 4)\n        windowSize = wbits - 2;\n    else if (wbits > 0)\n        windowSize = 2;\n    const MASK = bitMask(windowSize);\n    const buckets = new Array(Number(MASK) + 1).fill(zero); // +1 for zero array\n    const lastBits = Math.floor((fieldN.BITS - 1) / windowSize) * windowSize;\n    let sum = zero;\n    for (let i = lastBits; i >= 0; i -= windowSize) {\n        buckets.fill(zero);\n        for (let j = 0; j < slength; j++) {\n            const scalar = scalars[j];\n            const wbits = Number((scalar >> BigInt(i)) & MASK);\n            buckets[wbits] = buckets[wbits].add(points[j]);\n        }\n        let resI = zero; // not using this will do small speed-up, but will lose ct\n        // Skip first bucket, because it is zero\n        for (let j = buckets.length - 1, sumI = zero; j > 0; j--) {\n            sumI = sumI.add(buckets[j]);\n            resI = resI.add(sumI);\n        }\n        sum = sum.add(resI);\n        if (i !== 0)\n            for (let j = 0; j < windowSize; j++)\n                sum = sum.double();\n    }\n    return sum;\n}\n/**\n * Precomputed multi-scalar multiplication (MSM, Pa + Qb + Rc + ...).\n * @param c Curve Point constructor\n * @param fieldN field over CURVE.N - important that it's not over CURVE.P\n * @param points array of L curve points\n * @returns function which multiplies points with scaars\n */\nexport function precomputeMSMUnsafe(c, fieldN, points, windowSize) {\n    /**\n     * Performance Analysis of Window-based Precomputation\n     *\n     * Base Case (256-bit scalar, 8-bit window):\n     * - Standard precomputation requires:\n     *   - 31 additions per scalar  256 scalars = 7,936 ops\n     *   - Plus 255 summary additions = 8,191 total ops\n     *   Note: Summary additions can be optimized via accumulator\n     *\n     * Chunked Precomputation Analysis:\n     * - Using 32 chunks requires:\n     *   - 255 additions per chunk\n     *   - 256 doublings\n     *   - Total: (255  32) + 256 = 8,416 ops\n     *\n     * Memory Usage Comparison:\n     * Window Size | Standard Points | Chunked Points\n     * ------------|-----------------|---------------\n     *     4-bit   |     520         |      15\n     *     8-bit   |    4,224        |     255\n     *    10-bit   |   13,824        |   1,023\n     *    16-bit   |  557,056        |  65,535\n     *\n     * Key Advantages:\n     * 1. Enables larger window sizes due to reduced memory overhead\n     * 2. More efficient for smaller scalar counts:\n     *    - 16 chunks: (16  255) + 256 = 4,336 ops\n     *    - ~2x faster than standard 8,191 ops\n     *\n     * Limitations:\n     * - Not suitable for plain precomputes (requires 256 constant doublings)\n     * - Performance degrades with larger scalar counts:\n     *   - Optimal for ~256 scalars\n     *   - Less efficient for 4096+ scalars (Pippenger preferred)\n     */\n    validateW(windowSize, fieldN.BITS);\n    validateMSMPoints(points, c);\n    const zero = c.ZERO;\n    const tableSize = 2 ** windowSize - 1; // table size (without zero)\n    const chunks = Math.ceil(fieldN.BITS / windowSize); // chunks of item\n    const MASK = bitMask(windowSize);\n    const tables = points.map((p) => {\n        const res = [];\n        for (let i = 0, acc = p; i < tableSize; i++) {\n            res.push(acc);\n            acc = acc.add(p);\n        }\n        return res;\n    });\n    return (scalars) => {\n        validateMSMScalars(scalars, fieldN);\n        if (scalars.length > points.length)\n            throw new Error('array of scalars must be smaller than array of points');\n        let res = zero;\n        for (let i = 0; i < chunks; i++) {\n            // No need to double if accumulator is still zero.\n            if (res !== zero)\n                for (let j = 0; j < windowSize; j++)\n                    res = res.double();\n            const shiftBy = BigInt(chunks * windowSize - (i + 1) * windowSize);\n            for (let j = 0; j < scalars.length; j++) {\n                const n = scalars[j];\n                const curr = Number((n >> shiftBy) & MASK);\n                if (!curr)\n                    continue; // skip zero scalars chunks\n                res = res.add(tables[j][curr - 1]);\n            }\n        }\n        return res;\n    };\n}\nexport function validateBasic(curve) {\n    validateField(curve.Fp);\n    validateObject(curve, {\n        n: 'bigint',\n        h: 'bigint',\n        Gx: 'field',\n        Gy: 'field',\n    }, {\n        nBitLength: 'isSafeInteger',\n        nByteLength: 'isSafeInteger',\n    });\n    // Set defaults\n    return Object.freeze({\n        ...nLength(curve.n, curve.nBitLength),\n        ...curve,\n        ...{ p: curve.Fp.ORDER },\n    });\n}\n//# sourceMappingURL=curve.js.map","/**\n * Short Weierstrass curve methods. The formula is: y = x + ax + b.\n *\n * ### Parameters\n *\n * To initialize a weierstrass curve, one needs to pass following params:\n *\n * * a: formula param\n * * b: formula param\n * * Fp: finite field of prime characteristic P; may be complex (Fp2). Arithmetics is done in field\n * * n: order of prime subgroup a.k.a total amount of valid curve points\n * * Gx: Base point (x, y) aka generator point. Gx = x coordinate\n * * Gy: ...y coordinate\n * * h: cofactor, usually 1. h*n = curve group order (n is only subgroup order)\n * * lowS: whether to enable (default) or disable \"low-s\" non-malleable signatures\n *\n * ### Design rationale for types\n *\n * * Interaction between classes from different curves should fail:\n *   `k256.Point.BASE.add(p256.Point.BASE)`\n * * For this purpose we want to use `instanceof` operator, which is fast and works during runtime\n * * Different calls of `curve()` would return different classes -\n *   `curve(params) !== curve(params)`: if somebody decided to monkey-patch their curve,\n *   it won't affect others\n *\n * TypeScript can't infer types for classes created inside a function. Classes is one instance\n * of nominative types in TypeScript and interfaces only check for shape, so it's hard to create\n * unique type for every function call.\n *\n * We can use generic types via some param, like curve opts, but that would:\n *     1. Enable interaction between `curve(params)` and `curve(params)` (curves of same params)\n *     which is hard to debug.\n *     2. Params can be generic and we can't enforce them to be constant value:\n *     if somebody creates curve from non-constant params,\n *     it would be allowed to interact with other curves with non-constant params\n *\n * @todo https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-7.html#unique-symbol\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// prettier-ignore\nimport { pippenger, validateBasic, wNAF } from \"./curve.js\";\n// prettier-ignore\nimport { Field, FpInvertBatch, getMinHashLength, invert, mapHashToField, mod, validateField } from \"./modular.js\";\n// prettier-ignore\nimport { aInRange, abool, bitMask, bytesToHex, bytesToNumberBE, concatBytes, createHmacDrbg, ensureBytes, hexToBytes, inRange, isBytes, memoized, numberToBytesBE, numberToHexUnpadded, validateObject } from \"./utils.js\";\nfunction validateSigVerOpts(opts) {\n    if (opts.lowS !== undefined)\n        abool('lowS', opts.lowS);\n    if (opts.prehash !== undefined)\n        abool('prehash', opts.prehash);\n}\nfunction validatePointOpts(curve) {\n    const opts = validateBasic(curve);\n    validateObject(opts, {\n        a: 'field',\n        b: 'field',\n    }, {\n        allowInfinityPoint: 'boolean',\n        allowedPrivateKeyLengths: 'array',\n        clearCofactor: 'function',\n        fromBytes: 'function',\n        isTorsionFree: 'function',\n        toBytes: 'function',\n        wrapPrivateKey: 'boolean',\n    });\n    const { endo, Fp, a } = opts;\n    if (endo) {\n        if (!Fp.eql(a, Fp.ZERO)) {\n            throw new Error('invalid endo: CURVE.a must be 0');\n        }\n        if (typeof endo !== 'object' ||\n            typeof endo.beta !== 'bigint' ||\n            typeof endo.splitScalar !== 'function') {\n            throw new Error('invalid endo: expected \"beta\": bigint and \"splitScalar\": function');\n        }\n    }\n    return Object.freeze({ ...opts });\n}\nexport class DERErr extends Error {\n    constructor(m = '') {\n        super(m);\n    }\n}\n/**\n * ASN.1 DER encoding utilities. ASN is very complex & fragile. Format:\n *\n *     [0x30 (SEQUENCE), bytelength, 0x02 (INTEGER), intLength, R, 0x02 (INTEGER), intLength, S]\n *\n * Docs: https://letsencrypt.org/docs/a-warm-welcome-to-asn1-and-der/, https://luca.ntop.org/Teaching/Appunti/asn1.html\n */\nexport const DER = {\n    // asn.1 DER encoding utils\n    Err: DERErr,\n    // Basic building block is TLV (Tag-Length-Value)\n    _tlv: {\n        encode: (tag, data) => {\n            const { Err: E } = DER;\n            if (tag < 0 || tag > 256)\n                throw new E('tlv.encode: wrong tag');\n            if (data.length & 1)\n                throw new E('tlv.encode: unpadded data');\n            const dataLen = data.length / 2;\n            const len = numberToHexUnpadded(dataLen);\n            if ((len.length / 2) & 128)\n                throw new E('tlv.encode: long form length too big');\n            // length of length with long form flag\n            const lenLen = dataLen > 127 ? numberToHexUnpadded((len.length / 2) | 128) : '';\n            const t = numberToHexUnpadded(tag);\n            return t + lenLen + len + data;\n        },\n        // v - value, l - left bytes (unparsed)\n        decode(tag, data) {\n            const { Err: E } = DER;\n            let pos = 0;\n            if (tag < 0 || tag > 256)\n                throw new E('tlv.encode: wrong tag');\n            if (data.length < 2 || data[pos++] !== tag)\n                throw new E('tlv.decode: wrong tlv');\n            const first = data[pos++];\n            const isLong = !!(first & 128); // First bit of first length byte is flag for short/long form\n            let length = 0;\n            if (!isLong)\n                length = first;\n            else {\n                // Long form: [longFlag(1bit), lengthLength(7bit), length (BE)]\n                const lenLen = first & 127;\n                if (!lenLen)\n                    throw new E('tlv.decode(long): indefinite length not supported');\n                if (lenLen > 4)\n                    throw new E('tlv.decode(long): byte length is too big'); // this will overflow u32 in js\n                const lengthBytes = data.subarray(pos, pos + lenLen);\n                if (lengthBytes.length !== lenLen)\n                    throw new E('tlv.decode: length bytes not complete');\n                if (lengthBytes[0] === 0)\n                    throw new E('tlv.decode(long): zero leftmost byte');\n                for (const b of lengthBytes)\n                    length = (length << 8) | b;\n                pos += lenLen;\n                if (length < 128)\n                    throw new E('tlv.decode(long): not minimal encoding');\n            }\n            const v = data.subarray(pos, pos + length);\n            if (v.length !== length)\n                throw new E('tlv.decode: wrong value length');\n            return { v, l: data.subarray(pos + length) };\n        },\n    },\n    // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,\n    // since we always use positive integers here. It must always be empty:\n    // - add zero byte if exists\n    // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)\n    _int: {\n        encode(num) {\n            const { Err: E } = DER;\n            if (num < _0n)\n                throw new E('integer: negative integers are not allowed');\n            let hex = numberToHexUnpadded(num);\n            // Pad with zero byte if negative flag is present\n            if (Number.parseInt(hex[0], 16) & 0b1000)\n                hex = '00' + hex;\n            if (hex.length & 1)\n                throw new E('unexpected DER parsing assertion: unpadded hex');\n            return hex;\n        },\n        decode(data) {\n            const { Err: E } = DER;\n            if (data[0] & 128)\n                throw new E('invalid signature integer: negative');\n            if (data[0] === 0x00 && !(data[1] & 128))\n                throw new E('invalid signature integer: unnecessary leading zero');\n            return bytesToNumberBE(data);\n        },\n    },\n    toSig(hex) {\n        // parse DER signature\n        const { Err: E, _int: int, _tlv: tlv } = DER;\n        const data = ensureBytes('signature', hex);\n        const { v: seqBytes, l: seqLeftBytes } = tlv.decode(0x30, data);\n        if (seqLeftBytes.length)\n            throw new E('invalid signature: left bytes after parsing');\n        const { v: rBytes, l: rLeftBytes } = tlv.decode(0x02, seqBytes);\n        const { v: sBytes, l: sLeftBytes } = tlv.decode(0x02, rLeftBytes);\n        if (sLeftBytes.length)\n            throw new E('invalid signature: left bytes after parsing');\n        return { r: int.decode(rBytes), s: int.decode(sBytes) };\n    },\n    hexFromSig(sig) {\n        const { _tlv: tlv, _int: int } = DER;\n        const rs = tlv.encode(0x02, int.encode(sig.r));\n        const ss = tlv.encode(0x02, int.encode(sig.s));\n        const seq = rs + ss;\n        return tlv.encode(0x30, seq);\n    },\n};\nfunction numToSizedHex(num, size) {\n    return bytesToHex(numberToBytesBE(num, size));\n}\n// Be friendly to bad ECMAScript parsers by not using bigint literals\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3), _4n = BigInt(4);\nexport function weierstrassPoints(opts) {\n    const CURVE = validatePointOpts(opts);\n    const { Fp } = CURVE; // All curves has same field / group length as for now, but they can differ\n    const Fn = Field(CURVE.n, CURVE.nBitLength);\n    const toBytes = CURVE.toBytes ||\n        ((_c, point, _isCompressed) => {\n            const a = point.toAffine();\n            return concatBytes(Uint8Array.from([0x04]), Fp.toBytes(a.x), Fp.toBytes(a.y));\n        });\n    const fromBytes = CURVE.fromBytes ||\n        ((bytes) => {\n            // const head = bytes[0];\n            const tail = bytes.subarray(1);\n            // if (head !== 0x04) throw new Error('Only non-compressed encoding is supported');\n            const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));\n            const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));\n            return { x, y };\n        });\n    /**\n     * y = x + ax + b: Short weierstrass curve formula. Takes x, returns y.\n     * @returns y\n     */\n    function weierstrassEquation(x) {\n        const { a, b } = CURVE;\n        const x2 = Fp.sqr(x); // x * x\n        const x3 = Fp.mul(x2, x); // x * x\n        return Fp.add(Fp.add(x3, Fp.mul(x, a)), b); // x + a * x + b\n    }\n    function isValidXY(x, y) {\n        const left = Fp.sqr(y); // y\n        const right = weierstrassEquation(x); // x + ax + b\n        return Fp.eql(left, right);\n    }\n    // Validate whether the passed curve params are valid.\n    // Test 1: equation y = x + ax + b should work for generator point.\n    if (!isValidXY(CURVE.Gx, CURVE.Gy))\n        throw new Error('bad curve params: generator point');\n    // Test 2: discriminant  part should be non-zero: 4a + 27b != 0.\n    // Guarantees curve is genus-1, smooth (non-singular).\n    const _4a3 = Fp.mul(Fp.pow(CURVE.a, _3n), _4n);\n    const _27b2 = Fp.mul(Fp.sqr(CURVE.b), BigInt(27));\n    if (Fp.is0(Fp.add(_4a3, _27b2)))\n        throw new Error('bad curve params: a or b');\n    // Valid group elements reside in range 1..n-1\n    function isWithinCurveOrder(num) {\n        return inRange(num, _1n, CURVE.n);\n    }\n    // Validates if priv key is valid and converts it to bigint.\n    // Supports options allowedPrivateKeyLengths and wrapPrivateKey.\n    function normPrivateKeyToScalar(key) {\n        const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n: N } = CURVE;\n        if (lengths && typeof key !== 'bigint') {\n            if (isBytes(key))\n                key = bytesToHex(key);\n            // Normalize to hex string, pad. E.g. P521 would norm 130-132 char hex to 132-char bytes\n            if (typeof key !== 'string' || !lengths.includes(key.length))\n                throw new Error('invalid private key');\n            key = key.padStart(nByteLength * 2, '0');\n        }\n        let num;\n        try {\n            num =\n                typeof key === 'bigint'\n                    ? key\n                    : bytesToNumberBE(ensureBytes('private key', key, nByteLength));\n        }\n        catch (error) {\n            throw new Error('invalid private key, expected hex or ' + nByteLength + ' bytes, got ' + typeof key);\n        }\n        if (wrapPrivateKey)\n            num = mod(num, N); // disabled by default, enabled for BLS\n        aInRange('private key', num, _1n, N); // num in range [1..N-1]\n        return num;\n    }\n    function aprjpoint(other) {\n        if (!(other instanceof Point))\n            throw new Error('ProjectivePoint expected');\n    }\n    // Memoized toAffine / validity check. They are heavy. Points are immutable.\n    // Converts Projective point to affine (x, y) coordinates.\n    // Can accept precomputed Z^-1 - for example, from invertBatch.\n    // (X, Y, Z)  (x=X/Z, y=Y/Z)\n    const toAffineMemo = memoized((p, iz) => {\n        const { px: x, py: y, pz: z } = p;\n        // Fast-path for normalized points\n        if (Fp.eql(z, Fp.ONE))\n            return { x, y };\n        const is0 = p.is0();\n        // If invZ was 0, we return zero point. However we still want to execute\n        // all operations, so we replace invZ with a random number, 1.\n        if (iz == null)\n            iz = is0 ? Fp.ONE : Fp.inv(z);\n        const ax = Fp.mul(x, iz);\n        const ay = Fp.mul(y, iz);\n        const zz = Fp.mul(z, iz);\n        if (is0)\n            return { x: Fp.ZERO, y: Fp.ZERO };\n        if (!Fp.eql(zz, Fp.ONE))\n            throw new Error('invZ was invalid');\n        return { x: ax, y: ay };\n    });\n    // NOTE: on exception this will crash 'cached' and no value will be set.\n    // Otherwise true will be return\n    const assertValidMemo = memoized((p) => {\n        if (p.is0()) {\n            // (0, 1, 0) aka ZERO is invalid in most contexts.\n            // In BLS, ZERO can be serialized, so we allow it.\n            // (0, 0, 0) is invalid representation of ZERO.\n            if (CURVE.allowInfinityPoint && !Fp.is0(p.py))\n                return;\n            throw new Error('bad point: ZERO');\n        }\n        // Some 3rd-party test vectors require different wording between here & `fromCompressedHex`\n        const { x, y } = p.toAffine();\n        // Check if x, y are valid field elements\n        if (!Fp.isValid(x) || !Fp.isValid(y))\n            throw new Error('bad point: x or y not FE');\n        if (!isValidXY(x, y))\n            throw new Error('bad point: equation left != right');\n        if (!p.isTorsionFree())\n            throw new Error('bad point: not in prime-order subgroup');\n        return true;\n    });\n    /**\n     * Projective Point works in 3d / projective (homogeneous) coordinates: (X, Y, Z)  (x=X/Z, y=Y/Z)\n     * Default Point works in 2d / affine coordinates: (x, y)\n     * We're doing calculations in projective, because its operations don't require costly inversion.\n     */\n    class Point {\n        constructor(px, py, pz) {\n            if (px == null || !Fp.isValid(px))\n                throw new Error('x required');\n            if (py == null || !Fp.isValid(py) || Fp.is0(py))\n                throw new Error('y required');\n            if (pz == null || !Fp.isValid(pz))\n                throw new Error('z required');\n            this.px = px;\n            this.py = py;\n            this.pz = pz;\n            Object.freeze(this);\n        }\n        // Does not validate if the point is on-curve.\n        // Use fromHex instead, or call assertValidity() later.\n        static fromAffine(p) {\n            const { x, y } = p || {};\n            if (!p || !Fp.isValid(x) || !Fp.isValid(y))\n                throw new Error('invalid affine point');\n            if (p instanceof Point)\n                throw new Error('projective point not allowed');\n            const is0 = (i) => Fp.eql(i, Fp.ZERO);\n            // fromAffine(x:0, y:0) would produce (x:0, y:0, z:1), but we need (x:0, y:1, z:0)\n            if (is0(x) && is0(y))\n                return Point.ZERO;\n            return new Point(x, y, Fp.ONE);\n        }\n        get x() {\n            return this.toAffine().x;\n        }\n        get y() {\n            return this.toAffine().y;\n        }\n        /**\n         * Takes a bunch of Projective Points but executes only one\n         * inversion on all of them. Inversion is very slow operation,\n         * so this improves performance massively.\n         * Optimization: converts a list of projective points to a list of identical points with Z=1.\n         */\n        static normalizeZ(points) {\n            const toInv = FpInvertBatch(Fp, points.map((p) => p.pz));\n            return points.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);\n        }\n        /**\n         * Converts hash string or Uint8Array to Point.\n         * @param hex short/long ECDSA hex\n         */\n        static fromHex(hex) {\n            const P = Point.fromAffine(fromBytes(ensureBytes('pointHex', hex)));\n            P.assertValidity();\n            return P;\n        }\n        // Multiplies generator point by privateKey.\n        static fromPrivateKey(privateKey) {\n            return Point.BASE.multiply(normPrivateKeyToScalar(privateKey));\n        }\n        // Multiscalar Multiplication\n        static msm(points, scalars) {\n            return pippenger(Point, Fn, points, scalars);\n        }\n        // \"Private method\", don't use it directly\n        _setWindowSize(windowSize) {\n            wnaf.setWindowSize(this, windowSize);\n        }\n        // A point on curve is valid if it conforms to equation.\n        assertValidity() {\n            assertValidMemo(this);\n        }\n        hasEvenY() {\n            const { y } = this.toAffine();\n            if (Fp.isOdd)\n                return !Fp.isOdd(y);\n            throw new Error(\"Field doesn't support isOdd\");\n        }\n        /**\n         * Compare one point to another.\n         */\n        equals(other) {\n            aprjpoint(other);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            const { px: X2, py: Y2, pz: Z2 } = other;\n            const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));\n            const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));\n            return U1 && U2;\n        }\n        /**\n         * Flips point to one corresponding to (x, -y) in Affine coordinates.\n         */\n        negate() {\n            return new Point(this.px, Fp.neg(this.py), this.pz);\n        }\n        // Renes-Costello-Batina exception-free doubling formula.\n        // There is 30% faster Jacobian formula, but it is not complete.\n        // https://eprint.iacr.org/2015/1060, algorithm 3\n        // Cost: 8M + 3S + 3*a + 2*b3 + 15add.\n        double() {\n            const { a, b } = CURVE;\n            const b3 = Fp.mul(b, _3n);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n            let t0 = Fp.mul(X1, X1); // step 1\n            let t1 = Fp.mul(Y1, Y1);\n            let t2 = Fp.mul(Z1, Z1);\n            let t3 = Fp.mul(X1, Y1);\n            t3 = Fp.add(t3, t3); // step 5\n            Z3 = Fp.mul(X1, Z1);\n            Z3 = Fp.add(Z3, Z3);\n            X3 = Fp.mul(a, Z3);\n            Y3 = Fp.mul(b3, t2);\n            Y3 = Fp.add(X3, Y3); // step 10\n            X3 = Fp.sub(t1, Y3);\n            Y3 = Fp.add(t1, Y3);\n            Y3 = Fp.mul(X3, Y3);\n            X3 = Fp.mul(t3, X3);\n            Z3 = Fp.mul(b3, Z3); // step 15\n            t2 = Fp.mul(a, t2);\n            t3 = Fp.sub(t0, t2);\n            t3 = Fp.mul(a, t3);\n            t3 = Fp.add(t3, Z3);\n            Z3 = Fp.add(t0, t0); // step 20\n            t0 = Fp.add(Z3, t0);\n            t0 = Fp.add(t0, t2);\n            t0 = Fp.mul(t0, t3);\n            Y3 = Fp.add(Y3, t0);\n            t2 = Fp.mul(Y1, Z1); // step 25\n            t2 = Fp.add(t2, t2);\n            t0 = Fp.mul(t2, t3);\n            X3 = Fp.sub(X3, t0);\n            Z3 = Fp.mul(t2, t1);\n            Z3 = Fp.add(Z3, Z3); // step 30\n            Z3 = Fp.add(Z3, Z3);\n            return new Point(X3, Y3, Z3);\n        }\n        // Renes-Costello-Batina exception-free addition formula.\n        // There is 30% faster Jacobian formula, but it is not complete.\n        // https://eprint.iacr.org/2015/1060, algorithm 1\n        // Cost: 12M + 0S + 3*a + 3*b3 + 23add.\n        add(other) {\n            aprjpoint(other);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            const { px: X2, py: Y2, pz: Z2 } = other;\n            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n            const a = CURVE.a;\n            const b3 = Fp.mul(CURVE.b, _3n);\n            let t0 = Fp.mul(X1, X2); // step 1\n            let t1 = Fp.mul(Y1, Y2);\n            let t2 = Fp.mul(Z1, Z2);\n            let t3 = Fp.add(X1, Y1);\n            let t4 = Fp.add(X2, Y2); // step 5\n            t3 = Fp.mul(t3, t4);\n            t4 = Fp.add(t0, t1);\n            t3 = Fp.sub(t3, t4);\n            t4 = Fp.add(X1, Z1);\n            let t5 = Fp.add(X2, Z2); // step 10\n            t4 = Fp.mul(t4, t5);\n            t5 = Fp.add(t0, t2);\n            t4 = Fp.sub(t4, t5);\n            t5 = Fp.add(Y1, Z1);\n            X3 = Fp.add(Y2, Z2); // step 15\n            t5 = Fp.mul(t5, X3);\n            X3 = Fp.add(t1, t2);\n            t5 = Fp.sub(t5, X3);\n            Z3 = Fp.mul(a, t4);\n            X3 = Fp.mul(b3, t2); // step 20\n            Z3 = Fp.add(X3, Z3);\n            X3 = Fp.sub(t1, Z3);\n            Z3 = Fp.add(t1, Z3);\n            Y3 = Fp.mul(X3, Z3);\n            t1 = Fp.add(t0, t0); // step 25\n            t1 = Fp.add(t1, t0);\n            t2 = Fp.mul(a, t2);\n            t4 = Fp.mul(b3, t4);\n            t1 = Fp.add(t1, t2);\n            t2 = Fp.sub(t0, t2); // step 30\n            t2 = Fp.mul(a, t2);\n            t4 = Fp.add(t4, t2);\n            t0 = Fp.mul(t1, t4);\n            Y3 = Fp.add(Y3, t0);\n            t0 = Fp.mul(t5, t4); // step 35\n            X3 = Fp.mul(t3, X3);\n            X3 = Fp.sub(X3, t0);\n            t0 = Fp.mul(t3, t1);\n            Z3 = Fp.mul(t5, Z3);\n            Z3 = Fp.add(Z3, t0); // step 40\n            return new Point(X3, Y3, Z3);\n        }\n        subtract(other) {\n            return this.add(other.negate());\n        }\n        is0() {\n            return this.equals(Point.ZERO);\n        }\n        wNAF(n) {\n            return wnaf.wNAFCached(this, n, Point.normalizeZ);\n        }\n        /**\n         * Non-constant-time multiplication. Uses double-and-add algorithm.\n         * It's faster, but should only be used when you don't care about\n         * an exposed private key e.g. sig verification, which works over *public* keys.\n         */\n        multiplyUnsafe(sc) {\n            const { endo, n: N } = CURVE;\n            aInRange('scalar', sc, _0n, N);\n            const I = Point.ZERO;\n            if (sc === _0n)\n                return I;\n            if (this.is0() || sc === _1n)\n                return this;\n            // Case a: no endomorphism. Case b: has precomputes.\n            if (!endo || wnaf.hasPrecomputes(this))\n                return wnaf.wNAFCachedUnsafe(this, sc, Point.normalizeZ);\n            // Case c: endomorphism\n            /** See docs for {@link EndomorphismOpts} */\n            let { k1neg, k1, k2neg, k2 } = endo.splitScalar(sc);\n            let k1p = I;\n            let k2p = I;\n            let d = this;\n            while (k1 > _0n || k2 > _0n) {\n                if (k1 & _1n)\n                    k1p = k1p.add(d);\n                if (k2 & _1n)\n                    k2p = k2p.add(d);\n                d = d.double();\n                k1 >>= _1n;\n                k2 >>= _1n;\n            }\n            if (k1neg)\n                k1p = k1p.negate();\n            if (k2neg)\n                k2p = k2p.negate();\n            k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);\n            return k1p.add(k2p);\n        }\n        /**\n         * Constant time multiplication.\n         * Uses wNAF method. Windowed method may be 10% faster,\n         * but takes 2x longer to generate and consumes 2x memory.\n         * Uses precomputes when available.\n         * Uses endomorphism for Koblitz curves.\n         * @param scalar by which the point would be multiplied\n         * @returns New point\n         */\n        multiply(scalar) {\n            const { endo, n: N } = CURVE;\n            aInRange('scalar', scalar, _1n, N);\n            let point, fake; // Fake point is used to const-time mult\n            /** See docs for {@link EndomorphismOpts} */\n            if (endo) {\n                const { k1neg, k1, k2neg, k2 } = endo.splitScalar(scalar);\n                let { p: k1p, f: f1p } = this.wNAF(k1);\n                let { p: k2p, f: f2p } = this.wNAF(k2);\n                k1p = wnaf.constTimeNegate(k1neg, k1p);\n                k2p = wnaf.constTimeNegate(k2neg, k2p);\n                k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);\n                point = k1p.add(k2p);\n                fake = f1p.add(f2p);\n            }\n            else {\n                const { p, f } = this.wNAF(scalar);\n                point = p;\n                fake = f;\n            }\n            // Normalize `z` for both points, but return only real one\n            return Point.normalizeZ([point, fake])[0];\n        }\n        /**\n         * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.\n         * Not using Strauss-Shamir trick: precomputation tables are faster.\n         * The trick could be useful if both P and Q are not G (not in our case).\n         * @returns non-zero affine point\n         */\n        multiplyAndAddUnsafe(Q, a, b) {\n            const G = Point.BASE; // No Strauss-Shamir trick: we have 10% faster G precomputes\n            const mul = (P, a // Select faster multiply() method\n            ) => (a === _0n || a === _1n || !P.equals(G) ? P.multiplyUnsafe(a) : P.multiply(a));\n            const sum = mul(this, a).add(mul(Q, b));\n            return sum.is0() ? undefined : sum;\n        }\n        // Converts Projective point to affine (x, y) coordinates.\n        // Can accept precomputed Z^-1 - for example, from invertBatch.\n        // (x, y, z)  (x=x/z, y=y/z)\n        toAffine(iz) {\n            return toAffineMemo(this, iz);\n        }\n        isTorsionFree() {\n            const { h: cofactor, isTorsionFree } = CURVE;\n            if (cofactor === _1n)\n                return true; // No subgroups, always torsion-free\n            if (isTorsionFree)\n                return isTorsionFree(Point, this);\n            throw new Error('isTorsionFree() has not been declared for the elliptic curve');\n        }\n        clearCofactor() {\n            const { h: cofactor, clearCofactor } = CURVE;\n            if (cofactor === _1n)\n                return this; // Fast-path\n            if (clearCofactor)\n                return clearCofactor(Point, this);\n            return this.multiplyUnsafe(CURVE.h);\n        }\n        toRawBytes(isCompressed = true) {\n            abool('isCompressed', isCompressed);\n            this.assertValidity();\n            return toBytes(Point, this, isCompressed);\n        }\n        toHex(isCompressed = true) {\n            abool('isCompressed', isCompressed);\n            return bytesToHex(this.toRawBytes(isCompressed));\n        }\n    }\n    // base / generator point\n    Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);\n    // zero / infinity / identity point\n    Point.ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO); // 0, 1, 0\n    const { endo, nBitLength } = CURVE;\n    const wnaf = wNAF(Point, endo ? Math.ceil(nBitLength / 2) : nBitLength);\n    return {\n        CURVE,\n        ProjectivePoint: Point,\n        normPrivateKeyToScalar,\n        weierstrassEquation,\n        isWithinCurveOrder,\n    };\n}\nfunction validateOpts(curve) {\n    const opts = validateBasic(curve);\n    validateObject(opts, {\n        hash: 'hash',\n        hmac: 'function',\n        randomBytes: 'function',\n    }, {\n        bits2int: 'function',\n        bits2int_modN: 'function',\n        lowS: 'boolean',\n    });\n    return Object.freeze({ lowS: true, ...opts });\n}\n/**\n * Creates short weierstrass curve and ECDSA signature methods for it.\n * @example\n * import { Field } from '@noble/curves/abstract/modular';\n * // Before that, define BigInt-s: a, b, p, n, Gx, Gy\n * const curve = weierstrass({ a, b, Fp: Field(p), n, Gx, Gy, h: 1n })\n */\nexport function weierstrass(curveDef) {\n    const CURVE = validateOpts(curveDef);\n    const { Fp, n: CURVE_ORDER, nByteLength, nBitLength } = CURVE;\n    const compressedLen = Fp.BYTES + 1; // e.g. 33 for 32\n    const uncompressedLen = 2 * Fp.BYTES + 1; // e.g. 65 for 32\n    function modN(a) {\n        return mod(a, CURVE_ORDER);\n    }\n    function invN(a) {\n        return invert(a, CURVE_ORDER);\n    }\n    const { ProjectivePoint: Point, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder, } = weierstrassPoints({\n        ...CURVE,\n        toBytes(_c, point, isCompressed) {\n            const a = point.toAffine();\n            const x = Fp.toBytes(a.x);\n            const cat = concatBytes;\n            abool('isCompressed', isCompressed);\n            if (isCompressed) {\n                return cat(Uint8Array.from([point.hasEvenY() ? 0x02 : 0x03]), x);\n            }\n            else {\n                return cat(Uint8Array.from([0x04]), x, Fp.toBytes(a.y));\n            }\n        },\n        fromBytes(bytes) {\n            const len = bytes.length;\n            const head = bytes[0];\n            const tail = bytes.subarray(1);\n            // this.assertValidity() is done inside of fromHex\n            if (len === compressedLen && (head === 0x02 || head === 0x03)) {\n                const x = bytesToNumberBE(tail);\n                if (!inRange(x, _1n, Fp.ORDER))\n                    throw new Error('Point is not on curve');\n                const y2 = weierstrassEquation(x); // y = x + ax + b\n                let y;\n                try {\n                    y = Fp.sqrt(y2); // y = y ^ (p+1)/4\n                }\n                catch (sqrtError) {\n                    const suffix = sqrtError instanceof Error ? ': ' + sqrtError.message : '';\n                    throw new Error('Point is not on curve' + suffix);\n                }\n                const isYOdd = (y & _1n) === _1n;\n                // ECDSA\n                const isHeadOdd = (head & 1) === 1;\n                if (isHeadOdd !== isYOdd)\n                    y = Fp.neg(y);\n                return { x, y };\n            }\n            else if (len === uncompressedLen && head === 0x04) {\n                const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));\n                const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));\n                return { x, y };\n            }\n            else {\n                const cl = compressedLen;\n                const ul = uncompressedLen;\n                throw new Error('invalid Point, expected length of ' + cl + ', or uncompressed ' + ul + ', got ' + len);\n            }\n        },\n    });\n    function isBiggerThanHalfOrder(number) {\n        const HALF = CURVE_ORDER >> _1n;\n        return number > HALF;\n    }\n    function normalizeS(s) {\n        return isBiggerThanHalfOrder(s) ? modN(-s) : s;\n    }\n    // slice bytes num\n    const slcNum = (b, from, to) => bytesToNumberBE(b.slice(from, to));\n    /**\n     * ECDSA signature with its (r, s) properties. Supports DER & compact representations.\n     */\n    class Signature {\n        constructor(r, s, recovery) {\n            aInRange('r', r, _1n, CURVE_ORDER); // r in [1..N]\n            aInRange('s', s, _1n, CURVE_ORDER); // s in [1..N]\n            this.r = r;\n            this.s = s;\n            if (recovery != null)\n                this.recovery = recovery;\n            Object.freeze(this);\n        }\n        // pair (bytes of r, bytes of s)\n        static fromCompact(hex) {\n            const l = nByteLength;\n            hex = ensureBytes('compactSignature', hex, l * 2);\n            return new Signature(slcNum(hex, 0, l), slcNum(hex, l, 2 * l));\n        }\n        // DER encoded ECDSA signature\n        // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script\n        static fromDER(hex) {\n            const { r, s } = DER.toSig(ensureBytes('DER', hex));\n            return new Signature(r, s);\n        }\n        /**\n         * @todo remove\n         * @deprecated\n         */\n        assertValidity() { }\n        addRecoveryBit(recovery) {\n            return new Signature(this.r, this.s, recovery);\n        }\n        recoverPublicKey(msgHash) {\n            const { r, s, recovery: rec } = this;\n            const h = bits2int_modN(ensureBytes('msgHash', msgHash)); // Truncate hash\n            if (rec == null || ![0, 1, 2, 3].includes(rec))\n                throw new Error('recovery id invalid');\n            const radj = rec === 2 || rec === 3 ? r + CURVE.n : r;\n            if (radj >= Fp.ORDER)\n                throw new Error('recovery id 2 or 3 invalid');\n            const prefix = (rec & 1) === 0 ? '02' : '03';\n            const R = Point.fromHex(prefix + numToSizedHex(radj, Fp.BYTES));\n            const ir = invN(radj); // r^-1\n            const u1 = modN(-h * ir); // -hr^-1\n            const u2 = modN(s * ir); // sr^-1\n            const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2); // (sr^-1)R-(hr^-1)G = -(hr^-1)G + (sr^-1)\n            if (!Q)\n                throw new Error('point at infinify'); // unsafe is fine: no priv data leaked\n            Q.assertValidity();\n            return Q;\n        }\n        // Signatures should be low-s, to prevent malleability.\n        hasHighS() {\n            return isBiggerThanHalfOrder(this.s);\n        }\n        normalizeS() {\n            return this.hasHighS() ? new Signature(this.r, modN(-this.s), this.recovery) : this;\n        }\n        // DER-encoded\n        toDERRawBytes() {\n            return hexToBytes(this.toDERHex());\n        }\n        toDERHex() {\n            return DER.hexFromSig(this);\n        }\n        // padded bytes of r, then padded bytes of s\n        toCompactRawBytes() {\n            return hexToBytes(this.toCompactHex());\n        }\n        toCompactHex() {\n            const l = nByteLength;\n            return numToSizedHex(this.r, l) + numToSizedHex(this.s, l);\n        }\n    }\n    const utils = {\n        isValidPrivateKey(privateKey) {\n            try {\n                normPrivateKeyToScalar(privateKey);\n                return true;\n            }\n            catch (error) {\n                return false;\n            }\n        },\n        normPrivateKeyToScalar: normPrivateKeyToScalar,\n        /**\n         * Produces cryptographically secure private key from random of size\n         * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.\n         */\n        randomPrivateKey: () => {\n            const length = getMinHashLength(CURVE.n);\n            return mapHashToField(CURVE.randomBytes(length), CURVE.n);\n        },\n        /**\n         * Creates precompute table for an arbitrary EC point. Makes point \"cached\".\n         * Allows to massively speed-up `point.multiply(scalar)`.\n         * @returns cached point\n         * @example\n         * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));\n         * fast.multiply(privKey); // much faster ECDH now\n         */\n        precompute(windowSize = 8, point = Point.BASE) {\n            point._setWindowSize(windowSize);\n            point.multiply(BigInt(3)); // 3 is arbitrary, just need any number here\n            return point;\n        },\n    };\n    /**\n     * Computes public key for a private key. Checks for validity of the private key.\n     * @param privateKey private key\n     * @param isCompressed whether to return compact (default), or full key\n     * @returns Public key, full when isCompressed=false; short when isCompressed=true\n     */\n    function getPublicKey(privateKey, isCompressed = true) {\n        return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);\n    }\n    /**\n     * Quick and dirty check for item being public key. Does not validate hex, or being on-curve.\n     */\n    function isProbPub(item) {\n        if (typeof item === 'bigint')\n            return false;\n        if (item instanceof Point)\n            return true;\n        const arr = ensureBytes('key', item);\n        const len = arr.length;\n        const fpl = Fp.BYTES;\n        const compLen = fpl + 1; // e.g. 33 for 32\n        const uncompLen = 2 * fpl + 1; // e.g. 65 for 32\n        if (CURVE.allowedPrivateKeyLengths || nByteLength === compLen) {\n            return undefined;\n        }\n        else {\n            return len === compLen || len === uncompLen;\n        }\n    }\n    /**\n     * ECDH (Elliptic Curve Diffie Hellman).\n     * Computes shared public key from private key and public key.\n     * Checks: 1) private key validity 2) shared key is on-curve.\n     * Does NOT hash the result.\n     * @param privateA private key\n     * @param publicB different public key\n     * @param isCompressed whether to return compact (default), or full key\n     * @returns shared public key\n     */\n    function getSharedSecret(privateA, publicB, isCompressed = true) {\n        if (isProbPub(privateA) === true)\n            throw new Error('first arg must be private key');\n        if (isProbPub(publicB) === false)\n            throw new Error('second arg must be public key');\n        const b = Point.fromHex(publicB); // check for being on-curve\n        return b.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);\n    }\n    // RFC6979: ensure ECDSA msg is X bytes and < N. RFC suggests optional truncating via bits2octets.\n    // FIPS 186-4 4.6 suggests the leftmost min(nBitLen, outLen) bits, which matches bits2int.\n    // bits2int can produce res>N, we can do mod(res, N) since the bitLen is the same.\n    // int2octets can't be used; pads small msgs with 0: unacceptatble for trunc as per RFC vectors\n    const bits2int = CURVE.bits2int ||\n        function (bytes) {\n            // Our custom check \"just in case\", for protection against DoS\n            if (bytes.length > 8192)\n                throw new Error('input is too large');\n            // For curves with nBitLength % 8 !== 0: bits2octets(bits2octets(m)) !== bits2octets(m)\n            // for some cases, since bytes.length * 8 is not actual bitLength.\n            const num = bytesToNumberBE(bytes); // check for == u8 done here\n            const delta = bytes.length * 8 - nBitLength; // truncate to nBitLength leftmost bits\n            return delta > 0 ? num >> BigInt(delta) : num;\n        };\n    const bits2int_modN = CURVE.bits2int_modN ||\n        function (bytes) {\n            return modN(bits2int(bytes)); // can't use bytesToNumberBE here\n        };\n    // NOTE: pads output with zero as per spec\n    const ORDER_MASK = bitMask(nBitLength);\n    /**\n     * Converts to bytes. Checks if num in `[0..ORDER_MASK-1]` e.g.: `[0..2^256-1]`.\n     */\n    function int2octets(num) {\n        aInRange('num < 2^' + nBitLength, num, _0n, ORDER_MASK);\n        // works with order, can have different size than numToField!\n        return numberToBytesBE(num, nByteLength);\n    }\n    // Steps A, D of RFC6979 3.2\n    // Creates RFC6979 seed; converts msg/privKey to numbers.\n    // Used only in sign, not in verify.\n    // NOTE: we cannot assume here that msgHash has same amount of bytes as curve order,\n    // this will be invalid at least for P521. Also it can be bigger for P224 + SHA256\n    function prepSig(msgHash, privateKey, opts = defaultSigOpts) {\n        if (['recovered', 'canonical'].some((k) => k in opts))\n            throw new Error('sign() legacy options not supported');\n        const { hash, randomBytes } = CURVE;\n        let { lowS, prehash, extraEntropy: ent } = opts; // generates low-s sigs by default\n        if (lowS == null)\n            lowS = true; // RFC6979 3.2: we skip step A, because we already provide hash\n        msgHash = ensureBytes('msgHash', msgHash);\n        validateSigVerOpts(opts);\n        if (prehash)\n            msgHash = ensureBytes('prehashed msgHash', hash(msgHash));\n        // We can't later call bits2octets, since nested bits2int is broken for curves\n        // with nBitLength % 8 !== 0. Because of that, we unwrap it here as int2octets call.\n        // const bits2octets = (bits) => int2octets(bits2int_modN(bits))\n        const h1int = bits2int_modN(msgHash);\n        const d = normPrivateKeyToScalar(privateKey); // validate private key, convert to bigint\n        const seedArgs = [int2octets(d), int2octets(h1int)];\n        // extraEntropy. RFC6979 3.6: additional k' (optional).\n        if (ent != null && ent !== false) {\n            // K = HMAC_K(V || 0x00 || int2octets(x) || bits2octets(h1) || k')\n            const e = ent === true ? randomBytes(Fp.BYTES) : ent; // generate random bytes OR pass as-is\n            seedArgs.push(ensureBytes('extraEntropy', e)); // check for being bytes\n        }\n        const seed = concatBytes(...seedArgs); // Step D of RFC6979 3.2\n        const m = h1int; // NOTE: no need to call bits2int second time here, it is inside truncateHash!\n        // Converts signature params into point w r/s, checks result for validity.\n        function k2sig(kBytes) {\n            // RFC 6979 Section 3.2, step 3: k = bits2int(T)\n            const k = bits2int(kBytes); // Cannot use fields methods, since it is group element\n            if (!isWithinCurveOrder(k))\n                return; // Important: all mod() calls here must be done over N\n            const ik = invN(k); // k^-1 mod n\n            const q = Point.BASE.multiply(k).toAffine(); // q = Gk\n            const r = modN(q.x); // r = q.x mod n\n            if (r === _0n)\n                return;\n            // Can use scalar blinding b^-1(bm + bdr) where b  [1,q1] according to\n            // https://tches.iacr.org/index.php/TCHES/article/view/7337/6509. We've decided against it:\n            // a) dependency on CSPRNG b) 15% slowdown c) doesn't really help since bigints are not CT\n            const s = modN(ik * modN(m + r * d)); // Not using blinding here\n            if (s === _0n)\n                return;\n            let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n); // recovery bit (2 or 3, when q.x > n)\n            let normS = s;\n            if (lowS && isBiggerThanHalfOrder(s)) {\n                normS = normalizeS(s); // if lowS was passed, ensure s is always\n                recovery ^= 1; // // in the bottom half of N\n            }\n            return new Signature(r, normS, recovery); // use normS, not s\n        }\n        return { seed, k2sig };\n    }\n    const defaultSigOpts = { lowS: CURVE.lowS, prehash: false };\n    const defaultVerOpts = { lowS: CURVE.lowS, prehash: false };\n    /**\n     * Signs message hash with a private key.\n     * ```\n     * sign(m, d, k) where\n     *   (x, y) = G  k\n     *   r = x mod n\n     *   s = (m + dr)/k mod n\n     * ```\n     * @param msgHash NOT message. msg needs to be hashed to `msgHash`, or use `prehash`.\n     * @param privKey private key\n     * @param opts lowS for non-malleable sigs. extraEntropy for mixing randomness into k. prehash will hash first arg.\n     * @returns signature with recovery param\n     */\n    function sign(msgHash, privKey, opts = defaultSigOpts) {\n        const { seed, k2sig } = prepSig(msgHash, privKey, opts); // Steps A, D of RFC6979 3.2.\n        const C = CURVE;\n        const drbg = createHmacDrbg(C.hash.outputLen, C.nByteLength, C.hmac);\n        return drbg(seed, k2sig); // Steps B, C, D, E, F, G\n    }\n    // Enable precomputes. Slows down first publicKey computation by 20ms.\n    Point.BASE._setWindowSize(8);\n    // utils.precompute(8, ProjectivePoint.BASE)\n    /**\n     * Verifies a signature against message hash and public key.\n     * Rejects lowS signatures by default: to override,\n     * specify option `{lowS: false}`. Implements section 4.1.4 from https://www.secg.org/sec1-v2.pdf:\n     *\n     * ```\n     * verify(r, s, h, P) where\n     *   U1 = hs^-1 mod n\n     *   U2 = rs^-1 mod n\n     *   R = U1G - U2P\n     *   mod(R.x, n) == r\n     * ```\n     */\n    function verify(signature, msgHash, publicKey, opts = defaultVerOpts) {\n        const sg = signature;\n        msgHash = ensureBytes('msgHash', msgHash);\n        publicKey = ensureBytes('publicKey', publicKey);\n        const { lowS, prehash, format } = opts;\n        // Verify opts, deduce signature format\n        validateSigVerOpts(opts);\n        if ('strict' in opts)\n            throw new Error('options.strict was renamed to lowS');\n        if (format !== undefined && format !== 'compact' && format !== 'der')\n            throw new Error('format must be compact or der');\n        const isHex = typeof sg === 'string' || isBytes(sg);\n        const isObj = !isHex &&\n            !format &&\n            typeof sg === 'object' &&\n            sg !== null &&\n            typeof sg.r === 'bigint' &&\n            typeof sg.s === 'bigint';\n        if (!isHex && !isObj)\n            throw new Error('invalid signature, expected Uint8Array, hex string or Signature instance');\n        let _sig = undefined;\n        let P;\n        try {\n            if (isObj)\n                _sig = new Signature(sg.r, sg.s);\n            if (isHex) {\n                // Signature can be represented in 2 ways: compact (2*nByteLength) & DER (variable-length).\n                // Since DER can also be 2*nByteLength bytes, we check for it first.\n                try {\n                    if (format !== 'compact')\n                        _sig = Signature.fromDER(sg);\n                }\n                catch (derError) {\n                    if (!(derError instanceof DER.Err))\n                        throw derError;\n                }\n                if (!_sig && format !== 'der')\n                    _sig = Signature.fromCompact(sg);\n            }\n            P = Point.fromHex(publicKey);\n        }\n        catch (error) {\n            return false;\n        }\n        if (!_sig)\n            return false;\n        if (lowS && _sig.hasHighS())\n            return false;\n        if (prehash)\n            msgHash = CURVE.hash(msgHash);\n        const { r, s } = _sig;\n        const h = bits2int_modN(msgHash); // Cannot use fields methods, since it is group element\n        const is = invN(s); // s^-1\n        const u1 = modN(h * is); // u1 = hs^-1 mod n\n        const u2 = modN(r * is); // u2 = rs^-1 mod n\n        const R = Point.BASE.multiplyAndAddUnsafe(P, u1, u2)?.toAffine(); // R = u1G + u2P\n        if (!R)\n            return false;\n        const v = modN(R.x);\n        return v === r;\n    }\n    return {\n        CURVE,\n        getPublicKey,\n        getSharedSecret,\n        sign,\n        verify,\n        ProjectivePoint: Point,\n        Signature,\n        utils,\n    };\n}\n/**\n * Implementation of the Shallue and van de Woestijne method for any weierstrass curve.\n * TODO: check if there is a way to merge this with uvRatio in Edwards; move to modular.\n * b = True and y = sqrt(u / v) if (u / v) is square in F, and\n * b = False and y = sqrt(Z * (u / v)) otherwise.\n * @param Fp\n * @param Z\n * @returns\n */\nexport function SWUFpSqrtRatio(Fp, Z) {\n    // Generic implementation\n    const q = Fp.ORDER;\n    let l = _0n;\n    for (let o = q - _1n; o % _2n === _0n; o /= _2n)\n        l += _1n;\n    const c1 = l; // 1. c1, the largest integer such that 2^c1 divides q - 1.\n    // We need 2n ** c1 and 2n ** (c1-1). We can't use **; but we can use <<.\n    // 2n ** c1 == 2n << (c1-1)\n    const _2n_pow_c1_1 = _2n << (c1 - _1n - _1n);\n    const _2n_pow_c1 = _2n_pow_c1_1 * _2n;\n    const c2 = (q - _1n) / _2n_pow_c1; // 2. c2 = (q - 1) / (2^c1)  # Integer arithmetic\n    const c3 = (c2 - _1n) / _2n; // 3. c3 = (c2 - 1) / 2            # Integer arithmetic\n    const c4 = _2n_pow_c1 - _1n; // 4. c4 = 2^c1 - 1                # Integer arithmetic\n    const c5 = _2n_pow_c1_1; // 5. c5 = 2^(c1 - 1)                  # Integer arithmetic\n    const c6 = Fp.pow(Z, c2); // 6. c6 = Z^c2\n    const c7 = Fp.pow(Z, (c2 + _1n) / _2n); // 7. c7 = Z^((c2 + 1) / 2)\n    let sqrtRatio = (u, v) => {\n        let tv1 = c6; // 1. tv1 = c6\n        let tv2 = Fp.pow(v, c4); // 2. tv2 = v^c4\n        let tv3 = Fp.sqr(tv2); // 3. tv3 = tv2^2\n        tv3 = Fp.mul(tv3, v); // 4. tv3 = tv3 * v\n        let tv5 = Fp.mul(u, tv3); // 5. tv5 = u * tv3\n        tv5 = Fp.pow(tv5, c3); // 6. tv5 = tv5^c3\n        tv5 = Fp.mul(tv5, tv2); // 7. tv5 = tv5 * tv2\n        tv2 = Fp.mul(tv5, v); // 8. tv2 = tv5 * v\n        tv3 = Fp.mul(tv5, u); // 9. tv3 = tv5 * u\n        let tv4 = Fp.mul(tv3, tv2); // 10. tv4 = tv3 * tv2\n        tv5 = Fp.pow(tv4, c5); // 11. tv5 = tv4^c5\n        let isQR = Fp.eql(tv5, Fp.ONE); // 12. isQR = tv5 == 1\n        tv2 = Fp.mul(tv3, c7); // 13. tv2 = tv3 * c7\n        tv5 = Fp.mul(tv4, tv1); // 14. tv5 = tv4 * tv1\n        tv3 = Fp.cmov(tv2, tv3, isQR); // 15. tv3 = CMOV(tv2, tv3, isQR)\n        tv4 = Fp.cmov(tv5, tv4, isQR); // 16. tv4 = CMOV(tv5, tv4, isQR)\n        // 17. for i in (c1, c1 - 1, ..., 2):\n        for (let i = c1; i > _1n; i--) {\n            let tv5 = i - _2n; // 18.    tv5 = i - 2\n            tv5 = _2n << (tv5 - _1n); // 19.    tv5 = 2^tv5\n            let tvv5 = Fp.pow(tv4, tv5); // 20.    tv5 = tv4^tv5\n            const e1 = Fp.eql(tvv5, Fp.ONE); // 21.    e1 = tv5 == 1\n            tv2 = Fp.mul(tv3, tv1); // 22.    tv2 = tv3 * tv1\n            tv1 = Fp.mul(tv1, tv1); // 23.    tv1 = tv1 * tv1\n            tvv5 = Fp.mul(tv4, tv1); // 24.    tv5 = tv4 * tv1\n            tv3 = Fp.cmov(tv2, tv3, e1); // 25.    tv3 = CMOV(tv2, tv3, e1)\n            tv4 = Fp.cmov(tvv5, tv4, e1); // 26.    tv4 = CMOV(tv5, tv4, e1)\n        }\n        return { isValid: isQR, value: tv3 };\n    };\n    if (Fp.ORDER % _4n === _3n) {\n        // sqrt_ratio_3mod4(u, v)\n        const c1 = (Fp.ORDER - _3n) / _4n; // 1. c1 = (q - 3) / 4     # Integer arithmetic\n        const c2 = Fp.sqrt(Fp.neg(Z)); // 2. c2 = sqrt(-Z)\n        sqrtRatio = (u, v) => {\n            let tv1 = Fp.sqr(v); // 1. tv1 = v^2\n            const tv2 = Fp.mul(u, v); // 2. tv2 = u * v\n            tv1 = Fp.mul(tv1, tv2); // 3. tv1 = tv1 * tv2\n            let y1 = Fp.pow(tv1, c1); // 4. y1 = tv1^c1\n            y1 = Fp.mul(y1, tv2); // 5. y1 = y1 * tv2\n            const y2 = Fp.mul(y1, c2); // 6. y2 = y1 * c2\n            const tv3 = Fp.mul(Fp.sqr(y1), v); // 7. tv3 = y1^2; 8. tv3 = tv3 * v\n            const isQR = Fp.eql(tv3, u); // 9. isQR = tv3 == u\n            let y = Fp.cmov(y2, y1, isQR); // 10. y = CMOV(y2, y1, isQR)\n            return { isValid: isQR, value: y }; // 11. return (isQR, y) isQR ? y : y*c2\n        };\n    }\n    // No curves uses that\n    // if (Fp.ORDER % _8n === _5n) // sqrt_ratio_5mod8\n    return sqrtRatio;\n}\n/**\n * Simplified Shallue-van de Woestijne-Ulas Method\n * https://www.rfc-editor.org/rfc/rfc9380#section-6.6.2\n */\nexport function mapToCurveSimpleSWU(Fp, opts) {\n    validateField(Fp);\n    if (!Fp.isValid(opts.A) || !Fp.isValid(opts.B) || !Fp.isValid(opts.Z))\n        throw new Error('mapToCurveSimpleSWU: invalid opts');\n    const sqrtRatio = SWUFpSqrtRatio(Fp, opts.Z);\n    if (!Fp.isOdd)\n        throw new Error('Fp.isOdd is not implemented!');\n    // Input: u, an element of F.\n    // Output: (x, y), a point on E.\n    return (u) => {\n        // prettier-ignore\n        let tv1, tv2, tv3, tv4, tv5, tv6, x, y;\n        tv1 = Fp.sqr(u); // 1.  tv1 = u^2\n        tv1 = Fp.mul(tv1, opts.Z); // 2.  tv1 = Z * tv1\n        tv2 = Fp.sqr(tv1); // 3.  tv2 = tv1^2\n        tv2 = Fp.add(tv2, tv1); // 4.  tv2 = tv2 + tv1\n        tv3 = Fp.add(tv2, Fp.ONE); // 5.  tv3 = tv2 + 1\n        tv3 = Fp.mul(tv3, opts.B); // 6.  tv3 = B * tv3\n        tv4 = Fp.cmov(opts.Z, Fp.neg(tv2), !Fp.eql(tv2, Fp.ZERO)); // 7.  tv4 = CMOV(Z, -tv2, tv2 != 0)\n        tv4 = Fp.mul(tv4, opts.A); // 8.  tv4 = A * tv4\n        tv2 = Fp.sqr(tv3); // 9.  tv2 = tv3^2\n        tv6 = Fp.sqr(tv4); // 10. tv6 = tv4^2\n        tv5 = Fp.mul(tv6, opts.A); // 11. tv5 = A * tv6\n        tv2 = Fp.add(tv2, tv5); // 12. tv2 = tv2 + tv5\n        tv2 = Fp.mul(tv2, tv3); // 13. tv2 = tv2 * tv3\n        tv6 = Fp.mul(tv6, tv4); // 14. tv6 = tv6 * tv4\n        tv5 = Fp.mul(tv6, opts.B); // 15. tv5 = B * tv6\n        tv2 = Fp.add(tv2, tv5); // 16. tv2 = tv2 + tv5\n        x = Fp.mul(tv1, tv3); // 17.   x = tv1 * tv3\n        const { isValid, value } = sqrtRatio(tv2, tv6); // 18. (is_gx1_square, y1) = sqrt_ratio(tv2, tv6)\n        y = Fp.mul(tv1, u); // 19.   y = tv1 * u  -> Z * u^3 * y1\n        y = Fp.mul(y, value); // 20.   y = y * y1\n        x = Fp.cmov(x, tv3, isValid); // 21.   x = CMOV(x, tv3, is_gx1_square)\n        y = Fp.cmov(y, value, isValid); // 22.   y = CMOV(y, y1, is_gx1_square)\n        const e1 = Fp.isOdd(u) === Fp.isOdd(y); // 23.  e1 = sgn0(u) == sgn0(y)\n        y = Fp.cmov(Fp.neg(y), y, e1); // 24.   y = CMOV(-y, y, e1)\n        const tv4_inv = FpInvertBatch(Fp, [tv4], true)[0];\n        x = Fp.mul(x, tv4_inv); // 25.   x = x / tv4\n        return { x, y };\n    };\n}\n//# sourceMappingURL=weierstrass.js.map","/**\n * Utilities for short weierstrass curves, combined with noble-hashes.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { hmac } from '@noble/hashes/hmac';\nimport { concatBytes, randomBytes } from '@noble/hashes/utils';\nimport { weierstrass } from \"./abstract/weierstrass.js\";\n/** connects noble-curves to noble-hashes */\nexport function getHash(hash) {\n    return {\n        hash,\n        hmac: (key, ...msgs) => hmac(hash, key, concatBytes(...msgs)),\n        randomBytes,\n    };\n}\nexport function createCurve(curveDef, defHash) {\n    const create = (hash) => weierstrass({ ...curveDef, ...getHash(hash) });\n    return { ...create(defHash), create };\n}\n//# sourceMappingURL=_shortw_utils.js.map","/**\n * NIST secp256k1. See [pdf](https://www.secg.org/sec2-v2.pdf).\n *\n * Seems to be rigid (not backdoored)\n * [as per discussion](https://bitcointalk.org/index.php?topic=289795.msg3183975#msg3183975).\n *\n * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.\n * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.\n * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.\n * [See explanation](https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066).\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { sha256 } from '@noble/hashes/sha2';\nimport { randomBytes } from '@noble/hashes/utils';\nimport { createCurve } from \"./_shortw_utils.js\";\nimport { createHasher, isogenyMap } from \"./abstract/hash-to-curve.js\";\nimport { Field, mod, pow2 } from \"./abstract/modular.js\";\nimport { aInRange, bytesToNumberBE, concatBytes, ensureBytes, inRange, numberToBytesBE, } from \"./abstract/utils.js\";\nimport { mapToCurveSimpleSWU } from \"./abstract/weierstrass.js\";\nconst secp256k1P = BigInt('0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f');\nconst secp256k1N = BigInt('0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141');\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nconst divNearest = (a, b) => (a + b / _2n) / b;\n/**\n * n = n^((p+1)/4) for fields p = 3 mod 4. We unwrap the loop and multiply bit-by-bit.\n * (P+1n/4n).toString(2) would produce bits [223x 1, 0, 22x 1, 4x 0, 11, 00]\n */\nfunction sqrtMod(y) {\n    const P = secp256k1P;\n    // prettier-ignore\n    const _3n = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);\n    // prettier-ignore\n    const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);\n    const b2 = (y * y * y) % P; // x^3, 11\n    const b3 = (b2 * b2 * y) % P; // x^7\n    const b6 = (pow2(b3, _3n, P) * b3) % P;\n    const b9 = (pow2(b6, _3n, P) * b3) % P;\n    const b11 = (pow2(b9, _2n, P) * b2) % P;\n    const b22 = (pow2(b11, _11n, P) * b11) % P;\n    const b44 = (pow2(b22, _22n, P) * b22) % P;\n    const b88 = (pow2(b44, _44n, P) * b44) % P;\n    const b176 = (pow2(b88, _88n, P) * b88) % P;\n    const b220 = (pow2(b176, _44n, P) * b44) % P;\n    const b223 = (pow2(b220, _3n, P) * b3) % P;\n    const t1 = (pow2(b223, _23n, P) * b22) % P;\n    const t2 = (pow2(t1, _6n, P) * b2) % P;\n    const root = pow2(t2, _2n, P);\n    if (!Fpk1.eql(Fpk1.sqr(root), y))\n        throw new Error('Cannot find square root');\n    return root;\n}\nconst Fpk1 = Field(secp256k1P, undefined, undefined, { sqrt: sqrtMod });\n/**\n * secp256k1 curve, ECDSA and ECDH methods.\n *\n * Field: `2n**256n - 2n**32n - 2n**9n - 2n**8n - 2n**7n - 2n**6n - 2n**4n - 1n`\n *\n * @example\n * ```js\n * import { secp256k1 } from '@noble/curves/secp256k1';\n * const priv = secp256k1.utils.randomPrivateKey();\n * const pub = secp256k1.getPublicKey(priv);\n * const msg = new Uint8Array(32).fill(1); // message hash (not message) in ecdsa\n * const sig = secp256k1.sign(msg, priv); // `{prehash: true}` option is available\n * const isValid = secp256k1.verify(sig, msg, pub) === true;\n * ```\n */\nexport const secp256k1 = createCurve({\n    a: _0n,\n    b: BigInt(7),\n    Fp: Fpk1,\n    n: secp256k1N,\n    Gx: BigInt('55066263022277343669578718895168534326250603453777594175500187360389116729240'),\n    Gy: BigInt('32670510020758816978083085130507043184471273380659243275938904335757337482424'),\n    h: BigInt(1),\n    lowS: true, // Allow only low-S signatures by default in sign() and verify()\n    endo: {\n        // Endomorphism, see above\n        beta: BigInt('0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee'),\n        splitScalar: (k) => {\n            const n = secp256k1N;\n            const a1 = BigInt('0x3086d221a7d46bcde86c90e49284eb15');\n            const b1 = -_1n * BigInt('0xe4437ed6010e88286f547fa90abfe4c3');\n            const a2 = BigInt('0x114ca50f7a8e2f3f657c1108d9d44cfd8');\n            const b2 = a1;\n            const POW_2_128 = BigInt('0x100000000000000000000000000000000'); // (2n**128n).toString(16)\n            const c1 = divNearest(b2 * k, n);\n            const c2 = divNearest(-b1 * k, n);\n            let k1 = mod(k - c1 * a1 - c2 * a2, n);\n            let k2 = mod(-c1 * b1 - c2 * b2, n);\n            const k1neg = k1 > POW_2_128;\n            const k2neg = k2 > POW_2_128;\n            if (k1neg)\n                k1 = n - k1;\n            if (k2neg)\n                k2 = n - k2;\n            if (k1 > POW_2_128 || k2 > POW_2_128) {\n                throw new Error('splitScalar: Endomorphism failed, k=' + k);\n            }\n            return { k1neg, k1, k2neg, k2 };\n        },\n    },\n}, sha256);\n// Schnorr signatures are superior to ECDSA from above. Below is Schnorr-specific BIP0340 code.\n// https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki\n/** An object mapping tags to their tagged hash prefix of [SHA256(tag) | SHA256(tag)] */\nconst TAGGED_HASH_PREFIXES = {};\nfunction taggedHash(tag, ...messages) {\n    let tagP = TAGGED_HASH_PREFIXES[tag];\n    if (tagP === undefined) {\n        const tagH = sha256(Uint8Array.from(tag, (c) => c.charCodeAt(0)));\n        tagP = concatBytes(tagH, tagH);\n        TAGGED_HASH_PREFIXES[tag] = tagP;\n    }\n    return sha256(concatBytes(tagP, ...messages));\n}\n// ECDSA compact points are 33-byte. Schnorr is 32: we strip first byte 0x02 or 0x03\nconst pointToBytes = (point) => point.toRawBytes(true).slice(1);\nconst numTo32b = (n) => numberToBytesBE(n, 32);\nconst modP = (x) => mod(x, secp256k1P);\nconst modN = (x) => mod(x, secp256k1N);\nconst Point = /* @__PURE__ */ (() => secp256k1.ProjectivePoint)();\nconst GmulAdd = (Q, a, b) => Point.BASE.multiplyAndAddUnsafe(Q, a, b);\n// Calculate point, scalar and bytes\nfunction schnorrGetExtPubKey(priv) {\n    let d_ = secp256k1.utils.normPrivateKeyToScalar(priv); // same method executed in fromPrivateKey\n    let p = Point.fromPrivateKey(d_); // P = d'G; 0 < d' < n check is done inside\n    const scalar = p.hasEvenY() ? d_ : modN(-d_);\n    return { scalar: scalar, bytes: pointToBytes(p) };\n}\n/**\n * lift_x from BIP340. Convert 32-byte x coordinate to elliptic curve point.\n * @returns valid point checked for being on-curve\n */\nfunction lift_x(x) {\n    aInRange('x', x, _1n, secp256k1P); // Fail if x  p.\n    const xx = modP(x * x);\n    const c = modP(xx * x + BigInt(7)); // Let c = x + 7 mod p.\n    let y = sqrtMod(c); // Let y = c^(p+1)/4 mod p.\n    if (y % _2n !== _0n)\n        y = modP(-y); // Return the unique point P such that x(P) = x and\n    const p = new Point(x, y, _1n); // y(P) = y if y mod 2 = 0 or y(P) = p-y otherwise.\n    p.assertValidity();\n    return p;\n}\nconst num = bytesToNumberBE;\n/**\n * Create tagged hash, convert it to bigint, reduce modulo-n.\n */\nfunction challenge(...args) {\n    return modN(num(taggedHash('BIP0340/challenge', ...args)));\n}\n/**\n * Schnorr public key is just `x` coordinate of Point as per BIP340.\n */\nfunction schnorrGetPublicKey(privateKey) {\n    return schnorrGetExtPubKey(privateKey).bytes; // d'=int(sk). Fail if d'=0 or d'n. Ret bytes(d'G)\n}\n/**\n * Creates Schnorr signature as per BIP340. Verifies itself before returning anything.\n * auxRand is optional and is not the sole source of k generation: bad CSPRNG won't be dangerous.\n */\nfunction schnorrSign(message, privateKey, auxRand = randomBytes(32)) {\n    const m = ensureBytes('message', message);\n    const { bytes: px, scalar: d } = schnorrGetExtPubKey(privateKey); // checks for isWithinCurveOrder\n    const a = ensureBytes('auxRand', auxRand, 32); // Auxiliary random data a: a 32-byte array\n    const t = numTo32b(d ^ num(taggedHash('BIP0340/aux', a))); // Let t be the byte-wise xor of bytes(d) and hash/aux(a)\n    const rand = taggedHash('BIP0340/nonce', t, px, m); // Let rand = hash/nonce(t || bytes(P) || m)\n    const k_ = modN(num(rand)); // Let k' = int(rand) mod n\n    if (k_ === _0n)\n        throw new Error('sign failed: k is zero'); // Fail if k' = 0.\n    const { bytes: rx, scalar: k } = schnorrGetExtPubKey(k_); // Let R = k'G.\n    const e = challenge(rx, px, m); // Let e = int(hash/challenge(bytes(R) || bytes(P) || m)) mod n.\n    const sig = new Uint8Array(64); // Let sig = bytes(R) || bytes((k + ed) mod n).\n    sig.set(rx, 0);\n    sig.set(numTo32b(modN(k + e * d)), 32);\n    // If Verify(bytes(P), m, sig) (see below) returns failure, abort\n    if (!schnorrVerify(sig, m, px))\n        throw new Error('sign: Invalid signature produced');\n    return sig;\n}\n/**\n * Verifies Schnorr signature.\n * Will swallow errors & return false except for initial type validation of arguments.\n */\nfunction schnorrVerify(signature, message, publicKey) {\n    const sig = ensureBytes('signature', signature, 64);\n    const m = ensureBytes('message', message);\n    const pub = ensureBytes('publicKey', publicKey, 32);\n    try {\n        const P = lift_x(num(pub)); // P = lift_x(int(pk)); fail if that fails\n        const r = num(sig.subarray(0, 32)); // Let r = int(sig[0:32]); fail if r  p.\n        if (!inRange(r, _1n, secp256k1P))\n            return false;\n        const s = num(sig.subarray(32, 64)); // Let s = int(sig[32:64]); fail if s  n.\n        if (!inRange(s, _1n, secp256k1N))\n            return false;\n        const e = challenge(numTo32b(r), pointToBytes(P), m); // int(challenge(bytes(r)||bytes(P)||m))%n\n        const R = GmulAdd(P, s, modN(-e)); // R = sG - eP\n        if (!R || !R.hasEvenY() || R.toAffine().x !== r)\n            return false; // -eP == (n-e)P\n        return true; // Fail if is_infinite(R) / not has_even_y(R) / x(R)  r.\n    }\n    catch (error) {\n        return false;\n    }\n}\n/**\n * Schnorr signatures over secp256k1.\n * https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki\n * @example\n * ```js\n * import { schnorr } from '@noble/curves/secp256k1';\n * const priv = schnorr.utils.randomPrivateKey();\n * const pub = schnorr.getPublicKey(priv);\n * const msg = new TextEncoder().encode('hello');\n * const sig = schnorr.sign(msg, priv);\n * const isValid = schnorr.verify(sig, msg, pub);\n * ```\n */\nexport const schnorr = /* @__PURE__ */ (() => ({\n    getPublicKey: schnorrGetPublicKey,\n    sign: schnorrSign,\n    verify: schnorrVerify,\n    utils: {\n        randomPrivateKey: secp256k1.utils.randomPrivateKey,\n        lift_x,\n        pointToBytes,\n        numberToBytesBE,\n        bytesToNumberBE,\n        taggedHash,\n        mod,\n    },\n}))();\nconst isoMap = /* @__PURE__ */ (() => isogenyMap(Fpk1, [\n    // xNum\n    [\n        '0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7',\n        '0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581',\n        '0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262',\n        '0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c',\n    ],\n    // xDen\n    [\n        '0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b',\n        '0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14',\n        '0x0000000000000000000000000000000000000000000000000000000000000001', // LAST 1\n    ],\n    // yNum\n    [\n        '0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c',\n        '0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3',\n        '0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931',\n        '0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84',\n    ],\n    // yDen\n    [\n        '0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b',\n        '0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573',\n        '0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f',\n        '0x0000000000000000000000000000000000000000000000000000000000000001', // LAST 1\n    ],\n].map((i) => i.map((j) => BigInt(j)))))();\nconst mapSWU = /* @__PURE__ */ (() => mapToCurveSimpleSWU(Fpk1, {\n    A: BigInt('0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533'),\n    B: BigInt('1771'),\n    Z: Fpk1.create(BigInt('-11')),\n}))();\n/** Hashing / encoding to secp256k1 points / field. RFC 9380 methods. */\nexport const secp256k1_hasher = /* @__PURE__ */ (() => createHasher(secp256k1.ProjectivePoint, (scalars) => {\n    const { x, y } = mapSWU(Fpk1.create(scalars[0]));\n    return isoMap(x, y);\n}, {\n    DST: 'secp256k1_XMD:SHA-256_SSWU_RO_',\n    encodeDST: 'secp256k1_XMD:SHA-256_SSWU_NU_',\n    p: Fpk1.ORDER,\n    m: 1,\n    k: 128,\n    expand: 'xmd',\n    hash: sha256,\n}))();\nexport const hashToCurve = /* @__PURE__ */ (() => secp256k1_hasher.hashToCurve)();\nexport const encodeToCurve = /* @__PURE__ */ (() => secp256k1_hasher.encodeToCurve)();\n//# sourceMappingURL=secp256k1.js.map","import { secp256k1 } from '@noble/curves/secp256k1';\nimport * as Bytes from './Bytes.js';\nimport * as Errors from './Errors.js';\nimport * as Hex from './Hex.js';\nimport * as Json from './Json.js';\nimport * as Solidity from './Solidity.js';\n/**\n * Asserts that a Signature is valid.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * Signature.assert({\n *   r: -49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n *   yParity: 1,\n * })\n * // @error: InvalidSignatureRError:\n * // @error: Value `-549...n` is an invalid r value.\n * // @error: r must be a positive integer less than 2^256.\n * ```\n *\n * @param signature - The signature object to assert.\n */\nexport function assert(signature, options = {}) {\n    const { recovered } = options;\n    if (typeof signature.r === 'undefined')\n        throw new MissingPropertiesError({ signature });\n    if (typeof signature.s === 'undefined')\n        throw new MissingPropertiesError({ signature });\n    if (recovered && typeof signature.yParity === 'undefined')\n        throw new MissingPropertiesError({ signature });\n    if (signature.r < 0n || signature.r > Solidity.maxUint256)\n        throw new InvalidRError({ value: signature.r });\n    if (signature.s < 0n || signature.s > Solidity.maxUint256)\n        throw new InvalidSError({ value: signature.s });\n    if (typeof signature.yParity === 'number' &&\n        signature.yParity !== 0 &&\n        signature.yParity !== 1)\n        throw new InvalidYParityError({ value: signature.yParity });\n}\n/**\n * Deserializes a {@link ox#Bytes.Bytes} signature into a structured {@link ox#Signature.Signature}.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Signature } from 'ox'\n *\n * Signature.fromBytes(new Uint8Array([128, 3, 131, ...]))\n * // @log: { r: 5231...n, s: 3522...n, yParity: 0 }\n * ```\n *\n * @param signature - The serialized signature.\n * @returns The deserialized {@link ox#Signature.Signature}.\n */\nexport function fromBytes(signature) {\n    return fromHex(Hex.fromBytes(signature));\n}\n/**\n * Deserializes a {@link ox#Hex.Hex} signature into a structured {@link ox#Signature.Signature}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * Signature.fromHex('0x6e100a352ec6ad1b70802290e18aeed190704973570f3b8ed42cb9808e2ea6bf4a90a229a244495b41890987806fcbd2d5d23fc0dbe5f5256c2613c039d76db81c')\n * // @log: { r: 5231...n, s: 3522...n, yParity: 0 }\n * ```\n *\n * @param serialized - The serialized signature.\n * @returns The deserialized {@link ox#Signature.Signature}.\n */\nexport function fromHex(signature) {\n    if (signature.length !== 130 && signature.length !== 132)\n        throw new InvalidSerializedSizeError({ signature });\n    const r = BigInt(Hex.slice(signature, 0, 32));\n    const s = BigInt(Hex.slice(signature, 32, 64));\n    const yParity = (() => {\n        const yParity = Number(`0x${signature.slice(130)}`);\n        if (Number.isNaN(yParity))\n            return undefined;\n        try {\n            return vToYParity(yParity);\n        }\n        catch {\n            throw new InvalidYParityError({ value: yParity });\n        }\n    })();\n    if (typeof yParity === 'undefined')\n        return {\n            r,\n            s,\n        };\n    return {\n        r,\n        s,\n        yParity,\n    };\n}\n/**\n * Extracts a {@link ox#Signature.Signature} from an arbitrary object that may include signature properties.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Signature } from 'ox'\n *\n * Signature.extract({\n *   baz: 'barry',\n *   foo: 'bar',\n *   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n *   yParity: 1,\n *   zebra: 'stripes',\n * })\n * // @log: {\n * // @log:   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n * // @log:   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n * // @log:   yParity: 1\n * // @log: }\n * ```\n *\n * @param value - The arbitrary object to extract the signature from.\n * @returns The extracted {@link ox#Signature.Signature}.\n */\nexport function extract(value) {\n    if (typeof value.r === 'undefined')\n        return undefined;\n    if (typeof value.s === 'undefined')\n        return undefined;\n    return from(value);\n}\n/**\n * Instantiates a typed {@link ox#Signature.Signature} object from a {@link ox#Signature.Signature}, {@link ox#Signature.Legacy}, {@link ox#Bytes.Bytes}, or {@link ox#Hex.Hex}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * Signature.from({\n *   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n *   yParity: 1,\n * })\n * // @log: {\n * // @log:   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n * // @log:   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n * // @log:   yParity: 1\n * // @log: }\n * ```\n *\n * @example\n * ### From Serialized\n *\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * Signature.from('0x6e100a352ec6ad1b70802290e18aeed190704973570f3b8ed42cb9808e2ea6bf4a90a229a244495b41890987806fcbd2d5d23fc0dbe5f5256c2613c039d76db801')\n * // @log: {\n * // @log:   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n * // @log:   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n * // @log:   yParity: 1,\n * // @log: }\n * ```\n *\n * @example\n * ### From Legacy\n *\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * Signature.from({\n *   r: 47323457007453657207889730243826965761922296599680473886588287015755652701072n,\n *   s: 57228803202727131502949358313456071280488184270258293674242124340113824882788n,\n *   v: 27,\n * })\n * // @log: {\n * // @log:   r: 47323457007453657207889730243826965761922296599680473886588287015755652701072n,\n * // @log:   s: 57228803202727131502949358313456071280488184270258293674242124340113824882788n,\n * // @log:   yParity: 0\n * // @log: }\n * ```\n *\n * @param signature - The signature value to instantiate.\n * @returns The instantiated {@link ox#Signature.Signature}.\n */\nexport function from(signature) {\n    const signature_ = (() => {\n        if (typeof signature === 'string')\n            return fromHex(signature);\n        if (signature instanceof Uint8Array)\n            return fromBytes(signature);\n        if (typeof signature.r === 'string')\n            return fromRpc(signature);\n        if (signature.v)\n            return fromLegacy(signature);\n        return {\n            r: signature.r,\n            s: signature.s,\n            ...(typeof signature.yParity !== 'undefined'\n                ? { yParity: signature.yParity }\n                : {}),\n        };\n    })();\n    assert(signature_);\n    return signature_;\n}\n/**\n * Converts a DER-encoded signature to a {@link ox#Signature.Signature}.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Signature } from 'ox'\n *\n * const signature = Signature.fromDerBytes(new Uint8Array([132, 51, 23, ...]))\n * // @log: {\n * // @log:   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n * // @log:   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n * // @log: }\n * ```\n *\n * @param signature - The DER-encoded signature to convert.\n * @returns The {@link ox#Signature.Signature}.\n */\nexport function fromDerBytes(signature) {\n    return fromDerHex(Hex.fromBytes(signature));\n}\n/**\n * Converts a DER-encoded signature to a {@link ox#Signature.Signature}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.fromDerHex('0x304402206e100a352ec6ad1b70802290e18aeed190704973570f3b8ed42cb9808e2ea6bf02204a90a229a244495b41890987806fcbd2d5d23fc0dbe5f5256c2613c039d76db8')\n * // @log: {\n * // @log:   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n * // @log:   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n * // @log: }\n * ```\n *\n * @param signature - The DER-encoded signature to convert.\n * @returns The {@link ox#Signature.Signature}.\n */\nexport function fromDerHex(signature) {\n    const { r, s } = secp256k1.Signature.fromDER(Hex.from(signature).slice(2));\n    return { r, s };\n}\n/**\n * Converts a {@link ox#Signature.Legacy} into a {@link ox#Signature.Signature}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const legacy = Signature.fromLegacy({ r: 1n, s: 2n, v: 28 })\n * // @log: { r: 1n, s: 2n, yParity: 1 }\n * ```\n *\n * @param signature - The {@link ox#Signature.Legacy} to convert.\n * @returns The converted {@link ox#Signature.Signature}.\n */\nexport function fromLegacy(signature) {\n    return {\n        r: signature.r,\n        s: signature.s,\n        yParity: vToYParity(signature.v),\n    };\n}\n/**\n * Converts a {@link ox#Signature.Rpc} into a {@link ox#Signature.Signature}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.fromRpc({\n *   r: '0x635dc2033e60185bb36709c29c75d64ea51dfbd91c32ef4be198e4ceb169fb4d',\n *   s: '0x50c2667ac4c771072746acfdcf1f1483336dcca8bd2df47cd83175dbe60f0540',\n *   yParity: '0x0',\n * })\n * ```\n *\n * @param signature - The {@link ox#Signature.Rpc} to convert.\n * @returns The converted {@link ox#Signature.Signature}.\n */\nexport function fromRpc(signature) {\n    const yParity = (() => {\n        const v = signature.v ? Number(signature.v) : undefined;\n        let yParity = signature.yParity ? Number(signature.yParity) : undefined;\n        if (typeof v === 'number' && typeof yParity !== 'number')\n            yParity = vToYParity(v);\n        if (typeof yParity !== 'number')\n            throw new InvalidYParityError({ value: signature.yParity });\n        return yParity;\n    })();\n    return {\n        r: BigInt(signature.r),\n        s: BigInt(signature.s),\n        yParity,\n    };\n}\n/**\n * Converts a {@link ox#Signature.Tuple} to a {@link ox#Signature.Signature}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.fromTuple(['0x01', '0x7b', '0x1c8'])\n * // @log: {\n * // @log:   r: 123n,\n * // @log:   s: 456n,\n * // @log:   yParity: 1,\n * // @log: }\n * ```\n *\n * @param tuple - The {@link ox#Signature.Tuple} to convert.\n * @returns The {@link ox#Signature.Signature}.\n */\nexport function fromTuple(tuple) {\n    const [yParity, r, s] = tuple;\n    return from({\n        r: r === '0x' ? 0n : BigInt(r),\n        s: s === '0x' ? 0n : BigInt(s),\n        yParity: yParity === '0x' ? 0 : Number(yParity),\n    });\n}\n/**\n * Serializes a {@link ox#Signature.Signature} to {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.toBytes({\n *   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n *   yParity: 1\n * })\n * // @log: Uint8Array [102, 16, 10, ...]\n * ```\n *\n * @param signature - The signature to serialize.\n * @returns The serialized signature.\n */\nexport function toBytes(signature) {\n    return Bytes.fromHex(toHex(signature));\n}\n/**\n * Serializes a {@link ox#Signature.Signature} to {@link ox#Hex.Hex}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.toHex({\n *   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n *   yParity: 1\n * })\n * // @log: '0x6e100a352ec6ad1b70802290e18aeed190704973570f3b8ed42cb9808e2ea6bf4a90a229a244495b41890987806fcbd2d5d23fc0dbe5f5256c2613c039d76db81c'\n * ```\n *\n * @param signature - The signature to serialize.\n * @returns The serialized signature.\n */\nexport function toHex(signature) {\n    assert(signature);\n    const r = signature.r;\n    const s = signature.s;\n    const signature_ = Hex.concat(Hex.fromNumber(r, { size: 32 }), Hex.fromNumber(s, { size: 32 }), \n    // If the signature is recovered, add the recovery byte to the signature.\n    typeof signature.yParity === 'number'\n        ? Hex.fromNumber(yParityToV(signature.yParity), { size: 1 })\n        : '0x');\n    return signature_;\n}\n/**\n * Converts a {@link ox#Signature.Signature} to DER-encoded format.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.from({\n *   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n * })\n *\n * const signature_der = Signature.toDerBytes(signature)\n * // @log: Uint8Array [132, 51, 23, ...]\n * ```\n *\n * @param signature - The signature to convert.\n * @returns The DER-encoded signature.\n */\nexport function toDerBytes(signature) {\n    const sig = new secp256k1.Signature(signature.r, signature.s);\n    return sig.toDERRawBytes();\n}\n/**\n * Converts a {@link ox#Signature.Signature} to DER-encoded format.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.from({\n *   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n * })\n *\n * const signature_der = Signature.toDerHex(signature)\n * // @log: '0x304402206e100a352ec6ad1b70802290e18aeed190704973570f3b8ed42cb9808e2ea6bf02204a90a229a244495b41890987806fcbd2d5d23fc0dbe5f5256c2613c039d76db8'\n * ```\n *\n * @param signature - The signature to convert.\n * @returns The DER-encoded signature.\n */\nexport function toDerHex(signature) {\n    const sig = new secp256k1.Signature(signature.r, signature.s);\n    return `0x${sig.toDERHex()}`;\n}\n/**\n * Converts a {@link ox#Signature.Signature} into a {@link ox#Signature.Legacy}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const legacy = Signature.toLegacy({ r: 1n, s: 2n, yParity: 1 })\n * // @log: { r: 1n, s: 2n, v: 28 }\n * ```\n *\n * @param signature - The {@link ox#Signature.Signature} to convert.\n * @returns The converted {@link ox#Signature.Legacy}.\n */\nexport function toLegacy(signature) {\n    return {\n        r: signature.r,\n        s: signature.s,\n        v: yParityToV(signature.yParity),\n    };\n}\n/**\n * Converts a {@link ox#Signature.Signature} into a {@link ox#Signature.Rpc}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.toRpc({\n *   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n *   yParity: 1\n * })\n * ```\n *\n * @param signature - The {@link ox#Signature.Signature} to convert.\n * @returns The converted {@link ox#Signature.Rpc}.\n */\nexport function toRpc(signature) {\n    const { r, s, yParity } = signature;\n    return {\n        r: Hex.fromNumber(r, { size: 32 }),\n        s: Hex.fromNumber(s, { size: 32 }),\n        yParity: yParity === 0 ? '0x0' : '0x1',\n    };\n}\n/**\n * Converts a {@link ox#Signature.Signature} to a serialized {@link ox#Signature.Tuple} to be used for signatures in Transaction Envelopes, EIP-7702 Authorization Lists, etc.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signatureTuple = Signature.toTuple({\n *   r: 123n,\n *   s: 456n,\n *   yParity: 1,\n * })\n * // @log: [yParity: '0x01', r: '0x7b', s: '0x1c8']\n * ```\n *\n * @param signature - The {@link ox#Signature.Signature} to convert.\n * @returns The {@link ox#Signature.Tuple}.\n */\nexport function toTuple(signature) {\n    const { r, s, yParity } = signature;\n    return [\n        yParity ? '0x01' : '0x',\n        r === 0n ? '0x' : Hex.trimLeft(Hex.fromNumber(r)),\n        s === 0n ? '0x' : Hex.trimLeft(Hex.fromNumber(s)),\n    ];\n}\n/**\n * Validates a Signature. Returns `true` if the signature is valid, `false` otherwise.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const valid = Signature.validate({\n *   r: -49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n *   yParity: 1,\n * })\n * // @log: false\n * ```\n *\n * @param signature - The signature object to assert.\n */\nexport function validate(signature, options = {}) {\n    try {\n        assert(signature, options);\n        return true;\n    }\n    catch {\n        return false;\n    }\n}\n/**\n * Converts a ECDSA `v` value to a `yParity` value.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const yParity = Signature.vToYParity(28)\n * // @log: 1\n * ```\n *\n * @param v - The ECDSA `v` value to convert.\n * @returns The `yParity` value.\n */\nexport function vToYParity(v) {\n    if (v === 0 || v === 27)\n        return 0;\n    if (v === 1 || v === 28)\n        return 1;\n    if (v >= 35)\n        return v % 2 === 0 ? 1 : 0;\n    throw new InvalidVError({ value: v });\n}\n/**\n * Converts a ECDSA `v` value to a `yParity` value.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const v = Signature.yParityToV(1)\n * // @log: 28\n * ```\n *\n * @param yParity - The ECDSA `yParity` value to convert.\n * @returns The `v` value.\n */\nexport function yParityToV(yParity) {\n    if (yParity === 0)\n        return 27;\n    if (yParity === 1)\n        return 28;\n    throw new InvalidYParityError({ value: yParity });\n}\n/** Thrown when the serialized signature is of an invalid size. */\nexport class InvalidSerializedSizeError extends Errors.BaseError {\n    constructor({ signature }) {\n        super(`Value \\`${signature}\\` is an invalid signature size.`, {\n            metaMessages: [\n                'Expected: 64 bytes or 65 bytes.',\n                `Received ${Hex.size(Hex.from(signature))} bytes.`,\n            ],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Signature.InvalidSerializedSizeError'\n        });\n    }\n}\n/** Thrown when the signature is missing either an `r`, `s`, or `yParity` property. */\nexport class MissingPropertiesError extends Errors.BaseError {\n    constructor({ signature }) {\n        super(`Signature \\`${Json.stringify(signature)}\\` is missing either an \\`r\\`, \\`s\\`, or \\`yParity\\` property.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Signature.MissingPropertiesError'\n        });\n    }\n}\n/** Thrown when the signature has an invalid `r` value. */\nexport class InvalidRError extends Errors.BaseError {\n    constructor({ value }) {\n        super(`Value \\`${value}\\` is an invalid r value. r must be a positive integer less than 2^256.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Signature.InvalidRError'\n        });\n    }\n}\n/** Thrown when the signature has an invalid `s` value. */\nexport class InvalidSError extends Errors.BaseError {\n    constructor({ value }) {\n        super(`Value \\`${value}\\` is an invalid s value. s must be a positive integer less than 2^256.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Signature.InvalidSError'\n        });\n    }\n}\n/** Thrown when the signature has an invalid `yParity` value. */\nexport class InvalidYParityError extends Errors.BaseError {\n    constructor({ value }) {\n        super(`Value \\`${value}\\` is an invalid y-parity value. Y-parity must be 0 or 1.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Signature.InvalidYParityError'\n        });\n    }\n}\n/** Thrown when the signature has an invalid `v` value. */\nexport class InvalidVError extends Errors.BaseError {\n    constructor({ value }) {\n        super(`Value \\`${value}\\` is an invalid v value. v must be 27, 28 or >=35.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Signature.InvalidVError'\n        });\n    }\n}\n//# sourceMappingURL=Signature.js.map","import * as Hash from './Hash.js';\nimport * as Hex from './Hex.js';\nimport * as Rlp from './Rlp.js';\nimport * as Signature from './Signature.js';\n/**\n * Converts an [EIP-7702](https://eips.ethereum.org/EIPS/eip-7702) Authorization object into a typed {@link ox#Authorization.Authorization}.\n *\n * @example\n * An Authorization can be instantiated from an [EIP-7702](https://eips.ethereum.org/EIPS/eip-7702) Authorization tuple in object format.\n *\n * ```ts twoslash\n * import { Authorization } from 'ox'\n *\n * const authorization = Authorization.from({\n *   address: '0x1234567890abcdef1234567890abcdef12345678',\n *   chainId: 1,\n *   nonce: 69n,\n * })\n * ```\n *\n * @example\n * ### Attaching Signatures\n *\n * A {@link ox#Signature.Signature} can be attached with the `signature` option. The example below demonstrates signing\n * an Authorization with {@link ox#Secp256k1.(sign:function)}.\n *\n * ```ts twoslash\n * import { Authorization, Secp256k1 } from 'ox'\n *\n * const authorization = Authorization.from({\n *   address: '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n *   chainId: 1,\n *   nonce: 40n,\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: Authorization.getSignPayload(authorization),\n *   privateKey: '0x...',\n * })\n *\n * const authorization_signed = Authorization.from(authorization, { signature }) // [!code focus]\n * ```\n *\n * @param authorization - An [EIP-7702](https://eips.ethereum.org/EIPS/eip-7702) Authorization tuple in object format.\n * @param options - Authorization options.\n * @returns The {@link ox#Authorization.Authorization}.\n */\nexport function from(authorization, options = {}) {\n    if (typeof authorization.chainId === 'string')\n        return fromRpc(authorization);\n    return { ...authorization, ...options.signature };\n}\n/**\n * Converts an {@link ox#Authorization.Rpc} to an {@link ox#Authorization.Authorization}.\n *\n * @example\n * ```ts twoslash\n * import { Authorization } from 'ox'\n *\n * const authorization = Authorization.fromRpc({\n *   address: '0x0000000000000000000000000000000000000000',\n *   chainId: '0x1',\n *   nonce: '0x1',\n *   r: '0x635dc2033e60185bb36709c29c75d64ea51dfbd91c32ef4be198e4ceb169fb4d',\n *   s: '0x50c2667ac4c771072746acfdcf1f1483336dcca8bd2df47cd83175dbe60f0540',\n *   yParity: '0x0',\n * })\n * ```\n *\n * @param authorization - The RPC-formatted Authorization.\n * @returns A signed {@link ox#Authorization.Authorization}.\n */\nexport function fromRpc(authorization) {\n    const { address, chainId, nonce } = authorization;\n    const signature = Signature.extract(authorization);\n    return {\n        address,\n        chainId: Number(chainId),\n        nonce: BigInt(nonce),\n        ...signature,\n    };\n}\n/**\n * Converts an {@link ox#Authorization.ListRpc} to an {@link ox#Authorization.List}.\n *\n * @example\n * ```ts twoslash\n * import { Authorization } from 'ox'\n *\n * const authorizationList = Authorization.fromRpcList([{\n *   address: '0x0000000000000000000000000000000000000000',\n *   chainId: '0x1',\n *   nonce: '0x1',\n *   r: '0x635dc2033e60185bb36709c29c75d64ea51dfbd91c32ef4be198e4ceb169fb4d',\n *   s: '0x50c2667ac4c771072746acfdcf1f1483336dcca8bd2df47cd83175dbe60f0540',\n *   yParity: '0x0',\n * }])\n * ```\n *\n * @param authorizationList - The RPC-formatted Authorization list.\n * @returns A signed {@link ox#Authorization.List}.\n */\nexport function fromRpcList(authorizationList) {\n    return authorizationList.map(fromRpc);\n}\n/**\n * Converts an {@link ox#Authorization.Tuple} to an {@link ox#Authorization.Authorization}.\n *\n * @example\n * ```ts twoslash\n * import { Authorization } from 'ox'\n *\n * const authorization = Authorization.fromTuple([\n *   '0x1',\n *   '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n *   '0x3'\n * ])\n * // @log: {\n * // @log:   address: '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n * // @log:   chainId: 1,\n * // @log:   nonce: 3n\n * // @log: }\n * ```\n *\n * @example\n * It is also possible to append a Signature tuple to the end of an Authorization tuple.\n *\n * ```ts twoslash\n * import { Authorization } from 'ox'\n *\n * const authorization = Authorization.fromTuple([\n *   '0x1',\n *   '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n *   '0x3',\n *   '0x1',\n *   '0x68a020a209d3d56c46f38cc50a33f704f4a9a10a59377f8dd762ac66910e9b90',\n *   '0x7e865ad05c4035ab5792787d4a0297a43617ae897930a6fe4d822b8faea52064',\n * ])\n * // @log: {\n * // @log:   address: '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n * // @log:   chainId: 1,\n * // @log:   nonce: 3n\n * // @log:   r: BigInt('0x68a020a209d3d56c46f38cc50a33f704f4a9a10a59377f8dd762ac66910e9b90'),\n * // @log:   s: BigInt('0x7e865ad05c4035ab5792787d4a0297a43617ae897930a6fe4d822b8faea52064'),\n * // @log:   yParity: 0,\n * // @log: }\n * ```\n *\n * @param tuple - The [EIP-7702](https://eips.ethereum.org/EIPS/eip-7702) Authorization tuple.\n * @returns The {@link ox#Authorization.Authorization}.\n */\nexport function fromTuple(tuple) {\n    const [chainId, address, nonce, yParity, r, s] = tuple;\n    let args = {\n        address,\n        chainId: chainId === '0x' ? 0 : Number(chainId),\n        nonce: nonce === '0x' ? 0n : BigInt(nonce),\n    };\n    if (yParity && r && s)\n        args = { ...args, ...Signature.fromTuple([yParity, r, s]) };\n    return from(args);\n}\n/**\n * Converts an {@link ox#Authorization.TupleList} to an {@link ox#Authorization.List}.\n *\n * @example\n * ```ts twoslash\n * import { Authorization } from 'ox'\n *\n * const authorizationList = Authorization.fromTupleList([\n *   ['0x1', '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c', '0x3'],\n *   ['0x3', '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c', '0x14'],\n * ])\n * // @log: [\n * // @log:   {\n * // @log:     address: '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n * // @log:     chainId: 1,\n * // @log:     nonce: 3n,\n * // @log:   },\n * // @log:   {\n * // @log:     address: '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n * // @log:     chainId: 3,\n * // @log:     nonce: 20n,\n * // @log:   },\n * // @log: ]\n * ```\n *\n * @example\n * It is also possible to append a Signature tuple to the end of an Authorization tuple.\n *\n * ```ts twoslash\n * import { Authorization } from 'ox'\n *\n * const authorizationList = Authorization.fromTupleList([\n *   ['0x1', '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c', '0x3', '0x1', '0x68a020a209d3d56c46f38cc50a33f704f4a9a10a59377f8dd762ac66910e9b90', '0x7e865ad05c4035ab5792787d4a0297a43617ae897930a6fe4d822b8faea52064'],\n *   ['0x3', '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c', '0x14', '0x1', '0x68a020a209d3d56c46f38cc50a33f704f4a9a10a59377f8dd762ac66910e9b90', '0x7e865ad05c4035ab5792787d4a0297a43617ae897930a6fe4d822b8faea52064'],\n * ])\n * // @log: [\n * // @log:   {\n * // @log:     address: '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n * // @log:     chainId: 1,\n * // @log:     nonce: 3n,\n * // @log:     r: BigInt('0x68a020a209d3d56c46f38cc50a33f704f4a9a10a59377f8dd762ac66910e9b90'),\n * // @log:     s: BigInt('0x7e865ad05c4035ab5792787d4a0297a43617ae897930a6fe4d822b8faea52064'),\n * // @log:     yParity: 0,\n * // @log:   },\n * // @log:   {\n * // @log:     address: '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n * // @log:     chainId: 3,\n * // @log:     nonce: 20n,\n * // @log:     r: BigInt('0x68a020a209d3d56c46f38cc50a33f704f4a9a10a59377f8dd762ac66910e9b90'),\n * // @log:     s: BigInt('0x7e865ad05c4035ab5792787d4a0297a43617ae897930a6fe4d822b8faea52064'),\n * // @log:     yParity: 0,\n * // @log:   },\n * // @log: ]\n * ```\n *\n * @param tupleList - The [EIP-7702](https://eips.ethereum.org/EIPS/eip-7702) Authorization tuple list.\n * @returns An {@link ox#Authorization.List}.\n */\nexport function fromTupleList(tupleList) {\n    const list = [];\n    for (const tuple of tupleList)\n        list.push(fromTuple(tuple));\n    return list;\n}\n/**\n * Computes the sign payload for an {@link ox#Authorization.Authorization} in [EIP-7702 format](https://eips.ethereum.org/EIPS/eip-7702): `keccak256('0x05' || rlp([chain_id, address, nonce]))`.\n *\n * @example\n * The example below demonstrates computing the sign payload for an {@link ox#Authorization.Authorization}. This payload\n * can then be passed to signing functions like {@link ox#Secp256k1.(sign:function)}.\n *\n * ```ts twoslash\n * import { Authorization, Secp256k1 } from 'ox'\n *\n * const authorization = Authorization.from({\n *   address: '0x1234567890abcdef1234567890abcdef12345678',\n *   chainId: 1,\n *   nonce: 69n,\n * })\n *\n * const payload = Authorization.getSignPayload(authorization) // [!code focus]\n *\n * const signature = Secp256k1.sign({\n *   payload,\n *   privateKey: '0x...',\n * })\n * ```\n *\n * @param authorization - The {@link ox#Authorization.Authorization}.\n * @returns The sign payload.\n */\nexport function getSignPayload(authorization) {\n    return hash(authorization, { presign: true });\n}\n/**\n * Computes the hash for an {@link ox#Authorization.Authorization} in [EIP-7702 format](https://eips.ethereum.org/EIPS/eip-7702): `keccak256('0x05' || rlp([chain_id, address, nonce]))`.\n *\n * @example\n * ```ts twoslash\n * import { Authorization } from 'ox'\n *\n * const authorization = Authorization.from({\n *   address: '0x1234567890abcdef1234567890abcdef12345678',\n *   chainId: 1,\n *   nonce: 69n,\n * })\n *\n * const hash = Authorization.hash(authorization) // [!code focus]\n * ```\n *\n * @param authorization - The {@link ox#Authorization.Authorization}.\n * @returns The hash.\n */\nexport function hash(authorization, options = {}) {\n    const { presign } = options;\n    return Hash.keccak256(Hex.concat('0x05', Rlp.fromHex(toTuple(presign\n        ? {\n            address: authorization.address,\n            chainId: authorization.chainId,\n            nonce: authorization.nonce,\n        }\n        : authorization))));\n}\n/**\n * Converts an {@link ox#Authorization.Authorization} to an {@link ox#Authorization.Rpc}.\n *\n * @example\n * ```ts twoslash\n * import { Authorization } from 'ox'\n *\n * const authorization = Authorization.toRpc({\n *   address: '0x0000000000000000000000000000000000000000',\n *   chainId: 1,\n *   nonce: 1n,\n *   r: 44944627813007772897391531230081695102703289123332187696115181104739239197517n,\n *   s: 36528503505192438307355164441104001310566505351980369085208178712678799181120n,\n *   yParity: 0,\n * })\n * ```\n *\n * @param authorization - An Authorization.\n * @returns An RPC-formatted Authorization.\n */\nexport function toRpc(authorization) {\n    const { address, chainId, nonce, ...signature } = authorization;\n    return {\n        address,\n        chainId: Hex.fromNumber(chainId),\n        nonce: Hex.fromNumber(nonce),\n        ...Signature.toRpc(signature),\n    };\n}\n/**\n * Converts an {@link ox#Authorization.List} to an {@link ox#Authorization.ListRpc}.\n *\n * @example\n * ```ts twoslash\n * import { Authorization } from 'ox'\n *\n * const authorization = Authorization.toRpcList([{\n *   address: '0x0000000000000000000000000000000000000000',\n *   chainId: 1,\n *   nonce: 1n,\n *   r: 44944627813007772897391531230081695102703289123332187696115181104739239197517n,\n *   s: 36528503505192438307355164441104001310566505351980369085208178712678799181120n,\n *   yParity: 0,\n * }])\n * ```\n *\n * @param authorizationList - An Authorization List.\n * @returns An RPC-formatted Authorization List.\n */\nexport function toRpcList(authorizationList) {\n    return authorizationList.map(toRpc);\n}\n/**\n * Converts an {@link ox#Authorization.Authorization} to an {@link ox#Authorization.Tuple}.\n *\n * @example\n * ```ts twoslash\n * import { Authorization } from 'ox'\n *\n * const authorization = Authorization.from({\n *   address: '0x1234567890abcdef1234567890abcdef12345678',\n *   chainId: 1,\n *   nonce: 69n,\n * })\n *\n * const tuple = Authorization.toTuple(authorization) // [!code focus]\n * // @log: [\n * // @log:   address: '0x1234567890abcdef1234567890abcdef12345678',\n * // @log:   chainId: 1,\n * // @log:   nonce: 69n,\n * // @log: ]\n * ```\n *\n * @param authorization - The {@link ox#Authorization.Authorization}.\n * @returns An [EIP-7702](https://eips.ethereum.org/EIPS/eip-7702) Authorization tuple.\n */\nexport function toTuple(authorization) {\n    const { address, chainId, nonce } = authorization;\n    const signature = Signature.extract(authorization);\n    return [\n        chainId ? Hex.fromNumber(chainId) : '0x',\n        address,\n        nonce ? Hex.fromNumber(nonce) : '0x',\n        ...(signature ? Signature.toTuple(signature) : []),\n    ];\n}\n/**\n * Converts an {@link ox#Authorization.List} to an {@link ox#Authorization.TupleList}.\n *\n * @example\n * ```ts twoslash\n * import { Authorization } from 'ox'\n *\n * const authorization_1 = Authorization.from({\n *   address: '0x1234567890abcdef1234567890abcdef12345678',\n *   chainId: 1,\n *   nonce: 69n,\n * })\n * const authorization_2 = Authorization.from({\n *   address: '0x1234567890abcdef1234567890abcdef12345678',\n *   chainId: 3,\n *   nonce: 20n,\n * })\n *\n * const tuple = Authorization.toTupleList([authorization_1, authorization_2]) // [!code focus]\n * // @log: [\n * // @log:   [\n * // @log:     address: '0x1234567890abcdef1234567890abcdef12345678',\n * // @log:     chainId: 1,\n * // @log:     nonce: 69n,\n * // @log:   ],\n * // @log:   [\n * // @log:     address: '0x1234567890abcdef1234567890abcdef12345678',\n * // @log:     chainId: 3,\n * // @log:     nonce: 20n,\n * // @log:   ],\n * // @log: ]\n * ```\n *\n * @param list - An {@link ox#Authorization.List}.\n * @returns An [EIP-7702](https://eips.ethereum.org/EIPS/eip-7702) Authorization tuple list.\n */\nexport function toTupleList(list) {\n    if (!list || list.length === 0)\n        return [];\n    const tupleList = [];\n    for (const authorization of list)\n        tupleList.push(toTuple(authorization));\n    return tupleList;\n}\n//# sourceMappingURL=Authorization.js.map","import * as AbiParameters from '../core/AbiParameters.js';\nimport * as Authorization from '../core/Authorization.js';\nimport * as Errors from '../core/Errors.js';\nimport * as Hex from '../core/Hex.js';\nimport * as Secp256k1 from '../core/Secp256k1.js';\nimport * as Signature from '../core/Signature.js';\n/**\n * Magic bytes used to identify ERC-8010 wrapped signatures.\n */\nexport const magicBytes = '0x8010801080108010801080108010801080108010801080108010801080108010';\n/** Suffix ABI parameters for the ERC-8010 wrapped signature. */\nexport const suffixParameters = AbiParameters.from('(uint256 chainId, address delegation, uint256 nonce, uint8 yParity, uint256 r, uint256 s), address to, bytes data');\n/**\n * Asserts that the wrapped signature is valid.\n *\n * @example\n * ```ts twoslash\n * import { SignatureErc8010 } from 'ox/erc8010'\n *\n * SignatureErc8010.assert('0xdeadbeef')\n * // @error: InvalidWrappedSignatureError: Value `0xdeadbeef` is an invalid ERC-8010 wrapped signature.\n * ```\n *\n * @param value - The value to assert.\n */\nexport function assert(value) {\n    if (typeof value === 'string') {\n        if (Hex.slice(value, -32) !== magicBytes)\n            throw new InvalidWrappedSignatureError(value);\n    }\n    else\n        Signature.assert(value.authorization);\n}\n/**\n * Parses an [ERC-8010 wrapped signature](https://github.com/jxom/ERCs/blob/16f7e3891fff2e1e9c25dea0485497739db8a816/ERCS/erc-8010.md) into its constituent parts.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Secp256k1 } from 'ox'\n * import { SignatureErc8010 } from 'ox/erc8010' // [!code focus]\n *\n * const signature = Secp256k1.sign({\n *   payload: '0x...',\n *   privateKey: '0x...',\n * })\n *\n * // Instantiate from serialized format. // [!code focus]\n * const wrapped = SignatureErc8010.from('0x...') // [!code focus]\n * // @log: { authorization: { ... }, data: '0x...', signature: { ... } } // [!code focus]\n *\n * // Instantiate from constituent parts. // [!code focus]\n * const wrapped = SignatureErc8010.from({ // [!code focus]\n *   authorization: { ... }, // [!code focus]\n *   data: '0x...', // [!code focus]\n *   signature, // [!code focus]\n * })\n * // @log: { authorization: { ... }, data: '0x...', signature: { ... } }\n * ```\n *\n * @param value - Value to parse.\n * @returns Parsed value.\n */\nexport function from(value) {\n    if (typeof value === 'string')\n        return unwrap(value);\n    return value;\n}\n/**\n * Unwraps an [ERC-8010 wrapped signature](https://github.com/jxom/ERCs/blob/16f7e3891fff2e1e9c25dea0485497739db8a816/ERCS/erc-8010.md) into its constituent parts.\n *\n * @example\n * ```ts twoslash\n * import { SignatureErc8010 } from 'ox/erc8010'\n *\n * const { authorization, data, signature } = SignatureErc8010.unwrap('0x...')\n * ```\n *\n * @param wrapped - Wrapped signature to unwrap.\n * @returns Unwrapped signature.\n */\nexport function unwrap(wrapped) {\n    assert(wrapped);\n    const suffixLength = Hex.toNumber(Hex.slice(wrapped, -64, -32));\n    const suffix = Hex.slice(wrapped, -suffixLength - 64, -64);\n    const signature = Hex.slice(wrapped, 0, -suffixLength - 64);\n    const [auth, to, data] = AbiParameters.decode(suffixParameters, suffix);\n    const authorization = Authorization.from({\n        address: auth.delegation,\n        chainId: Number(auth.chainId),\n        nonce: auth.nonce,\n        yParity: auth.yParity,\n        r: auth.r,\n        s: auth.s,\n    });\n    return {\n        authorization,\n        signature,\n        ...(data && data !== '0x' ? { data, to } : {}),\n    };\n}\n/**\n * Wraps a signature into [ERC-8010 format](https://github.com/jxom/ERCs/blob/16f7e3891fff2e1e9c25dea0485497739db8a816/ERCS/erc-8010.md).\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Secp256k1, Signature } from 'ox'\n * import { SignatureErc8010 } from 'ox/erc8010' // [!code focus]\n *\n * const signature = Secp256k1.sign({\n *   payload: '0x...',\n *   privateKey: '0x...',\n * })\n *\n * const wrapped = SignatureErc8010.wrap({ // [!code focus]\n *   authorization: { ... }, // [!code focus]\n *   data: '0xdeadbeef', // [!code focus]\n *   signature: Signature.toHex(signature), // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * @param value - Values to wrap.\n * @returns Wrapped signature.\n */\nexport function wrap(value) {\n    const { data, signature } = value;\n    assert(value);\n    const self = Secp256k1.recoverAddress({\n        payload: Authorization.getSignPayload(value.authorization),\n        signature: Signature.from(value.authorization),\n    });\n    const suffix = AbiParameters.encode(suffixParameters, [\n        {\n            ...value.authorization,\n            delegation: value.authorization.address,\n            chainId: BigInt(value.authorization.chainId),\n        },\n        value.to ?? self,\n        data ?? '0x',\n    ]);\n    const suffixLength = Hex.fromNumber(Hex.size(suffix), { size: 32 });\n    return Hex.concat(signature, suffix, suffixLength, magicBytes);\n}\n/**\n * Validates a wrapped signature. Returns `true` if the wrapped signature is valid, `false` otherwise.\n *\n * @example\n * ```ts twoslash\n * import { SignatureErc8010 } from 'ox/erc8010'\n *\n * const valid = SignatureErc8010.validate('0xdeadbeef')\n * // @log: false\n * ```\n *\n * @param value - The value to validate.\n * @returns `true` if the value is valid, `false` otherwise.\n */\nexport function validate(value) {\n    try {\n        assert(value);\n        return true;\n    }\n    catch {\n        return false;\n    }\n}\n/** Thrown when the ERC-8010 wrapped signature is invalid. */\nexport class InvalidWrappedSignatureError extends Errors.BaseError {\n    constructor(wrapped) {\n        super(`Value \\`${wrapped}\\` is an invalid ERC-8010 wrapped signature.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'SignatureErc8010.InvalidWrappedSignatureError'\n        });\n    }\n}\n//# sourceMappingURL=SignatureErc8010.js.map","import { hexToNumber } from '../index.js';\nfunction formatStorageProof(storageProof) {\n    return storageProof.map((proof) => ({\n        ...proof,\n        value: BigInt(proof.value),\n    }));\n}\nexport function formatProof(proof) {\n    return {\n        ...proof,\n        balance: proof.balance ? BigInt(proof.balance) : undefined,\n        nonce: proof.nonce ? hexToNumber(proof.nonce) : undefined,\n        storageProof: proof.storageProof\n            ? formatStorageProof(proof.storageProof)\n            : undefined,\n    };\n}\n//# sourceMappingURL=proof.js.map","import { numberToHex, } from '../../utils/encoding/toHex.js';\nimport { formatProof, } from '../../utils/formatters/proof.js';\n/**\n * Returns the account and storage values of the specified account including the Merkle-proof.\n *\n * - Docs: https://viem.sh/docs/actions/public/getProof\n * - JSON-RPC Methods:\n *   - Calls [`eth_getProof`](https://eips.ethereum.org/EIPS/eip-1186)\n *\n * @param client - Client to use\n * @param parameters - {@link GetProofParameters}\n * @returns Proof data. {@link GetProofReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { getProof } from 'viem/public'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const block = await getProof(client, {\n *  address: '0x...',\n *  storageKeys: ['0x...'],\n * })\n */\nexport async function getProof(client, { address, blockNumber, blockTag: blockTag_, storageKeys, }) {\n    const blockTag = blockTag_ ?? 'latest';\n    const blockNumberHex = blockNumber !== undefined ? numberToHex(blockNumber) : undefined;\n    const proof = await client.request({\n        method: 'eth_getProof',\n        params: [address, storageKeys, blockNumberHex || blockTag],\n    });\n    return formatProof(proof);\n}\n//# sourceMappingURL=getProof.js.map","import { numberToHex, } from '../../utils/encoding/toHex.js';\n/**\n * Returns the value from a storage slot at a given address.\n *\n * - Docs: https://viem.sh/docs/contract/getStorageAt\n * - JSON-RPC Methods: [`eth_getStorageAt`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getstorageat)\n *\n * @param client - Client to use\n * @param parameters - {@link GetStorageAtParameters}\n * @returns The value of the storage slot. {@link GetStorageAtReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { getStorageAt } from 'viem/contract'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const code = await getStorageAt(client, {\n *   address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',\n *   slot: toHex(0),\n * })\n */\nexport async function getStorageAt(client, { address, blockNumber, blockTag = 'latest', slot }) {\n    const blockNumberHex = blockNumber !== undefined ? numberToHex(blockNumber) : undefined;\n    const data = await client.request({\n        method: 'eth_getStorageAt',\n        params: [address, slot, blockNumberHex || blockTag],\n    });\n    return data;\n}\n//# sourceMappingURL=getStorageAt.js.map","import { TransactionNotFoundError, } from '../../errors/transaction.js';\nimport { numberToHex, } from '../../utils/encoding/toHex.js';\nimport { formatTransaction, } from '../../utils/formatters/transaction.js';\n/**\n * Returns information about a [Transaction](https://viem.sh/docs/glossary/terms#transaction) given a hash or block identifier.\n *\n * - Docs: https://viem.sh/docs/actions/public/getTransaction\n * - Example: https://stackblitz.com/github/wevm/viem/tree/main/examples/transactions_fetching-transactions\n * - JSON-RPC Methods: [`eth_getTransactionByHash`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getTransactionByHash)\n *\n * @param client - Client to use\n * @param parameters - {@link GetTransactionParameters}\n * @returns The transaction information. {@link GetTransactionReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { getTransaction } from 'viem/public'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const transaction = await getTransaction(client, {\n *   hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d',\n * })\n */\nexport async function getTransaction(client, { blockHash, blockNumber, blockTag: blockTag_, hash, index, }) {\n    const blockTag = blockTag_ || 'latest';\n    const blockNumberHex = blockNumber !== undefined ? numberToHex(blockNumber) : undefined;\n    let transaction = null;\n    if (hash) {\n        transaction = await client.request({\n            method: 'eth_getTransactionByHash',\n            params: [hash],\n        }, { dedupe: true });\n    }\n    else if (blockHash) {\n        transaction = await client.request({\n            method: 'eth_getTransactionByBlockHashAndIndex',\n            params: [blockHash, numberToHex(index)],\n        }, { dedupe: true });\n    }\n    else if (blockNumberHex || blockTag) {\n        transaction = await client.request({\n            method: 'eth_getTransactionByBlockNumberAndIndex',\n            params: [blockNumberHex || blockTag, numberToHex(index)],\n        }, { dedupe: Boolean(blockNumberHex) });\n    }\n    if (!transaction)\n        throw new TransactionNotFoundError({\n            blockHash,\n            blockNumber,\n            blockTag,\n            hash,\n            index,\n        });\n    const format = client.chain?.formatters?.transaction?.format || formatTransaction;\n    return format(transaction);\n}\n//# sourceMappingURL=getTransaction.js.map","import { getAction } from '../../utils/getAction.js';\nimport { getBlockNumber, } from './getBlockNumber.js';\nimport { getTransaction, } from './getTransaction.js';\n/**\n * Returns the number of blocks passed (confirmations) since the transaction was processed on a block.\n *\n * - Docs: https://viem.sh/docs/actions/public/getTransactionConfirmations\n * - Example: https://stackblitz.com/github/wevm/viem/tree/main/examples/transactions_fetching-transactions\n * - JSON-RPC Methods: [`eth_getTransactionConfirmations`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getTransactionConfirmations)\n *\n * @param client - Client to use\n * @param parameters - {@link GetTransactionConfirmationsParameters}\n * @returns The number of blocks passed since the transaction was processed. If confirmations is 0, then the Transaction has not been confirmed & processed yet. {@link GetTransactionConfirmationsReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { getTransactionConfirmations } from 'viem/public'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const confirmations = await getTransactionConfirmations(client, {\n *   hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d',\n * })\n */\nexport async function getTransactionConfirmations(client, { hash, transactionReceipt }) {\n    const [blockNumber, transaction] = await Promise.all([\n        getAction(client, getBlockNumber, 'getBlockNumber')({}),\n        hash\n            ? getAction(client, getTransaction, 'getTransaction')({ hash })\n            : undefined,\n    ]);\n    const transactionBlockNumber = transactionReceipt?.blockNumber || transaction?.blockNumber;\n    if (!transactionBlockNumber)\n        return 0n;\n    return blockNumber - transactionBlockNumber + 1n;\n}\n//# sourceMappingURL=getTransactionConfirmations.js.map","import { TransactionReceiptNotFoundError, } from '../../errors/transaction.js';\nimport { formatTransactionReceipt, } from '../../utils/formatters/transactionReceipt.js';\n/**\n * Returns the [Transaction Receipt](https://viem.sh/docs/glossary/terms#transaction-receipt) given a [Transaction](https://viem.sh/docs/glossary/terms#transaction) hash.\n *\n * - Docs: https://viem.sh/docs/actions/public/getTransactionReceipt\n * - Example: https://stackblitz.com/github/wevm/viem/tree/main/examples/transactions_fetching-transactions\n * - JSON-RPC Methods: [`eth_getTransactionReceipt`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_gettransactionreceipt)\n *\n * @param client - Client to use\n * @param parameters - {@link GetTransactionReceiptParameters}\n * @returns The transaction receipt. {@link GetTransactionReceiptReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { getTransactionReceipt } from 'viem/public'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const transactionReceipt = await getTransactionReceipt(client, {\n *   hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d',\n * })\n */\nexport async function getTransactionReceipt(client, { hash }) {\n    const receipt = await client.request({\n        method: 'eth_getTransactionReceipt',\n        params: [hash],\n    }, { dedupe: true });\n    if (!receipt)\n        throw new TransactionReceiptNotFoundError({ hash });\n    const format = client.chain?.formatters?.transactionReceipt?.format ||\n        formatTransactionReceipt;\n    return format(receipt);\n}\n//# sourceMappingURL=getTransactionReceipt.js.map","import * as BlockOverrides from 'ox/BlockOverrides';\nimport { parseAccount, } from '../../accounts/utils/parseAccount.js';\nimport { AbiDecodingZeroDataError } from '../../errors/abi.js';\nimport { RawContractError } from '../../errors/contract.js';\nimport { UnknownNodeError } from '../../errors/node.js';\nimport { decodeFunctionResult, } from '../../utils/abi/decodeFunctionResult.js';\nimport { encodeFunctionData, } from '../../utils/abi/encodeFunctionData.js';\nimport { concat } from '../../utils/data/concat.js';\nimport { numberToHex, } from '../../utils/encoding/toHex.js';\nimport { getContractError } from '../../utils/errors/getContractError.js';\nimport { getNodeError, } from '../../utils/errors/getNodeError.js';\nimport { formatBlock, } from '../../utils/formatters/block.js';\nimport { formatLog } from '../../utils/formatters/log.js';\nimport { formatTransactionRequest, } from '../../utils/formatters/transactionRequest.js';\nimport { serializeStateOverride, } from '../../utils/stateOverride.js';\nimport { assertRequest, } from '../../utils/transaction/assertRequest.js';\n/**\n * Simulates a set of calls on block(s) with optional block and state overrides.\n *\n * @example\n * ```ts\n * import { createClient, http, parseEther } from 'viem'\n * import { simulate } from 'viem/actions'\n * import { mainnet } from 'viem/chains'\n *\n * const client = createClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n *\n * const result = await simulate(client, {\n *   blocks: [{\n *     blockOverrides: {\n *       number: 69420n,\n *     },\n *     calls: [{\n *       {\n *         account: '0x5a0b54d5dc17e482fe8b0bdca5320161b95fb929',\n *         data: '0xdeadbeef',\n *         to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *       },\n *       {\n *         account: '0x5a0b54d5dc17e482fe8b0bdca5320161b95fb929',\n *         to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *         value: parseEther('1'),\n *       },\n *     }],\n *     stateOverrides: [{\n *       address: '0x5a0b54d5dc17e482fe8b0bdca5320161b95fb929',\n *       balance: parseEther('10'),\n *     }],\n *   }]\n * })\n * ```\n *\n * @param client - Client to use.\n * @param parameters - {@link SimulateBlocksParameters}\n * @returns Simulated blocks. {@link SimulateBlocksReturnType}\n */\nexport async function simulateBlocks(client, parameters) {\n    const { blockNumber, blockTag = client.experimental_blockTag ?? 'latest', blocks, returnFullTransactions, traceTransfers, validation, } = parameters;\n    try {\n        const blockStateCalls = [];\n        for (const block of blocks) {\n            const blockOverrides = block.blockOverrides\n                ? BlockOverrides.toRpc(block.blockOverrides)\n                : undefined;\n            const calls = block.calls.map((call_) => {\n                const call = call_;\n                const account = call.account ? parseAccount(call.account) : undefined;\n                const data = call.abi ? encodeFunctionData(call) : call.data;\n                const request = {\n                    ...call,\n                    data: call.dataSuffix\n                        ? concat([data || '0x', call.dataSuffix])\n                        : data,\n                    from: call.from ?? account?.address,\n                };\n                assertRequest(request);\n                return formatTransactionRequest(request);\n            });\n            const stateOverrides = block.stateOverrides\n                ? serializeStateOverride(block.stateOverrides)\n                : undefined;\n            blockStateCalls.push({\n                blockOverrides,\n                calls,\n                stateOverrides,\n            });\n        }\n        const blockNumberHex = typeof blockNumber === 'bigint' ? numberToHex(blockNumber) : undefined;\n        const block = blockNumberHex || blockTag;\n        const result = await client.request({\n            method: 'eth_simulateV1',\n            params: [\n                { blockStateCalls, returnFullTransactions, traceTransfers, validation },\n                block,\n            ],\n        });\n        return result.map((block, i) => ({\n            ...formatBlock(block),\n            calls: block.calls.map((call, j) => {\n                const { abi, args, functionName, to } = blocks[i].calls[j];\n                const data = call.error?.data ?? call.returnData;\n                const gasUsed = BigInt(call.gasUsed);\n                const logs = call.logs?.map((log) => formatLog(log));\n                const status = call.status === '0x1' ? 'success' : 'failure';\n                const result = abi && status === 'success' && data !== '0x'\n                    ? decodeFunctionResult({\n                        abi,\n                        data,\n                        functionName,\n                    })\n                    : null;\n                const error = (() => {\n                    if (status === 'success')\n                        return undefined;\n                    let error;\n                    if (call.error?.data === '0x')\n                        error = new AbiDecodingZeroDataError();\n                    else if (call.error)\n                        error = new RawContractError(call.error);\n                    if (!error)\n                        return undefined;\n                    return getContractError(error, {\n                        abi: (abi ?? []),\n                        address: to ?? '0x',\n                        args,\n                        functionName: functionName ?? '<unknown>',\n                    });\n                })();\n                return {\n                    data,\n                    gasUsed,\n                    logs,\n                    status,\n                    ...(status === 'success'\n                        ? {\n                            result,\n                        }\n                        : {\n                            error,\n                        }),\n                };\n            }),\n        }));\n    }\n    catch (e) {\n        const cause = e;\n        const error = getNodeError(cause, {});\n        if (error instanceof UnknownNodeError)\n            throw cause;\n        throw error;\n    }\n}\n//# sourceMappingURL=simulateBlocks.js.map","import * as Address from '../Address.js';\nimport * as Errors from '../Errors.js';\n/** @internal */\nexport function normalizeSignature(signature) {\n    let active = true;\n    let current = '';\n    let level = 0;\n    let result = '';\n    let valid = false;\n    for (let i = 0; i < signature.length; i++) {\n        const char = signature[i];\n        // If the character is a separator, we want to reactivate.\n        if (['(', ')', ','].includes(char))\n            active = true;\n        // If the character is a \"level\" token, we want to increment/decrement.\n        if (char === '(')\n            level++;\n        if (char === ')')\n            level--;\n        // If we aren't active, we don't want to mutate the result.\n        if (!active)\n            continue;\n        // If level === 0, we are at the definition level.\n        if (level === 0) {\n            if (char === ' ' && ['event', 'function', 'error', ''].includes(result))\n                result = '';\n            else {\n                result += char;\n                // If we are at the end of the definition, we must be finished.\n                if (char === ')') {\n                    valid = true;\n                    break;\n                }\n            }\n            continue;\n        }\n        // Ignore spaces\n        if (char === ' ') {\n            // If the previous character is a separator, and the current section isn't empty, we want to deactivate.\n            if (signature[i - 1] !== ',' && current !== ',' && current !== ',(') {\n                current = '';\n                active = false;\n            }\n            continue;\n        }\n        result += char;\n        current += char;\n    }\n    if (!valid)\n        throw new Errors.BaseError('Unable to normalize signature.');\n    return result;\n}\n/** @internal */\nexport function isArgOfType(arg, abiParameter) {\n    const argType = typeof arg;\n    const abiParameterType = abiParameter.type;\n    switch (abiParameterType) {\n        case 'address':\n            return Address.validate(arg, { strict: false });\n        case 'bool':\n            return argType === 'boolean';\n        case 'function':\n            return argType === 'string';\n        case 'string':\n            return argType === 'string';\n        default: {\n            if (abiParameterType === 'tuple' && 'components' in abiParameter)\n                return Object.values(abiParameter.components).every((component, index) => {\n                    return isArgOfType(Object.values(arg)[index], component);\n                });\n            // `(u)int<M>`: (un)signed integer type of `M` bits, `0 < M <= 256`, `M % 8 == 0`\n            // https://regexr.com/6v8hp\n            if (/^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/.test(abiParameterType))\n                return argType === 'number' || argType === 'bigint';\n            // `bytes<M>`: binary type of `M` bytes, `0 < M <= 32`\n            // https://regexr.com/6va55\n            if (/^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/.test(abiParameterType))\n                return argType === 'string' || arg instanceof Uint8Array;\n            // fixed-length (`<type>[M]`) and dynamic (`<type>[]`) arrays\n            // https://regexr.com/6va6i\n            if (/[a-z]+[1-9]{0,3}(\\[[0-9]{0,}\\])+$/.test(abiParameterType)) {\n                return (Array.isArray(arg) &&\n                    arg.every((x) => isArgOfType(x, {\n                        ...abiParameter,\n                        // Pop off `[]` or `[M]` from end of type\n                        type: abiParameterType.replace(/(\\[[0-9]{0,}\\])$/, ''),\n                    })));\n            }\n            return false;\n        }\n    }\n}\n/** @internal */\nexport function getAmbiguousTypes(sourceParameters, targetParameters, args) {\n    for (const parameterIndex in sourceParameters) {\n        const sourceParameter = sourceParameters[parameterIndex];\n        const targetParameter = targetParameters[parameterIndex];\n        if (sourceParameter.type === 'tuple' &&\n            targetParameter.type === 'tuple' &&\n            'components' in sourceParameter &&\n            'components' in targetParameter)\n            return getAmbiguousTypes(sourceParameter.components, targetParameter.components, args[parameterIndex]);\n        const types = [sourceParameter.type, targetParameter.type];\n        const ambiguous = (() => {\n            if (types.includes('address') && types.includes('bytes20'))\n                return true;\n            if (types.includes('address') && types.includes('string'))\n                return Address.validate(args[parameterIndex], {\n                    strict: false,\n                });\n            if (types.includes('address') && types.includes('bytes'))\n                return Address.validate(args[parameterIndex], {\n                    strict: false,\n                });\n            return false;\n        })();\n        if (ambiguous)\n            return types;\n    }\n    return;\n}\n//# sourceMappingURL=abiItem.js.map","import * as abitype from 'abitype';\nimport * as Errors from './Errors.js';\nimport * as Hash from './Hash.js';\nimport * as Hex from './Hex.js';\nimport * as internal from './internal/abiItem.js';\n/**\n * Formats an {@link ox#AbiItem.AbiItem} into a **Human Readable ABI Item**.\n *\n * @example\n * ```ts twoslash\n * import { AbiItem } from 'ox'\n *\n * const formatted = AbiItem.format({\n *   type: 'function',\n *   name: 'approve',\n *   stateMutability: 'nonpayable',\n *   inputs: [\n *     {\n *       name: 'spender',\n *       type: 'address',\n *     },\n *     {\n *       name: 'amount',\n *       type: 'uint256',\n *     },\n *   ],\n *   outputs: [{ type: 'bool' }],\n * })\n *\n * formatted\n * //    ^?\n *\n *\n * ```\n *\n * @param abiItem - The ABI Item to format.\n * @returns The formatted ABI Item  .\n */\nexport function format(abiItem) {\n    return abitype.formatAbiItem(abiItem);\n}\n/**\n * Parses an arbitrary **JSON ABI Item** or **Human Readable ABI Item** into a typed {@link ox#AbiItem.AbiItem}.\n *\n * @example\n * ### JSON ABIs\n *\n * ```ts twoslash\n * import { AbiItem } from 'ox'\n *\n * const abiItem = AbiItem.from({\n *   type: 'function',\n *   name: 'approve',\n *   stateMutability: 'nonpayable',\n *   inputs: [\n *     {\n *       name: 'spender',\n *       type: 'address',\n *     },\n *     {\n *       name: 'amount',\n *       type: 'uint256',\n *     },\n *   ],\n *   outputs: [{ type: 'bool' }],\n * })\n *\n * abiItem\n * //^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * ### Human Readable ABIs\n *\n * A Human Readable ABI can be parsed into a typed ABI object:\n *\n * ```ts twoslash\n * import { AbiItem } from 'ox'\n *\n * const abiItem = AbiItem.from(\n *   'function approve(address spender, uint256 amount) returns (bool)' // [!code hl]\n * )\n *\n * abiItem\n * //^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * It is possible to specify `struct`s along with your definitions:\n *\n * ```ts twoslash\n * import { AbiItem } from 'ox'\n *\n * const abiItem = AbiItem.from([\n *   'struct Foo { address spender; uint256 amount; }', // [!code hl]\n *   'function approve(Foo foo) returns (bool)',\n * ])\n *\n * abiItem\n * //^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n *\n *\n * @param abiItem - The ABI Item to parse.\n * @returns The typed ABI Item.\n */\nexport function from(abiItem, options = {}) {\n    const { prepare = true } = options;\n    const item = (() => {\n        if (Array.isArray(abiItem))\n            return abitype.parseAbiItem(abiItem);\n        if (typeof abiItem === 'string')\n            return abitype.parseAbiItem(abiItem);\n        return abiItem;\n    })();\n    return {\n        ...item,\n        ...(prepare ? { hash: getSignatureHash(item) } : {}),\n    };\n}\n/**\n * Extracts an {@link ox#AbiItem.AbiItem} from an {@link ox#Abi.Abi} given a name and optional arguments.\n *\n * @example\n * ABI Items can be extracted by their name using the `name` option:\n *\n * ```ts twoslash\n * import { Abi, AbiItem } from 'ox'\n *\n * const abi = Abi.from([\n *   'function foo()',\n *   'event Transfer(address owner, address to, uint256 tokenId)',\n *   'function bar(string a) returns (uint256 x)',\n * ])\n *\n * const item = AbiItem.fromAbi(abi, 'Transfer') // [!code focus]\n * //    ^?\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * ### Extracting by Selector\n *\n * ABI Items can be extract by their selector when {@link ox#Hex.Hex} is provided to `name`.\n *\n * ```ts twoslash\n * import { Abi, AbiItem } from 'ox'\n *\n * const abi = Abi.from([\n *   'function foo()',\n *   'event Transfer(address owner, address to, uint256 tokenId)',\n *   'function bar(string a) returns (uint256 x)',\n * ])\n * const item = AbiItem.fromAbi(abi, '0x095ea7b3') // [!code focus]\n * //    ^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * :::note\n *\n * Extracting via a hex selector is useful when extracting an ABI Item from an `eth_call` RPC response,\n * a Transaction `input`, or from Event Log `topics`.\n *\n * :::\n *\n * @param abi - The ABI to extract from.\n * @param name - The name (or selector) of the ABI item to extract.\n * @param options - Extraction options.\n * @returns The ABI item.\n */\nexport function fromAbi(abi, name, options) {\n    const { args = [], prepare = true } = (options ??\n        {});\n    const isSelector = Hex.validate(name, { strict: false });\n    const abiItems = abi.filter((abiItem) => {\n        if (isSelector) {\n            if (abiItem.type === 'function' || abiItem.type === 'error')\n                return getSelector(abiItem) === Hex.slice(name, 0, 4);\n            if (abiItem.type === 'event')\n                return getSignatureHash(abiItem) === name;\n            return false;\n        }\n        return 'name' in abiItem && abiItem.name === name;\n    });\n    if (abiItems.length === 0)\n        throw new NotFoundError({ name: name });\n    if (abiItems.length === 1)\n        return {\n            ...abiItems[0],\n            ...(prepare ? { hash: getSignatureHash(abiItems[0]) } : {}),\n        };\n    let matchedAbiItem;\n    for (const abiItem of abiItems) {\n        if (!('inputs' in abiItem))\n            continue;\n        if (!args || args.length === 0) {\n            if (!abiItem.inputs || abiItem.inputs.length === 0)\n                return {\n                    ...abiItem,\n                    ...(prepare ? { hash: getSignatureHash(abiItem) } : {}),\n                };\n            continue;\n        }\n        if (!abiItem.inputs)\n            continue;\n        if (abiItem.inputs.length === 0)\n            continue;\n        if (abiItem.inputs.length !== args.length)\n            continue;\n        const matched = args.every((arg, index) => {\n            const abiParameter = 'inputs' in abiItem && abiItem.inputs[index];\n            if (!abiParameter)\n                return false;\n            return internal.isArgOfType(arg, abiParameter);\n        });\n        if (matched) {\n            // Check for ambiguity against already matched parameters (e.g. `address` vs `bytes20`).\n            if (matchedAbiItem &&\n                'inputs' in matchedAbiItem &&\n                matchedAbiItem.inputs) {\n                const ambiguousTypes = internal.getAmbiguousTypes(abiItem.inputs, matchedAbiItem.inputs, args);\n                if (ambiguousTypes)\n                    throw new AmbiguityError({\n                        abiItem,\n                        type: ambiguousTypes[0],\n                    }, {\n                        abiItem: matchedAbiItem,\n                        type: ambiguousTypes[1],\n                    });\n            }\n            matchedAbiItem = abiItem;\n        }\n    }\n    const abiItem = (() => {\n        if (matchedAbiItem)\n            return matchedAbiItem;\n        const [abiItem, ...overloads] = abiItems;\n        return { ...abiItem, overloads };\n    })();\n    if (!abiItem)\n        throw new NotFoundError({ name: name });\n    return {\n        ...abiItem,\n        ...(prepare ? { hash: getSignatureHash(abiItem) } : {}),\n    };\n}\n// eslint-disable-next-line jsdoc/require-jsdoc\nexport function getSelector(...parameters) {\n    const abiItem = (() => {\n        if (Array.isArray(parameters[0])) {\n            const [abi, name] = parameters;\n            return fromAbi(abi, name);\n        }\n        return parameters[0];\n    })();\n    return Hex.slice(getSignatureHash(abiItem), 0, 4);\n}\n// eslint-disable-next-line jsdoc/require-jsdoc\nexport function getSignature(...parameters) {\n    const abiItem = (() => {\n        if (Array.isArray(parameters[0])) {\n            const [abi, name] = parameters;\n            return fromAbi(abi, name);\n        }\n        return parameters[0];\n    })();\n    const signature = (() => {\n        if (typeof abiItem === 'string')\n            return abiItem;\n        return abitype.formatAbiItem(abiItem);\n    })();\n    return internal.normalizeSignature(signature);\n}\n// eslint-disable-next-line jsdoc/require-jsdoc\nexport function getSignatureHash(...parameters) {\n    const abiItem = (() => {\n        if (Array.isArray(parameters[0])) {\n            const [abi, name] = parameters;\n            return fromAbi(abi, name);\n        }\n        return parameters[0];\n    })();\n    if (typeof abiItem !== 'string' && 'hash' in abiItem && abiItem.hash)\n        return abiItem.hash;\n    return Hash.keccak256(Hex.fromString(getSignature(abiItem)));\n}\n/**\n * Throws when ambiguous types are found on overloaded ABI items.\n *\n * @example\n * ```ts twoslash\n * import { Abi, AbiFunction } from 'ox'\n *\n * const foo = Abi.from(['function foo(address)', 'function foo(bytes20)'])\n * AbiFunction.fromAbi(foo, 'foo', {\n *   args: ['0xA0Cf798816D4b9b9866b5330EEa46a18382f251e'],\n * })\n * // @error: AbiItem.AmbiguityError: Found ambiguous types in overloaded ABI Items.\n * // @error: `bytes20` in `foo(bytes20)`, and\n * // @error: `address` in `foo(address)`\n * // @error: These types encode differently and cannot be distinguished at runtime.\n * // @error: Remove one of the ambiguous items in the ABI.\n * ```\n *\n * ### Solution\n *\n * Remove one of the ambiguous types from the ABI.\n *\n * ```ts twoslash\n * import { Abi, AbiFunction } from 'ox'\n *\n * const foo = Abi.from([\n *   'function foo(address)',\n *   'function foo(bytes20)' // [!code --]\n * ])\n * AbiFunction.fromAbi(foo, 'foo', {\n *   args: ['0xA0Cf798816D4b9b9866b5330EEa46a18382f251e'],\n * })\n * // @error: AbiItem.AmbiguityError: Found ambiguous types in overloaded ABI Items.\n * // @error: `bytes20` in `foo(bytes20)`, and\n * // @error: `address` in `foo(address)`\n * // @error: These types encode differently and cannot be distinguished at runtime.\n * // @error: Remove one of the ambiguous items in the ABI.\n * ```\n */\nexport class AmbiguityError extends Errors.BaseError {\n    constructor(x, y) {\n        super('Found ambiguous types in overloaded ABI Items.', {\n            metaMessages: [\n                // TODO: abitype to add support for signature-formatted ABI items.\n                `\\`${x.type}\\` in \\`${internal.normalizeSignature(abitype.formatAbiItem(x.abiItem))}\\`, and`,\n                `\\`${y.type}\\` in \\`${internal.normalizeSignature(abitype.formatAbiItem(y.abiItem))}\\``,\n                '',\n                'These types encode differently and cannot be distinguished at runtime.',\n                'Remove one of the ambiguous items in the ABI.',\n            ],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'AbiItem.AmbiguityError'\n        });\n    }\n}\n/**\n * Throws when an ABI item is not found in the ABI.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Abi, AbiFunction } from 'ox'\n *\n * const foo = Abi.from([\n *   'function foo(address)',\n *   'function bar(uint)'\n * ])\n * AbiFunction.fromAbi(foo, 'baz')\n * // @error: AbiItem.NotFoundError: ABI function with name \"baz\" not found.\n * ```\n *\n * ### Solution\n *\n * Ensure the ABI item exists on the ABI.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Abi, AbiFunction } from 'ox'\n *\n * const foo = Abi.from([\n *   'function foo(address)',\n *   'function bar(uint)',\n *   'function baz(bool)' // [!code ++]\n * ])\n * AbiFunction.fromAbi(foo, 'baz')\n * ```\n */\nexport class NotFoundError extends Errors.BaseError {\n    constructor({ name, data, type = 'item', }) {\n        const selector = (() => {\n            if (name)\n                return ` with name \"${name}\"`;\n            if (data)\n                return ` with data \"${data}\"`;\n            return '';\n        })();\n        super(`ABI ${type}${selector} not found.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'AbiItem.NotFoundError'\n        });\n    }\n}\n/**\n * Throws when the selector size is invalid.\n *\n * @example\n * ```ts twoslash\n * import { Abi, AbiFunction } from 'ox'\n *\n * const foo = Abi.from([\n *   'function foo(address)',\n *   'function bar(uint)'\n * ])\n * AbiFunction.fromAbi(foo, '0xaaa')\n * // @error: AbiItem.InvalidSelectorSizeError: Selector size is invalid. Expected 4 bytes. Received 2 bytes (\"0xaaa\").\n * ```\n *\n * ### Solution\n *\n * Ensure the selector size is 4 bytes.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Abi, AbiFunction } from 'ox'\n *\n * const foo = Abi.from([\n *   'function foo(address)',\n *   'function bar(uint)'\n * ])\n * AbiFunction.fromAbi(foo, '0x7af82b1a')\n * ```\n */\nexport class InvalidSelectorSizeError extends Errors.BaseError {\n    constructor({ data }) {\n        super(`Selector size is invalid. Expected 4 bytes. Received ${Hex.size(data)} bytes (\"${data}\").`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'AbiItem.InvalidSelectorSizeError'\n        });\n    }\n}\n//# sourceMappingURL=AbiItem.js.map","import * as abitype from 'abitype';\nimport * as AbiItem from './AbiItem.js';\nimport * as AbiParameters from './AbiParameters.js';\nimport * as Hex from './Hex.js';\n// eslint-disable-next-line jsdoc/require-jsdoc\nexport function decode(...parameters) {\n    const [abiConstructor, options] = (() => {\n        if (Array.isArray(parameters[0])) {\n            const [abi, options] = parameters;\n            return [fromAbi(abi), options];\n        }\n        return parameters;\n    })();\n    const { bytecode } = options;\n    if (abiConstructor.inputs.length === 0)\n        return undefined;\n    const data = options.data.replace(bytecode, '0x');\n    return AbiParameters.decode(abiConstructor.inputs, data);\n}\n// eslint-disable-next-line jsdoc/require-jsdoc\nexport function encode(...parameters) {\n    const [abiConstructor, options] = (() => {\n        if (Array.isArray(parameters[0])) {\n            const [abi, options] = parameters;\n            return [fromAbi(abi), options];\n        }\n        return parameters;\n    })();\n    const { bytecode, args } = options;\n    return Hex.concat(bytecode, abiConstructor.inputs?.length && args?.length\n        ? AbiParameters.encode(abiConstructor.inputs, args)\n        : '0x');\n}\n/** @internal */\nexport function format(abiConstructor) {\n    return abitype.formatAbiItem(abiConstructor);\n}\n/** @internal */\nexport function from(abiConstructor) {\n    return AbiItem.from(abiConstructor);\n}\n/** @internal */\nexport function fromAbi(abi) {\n    const item = abi.find((item) => item.type === 'constructor');\n    if (!item)\n        throw new AbiItem.NotFoundError({ name: 'constructor' });\n    return item;\n}\n//# sourceMappingURL=AbiConstructor.js.map","import * as abitype from 'abitype';\nimport * as AbiItem from './AbiItem.js';\nimport * as AbiParameters from './AbiParameters.js';\nimport * as Hex from './Hex.js';\n// eslint-disable-next-line jsdoc/require-jsdoc\nexport function decodeData(...parameters) {\n    const [abiFunction, data] = (() => {\n        if (Array.isArray(parameters[0])) {\n            const [abi, name, data] = parameters;\n            return [fromAbi(abi, name), data];\n        }\n        return parameters;\n    })();\n    const { overloads } = abiFunction;\n    if (Hex.size(data) < 4)\n        throw new AbiItem.InvalidSelectorSizeError({ data });\n    if (abiFunction.inputs.length === 0)\n        return undefined;\n    const item = overloads\n        ? fromAbi([abiFunction, ...overloads], data)\n        : abiFunction;\n    if (Hex.size(data) <= 4)\n        return undefined;\n    return AbiParameters.decode(item.inputs, Hex.slice(data, 4));\n}\n// eslint-disable-next-line jsdoc/require-jsdoc\nexport function decodeResult(...parameters) {\n    const [abiFunction, data, options = {}] = (() => {\n        if (Array.isArray(parameters[0])) {\n            const [abi, name, data, options] = parameters;\n            return [fromAbi(abi, name), data, options];\n        }\n        return parameters;\n    })();\n    const values = AbiParameters.decode(abiFunction.outputs, data, options);\n    if (values && Object.keys(values).length === 0)\n        return undefined;\n    if (values && Object.keys(values).length === 1) {\n        if (Array.isArray(values))\n            return values[0];\n        return Object.values(values)[0];\n    }\n    return values;\n}\n// eslint-disable-next-line jsdoc/require-jsdoc\nexport function encodeData(...parameters) {\n    const [abiFunction, args = []] = (() => {\n        if (Array.isArray(parameters[0])) {\n            const [abi, name, args] = parameters;\n            return [fromAbi(abi, name, { args }), args];\n        }\n        const [abiFunction, args] = parameters;\n        return [abiFunction, args];\n    })();\n    const { overloads } = abiFunction;\n    const item = overloads\n        ? fromAbi([abiFunction, ...overloads], abiFunction.name, {\n            args,\n        })\n        : abiFunction;\n    const selector = getSelector(item);\n    const data = args.length > 0 ? AbiParameters.encode(item.inputs, args) : undefined;\n    return data ? Hex.concat(selector, data) : selector;\n}\n// eslint-disable-next-line jsdoc/require-jsdoc\nexport function encodeResult(...parameters) {\n    const [abiFunction, output, options = {}] = (() => {\n        if (Array.isArray(parameters[0])) {\n            const [abi, name, output, options] = parameters;\n            return [fromAbi(abi, name), output, options];\n        }\n        return parameters;\n    })();\n    const { as = 'Array' } = options;\n    const values = (() => {\n        if (abiFunction.outputs.length === 1)\n            return [output];\n        if (Array.isArray(output))\n            return output;\n        if (as === 'Object')\n            return Object.values(output);\n        return [output];\n    })();\n    return AbiParameters.encode(abiFunction.outputs, values);\n}\n/**\n * Formats an {@link ox#AbiFunction.AbiFunction} into a **Human Readable ABI Function**.\n *\n * @example\n * ```ts twoslash\n * import { AbiFunction } from 'ox'\n *\n * const formatted = AbiFunction.format({\n *   type: 'function',\n *   name: 'approve',\n *   stateMutability: 'nonpayable',\n *   inputs: [\n *     {\n *       name: 'spender',\n *       type: 'address',\n *     },\n *     {\n *       name: 'amount',\n *       type: 'uint256',\n *     },\n *   ],\n *   outputs: [{ type: 'bool' }],\n * })\n *\n * formatted\n * //    ^?\n *\n *\n * ```\n *\n * @param abiFunction - The ABI Function to format.\n * @returns The formatted ABI Function.\n */\nexport function format(abiFunction) {\n    return abitype.formatAbiItem(abiFunction);\n}\n/**\n * Parses an arbitrary **JSON ABI Function** or **Human Readable ABI Function** into a typed {@link ox#AbiFunction.AbiFunction}.\n *\n * @example\n * ### JSON ABIs\n *\n * ```ts twoslash\n * import { AbiFunction } from 'ox'\n *\n * const approve = AbiFunction.from({\n *   type: 'function',\n *   name: 'approve',\n *   stateMutability: 'nonpayable',\n *   inputs: [\n *     {\n *       name: 'spender',\n *       type: 'address',\n *     },\n *     {\n *       name: 'amount',\n *       type: 'uint256',\n *     },\n *   ],\n *   outputs: [{ type: 'bool' }],\n * })\n *\n * approve\n * //^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * ### Human Readable ABIs\n *\n * A Human Readable ABI can be parsed into a typed ABI object:\n *\n * ```ts twoslash\n * import { AbiFunction } from 'ox'\n *\n * const approve = AbiFunction.from(\n *   'function approve(address spender, uint256 amount) returns (bool)' // [!code hl]\n * )\n *\n * approve\n * //^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * It is possible to specify `struct`s along with your definitions:\n *\n * ```ts twoslash\n * import { AbiFunction } from 'ox'\n *\n * const approve = AbiFunction.from([\n *   'struct Foo { address spender; uint256 amount; }', // [!code hl]\n *   'function approve(Foo foo) returns (bool)',\n * ])\n *\n * approve\n * //^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n *\n *\n * @param abiFunction - The ABI Function to parse.\n * @returns Typed ABI Function.\n */\nexport function from(abiFunction, options = {}) {\n    return AbiItem.from(abiFunction, options);\n}\n/**\n * Extracts an {@link ox#AbiFunction.AbiFunction} from an {@link ox#Abi.Abi} given a name and optional arguments.\n *\n * @example\n * ### Extracting by Name\n *\n * ABI Functions can be extracted by their name using the `name` option:\n *\n * ```ts twoslash\n * import { Abi, AbiFunction } from 'ox'\n *\n * const abi = Abi.from([\n *   'function foo()',\n *   'event Transfer(address owner, address to, uint256 tokenId)',\n *   'function bar(string a) returns (uint256 x)',\n * ])\n *\n * const item = AbiFunction.fromAbi(abi, 'foo') // [!code focus]\n * //    ^?\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * ### Extracting by Selector\n *\n * ABI Functions can be extract by their selector when {@link ox#Hex.Hex} is provided to `name`.\n *\n * ```ts twoslash\n * import { Abi, AbiFunction } from 'ox'\n *\n * const abi = Abi.from([\n *   'function foo()',\n *   'event Transfer(address owner, address to, uint256 tokenId)',\n *   'function bar(string a) returns (uint256 x)',\n * ])\n * const item = AbiFunction.fromAbi(abi, '0x095ea7b3') // [!code focus]\n * //    ^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * :::note\n *\n * Extracting via a hex selector is useful when extracting an ABI Function from an `eth_call` RPC response or\n * from a Transaction `input`.\n *\n * :::\n *\n * @param abi - The ABI to extract from.\n * @param name - The name (or selector) of the ABI item to extract.\n * @param options - Extraction options.\n * @returns The ABI item.\n */\nexport function fromAbi(abi, name, options) {\n    const item = AbiItem.fromAbi(abi, name, options);\n    if (item.type !== 'function')\n        throw new AbiItem.NotFoundError({ name, type: 'function' });\n    return item;\n}\n/**\n * Computes the [4-byte selector](https://solidity-by-example.org/function-selector/) for an {@link ox#AbiFunction.AbiFunction}.\n *\n * Useful for computing function selectors for calldata.\n *\n * @example\n * ```ts twoslash\n * import { AbiFunction } from 'ox'\n *\n * const selector = AbiFunction.getSelector('function ownerOf(uint256 tokenId)')\n * // @log: '0x6352211e'\n * ```\n *\n * @example\n * ```ts twoslash\n * import { AbiFunction } from 'ox'\n *\n * const selector = AbiFunction.getSelector({\n *   inputs: [{ type: 'uint256' }],\n *   name: 'ownerOf',\n *   outputs: [],\n *   stateMutability: 'view',\n *   type: 'function'\n * })\n * // @log: '0x6352211e'\n * ```\n *\n * @param abiItem - The ABI item to compute the selector for.\n * @returns The first 4 bytes of the {@link ox#Hash.(keccak256:function)} hash of the function signature.\n */\nexport function getSelector(abiItem) {\n    return AbiItem.getSelector(abiItem);\n}\n//# sourceMappingURL=AbiFunction.js.map","export const entryPoint06Address = '0x5FF137D4b0FDCD49DcA30c7CF57E578a026d2789';\nexport const entryPoint07Address = '0x0000000071727De22E5E9d8BAf0edAc6f37da032';\nexport const entryPoint08Address = '0x4337084D9E255Ff0702461CF8895CE9E3b5Ff108';\nexport const ethAddress = '0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee';\nexport const zeroAddress = '0x0000000000000000000000000000000000000000';\n//# sourceMappingURL=address.js.map","import * as AbiConstructor from 'ox/AbiConstructor';\nimport * as AbiFunction from 'ox/AbiFunction';\nimport { parseAccount } from '../../accounts/utils/parseAccount.js';\nimport { ethAddress, zeroAddress } from '../../constants/address.js';\nimport { deploylessCallViaBytecodeBytecode } from '../../constants/contracts.js';\nimport { BaseError } from '../../errors/base.js';\nimport { encodeFunctionData, } from '../../utils/abi/encodeFunctionData.js';\nimport { hexToBigInt } from '../../utils/index.js';\nimport { createAccessList, } from './createAccessList.js';\nimport { simulateBlocks, } from './simulateBlocks.js';\nconst getBalanceCode = '0x6080604052348015600e575f80fd5b5061016d8061001c5f395ff3fe608060405234801561000f575f80fd5b5060043610610029575f3560e01c8063f8b2cb4f1461002d575b5f80fd5b610047600480360381019061004291906100db565b61005d565b604051610054919061011e565b60405180910390f35b5f8173ffffffffffffffffffffffffffffffffffffffff16319050919050565b5f80fd5b5f73ffffffffffffffffffffffffffffffffffffffff82169050919050565b5f6100aa82610081565b9050919050565b6100ba816100a0565b81146100c4575f80fd5b50565b5f813590506100d5816100b1565b92915050565b5f602082840312156100f0576100ef61007d565b5b5f6100fd848285016100c7565b91505092915050565b5f819050919050565b61011881610106565b82525050565b5f6020820190506101315f83018461010f565b9291505056fea26469706673582212203b9fe929fe995c7cf9887f0bdba8a36dd78e8b73f149b17d2d9ad7cd09d2dc6264736f6c634300081a0033';\n/**\n * Simulates execution of a batch of calls.\n *\n * @param client - Client to use\n * @param parameters - {@link SimulateCallsParameters}\n * @returns Results. {@link SimulateCallsReturnType}\n *\n * @example\n * ```ts\n * import { createPublicClient, http, parseEther } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { simulateCalls } from 'viem/actions'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n *\n * const result = await simulateCalls(client, {\n *   account: '0x5a0b54d5dc17e482fe8b0bdca5320161b95fb929',\n *   calls: [{\n *     {\n *       data: '0xdeadbeef',\n *       to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *     },\n *     {\n *       to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *       value: parseEther('1'),\n *     },\n *   ]\n * })\n * ```\n */\nexport async function simulateCalls(client, parameters) {\n    const { blockNumber, blockTag, calls, stateOverrides, traceAssetChanges, traceTransfers, validation, } = parameters;\n    const account = parameters.account\n        ? parseAccount(parameters.account)\n        : undefined;\n    if (traceAssetChanges && !account)\n        throw new BaseError('`account` is required when `traceAssetChanges` is true');\n    // Derive bytecode to extract ETH balance via a contract call.\n    const getBalanceData = account\n        ? AbiConstructor.encode(AbiConstructor.from('constructor(bytes, bytes)'), {\n            bytecode: deploylessCallViaBytecodeBytecode,\n            args: [\n                getBalanceCode,\n                AbiFunction.encodeData(AbiFunction.from('function getBalance(address)'), [account.address]),\n            ],\n        })\n        : undefined;\n    // Fetch ERC20/721 addresses that were \"touched\" from the calls.\n    const assetAddresses = traceAssetChanges\n        ? await Promise.all(parameters.calls.map(async (call) => {\n            if (!call.data && !call.abi)\n                return;\n            const { accessList } = await createAccessList(client, {\n                account: account.address,\n                ...call,\n                data: call.abi ? encodeFunctionData(call) : call.data,\n            });\n            return accessList.map(({ address, storageKeys }) => storageKeys.length > 0 ? address : null);\n        })).then((x) => x.flat().filter(Boolean))\n        : [];\n    const blocks = await simulateBlocks(client, {\n        blockNumber,\n        blockTag: blockTag,\n        blocks: [\n            ...(traceAssetChanges\n                ? [\n                    // ETH pre balances\n                    {\n                        calls: [{ data: getBalanceData }],\n                        stateOverrides,\n                    },\n                    // Asset pre balances\n                    {\n                        calls: assetAddresses.map((address, i) => ({\n                            abi: [\n                                AbiFunction.from('function balanceOf(address) returns (uint256)'),\n                            ],\n                            functionName: 'balanceOf',\n                            args: [account.address],\n                            to: address,\n                            from: zeroAddress,\n                            nonce: i,\n                        })),\n                        stateOverrides: [\n                            {\n                                address: zeroAddress,\n                                nonce: 0,\n                            },\n                        ],\n                    },\n                ]\n                : []),\n            {\n                calls: [...calls, {}].map((call) => ({\n                    ...call,\n                    from: account?.address,\n                })),\n                stateOverrides,\n            },\n            ...(traceAssetChanges\n                ? [\n                    // ETH post balances\n                    {\n                        calls: [{ data: getBalanceData }],\n                    },\n                    // Asset post balances\n                    {\n                        calls: assetAddresses.map((address, i) => ({\n                            abi: [\n                                AbiFunction.from('function balanceOf(address) returns (uint256)'),\n                            ],\n                            functionName: 'balanceOf',\n                            args: [account.address],\n                            to: address,\n                            from: zeroAddress,\n                            nonce: i,\n                        })),\n                        stateOverrides: [\n                            {\n                                address: zeroAddress,\n                                nonce: 0,\n                            },\n                        ],\n                    },\n                    // Decimals\n                    {\n                        calls: assetAddresses.map((address, i) => ({\n                            to: address,\n                            abi: [\n                                AbiFunction.from('function decimals() returns (uint256)'),\n                            ],\n                            functionName: 'decimals',\n                            from: zeroAddress,\n                            nonce: i,\n                        })),\n                        stateOverrides: [\n                            {\n                                address: zeroAddress,\n                                nonce: 0,\n                            },\n                        ],\n                    },\n                    // Token URI\n                    {\n                        calls: assetAddresses.map((address, i) => ({\n                            to: address,\n                            abi: [\n                                AbiFunction.from('function tokenURI(uint256) returns (string)'),\n                            ],\n                            functionName: 'tokenURI',\n                            args: [0n],\n                            from: zeroAddress,\n                            nonce: i,\n                        })),\n                        stateOverrides: [\n                            {\n                                address: zeroAddress,\n                                nonce: 0,\n                            },\n                        ],\n                    },\n                    // Symbols\n                    {\n                        calls: assetAddresses.map((address, i) => ({\n                            to: address,\n                            abi: [AbiFunction.from('function symbol() returns (string)')],\n                            functionName: 'symbol',\n                            from: zeroAddress,\n                            nonce: i,\n                        })),\n                        stateOverrides: [\n                            {\n                                address: zeroAddress,\n                                nonce: 0,\n                            },\n                        ],\n                    },\n                ]\n                : []),\n        ],\n        traceTransfers,\n        validation,\n    });\n    const block_results = traceAssetChanges ? blocks[2] : blocks[0];\n    const [block_ethPre, block_assetsPre, , block_ethPost, block_assetsPost, block_decimals, block_tokenURI, block_symbols,] = traceAssetChanges ? blocks : [];\n    // Extract call results from the simulation.\n    const { calls: block_calls, ...block } = block_results;\n    const results = block_calls.slice(0, -1) ?? [];\n    // Extract pre-execution ETH and asset balances.\n    const ethPre = block_ethPre?.calls ?? [];\n    const assetsPre = block_assetsPre?.calls ?? [];\n    const balancesPre = [...ethPre, ...assetsPre].map((call) => call.status === 'success' ? hexToBigInt(call.data) : null);\n    // Extract post-execution ETH and asset balances.\n    const ethPost = block_ethPost?.calls ?? [];\n    const assetsPost = block_assetsPost?.calls ?? [];\n    const balancesPost = [...ethPost, ...assetsPost].map((call) => call.status === 'success' ? hexToBigInt(call.data) : null);\n    // Extract asset symbols & decimals.\n    const decimals = (block_decimals?.calls ?? []).map((x) => x.status === 'success' ? x.result : null);\n    const symbols = (block_symbols?.calls ?? []).map((x) => x.status === 'success' ? x.result : null);\n    const tokenURI = (block_tokenURI?.calls ?? []).map((x) => x.status === 'success' ? x.result : null);\n    const changes = [];\n    for (const [i, balancePost] of balancesPost.entries()) {\n        const balancePre = balancesPre[i];\n        if (typeof balancePost !== 'bigint')\n            continue;\n        if (typeof balancePre !== 'bigint')\n            continue;\n        const decimals_ = decimals[i - 1];\n        const symbol_ = symbols[i - 1];\n        const tokenURI_ = tokenURI[i - 1];\n        const token = (() => {\n            if (i === 0)\n                return {\n                    address: ethAddress,\n                    decimals: 18,\n                    symbol: 'ETH',\n                };\n            return {\n                address: assetAddresses[i - 1],\n                decimals: tokenURI_ || decimals_ ? Number(decimals_ ?? 1) : undefined,\n                symbol: symbol_ ?? undefined,\n            };\n        })();\n        if (changes.some((change) => change.token.address === token.address))\n            continue;\n        changes.push({\n            token,\n            value: {\n                pre: balancePre,\n                post: balancePost,\n                diff: balancePost - balancePre,\n            },\n        });\n    }\n    return {\n        assetChanges: changes,\n        block,\n        results,\n    };\n}\n//# sourceMappingURL=simulateCalls.js.map","import * as AbiParameters from '../core/AbiParameters.js';\nimport * as Errors from '../core/Errors.js';\nimport * as Hex from '../core/Hex.js';\n/**\n * Magic bytes used to identify ERC-6492 wrapped signatures.\n */\nexport const magicBytes = '0x6492649264926492649264926492649264926492649264926492649264926492';\n/**\n * Deployless ERC-6492 signature verification bytecode.\n */\nexport const universalSignatureValidatorBytecode = '0x608060405234801561001057600080fd5b5060405161069438038061069483398101604081905261002f9161051e565b600061003c848484610048565b9050806000526001601ff35b60007f64926492649264926492649264926492649264926492649264926492649264926100748361040c565b036101e7576000606080848060200190518101906100929190610577565b60405192955090935091506000906001600160a01b038516906100b69085906105dd565b6000604051808303816000865af19150503d80600081146100f3576040519150601f19603f3d011682016040523d82523d6000602084013e6100f8565b606091505b50509050876001600160a01b03163b60000361016057806101605760405162461bcd60e51b815260206004820152601e60248201527f5369676e617475726556616c696461746f723a206465706c6f796d656e74000060448201526064015b60405180910390fd5b604051630b135d3f60e11b808252906001600160a01b038a1690631626ba7e90610190908b9087906004016105f9565b602060405180830381865afa1580156101ad573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906101d19190610633565b6001600160e01b03191614945050505050610405565b6001600160a01b0384163b1561027a57604051630b135d3f60e11b808252906001600160a01b03861690631626ba7e9061022790879087906004016105f9565b602060405180830381865afa158015610244573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102689190610633565b6001600160e01b031916149050610405565b81516041146102df5760405162461bcd60e51b815260206004820152603a602482015260008051602061067483398151915260448201527f3a20696e76616c6964207369676e6174757265206c656e6774680000000000006064820152608401610157565b6102e7610425565b5060208201516040808401518451859392600091859190811061030c5761030c61065d565b016020015160f81c9050601b811480159061032b57508060ff16601c14155b1561038c5760405162461bcd60e51b815260206004820152603b602482015260008051602061067483398151915260448201527f3a20696e76616c6964207369676e617475726520762076616c756500000000006064820152608401610157565b60408051600081526020810180835289905260ff83169181019190915260608101849052608081018390526001600160a01b0389169060019060a0016020604051602081039080840390855afa1580156103ea573d6000803e3d6000fd5b505050602060405103516001600160a01b0316149450505050505b9392505050565b600060208251101561041d57600080fd5b508051015190565b60405180606001604052806003906020820280368337509192915050565b6001600160a01b038116811461045857600080fd5b50565b634e487b7160e01b600052604160045260246000fd5b60005b8381101561048c578181015183820152602001610474565b50506000910152565b600082601f8301126104a657600080fd5b81516001600160401b038111156104bf576104bf61045b565b604051601f8201601f19908116603f011681016001600160401b03811182821017156104ed576104ed61045b565b60405281815283820160200185101561050557600080fd5b610516826020830160208701610471565b949350505050565b60008060006060848603121561053357600080fd5b835161053e81610443565b6020850151604086015191945092506001600160401b0381111561056157600080fd5b61056d86828701610495565b9150509250925092565b60008060006060848603121561058c57600080fd5b835161059781610443565b60208501519093506001600160401b038111156105b357600080fd5b6105bf86828701610495565b604086015190935090506001600160401b0381111561056157600080fd5b600082516105ef818460208701610471565b9190910192915050565b828152604060208201526000825180604084015261061e816060850160208701610471565b601f01601f1916919091016060019392505050565b60006020828403121561064557600080fd5b81516001600160e01b03198116811461040557600080fd5b634e487b7160e01b600052603260045260246000fdfe5369676e617475726556616c696461746f72237265636f7665725369676e6572';\n/**\n * ABI for the ERC-6492 universal deployless signature validator contract.\n *\n * Constructor return value is `0x1` (valid) or `0x0` (invalid).\n */\nexport const universalSignatureValidatorAbi = [\n    {\n        inputs: [\n            {\n                name: '_signer',\n                type: 'address',\n            },\n            {\n                name: '_hash',\n                type: 'bytes32',\n            },\n            {\n                name: '_signature',\n                type: 'bytes',\n            },\n        ],\n        stateMutability: 'nonpayable',\n        type: 'constructor',\n    },\n    {\n        inputs: [\n            {\n                name: '_signer',\n                type: 'address',\n            },\n            {\n                name: '_hash',\n                type: 'bytes32',\n            },\n            {\n                name: '_signature',\n                type: 'bytes',\n            },\n        ],\n        outputs: [\n            {\n                type: 'bool',\n            },\n        ],\n        stateMutability: 'nonpayable',\n        type: 'function',\n        name: 'isValidSig',\n    },\n];\n/**\n * Asserts that the wrapped signature is valid.\n *\n * @example\n * ```ts twoslash\n * import { SignatureErc6492 } from 'ox/erc6492'\n *\n * SignatureErc6492.assert('0xdeadbeef')\n * // @error: InvalidWrappedSignatureError: Value `0xdeadbeef` is an invalid ERC-6492 wrapped signature.\n * ```\n *\n * @param wrapped - The wrapped signature to assert.\n */\nexport function assert(wrapped) {\n    if (Hex.slice(wrapped, -32) !== magicBytes)\n        throw new InvalidWrappedSignatureError(wrapped);\n}\n/**\n * Parses an [ERC-6492 wrapped signature](https://eips.ethereum.org/EIPS/eip-6492#specification) into its constituent parts.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Secp256k1 } from 'ox'\n * import { SignatureErc6492 } from 'ox/erc6492' // [!code focus]\n *\n * const signature = Secp256k1.sign({\n *   payload: '0x...',\n *   privateKey: '0x...',\n * })\n *\n * // Instantiate from serialized format. // [!code focus]\n * const wrapped = SignatureErc6492.from('0x...') // [!code focus]\n * // @log: { data: '0x...', signature: { ... }, to: '0x...', } // [!code focus]\n *\n * // Instantiate from constituent parts. // [!code focus]\n * const wrapped = SignatureErc6492.from({ // [!code focus]\n *   data: '0x...', // [!code focus]\n *   signature, // [!code focus]\n *   to: '0x...', // [!code focus]\n * })\n * // @log: { data: '0x...', signature: { ... }, to: '0x...', }\n * ```\n *\n * @param wrapped - Wrapped signature to parse.\n * @returns Wrapped signature.\n */\nexport function from(wrapped) {\n    if (typeof wrapped === 'string')\n        return unwrap(wrapped);\n    return wrapped;\n}\n/**\n * Parses an [ERC-6492 wrapped signature](https://eips.ethereum.org/EIPS/eip-6492#specification) into its constituent parts.\n *\n * @example\n * ```ts twoslash\n * import { SignatureErc6492 } from 'ox/erc6492'\n *\n * const { data, signature, to } = SignatureErc6492.unwrap('0x...')\n * ```\n *\n * @param wrapped - Wrapped signature to parse.\n * @returns Wrapped signature.\n */\nexport function unwrap(wrapped) {\n    assert(wrapped);\n    const [to, data, signature] = AbiParameters.decode(AbiParameters.from('address, bytes, bytes'), wrapped);\n    return { data, signature, to };\n}\n/**\n * Serializes an [ERC-6492 wrapped signature](https://eips.ethereum.org/EIPS/eip-6492#specification).\n *\n * @example\n * ```ts twoslash\n * import { Secp256k1, Signature } from 'ox'\n * import { SignatureErc6492 } from 'ox/erc6492' // [!code focus]\n *\n * const signature = Secp256k1.sign({\n *   payload: '0x...',\n *   privateKey: '0x...',\n * })\n *\n * const wrapped = SignatureErc6492.wrap({ // [!code focus]\n *   data: '0xdeadbeef', // [!code focus]\n *   signature: Signature.toHex(signature), // [!code focus]\n *   to: '0x00000000219ab540356cBB839Cbe05303d7705Fa', // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * @param value - Wrapped signature to serialize.\n * @returns Serialized wrapped signature.\n */\nexport function wrap(value) {\n    const { data, signature, to } = value;\n    return Hex.concat(AbiParameters.encode(AbiParameters.from('address, bytes, bytes'), [\n        to,\n        data,\n        signature,\n    ]), magicBytes);\n}\n/**\n * Validates a wrapped signature. Returns `true` if the wrapped signature is valid, `false` otherwise.\n *\n * @example\n * ```ts twoslash\n * import { SignatureErc6492 } from 'ox/erc6492'\n *\n * const valid = SignatureErc6492.validate('0xdeadbeef')\n * // @log: false\n * ```\n *\n * @param wrapped - The wrapped signature to validate.\n * @returns `true` if the wrapped signature is valid, `false` otherwise.\n */\nexport function validate(wrapped) {\n    try {\n        assert(wrapped);\n        return true;\n    }\n    catch {\n        return false;\n    }\n}\n/** Thrown when the ERC-6492 wrapped signature is invalid. */\nexport class InvalidWrappedSignatureError extends Errors.BaseError {\n    constructor(wrapped) {\n        super(`Value \\`${wrapped}\\` is an invalid ERC-6492 wrapped signature.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'SignatureErc6492.InvalidWrappedSignatureError'\n        });\n    }\n}\n//# sourceMappingURL=SignatureErc6492.js.map","import { secp256k1 } from '@noble/curves/secp256k1';\nimport { hexToBigInt } from '../encoding/fromHex.js';\nimport { hexToBytes } from '../encoding/toBytes.js';\n/**\n * @description Converts a signature into hex format.\n *\n * @param signature The signature to convert.\n * @returns The signature in hex format.\n *\n * @example\n * serializeSignature({\n *   r: '0x6e100a352ec6ad1b70802290e18aeed190704973570f3b8ed42cb9808e2ea6bf',\n *   s: '0x4a90a229a244495b41890987806fcbd2d5d23fc0dbe5f5256c2613c039d76db8',\n *   yParity: 1\n * })\n * // \"0x6e100a352ec6ad1b70802290e18aeed190704973570f3b8ed42cb9808e2ea6bf4a90a229a244495b41890987806fcbd2d5d23fc0dbe5f5256c2613c039d76db81c\"\n */\nexport function serializeSignature({ r, s, to = 'hex', v, yParity, }) {\n    const yParity_ = (() => {\n        if (yParity === 0 || yParity === 1)\n            return yParity;\n        if (v && (v === 27n || v === 28n || v >= 35n))\n            return v % 2n === 0n ? 1 : 0;\n        throw new Error('Invalid `v` or `yParity` value');\n    })();\n    const signature = `0x${new secp256k1.Signature(hexToBigInt(r), hexToBigInt(s)).toCompactHex()}${yParity_ === 0 ? '1b' : '1c'}`;\n    if (to === 'hex')\n        return signature;\n    return hexToBytes(signature);\n}\n//# sourceMappingURL=serializeSignature.js.map","import { SignatureErc6492 } from 'ox/erc6492';\nimport { SignatureErc8010 } from 'ox/erc8010';\nimport { erc1271Abi, erc6492SignatureValidatorAbi, multicall3Abi, } from '../../constants/abis.js';\nimport { erc6492SignatureValidatorByteCode, multicall3Bytecode, } from '../../constants/contracts.js';\nimport { CallExecutionError, ContractFunctionExecutionError, } from '../../errors/contract.js';\nimport { encodeDeployData, } from '../../utils/abi/encodeDeployData.js';\nimport { encodeFunctionData, } from '../../utils/abi/encodeFunctionData.js';\nimport { getAddress, } from '../../utils/address/getAddress.js';\nimport { isAddressEqual, } from '../../utils/address/isAddressEqual.js';\nimport { verifyAuthorization } from '../../utils/authorization/verifyAuthorization.js';\nimport { concatHex } from '../../utils/data/concat.js';\nimport { isHex } from '../../utils/data/isHex.js';\nimport { hexToBool } from '../../utils/encoding/fromHex.js';\nimport { bytesToHex, numberToHex, } from '../../utils/encoding/toHex.js';\nimport { getAction } from '../../utils/getAction.js';\nimport { recoverAddress, } from '../../utils/signature/recoverAddress.js';\nimport { serializeSignature, } from '../../utils/signature/serializeSignature.js';\nimport { call } from './call.js';\nimport { getCode } from './getCode.js';\nimport { readContract } from './readContract.js';\n/**\n * Verifies a message hash onchain using ERC-6492.\n *\n * @param client - Client to use.\n * @param parameters - {@link VerifyHashParameters}\n * @returns Whether or not the signature is valid. {@link VerifyHashReturnType}\n */\nexport async function verifyHash(client, parameters) {\n    const { address, hash, erc6492VerifierAddress: verifierAddress = parameters.universalSignatureVerifierAddress ??\n        client.chain?.contracts?.erc6492Verifier?.address, multicallAddress = parameters.multicallAddress ??\n        client.chain?.contracts?.multicall3?.address, } = parameters;\n    const signature = (() => {\n        const signature = parameters.signature;\n        if (isHex(signature))\n            return signature;\n        if (typeof signature === 'object' && 'r' in signature && 's' in signature)\n            return serializeSignature(signature);\n        return bytesToHex(signature);\n    })();\n    try {\n        if (SignatureErc8010.validate(signature))\n            return await verifyErc8010(client, {\n                ...parameters,\n                multicallAddress,\n                signature,\n            });\n        return await verifyErc6492(client, {\n            ...parameters,\n            verifierAddress,\n            signature,\n        });\n    }\n    catch (error) {\n        // Fallback attempt to verify the signature via ECDSA recovery.\n        try {\n            const verified = isAddressEqual(getAddress(address), await recoverAddress({ hash, signature }));\n            if (verified)\n                return true;\n        }\n        catch { }\n        if (error instanceof VerificationError) {\n            // if the execution fails, the signature was not valid and an internal method inside of the validator reverted\n            // this can happen for many reasons, for example if signer can not be recovered from the signature\n            // or if the signature has no valid format\n            return false;\n        }\n        throw error;\n    }\n}\n/** @internal */\nexport async function verifyErc8010(client, parameters) {\n    const { address, blockNumber, blockTag, hash, multicallAddress } = parameters;\n    const { authorization: authorization_ox, data: initData, signature, to, } = SignatureErc8010.unwrap(parameters.signature);\n    // Check if already delegated\n    const code = await getCode(client, {\n        address,\n        blockNumber,\n        blockTag,\n    });\n    // If already delegated, perform standard ERC-1271 verification.\n    if (code === concatHex(['0xef0100', authorization_ox.address]))\n        return await verifyErc1271(client, {\n            address,\n            blockNumber,\n            blockTag,\n            hash,\n            signature,\n        });\n    const authorization = {\n        address: authorization_ox.address,\n        chainId: Number(authorization_ox.chainId),\n        nonce: Number(authorization_ox.nonce),\n        r: numberToHex(authorization_ox.r, { size: 32 }),\n        s: numberToHex(authorization_ox.s, { size: 32 }),\n        yParity: authorization_ox.yParity,\n    };\n    const valid = await verifyAuthorization({\n        address,\n        authorization,\n    });\n    if (!valid)\n        throw new VerificationError();\n    // Deployless verification.\n    const results = await getAction(client, readContract, 'readContract')({\n        ...(multicallAddress\n            ? { address: multicallAddress }\n            : { code: multicall3Bytecode }),\n        authorizationList: [authorization],\n        abi: multicall3Abi,\n        blockNumber,\n        blockTag: 'pending',\n        functionName: 'aggregate3',\n        args: [\n            [\n                ...(initData\n                    ? [\n                        {\n                            allowFailure: true,\n                            target: to ?? address,\n                            callData: initData,\n                        },\n                    ]\n                    : []),\n                {\n                    allowFailure: true,\n                    target: address,\n                    callData: encodeFunctionData({\n                        abi: erc1271Abi,\n                        functionName: 'isValidSignature',\n                        args: [hash, signature],\n                    }),\n                },\n            ],\n        ],\n    });\n    const data = results[results.length - 1]?.returnData;\n    if (data?.startsWith('0x1626ba7e'))\n        return true;\n    throw new VerificationError();\n}\n/** @internal */\n// biome-ignore lint/correctness/noUnusedVariables: _\nasync function verifyErc6492(client, parameters) {\n    const { address, factory, factoryData, hash, signature, verifierAddress, ...rest } = parameters;\n    const wrappedSignature = await (async () => {\n        // If no `factory` or `factoryData` is provided, it is assumed that the\n        // address is not a Smart Account, or the Smart Account is already deployed.\n        if (!factory && !factoryData)\n            return signature;\n        // If the signature is already wrapped, return the signature.\n        if (SignatureErc6492.validate(signature))\n            return signature;\n        // If the Smart Account is not deployed, wrap the signature with a 6492 wrapper\n        // to perform counterfactual validation.\n        return SignatureErc6492.wrap({\n            data: factoryData,\n            signature,\n            to: factory,\n        });\n    })();\n    const args = verifierAddress\n        ? {\n            to: verifierAddress,\n            data: encodeFunctionData({\n                abi: erc6492SignatureValidatorAbi,\n                functionName: 'isValidSig',\n                args: [address, hash, wrappedSignature],\n            }),\n            ...rest,\n        }\n        : {\n            data: encodeDeployData({\n                abi: erc6492SignatureValidatorAbi,\n                args: [address, hash, wrappedSignature],\n                bytecode: erc6492SignatureValidatorByteCode,\n            }),\n            ...rest,\n        };\n    const { data } = await getAction(client, call, 'call')(args).catch((error) => {\n        if (error instanceof CallExecutionError)\n            throw new VerificationError();\n        throw error;\n    });\n    if (hexToBool(data ?? '0x0'))\n        return true;\n    throw new VerificationError();\n}\n/** @internal */\nexport async function verifyErc1271(client, parameters) {\n    const { address, blockNumber, blockTag, hash, signature } = parameters;\n    const result = await getAction(client, readContract, 'readContract')({\n        address,\n        abi: erc1271Abi,\n        args: [hash, signature],\n        blockNumber,\n        blockTag,\n        functionName: 'isValidSignature',\n    }).catch((error) => {\n        if (error instanceof ContractFunctionExecutionError)\n            throw new VerificationError();\n        throw error;\n    });\n    if (result.startsWith('0x1626ba7e'))\n        return true;\n    throw new VerificationError();\n}\nclass VerificationError extends Error {\n}\n//# sourceMappingURL=verifyHash.js.map","import { hashMessage } from '../../utils/signature/hashMessage.js';\nimport { verifyHash, } from './verifyHash.js';\n/**\n * Verify that a message was signed by the provided address.\n *\n * Compatible with Smart Contract Accounts & Externally Owned Accounts via [ERC-6492](https://eips.ethereum.org/EIPS/eip-6492).\n *\n * - Docs {@link https://viem.sh/docs/actions/public/verifyMessage}\n *\n * @param client - Client to use.\n * @param parameters - {@link VerifyMessageParameters}\n * @returns Whether or not the signature is valid. {@link VerifyMessageReturnType}\n */\nexport async function verifyMessage(client, { address, message, factory, factoryData, signature, ...callRequest }) {\n    const hash = hashMessage(message);\n    return verifyHash(client, {\n        address,\n        factory: factory,\n        factoryData: factoryData,\n        hash,\n        signature,\n        ...callRequest,\n    });\n}\n//# sourceMappingURL=verifyMessage.js.map","import { hashTypedData, } from '../../utils/signature/hashTypedData.js';\nimport { verifyHash, } from './verifyHash.js';\n/**\n * Verify that typed data was signed by the provided address.\n *\n * - Docs {@link https://viem.sh/docs/actions/public/verifyTypedData}\n *\n * @param client - Client to use.\n * @param parameters - {@link VerifyTypedDataParameters}\n * @returns Whether or not the signature is valid. {@link VerifyTypedDataReturnType}\n */\nexport async function verifyTypedData(client, parameters) {\n    const { address, factory, factoryData, signature, message, primaryType, types, domain, ...callRequest } = parameters;\n    const hash = hashTypedData({ message, primaryType, types, domain });\n    return verifyHash(client, {\n        address,\n        factory: factory,\n        factoryData: factoryData,\n        hash,\n        signature,\n        ...callRequest,\n    });\n}\n//# sourceMappingURL=verifyTypedData.js.map","import { hexToBigInt } from '../../utils/encoding/fromHex.js';\nimport { getAction } from '../../utils/getAction.js';\nimport { observe } from '../../utils/observe.js';\nimport { poll } from '../../utils/poll.js';\nimport { stringify } from '../../utils/stringify.js';\nimport { getBlockNumber, } from './getBlockNumber.js';\n/**\n * Watches and returns incoming block numbers.\n *\n * - Docs: https://viem.sh/docs/actions/public/watchBlockNumber\n * - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/blocks_watching-blocks\n * - JSON-RPC Methods:\n *   - When `poll: true`, calls [`eth_blockNumber`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_blocknumber) on a polling interval.\n *   - When `poll: false` & WebSocket Transport, uses a WebSocket subscription via [`eth_subscribe`](https://docs.alchemy.com/reference/eth-subscribe-polygon) and the `\"newHeads\"` event.\n *\n * @param client - Client to use\n * @param parameters - {@link WatchBlockNumberParameters}\n * @returns A function that can be invoked to stop watching for new block numbers. {@link WatchBlockNumberReturnType}\n *\n * @example\n * import { createPublicClient, watchBlockNumber, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const unwatch = watchBlockNumber(client, {\n *   onBlockNumber: (blockNumber) => console.log(blockNumber),\n * })\n */\nexport function watchBlockNumber(client, { emitOnBegin = false, emitMissed = false, onBlockNumber, onError, poll: poll_, pollingInterval = client.pollingInterval, }) {\n    const enablePolling = (() => {\n        if (typeof poll_ !== 'undefined')\n            return poll_;\n        if (client.transport.type === 'webSocket' ||\n            client.transport.type === 'ipc')\n            return false;\n        if (client.transport.type === 'fallback' &&\n            (client.transport.transports[0].config.type === 'webSocket' ||\n                client.transport.transports[0].config.type === 'ipc'))\n            return false;\n        return true;\n    })();\n    let prevBlockNumber;\n    const pollBlockNumber = () => {\n        const observerId = stringify([\n            'watchBlockNumber',\n            client.uid,\n            emitOnBegin,\n            emitMissed,\n            pollingInterval,\n        ]);\n        return observe(observerId, { onBlockNumber, onError }, (emit) => poll(async () => {\n            try {\n                const blockNumber = await getAction(client, getBlockNumber, 'getBlockNumber')({ cacheTime: 0 });\n                if (prevBlockNumber !== undefined) {\n                    // If the current block number is the same as the previous,\n                    // we can skip.\n                    if (blockNumber === prevBlockNumber)\n                        return;\n                    // If we have missed out on some previous blocks, and the\n                    // `emitMissed` flag is truthy, let's emit those blocks.\n                    if (blockNumber - prevBlockNumber > 1 && emitMissed) {\n                        for (let i = prevBlockNumber + 1n; i < blockNumber; i++) {\n                            emit.onBlockNumber(i, prevBlockNumber);\n                            prevBlockNumber = i;\n                        }\n                    }\n                }\n                // If the next block number is greater than the previous,\n                // it is not in the past, and we can emit the new block number.\n                if (prevBlockNumber === undefined ||\n                    blockNumber > prevBlockNumber) {\n                    emit.onBlockNumber(blockNumber, prevBlockNumber);\n                    prevBlockNumber = blockNumber;\n                }\n            }\n            catch (err) {\n                emit.onError?.(err);\n            }\n        }, {\n            emitOnBegin,\n            interval: pollingInterval,\n        }));\n    };\n    const subscribeBlockNumber = () => {\n        const observerId = stringify([\n            'watchBlockNumber',\n            client.uid,\n            emitOnBegin,\n            emitMissed,\n        ]);\n        return observe(observerId, { onBlockNumber, onError }, (emit) => {\n            let active = true;\n            let unsubscribe = () => (active = false);\n            (async () => {\n                try {\n                    const transport = (() => {\n                        if (client.transport.type === 'fallback') {\n                            const transport = client.transport.transports.find((transport) => transport.config.type === 'webSocket' ||\n                                transport.config.type === 'ipc');\n                            if (!transport)\n                                return client.transport;\n                            return transport.value;\n                        }\n                        return client.transport;\n                    })();\n                    const { unsubscribe: unsubscribe_ } = await transport.subscribe({\n                        params: ['newHeads'],\n                        onData(data) {\n                            if (!active)\n                                return;\n                            const blockNumber = hexToBigInt(data.result?.number);\n                            emit.onBlockNumber(blockNumber, prevBlockNumber);\n                            prevBlockNumber = blockNumber;\n                        },\n                        onError(error) {\n                            emit.onError?.(error);\n                        },\n                    });\n                    unsubscribe = unsubscribe_;\n                    if (!active)\n                        unsubscribe();\n                }\n                catch (err) {\n                    onError?.(err);\n                }\n            })();\n            return () => unsubscribe();\n        });\n    };\n    return enablePolling ? pollBlockNumber() : subscribeBlockNumber();\n}\n//# sourceMappingURL=watchBlockNumber.js.map","import { BlockNotFoundError } from '../../errors/block.js';\nimport { TransactionNotFoundError, TransactionReceiptNotFoundError, WaitForTransactionReceiptTimeoutError, } from '../../errors/transaction.js';\nimport { getAction } from '../../utils/getAction.js';\nimport { observe } from '../../utils/observe.js';\nimport { withResolvers } from '../../utils/promise/withResolvers.js';\nimport { withRetry, } from '../../utils/promise/withRetry.js';\nimport { stringify } from '../../utils/stringify.js';\nimport { getBlock } from './getBlock.js';\nimport { getTransaction, } from './getTransaction.js';\nimport { getTransactionReceipt, } from './getTransactionReceipt.js';\nimport { watchBlockNumber, } from './watchBlockNumber.js';\n/**\n * Waits for the [Transaction](https://viem.sh/docs/glossary/terms#transaction) to be included on a [Block](https://viem.sh/docs/glossary/terms#block) (one confirmation), and then returns the [Transaction Receipt](https://viem.sh/docs/glossary/terms#transaction-receipt).\n *\n * - Docs: https://viem.sh/docs/actions/public/waitForTransactionReceipt\n * - Example: https://stackblitz.com/github/wevm/viem/tree/main/examples/transactions_sending-transactions\n * - JSON-RPC Methods:\n *   - Polls [`eth_getTransactionReceipt`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getTransactionReceipt) on each block until it has been processed.\n *   - If a Transaction has been replaced:\n *     - Calls [`eth_getBlockByNumber`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getblockbynumber) and extracts the transactions\n *     - Checks if one of the Transactions is a replacement\n *     - If so, calls [`eth_getTransactionReceipt`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getTransactionReceipt).\n *\n * The `waitForTransactionReceipt` action additionally supports Replacement detection (e.g. sped up Transactions).\n *\n * Transactions can be replaced when a user modifies their transaction in their wallet (to speed up or cancel). Transactions are replaced when they are sent from the same nonce.\n *\n * There are 3 types of Transaction Replacement reasons:\n *\n * - `repriced`: The gas price has been modified (e.g. different `maxFeePerGas`)\n * - `cancelled`: The Transaction has been cancelled (e.g. `value === 0n`)\n * - `replaced`: The Transaction has been replaced (e.g. different `value` or `data`)\n *\n * @param client - Client to use\n * @param parameters - {@link WaitForTransactionReceiptParameters}\n * @returns The transaction receipt. {@link WaitForTransactionReceiptReturnType}\n *\n * @example\n * import { createPublicClient, waitForTransactionReceipt, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const transactionReceipt = await waitForTransactionReceipt(client, {\n *   hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d',\n * })\n */\nexport async function waitForTransactionReceipt(client, parameters) {\n    const { checkReplacement = true, confirmations = 1, hash, onReplaced, retryCount = 6, retryDelay = ({ count }) => ~~(1 << count) * 200, // exponential backoff\n    timeout = 180_000, } = parameters;\n    const observerId = stringify(['waitForTransactionReceipt', client.uid, hash]);\n    const pollingInterval = (() => {\n        if (parameters.pollingInterval)\n            return parameters.pollingInterval;\n        if (client.chain?.experimental_preconfirmationTime)\n            return client.chain.experimental_preconfirmationTime;\n        return client.pollingInterval;\n    })();\n    let transaction;\n    let replacedTransaction;\n    let receipt;\n    let retrying = false;\n    let _unobserve;\n    let _unwatch;\n    const { promise, resolve, reject } = withResolvers();\n    const timer = timeout\n        ? setTimeout(() => {\n            _unwatch?.();\n            _unobserve?.();\n            reject(new WaitForTransactionReceiptTimeoutError({ hash }));\n        }, timeout)\n        : undefined;\n    _unobserve = observe(observerId, { onReplaced, resolve, reject }, async (emit) => {\n        receipt = await getAction(client, getTransactionReceipt, 'getTransactionReceipt')({ hash }).catch(() => undefined);\n        if (receipt && confirmations <= 1) {\n            clearTimeout(timer);\n            emit.resolve(receipt);\n            _unobserve?.();\n            return;\n        }\n        _unwatch = getAction(client, watchBlockNumber, 'watchBlockNumber')({\n            emitMissed: true,\n            emitOnBegin: true,\n            poll: true,\n            pollingInterval,\n            async onBlockNumber(blockNumber_) {\n                const done = (fn) => {\n                    clearTimeout(timer);\n                    _unwatch?.();\n                    fn();\n                    _unobserve?.();\n                };\n                let blockNumber = blockNumber_;\n                if (retrying)\n                    return;\n                try {\n                    // If we already have a valid receipt, let's check if we have enough\n                    // confirmations. If we do, then we can resolve.\n                    if (receipt) {\n                        if (confirmations > 1 &&\n                            (!receipt.blockNumber ||\n                                blockNumber - receipt.blockNumber + 1n < confirmations))\n                            return;\n                        done(() => emit.resolve(receipt));\n                        return;\n                    }\n                    // Get the transaction to check if it's been replaced.\n                    // We need to retry as some RPC Providers may be slow to sync\n                    // up mined transactions.\n                    if (checkReplacement && !transaction) {\n                        retrying = true;\n                        await withRetry(async () => {\n                            transaction = (await getAction(client, getTransaction, 'getTransaction')({ hash }));\n                            if (transaction.blockNumber)\n                                blockNumber = transaction.blockNumber;\n                        }, {\n                            delay: retryDelay,\n                            retryCount,\n                        });\n                        retrying = false;\n                    }\n                    // Get the receipt to check if it's been processed.\n                    receipt = await getAction(client, getTransactionReceipt, 'getTransactionReceipt')({ hash });\n                    // Check if we have enough confirmations. If not, continue polling.\n                    if (confirmations > 1 &&\n                        (!receipt.blockNumber ||\n                            blockNumber - receipt.blockNumber + 1n < confirmations))\n                        return;\n                    done(() => emit.resolve(receipt));\n                }\n                catch (err) {\n                    // If the receipt is not found, the transaction will be pending.\n                    // We need to check if it has potentially been replaced.\n                    if (err instanceof TransactionNotFoundError ||\n                        err instanceof TransactionReceiptNotFoundError) {\n                        if (!transaction) {\n                            retrying = false;\n                            return;\n                        }\n                        try {\n                            replacedTransaction = transaction;\n                            // Let's retrieve the transactions from the current block.\n                            // We need to retry as some RPC Providers may be slow to sync\n                            // up mined blocks.\n                            retrying = true;\n                            const block = await withRetry(() => getAction(client, getBlock, 'getBlock')({\n                                blockNumber,\n                                includeTransactions: true,\n                            }), {\n                                delay: retryDelay,\n                                retryCount,\n                                shouldRetry: ({ error }) => error instanceof BlockNotFoundError,\n                            });\n                            retrying = false;\n                            const replacementTransaction = block.transactions.find(({ from, nonce }) => from === replacedTransaction.from &&\n                                nonce === replacedTransaction.nonce);\n                            // If we couldn't find a replacement transaction, continue polling.\n                            if (!replacementTransaction)\n                                return;\n                            // If we found a replacement transaction, return it's receipt.\n                            receipt = await getAction(client, getTransactionReceipt, 'getTransactionReceipt')({\n                                hash: replacementTransaction.hash,\n                            });\n                            // Check if we have enough confirmations. If not, continue polling.\n                            if (confirmations > 1 &&\n                                (!receipt.blockNumber ||\n                                    blockNumber - receipt.blockNumber + 1n < confirmations))\n                                return;\n                            let reason = 'replaced';\n                            if (replacementTransaction.to === replacedTransaction.to &&\n                                replacementTransaction.value === replacedTransaction.value &&\n                                replacementTransaction.input === replacedTransaction.input) {\n                                reason = 'repriced';\n                            }\n                            else if (replacementTransaction.from === replacementTransaction.to &&\n                                replacementTransaction.value === 0n) {\n                                reason = 'cancelled';\n                            }\n                            done(() => {\n                                emit.onReplaced?.({\n                                    reason,\n                                    replacedTransaction: replacedTransaction,\n                                    transaction: replacementTransaction,\n                                    transactionReceipt: receipt,\n                                });\n                                emit.resolve(receipt);\n                            });\n                        }\n                        catch (err_) {\n                            done(() => emit.reject(err_));\n                        }\n                    }\n                    else {\n                        done(() => emit.reject(err));\n                    }\n                }\n            },\n        });\n    });\n    return promise;\n}\n//# sourceMappingURL=waitForTransactionReceipt.js.map","import { getAction } from '../../utils/getAction.js';\nimport { observe } from '../../utils/observe.js';\nimport { poll } from '../../utils/poll.js';\nimport { stringify } from '../../utils/stringify.js';\nimport { getBlock } from './getBlock.js';\n/**\n * Watches and returns information for incoming blocks.\n *\n * - Docs: https://viem.sh/docs/actions/public/watchBlocks\n * - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/blocks_watching-blocks\n * - JSON-RPC Methods:\n *   - When `poll: true`, calls [`eth_getBlockByNumber`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getBlockByNumber) on a polling interval.\n *   - When `poll: false` & WebSocket Transport, uses a WebSocket subscription via [`eth_subscribe`](https://docs.alchemy.com/reference/eth-subscribe-polygon) and the `\"newHeads\"` event.\n *\n * @param client - Client to use\n * @param parameters - {@link WatchBlocksParameters}\n * @returns A function that can be invoked to stop watching for new block numbers. {@link WatchBlocksReturnType}\n *\n * @example\n * import { createPublicClient, watchBlocks, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const unwatch = watchBlocks(client, {\n *   onBlock: (block) => console.log(block),\n * })\n */\nexport function watchBlocks(client, { blockTag = client.experimental_blockTag ?? 'latest', emitMissed = false, emitOnBegin = false, onBlock, onError, includeTransactions: includeTransactions_, poll: poll_, pollingInterval = client.pollingInterval, }) {\n    const enablePolling = (() => {\n        if (typeof poll_ !== 'undefined')\n            return poll_;\n        if (client.transport.type === 'webSocket' ||\n            client.transport.type === 'ipc')\n            return false;\n        if (client.transport.type === 'fallback' &&\n            (client.transport.transports[0].config.type === 'webSocket' ||\n                client.transport.transports[0].config.type === 'ipc'))\n            return false;\n        return true;\n    })();\n    const includeTransactions = includeTransactions_ ?? false;\n    let prevBlock;\n    const pollBlocks = () => {\n        const observerId = stringify([\n            'watchBlocks',\n            client.uid,\n            blockTag,\n            emitMissed,\n            emitOnBegin,\n            includeTransactions,\n            pollingInterval,\n        ]);\n        return observe(observerId, { onBlock, onError }, (emit) => poll(async () => {\n            try {\n                const block = await getAction(client, getBlock, 'getBlock')({\n                    blockTag,\n                    includeTransactions,\n                });\n                if (block.number !== null && prevBlock?.number != null) {\n                    // If the current block number is the same as the previous,\n                    // we can skip.\n                    if (block.number === prevBlock.number)\n                        return;\n                    // If we have missed out on some previous blocks, and the\n                    // `emitMissed` flag is truthy, let's emit those blocks.\n                    if (block.number - prevBlock.number > 1 && emitMissed) {\n                        for (let i = prevBlock?.number + 1n; i < block.number; i++) {\n                            const block = (await getAction(client, getBlock, 'getBlock')({\n                                blockNumber: i,\n                                includeTransactions,\n                            }));\n                            emit.onBlock(block, prevBlock);\n                            prevBlock = block;\n                        }\n                    }\n                }\n                if (\n                // If no previous block exists, emit.\n                prevBlock?.number == null ||\n                    // If the block tag is \"pending\" with no block number, emit.\n                    (blockTag === 'pending' && block?.number == null) ||\n                    // If the next block number is greater than the previous block number, emit.\n                    // We don't want to emit blocks in the past.\n                    (block.number !== null && block.number > prevBlock.number)) {\n                    emit.onBlock(block, prevBlock);\n                    prevBlock = block;\n                }\n            }\n            catch (err) {\n                emit.onError?.(err);\n            }\n        }, {\n            emitOnBegin,\n            interval: pollingInterval,\n        }));\n    };\n    const subscribeBlocks = () => {\n        let active = true;\n        let emitFetched = true;\n        let unsubscribe = () => (active = false);\n        (async () => {\n            try {\n                if (emitOnBegin) {\n                    getAction(client, getBlock, 'getBlock')({\n                        blockTag,\n                        includeTransactions,\n                    })\n                        .then((block) => {\n                        if (!active)\n                            return;\n                        if (!emitFetched)\n                            return;\n                        onBlock(block, undefined);\n                        emitFetched = false;\n                    })\n                        .catch(onError);\n                }\n                const transport = (() => {\n                    if (client.transport.type === 'fallback') {\n                        const transport = client.transport.transports.find((transport) => transport.config.type === 'webSocket' ||\n                            transport.config.type === 'ipc');\n                        if (!transport)\n                            return client.transport;\n                        return transport.value;\n                    }\n                    return client.transport;\n                })();\n                const { unsubscribe: unsubscribe_ } = await transport.subscribe({\n                    params: ['newHeads'],\n                    async onData(data) {\n                        if (!active)\n                            return;\n                        const block = (await getAction(client, getBlock, 'getBlock')({\n                            blockNumber: data.result?.number,\n                            includeTransactions,\n                        }).catch(() => { }));\n                        if (!active)\n                            return;\n                        onBlock(block, prevBlock);\n                        emitFetched = false;\n                        prevBlock = block;\n                    },\n                    onError(error) {\n                        onError?.(error);\n                    },\n                });\n                unsubscribe = unsubscribe_;\n                if (!active)\n                    unsubscribe();\n            }\n            catch (err) {\n                onError?.(err);\n            }\n        })();\n        return () => unsubscribe();\n    };\n    return enablePolling ? pollBlocks() : subscribeBlocks();\n}\n//# sourceMappingURL=watchBlocks.js.map","import { DecodeLogDataMismatch, DecodeLogTopicsMismatch, } from '../../errors/abi.js';\nimport { InvalidInputRpcError } from '../../errors/rpc.js';\nimport { decodeEventLog } from '../../utils/abi/decodeEventLog.js';\nimport { encodeEventTopics, } from '../../utils/abi/encodeEventTopics.js';\nimport { formatLog } from '../../utils/formatters/log.js';\nimport { getAction } from '../../utils/getAction.js';\nimport { observe } from '../../utils/observe.js';\nimport { poll } from '../../utils/poll.js';\nimport { stringify } from '../../utils/stringify.js';\nimport { createEventFilter, } from './createEventFilter.js';\nimport { getBlockNumber } from './getBlockNumber.js';\nimport { getFilterChanges } from './getFilterChanges.js';\nimport { getLogs } from './getLogs.js';\nimport { uninstallFilter } from './uninstallFilter.js';\n/**\n * Watches and returns emitted [Event Logs](https://viem.sh/docs/glossary/terms#event-log).\n *\n * - Docs: https://viem.sh/docs/actions/public/watchEvent\n * - JSON-RPC Methods:\n *   - **RPC Provider supports `eth_newFilter`:**\n *     - Calls [`eth_newFilter`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_newfilter) to create a filter (called on initialize).\n *     - On a polling interval, it will call [`eth_getFilterChanges`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getfilterchanges).\n *   - **RPC Provider does not support `eth_newFilter`:**\n *     - Calls [`eth_getLogs`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getlogs) for each block between the polling interval.\n *\n * This Action will batch up all the Event Logs found within the [`pollingInterval`](https://viem.sh/docs/actions/public/watchEvent#pollinginterval-optional), and invoke them via [`onLogs`](https://viem.sh/docs/actions/public/watchEvent#onLogs).\n *\n * `watchEvent` will attempt to create an [Event Filter](https://viem.sh/docs/actions/public/createEventFilter) and listen to changes to the Filter per polling interval, however, if the RPC Provider does not support Filters (e.g. `eth_newFilter`), then `watchEvent` will fall back to using [`getLogs`](https://viem.sh/docs/actions/public/getLogs) instead.\n *\n * @param client - Client to use\n * @param parameters - {@link WatchEventParameters}\n * @returns A function that can be invoked to stop watching for new Event Logs. {@link WatchEventReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { watchEvent } from 'viem/public'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const unwatch = watchEvent(client, {\n *   onLogs: (logs) => console.log(logs),\n * })\n */\nexport function watchEvent(client, { address, args, batch = true, event, events, fromBlock, onError, onLogs, poll: poll_, pollingInterval = client.pollingInterval, strict: strict_, }) {\n    const enablePolling = (() => {\n        if (typeof poll_ !== 'undefined')\n            return poll_;\n        if (typeof fromBlock === 'bigint')\n            return true;\n        if (client.transport.type === 'webSocket' ||\n            client.transport.type === 'ipc')\n            return false;\n        if (client.transport.type === 'fallback' &&\n            (client.transport.transports[0].config.type === 'webSocket' ||\n                client.transport.transports[0].config.type === 'ipc'))\n            return false;\n        return true;\n    })();\n    const strict = strict_ ?? false;\n    const pollEvent = () => {\n        const observerId = stringify([\n            'watchEvent',\n            address,\n            args,\n            batch,\n            client.uid,\n            event,\n            pollingInterval,\n            fromBlock,\n        ]);\n        return observe(observerId, { onLogs, onError }, (emit) => {\n            let previousBlockNumber;\n            if (fromBlock !== undefined)\n                previousBlockNumber = fromBlock - 1n;\n            let filter;\n            let initialized = false;\n            const unwatch = poll(async () => {\n                if (!initialized) {\n                    try {\n                        filter = (await getAction(client, createEventFilter, 'createEventFilter')({\n                            address,\n                            args,\n                            event: event,\n                            events,\n                            strict,\n                            fromBlock,\n                        }));\n                    }\n                    catch { }\n                    initialized = true;\n                    return;\n                }\n                try {\n                    let logs;\n                    if (filter) {\n                        logs = await getAction(client, getFilterChanges, 'getFilterChanges')({ filter });\n                    }\n                    else {\n                        // If the filter doesn't exist, we will fall back to use `getLogs`.\n                        // The fall back exists because some RPC Providers do not support filters.\n                        // Fetch the block number to use for `getLogs`.\n                        const blockNumber = await getAction(client, getBlockNumber, 'getBlockNumber')({});\n                        // If the block number has changed, we will need to fetch the logs.\n                        // If the block number doesn't exist, we are yet to reach the first poll interval,\n                        // so do not emit any logs.\n                        if (previousBlockNumber && previousBlockNumber !== blockNumber) {\n                            logs = await getAction(client, getLogs, 'getLogs')({\n                                address,\n                                args,\n                                event: event,\n                                events,\n                                fromBlock: previousBlockNumber + 1n,\n                                toBlock: blockNumber,\n                            });\n                        }\n                        else {\n                            logs = [];\n                        }\n                        previousBlockNumber = blockNumber;\n                    }\n                    if (logs.length === 0)\n                        return;\n                    if (batch)\n                        emit.onLogs(logs);\n                    else\n                        for (const log of logs)\n                            emit.onLogs([log]);\n                }\n                catch (err) {\n                    // If a filter has been set and gets uninstalled, providers will throw an InvalidInput error.\n                    // Reinitialize the filter when this occurs\n                    if (filter && err instanceof InvalidInputRpcError)\n                        initialized = false;\n                    emit.onError?.(err);\n                }\n            }, {\n                emitOnBegin: true,\n                interval: pollingInterval,\n            });\n            return async () => {\n                if (filter)\n                    await getAction(client, uninstallFilter, 'uninstallFilter')({ filter });\n                unwatch();\n            };\n        });\n    };\n    const subscribeEvent = () => {\n        let active = true;\n        let unsubscribe = () => (active = false);\n        (async () => {\n            try {\n                const transport = (() => {\n                    if (client.transport.type === 'fallback') {\n                        const transport = client.transport.transports.find((transport) => transport.config.type === 'webSocket' ||\n                            transport.config.type === 'ipc');\n                        if (!transport)\n                            return client.transport;\n                        return transport.value;\n                    }\n                    return client.transport;\n                })();\n                const events_ = events ?? (event ? [event] : undefined);\n                let topics = [];\n                if (events_) {\n                    const encoded = events_.flatMap((event) => encodeEventTopics({\n                        abi: [event],\n                        eventName: event.name,\n                        args,\n                    }));\n                    // TODO: Clean up type casting\n                    topics = [encoded];\n                    if (event)\n                        topics = topics[0];\n                }\n                const { unsubscribe: unsubscribe_ } = await transport.subscribe({\n                    params: ['logs', { address, topics }],\n                    onData(data) {\n                        if (!active)\n                            return;\n                        const log = data.result;\n                        try {\n                            const { eventName, args } = decodeEventLog({\n                                abi: events_ ?? [],\n                                data: log.data,\n                                topics: log.topics,\n                                strict,\n                            });\n                            const formatted = formatLog(log, { args, eventName });\n                            onLogs([formatted]);\n                        }\n                        catch (err) {\n                            let eventName;\n                            let isUnnamed;\n                            if (err instanceof DecodeLogDataMismatch ||\n                                err instanceof DecodeLogTopicsMismatch) {\n                                // If strict mode is on, and log data/topics do not match event definition, skip.\n                                if (strict_)\n                                    return;\n                                eventName = err.abiItem.name;\n                                isUnnamed = err.abiItem.inputs?.some((x) => !('name' in x && x.name));\n                            }\n                            // Set args to empty if there is an error decoding (e.g. indexed/non-indexed params mismatch).\n                            const formatted = formatLog(log, {\n                                args: isUnnamed ? [] : {},\n                                eventName,\n                            });\n                            onLogs([formatted]);\n                        }\n                    },\n                    onError(error) {\n                        onError?.(error);\n                    },\n                });\n                unsubscribe = unsubscribe_;\n                if (!active)\n                    unsubscribe();\n            }\n            catch (err) {\n                onError?.(err);\n            }\n        })();\n        return () => unsubscribe();\n    };\n    return enablePolling ? pollEvent() : subscribeEvent();\n}\n//# sourceMappingURL=watchEvent.js.map","import { getAction } from '../../utils/getAction.js';\nimport { observe } from '../../utils/observe.js';\nimport { poll } from '../../utils/poll.js';\nimport { stringify } from '../../utils/stringify.js';\nimport { createPendingTransactionFilter } from './createPendingTransactionFilter.js';\nimport { getFilterChanges } from './getFilterChanges.js';\nimport { uninstallFilter } from './uninstallFilter.js';\n/**\n * Watches and returns pending transaction hashes.\n *\n * - Docs: https://viem.sh/docs/actions/public/watchPendingTransactions\n * - JSON-RPC Methods:\n *   - When `poll: true`\n *     - Calls [`eth_newPendingTransactionFilter`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_newpendingtransactionfilter) to initialize the filter.\n *     - Calls [`eth_getFilterChanges`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getFilterChanges) on a polling interval.\n *   - When `poll: false` & WebSocket Transport, uses a WebSocket subscription via [`eth_subscribe`](https://docs.alchemy.com/reference/eth-subscribe-polygon) and the `\"newPendingTransactions\"` event.\n *\n * This Action will batch up all the pending transactions found within the [`pollingInterval`](https://viem.sh/docs/actions/public/watchPendingTransactions#pollinginterval-optional), and invoke them via [`onTransactions`](https://viem.sh/docs/actions/public/watchPendingTransactions#ontransactions).\n *\n * @param client - Client to use\n * @param parameters - {@link WatchPendingTransactionsParameters}\n * @returns A function that can be invoked to stop watching for new pending transaction hashes. {@link WatchPendingTransactionsReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { watchPendingTransactions } from 'viem/public'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const unwatch = await watchPendingTransactions(client, {\n *   onTransactions: (hashes) => console.log(hashes),\n * })\n */\nexport function watchPendingTransactions(client, { batch = true, onError, onTransactions, poll: poll_, pollingInterval = client.pollingInterval, }) {\n    const enablePolling = typeof poll_ !== 'undefined'\n        ? poll_\n        : client.transport.type !== 'webSocket' && client.transport.type !== 'ipc';\n    const pollPendingTransactions = () => {\n        const observerId = stringify([\n            'watchPendingTransactions',\n            client.uid,\n            batch,\n            pollingInterval,\n        ]);\n        return observe(observerId, { onTransactions, onError }, (emit) => {\n            let filter;\n            const unwatch = poll(async () => {\n                try {\n                    if (!filter) {\n                        try {\n                            filter = await getAction(client, createPendingTransactionFilter, 'createPendingTransactionFilter')({});\n                            return;\n                        }\n                        catch (err) {\n                            unwatch();\n                            throw err;\n                        }\n                    }\n                    const hashes = await getAction(client, getFilterChanges, 'getFilterChanges')({ filter });\n                    if (hashes.length === 0)\n                        return;\n                    if (batch)\n                        emit.onTransactions(hashes);\n                    else\n                        for (const hash of hashes)\n                            emit.onTransactions([hash]);\n                }\n                catch (err) {\n                    emit.onError?.(err);\n                }\n            }, {\n                emitOnBegin: true,\n                interval: pollingInterval,\n            });\n            return async () => {\n                if (filter)\n                    await getAction(client, uninstallFilter, 'uninstallFilter')({ filter });\n                unwatch();\n            };\n        });\n    };\n    const subscribePendingTransactions = () => {\n        let active = true;\n        let unsubscribe = () => (active = false);\n        (async () => {\n            try {\n                const { unsubscribe: unsubscribe_ } = await client.transport.subscribe({\n                    params: ['newPendingTransactions'],\n                    onData(data) {\n                        if (!active)\n                            return;\n                        const transaction = data.result;\n                        onTransactions([transaction]);\n                    },\n                    onError(error) {\n                        onError?.(error);\n                    },\n                });\n                unsubscribe = unsubscribe_;\n                if (!active)\n                    unsubscribe();\n            }\n            catch (err) {\n                onError?.(err);\n            }\n        })();\n        return () => unsubscribe();\n    };\n    return enablePolling\n        ? pollPendingTransactions()\n        : subscribePendingTransactions();\n}\n//# sourceMappingURL=watchPendingTransactions.js.map","/**\n * @description Parses EIP-4361 formatted message into message fields object.\n *\n * @see https://eips.ethereum.org/EIPS/eip-4361\n *\n * @returns EIP-4361 fields object\n */\nexport function parseSiweMessage(message) {\n    const { scheme, statement, ...prefix } = (message.match(prefixRegex)\n        ?.groups ?? {});\n    const { chainId, expirationTime, issuedAt, notBefore, requestId, ...suffix } = (message.match(suffixRegex)?.groups ?? {});\n    const resources = message.split('Resources:')[1]?.split('\\n- ').slice(1);\n    return {\n        ...prefix,\n        ...suffix,\n        ...(chainId ? { chainId: Number(chainId) } : {}),\n        ...(expirationTime ? { expirationTime: new Date(expirationTime) } : {}),\n        ...(issuedAt ? { issuedAt: new Date(issuedAt) } : {}),\n        ...(notBefore ? { notBefore: new Date(notBefore) } : {}),\n        ...(requestId ? { requestId } : {}),\n        ...(resources ? { resources } : {}),\n        ...(scheme ? { scheme } : {}),\n        ...(statement ? { statement } : {}),\n    };\n}\n// https://regexr.com/80gdj\nconst prefixRegex = /^(?:(?<scheme>[a-zA-Z][a-zA-Z0-9+-.]*):\\/\\/)?(?<domain>[a-zA-Z0-9+-.]*(?::[0-9]{1,5})?) (?:wants you to sign in with your Ethereum account:\\n)(?<address>0x[a-fA-F0-9]{40})\\n\\n(?:(?<statement>.*)\\n\\n)?/;\n// https://regexr.com/80gf9\nconst suffixRegex = /(?:URI: (?<uri>.+))\\n(?:Version: (?<version>.+))\\n(?:Chain ID: (?<chainId>\\d+))\\n(?:Nonce: (?<nonce>[a-zA-Z0-9]+))\\n(?:Issued At: (?<issuedAt>.+))(?:\\nExpiration Time: (?<expirationTime>.+))?(?:\\nNot Before: (?<notBefore>.+))?(?:\\nRequest ID: (?<requestId>.+))?/;\n//# sourceMappingURL=parseSiweMessage.js.map","import { isAddress } from '../address/isAddress.js';\nimport { isAddressEqual } from '../address/isAddressEqual.js';\n/**\n * @description Validates EIP-4361 message.\n *\n * @see https://eips.ethereum.org/EIPS/eip-4361\n */\nexport function validateSiweMessage(parameters) {\n    const { address, domain, message, nonce, scheme, time = new Date(), } = parameters;\n    if (domain && message.domain !== domain)\n        return false;\n    if (nonce && message.nonce !== nonce)\n        return false;\n    if (scheme && message.scheme !== scheme)\n        return false;\n    if (message.expirationTime && time >= message.expirationTime)\n        return false;\n    if (message.notBefore && time < message.notBefore)\n        return false;\n    try {\n        if (!message.address)\n            return false;\n        if (!isAddress(message.address, { strict: false }))\n            return false;\n        if (address && !isAddressEqual(message.address, address))\n            return false;\n    }\n    catch {\n        return false;\n    }\n    return true;\n}\n//# sourceMappingURL=validateSiweMessage.js.map","import { hashMessage } from '../../utils/signature/hashMessage.js';\nimport { parseSiweMessage } from '../../utils/siwe/parseSiweMessage.js';\nimport { validateSiweMessage, } from '../../utils/siwe/validateSiweMessage.js';\nimport { verifyHash, } from '../public/verifyHash.js';\n/**\n * Verifies [EIP-4361](https://eips.ethereum.org/EIPS/eip-4361) formatted message was signed.\n *\n * Compatible with Smart Contract Accounts & Externally Owned Accounts via [ERC-6492](https://eips.ethereum.org/EIPS/eip-6492).\n *\n * - Docs {@link https://viem.sh/docs/siwe/actions/verifySiweMessage}\n *\n * @param client - Client to use.\n * @param parameters - {@link VerifySiweMessageParameters}\n * @returns Whether or not the signature is valid. {@link VerifySiweMessageReturnType}\n */\nexport async function verifySiweMessage(client, parameters) {\n    const { address, domain, message, nonce, scheme, signature, time = new Date(), ...callRequest } = parameters;\n    const parsed = parseSiweMessage(message);\n    if (!parsed.address)\n        return false;\n    const isValid = validateSiweMessage({\n        address,\n        domain,\n        message: parsed,\n        nonce,\n        scheme,\n        time,\n    });\n    if (!isValid)\n        return false;\n    const hash = hashMessage(message);\n    return verifyHash(client, {\n        address: parsed.address,\n        hash,\n        signature,\n        ...callRequest,\n    });\n}\n//# sourceMappingURL=verifySiweMessage.js.map","import { getEnsAddress, } from '../../actions/ens/getEnsAddress.js';\nimport { getEnsAvatar, } from '../../actions/ens/getEnsAvatar.js';\nimport { getEnsName, } from '../../actions/ens/getEnsName.js';\nimport { getEnsResolver, } from '../../actions/ens/getEnsResolver.js';\nimport { getEnsText, } from '../../actions/ens/getEnsText.js';\nimport { call, } from '../../actions/public/call.js';\nimport { createAccessList, } from '../../actions/public/createAccessList.js';\nimport { createBlockFilter, } from '../../actions/public/createBlockFilter.js';\nimport { createContractEventFilter, } from '../../actions/public/createContractEventFilter.js';\nimport { createEventFilter, } from '../../actions/public/createEventFilter.js';\nimport { createPendingTransactionFilter, } from '../../actions/public/createPendingTransactionFilter.js';\nimport { estimateContractGas, } from '../../actions/public/estimateContractGas.js';\nimport { estimateFeesPerGas, } from '../../actions/public/estimateFeesPerGas.js';\nimport { estimateGas, } from '../../actions/public/estimateGas.js';\nimport { estimateMaxPriorityFeePerGas, } from '../../actions/public/estimateMaxPriorityFeePerGas.js';\nimport { getBalance, } from '../../actions/public/getBalance.js';\nimport { getBlobBaseFee, } from '../../actions/public/getBlobBaseFee.js';\nimport { getBlock, } from '../../actions/public/getBlock.js';\nimport { getBlockNumber, } from '../../actions/public/getBlockNumber.js';\nimport { getBlockTransactionCount, } from '../../actions/public/getBlockTransactionCount.js';\nimport { getChainId, } from '../../actions/public/getChainId.js';\nimport { getCode, } from '../../actions/public/getCode.js';\nimport { getContractEvents, } from '../../actions/public/getContractEvents.js';\nimport { getEip712Domain, } from '../../actions/public/getEip712Domain.js';\nimport { getFeeHistory, } from '../../actions/public/getFeeHistory.js';\nimport { getFilterChanges, } from '../../actions/public/getFilterChanges.js';\nimport { getFilterLogs, } from '../../actions/public/getFilterLogs.js';\nimport { getGasPrice, } from '../../actions/public/getGasPrice.js';\nimport { getLogs, } from '../../actions/public/getLogs.js';\nimport { getProof, } from '../../actions/public/getProof.js';\nimport { getStorageAt, } from '../../actions/public/getStorageAt.js';\nimport { getTransaction, } from '../../actions/public/getTransaction.js';\nimport { getTransactionConfirmations, } from '../../actions/public/getTransactionConfirmations.js';\nimport { getTransactionCount, } from '../../actions/public/getTransactionCount.js';\nimport { getTransactionReceipt, } from '../../actions/public/getTransactionReceipt.js';\nimport { multicall, } from '../../actions/public/multicall.js';\nimport { readContract, } from '../../actions/public/readContract.js';\nimport { simulateBlocks, } from '../../actions/public/simulateBlocks.js';\nimport { simulateCalls, } from '../../actions/public/simulateCalls.js';\nimport { simulateContract, } from '../../actions/public/simulateContract.js';\nimport { uninstallFilter, } from '../../actions/public/uninstallFilter.js';\nimport { verifyHash, } from '../../actions/public/verifyHash.js';\nimport { verifyMessage, } from '../../actions/public/verifyMessage.js';\nimport { verifyTypedData, } from '../../actions/public/verifyTypedData.js';\nimport { waitForTransactionReceipt, } from '../../actions/public/waitForTransactionReceipt.js';\nimport { watchBlockNumber, } from '../../actions/public/watchBlockNumber.js';\nimport { watchBlocks, } from '../../actions/public/watchBlocks.js';\nimport { watchContractEvent, } from '../../actions/public/watchContractEvent.js';\nimport { watchEvent, } from '../../actions/public/watchEvent.js';\nimport { watchPendingTransactions, } from '../../actions/public/watchPendingTransactions.js';\nimport { verifySiweMessage, } from '../../actions/siwe/verifySiweMessage.js';\nimport { prepareTransactionRequest, } from '../../actions/wallet/prepareTransactionRequest.js';\nimport { sendRawTransaction, } from '../../actions/wallet/sendRawTransaction.js';\nexport function publicActions(client) {\n    return {\n        call: (args) => call(client, args),\n        createAccessList: (args) => createAccessList(client, args),\n        createBlockFilter: () => createBlockFilter(client),\n        createContractEventFilter: (args) => createContractEventFilter(client, args),\n        createEventFilter: (args) => createEventFilter(client, args),\n        createPendingTransactionFilter: () => createPendingTransactionFilter(client),\n        estimateContractGas: (args) => estimateContractGas(client, args),\n        estimateGas: (args) => estimateGas(client, args),\n        getBalance: (args) => getBalance(client, args),\n        getBlobBaseFee: () => getBlobBaseFee(client),\n        getBlock: (args) => getBlock(client, args),\n        getBlockNumber: (args) => getBlockNumber(client, args),\n        getBlockTransactionCount: (args) => getBlockTransactionCount(client, args),\n        getBytecode: (args) => getCode(client, args),\n        getChainId: () => getChainId(client),\n        getCode: (args) => getCode(client, args),\n        getContractEvents: (args) => getContractEvents(client, args),\n        getEip712Domain: (args) => getEip712Domain(client, args),\n        getEnsAddress: (args) => getEnsAddress(client, args),\n        getEnsAvatar: (args) => getEnsAvatar(client, args),\n        getEnsName: (args) => getEnsName(client, args),\n        getEnsResolver: (args) => getEnsResolver(client, args),\n        getEnsText: (args) => getEnsText(client, args),\n        getFeeHistory: (args) => getFeeHistory(client, args),\n        estimateFeesPerGas: (args) => estimateFeesPerGas(client, args),\n        getFilterChanges: (args) => getFilterChanges(client, args),\n        getFilterLogs: (args) => getFilterLogs(client, args),\n        getGasPrice: () => getGasPrice(client),\n        getLogs: (args) => getLogs(client, args),\n        getProof: (args) => getProof(client, args),\n        estimateMaxPriorityFeePerGas: (args) => estimateMaxPriorityFeePerGas(client, args),\n        getStorageAt: (args) => getStorageAt(client, args),\n        getTransaction: (args) => getTransaction(client, args),\n        getTransactionConfirmations: (args) => getTransactionConfirmations(client, args),\n        getTransactionCount: (args) => getTransactionCount(client, args),\n        getTransactionReceipt: (args) => getTransactionReceipt(client, args),\n        multicall: (args) => multicall(client, args),\n        prepareTransactionRequest: (args) => prepareTransactionRequest(client, args),\n        readContract: (args) => readContract(client, args),\n        sendRawTransaction: (args) => sendRawTransaction(client, args),\n        simulate: (args) => simulateBlocks(client, args),\n        simulateBlocks: (args) => simulateBlocks(client, args),\n        simulateCalls: (args) => simulateCalls(client, args),\n        simulateContract: (args) => simulateContract(client, args),\n        verifyHash: (args) => verifyHash(client, args),\n        verifyMessage: (args) => verifyMessage(client, args),\n        verifySiweMessage: (args) => verifySiweMessage(client, args),\n        verifyTypedData: (args) => verifyTypedData(client, args),\n        uninstallFilter: (args) => uninstallFilter(client, args),\n        waitForTransactionReceipt: (args) => waitForTransactionReceipt(client, args),\n        watchBlocks: (args) => watchBlocks(client, args),\n        watchBlockNumber: (args) => watchBlockNumber(client, args),\n        watchContractEvent: (args) => watchContractEvent(client, args),\n        watchEvent: (args) => watchEvent(client, args),\n        watchPendingTransactions: (args) => watchPendingTransactions(client, args),\n    };\n}\n//# sourceMappingURL=public.js.map","import { createClient, } from './createClient.js';\nimport { publicActions } from './decorators/public.js';\n/**\n * Creates a Public Client with a given [Transport](https://viem.sh/docs/clients/intro) configured for a [Chain](https://viem.sh/docs/clients/chains).\n *\n * - Docs: https://viem.sh/docs/clients/public\n *\n * A Public Client is an interface to \"public\" [JSON-RPC API](https://ethereum.org/en/developers/docs/apis/json-rpc/) methods such as retrieving block numbers, transactions, reading from smart contracts, etc through [Public Actions](/docs/actions/public/introduction).\n *\n * @param config - {@link PublicClientConfig}\n * @returns A Public Client. {@link PublicClient}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n */\nexport function createPublicClient(parameters) {\n    const { key = 'public', name = 'Public Client' } = parameters;\n    const client = createClient({\n        ...parameters,\n        key,\n        name,\n        type: 'publicClient',\n    });\n    return client.extend(publicActions);\n}\n//# sourceMappingURL=createPublicClient.js.map"],"file":"assets/index-5feYa9Q8.js"}