import{aq as g,ar as E,cS as A,d9 as F,f as M,bJ as T,W as j,g as x,bF as R,bE as D,e as w,u as G,bH as O,bI as v,bM as H,dh as m,di as _,B as y,dj as S,a9 as P,cJ as B,a6 as U,ae as J,c8 as k,j as W}from"./index-Ddva7RnH.js";function z(t,s){if(!g(t,{strict:!1}))throw new E({address:t});if(!g(s,{strict:!1}))throw new E({address:s});return t.toLowerCase()===s.toLowerCase()}function K(t){const{abi:s,data:a}=t,r=A(a,0,4),e=s.find(o=>o.type==="function"&&r===F(M(o)));if(!e)throw new T(r,{docsPath:"/docs/contract/decodeFunctionData"});return{functionName:e.name,args:"inputs"in e&&e.inputs&&e.inputs.length>0?j(e.inputs,A(a,4)):void 0}}const p="/docs/contract/encodeErrorResult";function L(t){const{abi:s,errorName:a,args:r}=t;let e=s[0];if(a){const u=x({abi:s,args:r,name:a});if(!u)throw new R(a,{docsPath:p});e=u}if(e.type!=="error")throw new R(void 0,{docsPath:p});const o=M(e),n=F(o);let c="0x";if(r&&r.length>0){if(!e.inputs)throw new D(e.name,{docsPath:p});c=w(e.inputs,r)}return G([n,c])}const h="/docs/contract/encodeFunctionResult";function Q(t){const{abi:s,functionName:a,result:r}=t;let e=s[0];if(a){const n=x({abi:s,name:a});if(!n)throw new O(a,{docsPath:h});e=n}if(e.type!=="function")throw new O(void 0,{docsPath:h});if(!e.outputs)throw new v(e.name,{docsPath:h});const o=(()=>{if(e.outputs.length===0)return[];if(e.outputs.length===1)return[r];if(Array.isArray(r))return r;throw new H(r)})();return w(e.outputs,o)}const N="x-batch-gateway:true";async function q(t){const{data:s,ccipRequest:a}=t,{args:[r]}=K({abi:m,data:s}),e=[],o=[];return await Promise.all(r.map(async(n,c)=>{try{o[c]=n.urls.includes(N)?await q({data:n.data,ccipRequest:a}):await a(n),e[c]=!1}catch(u){e[c]=!0,o[c]=V(u)}})),Q({abi:m,functionName:"query",result:[e,o]})}function V(t){return t.name==="HttpRequestError"&&t.status?L({abi:m,errorName:"HttpError",args:[t.status,t.shortMessage]}):L({abi:[_],errorName:"Error",args:["shortMessage"in t?t.shortMessage:t.message]})}class X extends y{constructor({callbackSelector:s,cause:a,data:r,extraData:e,sender:o,urls:n}){var c;super(a.shortMessage||"An error occurred while fetching for an offchain result.",{cause:a,metaMessages:[...a.metaMessages||[],(c=a.metaMessages)!=null&&c.length?"":[],"Offchain Gateway Call:",n&&["  Gateway URL(s):",...n.map(u=>`    ${S(u)}`)],`  Sender: ${o}`,`  Data: ${r}`,`  Callback selector: ${s}`,`  Extra data: ${e}`].flat(),name:"OffchainLookupError"})}}class Y extends y{constructor({result:s,url:a}){super("Offchain gateway response is malformed. Response data must be a hex value.",{metaMessages:[`Gateway URL: ${S(a)}`,`Response: ${P(s)}`],name:"OffchainLookupResponseMalformedError"})}}class Z extends y{constructor({sender:s,to:a}){super("Reverted sender address does not match target contract address (`to`).",{metaMessages:[`Contract address: ${a}`,`OffchainLookup sender address: ${s}`],name:"OffchainLookupSenderMismatchError"})}}const ee="0x556f1830",$={name:"OffchainLookup",type:"error",inputs:[{name:"sender",type:"address"},{name:"urls",type:"string[]"},{name:"callData",type:"bytes"},{name:"callbackFunction",type:"bytes4"},{name:"extraData",type:"bytes"}]};async function te(t,{blockNumber:s,blockTag:a,data:r,to:e}){const{args:o}=B({data:r,abi:[$]}),[n,c,u,f,d]=o,{ccipRead:i}=t,b=i&&typeof(i==null?void 0:i.request)=="function"?i.request:I;try{if(!z(e,n))throw new Z({sender:n,to:e});const l=c.includes(N)?await q({data:u,ccipRequest:b}):await b({data:u,sender:n,urls:c}),{data:C}=await U(t,{blockNumber:s,blockTag:a,data:J([f,w([{type:"bytes"},{type:"bytes"}],[l,d])]),to:e});return C}catch(l){throw new X({callbackSelector:f,cause:l,data:r,extraData:d,sender:n,urls:c})}}async function I({data:t,sender:s,urls:a}){var e;let r=new Error("An unknown error occurred.");for(let o=0;o<a.length;o++){const n=a[o],c=n.includes("{data}")?"GET":"POST",u=c==="POST"?{data:t,sender:s}:void 0,f=c==="POST"?{"Content-Type":"application/json"}:{};try{const d=await fetch(n.replace("{sender}",s.toLowerCase()).replace("{data}",t),{body:JSON.stringify(u),headers:f,method:c});let i;if((e=d.headers.get("Content-Type"))!=null&&e.startsWith("application/json")?i=(await d.json()).data:i=await d.text(),!d.ok){r=new k({body:u,details:i!=null&&i.error?P(i.error):d.statusText,headers:d.headers,status:d.status,url:n});continue}if(!W(i)){r=new Y({result:i,url:n});continue}return i}catch(d){r=new k({body:u,details:d.message,url:n})}}throw r}const se=Object.freeze(Object.defineProperty({__proto__:null,ccipRequest:I,offchainLookup:te,offchainLookupAbiItem:$,offchainLookupSignature:ee},Symbol.toStringTag,{value:"Module"}));export{Q as a,$ as b,I as c,K as d,L as e,ee as f,se as g,z as i,N as l,te as o};
//# sourceMappingURL=ccip-U_T_BUfb.js.map
