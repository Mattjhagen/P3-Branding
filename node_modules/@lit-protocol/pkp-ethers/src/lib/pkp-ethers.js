"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PKPEthersWallet = void 0;
const address_1 = require("@ethersproject/address");
const bytes_1 = require("@ethersproject/bytes");
const hash_1 = require("@ethersproject/hash");
const hdnode_1 = require("@ethersproject/hdnode");
const keccak256_1 = require("@ethersproject/keccak256");
const properties_1 = require("@ethersproject/properties");
const random_1 = require("@ethersproject/random");
const json_wallets_1 = require("@ethersproject/json-wallets");
const transactions_1 = require("@ethersproject/transactions");
const logger_1 = require("@ethersproject/logger");
const ethers_1 = require("ethers");
const ethers_2 = require("ethers");
const pkp_base_1 = require("@lit-protocol/pkp-base");
const handler_1 = require("./handler");
const constants_1 = require("@lit-protocol/constants");
const helper_1 = require("./helper");
const logger = new logger_1.Logger(ethers_1.version);
class PKPEthersWallet extends pkp_base_1.PKPBase {
    constructor(prop) {
        super(prop);
        this.getRpc = () => {
            return this.rpcProvider.connection.url;
        };
        this.setRpc = async (rpc) => {
            this.rpcProvider = new ethers_2.ethers.providers.JsonRpcProvider(rpc);
        };
        this.handleRequest = async (payload) => {
            return await (0, handler_1.ethRequestHandler)({
                signer: this,
                payload,
            });
        };
        this.setGasPrice = (gasPrice) => {
            this.manualGasPrice = gasPrice;
        };
        this.setGasLimit = (gasLimit) => {
            this.manualGasLimit = gasLimit;
        };
        this.setNonce = (nonce) => {
            this.nonce = nonce;
        };
        this.setChainId = (chainId) => {
            this.chainId = chainId;
        };
        this.resetManualSettings = () => {
            this.manualGasPrice = undefined;
            this.manualGasLimit = undefined;
            this.nonce = undefined;
            this.chainId = undefined;
        };
        this.rpcProvider = new ethers_2.ethers.providers.JsonRpcProvider(prop.rpc ?? constants_1.LIT_CHAINS['chronicleTestnet'].rpcUrls[0]);
        this.provider = prop.provider ?? this.rpcProvider;
        (0, properties_1.defineReadOnly)(this, '_isSigner', true);
        (0, properties_1.defineReadOnly)(this, 'address', (0, transactions_1.computeAddress)(this.uncompressedPubKeyBuffer));
    }
    get publicKey() {
        return this.uncompressedPubKey;
    }
    getAddress() {
        const addr = (0, transactions_1.computeAddress)(this.uncompressedPubKeyBuffer);
        return Promise.resolve(addr);
    }
    connect() {
        throw new Error('Use setRPC to set a new JSON RPC provider');
    }
    async signTransaction(transaction) {
        this.log('signTransaction => transaction:', transaction);
        if (!this.litNodeClientReady) {
            await this.init();
        }
        const addr = await this.getAddress();
        this.log('signTransaction => addr:', addr);
        // if manual settings are set, use them
        if (this.manualGasPrice) {
            transaction.gasPrice = this.manualGasPrice;
        }
        if (this.manualGasLimit) {
            transaction.gasLimit = this.manualGasLimit;
        }
        if (this.nonce) {
            transaction.nonce = this.nonce;
        }
        if (this.chainId) {
            transaction.chainId = this.chainId;
        }
        try {
            if (!transaction['gasLimit']) {
                transaction.gasLimit = await this.rpcProvider.estimateGas(transaction);
                this.log('signTransaction => gasLimit:', transaction.gasLimit);
            }
            if (!transaction['nonce']) {
                transaction.nonce = await this.rpcProvider.getTransactionCount(addr);
                this.log('signTransaction => nonce:', transaction.nonce);
            }
            if (!transaction['chainId']) {
                transaction.chainId = (await this.rpcProvider.getNetwork()).chainId;
                this.log('signTransaction => chainId:', transaction.chainId);
            }
            if (!transaction['gasPrice']) {
                transaction.gasPrice = await this.getGasPrice();
                this.log('signTransaction => gasPrice:', transaction.gasPrice);
            }
        }
        catch (err) {
            this.log('signTransaction => unable to populate transaction with details:', err);
        }
        return (0, properties_1.resolveProperties)(transaction).then(async (tx) => {
            this.log('tx.from:', tx.from);
            this.log('this.address:', this.address);
            if (tx.from != null) {
                if ((0, address_1.getAddress)(tx.from) !== this.address) {
                    logger.throwArgumentError('transaction from address mismatch', 'transaction.from', transaction.from);
                }
                delete tx.from;
            }
            const serializedTx = (0, transactions_1.serialize)(tx);
            const unsignedTxn = (0, keccak256_1.keccak256)(serializedTx);
            // -- lit action --
            const toSign = (0, bytes_1.arrayify)(unsignedTxn);
            let signature;
            if (this.useAction) {
                this.log('running lit action => sigName: pkp-eth-sign-tx');
                signature = (await this.runLitAction(toSign, 'pkp-eth-sign-tx'))
                    .signature;
            }
            else {
                this.log('requesting signature from nodes');
                signature = (await this.runSign(toSign)).signature;
            }
            // -- reset manual settings --
            this.resetManualSettings();
            return (0, transactions_1.serialize)(tx, signature);
        });
    }
    async signMessage(message) {
        if (!this.litNodeClientReady) {
            await this.init();
        }
        const toSign = (0, bytes_1.arrayify)((0, hash_1.hashMessage)(message));
        let signature;
        if (this.useAction) {
            this.log('running lit action => sigName: pkp-eth-sign-message');
            signature = await this.runLitAction(toSign, 'pkp-eth-sign-message');
        }
        else {
            this.log('requesting signature from nodes');
            signature = await this.runSign(toSign);
        }
        return (0, bytes_1.joinSignature)({
            r: '0x' + signature.r,
            s: '0x' + signature.s,
            v: signature.recid,
        });
    }
    async _signTypedData(domain, types, value) {
        if (!this.litNodeClientReady) {
            await this.init();
        }
        // Populate any ENS names
        const populated = await hash_1._TypedDataEncoder.resolveNames(domain, types, value, 
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        (name) => {
            if (this.provider == null) {
                logger.throwError('cannot resolve ENS names without a provider', logger_1.Logger.errors.UNSUPPORTED_OPERATION, {
                    operation: 'resolveName',
                    value: name,
                });
            }
            return this.provider.resolveName(name);
        });
        // -- lit action --
        const toSign = hash_1._TypedDataEncoder.hash(populated.domain, types, populated.value);
        const toSignBuffer = (0, bytes_1.arrayify)(toSign);
        let signature;
        if (this.useAction) {
            this.log('running lit action => sigName: pkp-eth-sign-message');
            signature = await this.runLitAction(toSignBuffer, 'pkp-eth-sign-message');
        }
        else {
            this.log('requesting signature from nodes');
            signature = await this.runSign(toSignBuffer);
        }
        return (0, bytes_1.joinSignature)({
            r: '0x' + signature.r,
            s: '0x' + signature.s,
            v: signature.recid,
        });
    }
    encrypt(password, options, progressCallback) {
        if (typeof options === 'function' && !progressCallback) {
            progressCallback = options;
            options = {};
        }
        if (progressCallback && typeof progressCallback !== 'function') {
            throw new Error('invalid callback');
        }
        if (!options) {
            options = {};
        }
        return (0, json_wallets_1.encryptKeystore)(this, password, options, progressCallback);
    }
    async sendTransaction(transaction) {
        this.log('sendTransaction => transaction:', transaction);
        let res;
        let signedTxn;
        try {
            if (!(0, helper_1.isSignedTransaction)(transaction)) {
                const unsignedTxFormatted = (0, helper_1.getTransactionToSign)(transaction);
                signedTxn = await this.signTransaction(unsignedTxFormatted);
            }
            else {
                signedTxn = transaction;
            }
            res = await this.rpcProvider.sendTransaction(signedTxn);
        }
        catch (e) {
            this.log('sendTransaction => error:', e);
            throw e;
        }
        return res;
    }
    /**
     *  Static methods to create Wallet instances.
     */
    static createRandom(options) {
        let entropy = (0, random_1.randomBytes)(16);
        if (!options) {
            options = {};
        }
        if (options.extraEntropy) {
            entropy = (0, bytes_1.arrayify)((0, bytes_1.hexDataSlice)((0, keccak256_1.keccak256)((0, bytes_1.concat)([entropy, options.extraEntropy])), 0, 16));
        }
        const mnemonic = (0, hdnode_1.entropyToMnemonic)(entropy, options.locale);
        return ethers_2.Wallet.fromMnemonic(mnemonic, options.path, options.locale);
    }
    static fromEncryptedJson(json, password, progressCallback) {
        return (0, json_wallets_1.decryptJsonWallet)(json, password, progressCallback).then((account) => {
            return new ethers_2.Wallet(account);
        });
    }
    static fromEncryptedJsonSync(json, password) {
        return new ethers_2.Wallet((0, json_wallets_1.decryptJsonWalletSync)(json, password));
    }
    static fromMnemonic(mnemonic, path, wordlist) {
        if (!path) {
            path = hdnode_1.defaultPath;
        }
        return new ethers_2.Wallet(
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        hdnode_1.HDNode.fromMnemonic(mnemonic, null, wordlist).derivePath(path));
    }
    getBalance(blockTag) {
        return this.rpcProvider.getBalance(this.address, blockTag);
    }
    getTransactionCount(blockTag) {
        return this.rpcProvider.getTransactionCount(this.address, blockTag);
    }
    estimateGas(transaction) {
        return this.rpcProvider.estimateGas(transaction);
    }
    async call(transaction, blockTag) {
        if (!blockTag) {
            return this.throwError(`blockTag is required`);
        }
        const resolved = await (0, properties_1.resolveProperties)({
            transaction: this.rpcProvider._getTransactionRequest(transaction),
            blockTag: this.rpcProvider._getBlockTag(blockTag),
            ccipReadEnabled: Promise.resolve(transaction.ccipReadEnabled)
        });
        // @ts-ignore
        return this.rpcProvider._call(resolved.transaction, resolved.blockTag, resolved.ccipReadEnabled);
    }
    async getChainId() {
        return (await this.rpcProvider.getNetwork()).chainId;
    }
    getGasPrice() {
        return this.rpcProvider.getGasPrice();
    }
    getFeeData() {
        return this.rpcProvider.getFeeData();
    }
    resolveName(name) {
        return this.throwError(`Not available in PKPEthersWallet`);
    }
    checkTransaction(transaction) {
        return this.throwError(`Not available in PKPEthersWallet`);
    }
    populateTransaction(transaction) {
        return this.throwError(`Not available in PKPEthersWallet`);
    }
    _checkProvider(operation) {
        this.log("This function is not implemented yet, but will skip it for now.");
    }
    get mnemonic() {
        return this.throwError(`There's no mnemonic for a PKPWallet`);
    }
    get privateKey() {
        return this.throwError(`This PKP contains no private key (can you imagine!?)`);
    }
}
exports.PKPEthersWallet = PKPEthersWallet;
//# sourceMappingURL=pkp-ethers.js.map