import { Store } from '@tanstack/store';
import { Updater } from './utils.cjs';
import { DeepKeys, DeepValue } from './util-types.cjs';
import { FieldApi, FieldMeta } from './FieldApi.cjs';
import { ValidationCause, ValidationError, ValidationErrorMap, ValidationErrorMapKeys, Validator } from './types.cjs';

export type FormValidateFn<TFormData, TFormValidator extends Validator<TFormData, unknown> | undefined = undefined> = (props: {
    value: TFormData;
    formApi: FormApi<TFormData, TFormValidator>;
}) => ValidationError;
export type FormValidateOrFn<TFormData, TFormValidator extends Validator<TFormData, unknown> | undefined = undefined> = TFormValidator extends Validator<TFormData, infer TFN> ? TFN : FormValidateFn<TFormData, TFormValidator>;
export type FormValidateAsyncFn<TFormData, TFormValidator extends Validator<TFormData, unknown> | undefined = undefined> = (props: {
    value: TFormData;
    formApi: FormApi<TFormData, TFormValidator>;
    signal: AbortSignal;
}) => ValidationError | Promise<ValidationError>;
export type FormAsyncValidateOrFn<TFormData, TFormValidator extends Validator<TFormData, unknown> | undefined = undefined> = TFormValidator extends Validator<TFormData, infer FFN> ? FFN | FormValidateAsyncFn<TFormData, TFormValidator> : FormValidateAsyncFn<TFormData, TFormValidator>;
export interface FormValidators<TFormData, TFormValidator extends Validator<TFormData, unknown> | undefined = undefined> {
    onMount?: FormValidateOrFn<TFormData, TFormValidator>;
    onChange?: FormValidateOrFn<TFormData, TFormValidator>;
    onChangeAsync?: FormAsyncValidateOrFn<TFormData, TFormValidator>;
    onChangeAsyncDebounceMs?: number;
    onBlur?: FormValidateOrFn<TFormData, TFormValidator>;
    onBlurAsync?: FormAsyncValidateOrFn<TFormData, TFormValidator>;
    onBlurAsyncDebounceMs?: number;
    onSubmit?: FormValidateOrFn<TFormData, TFormValidator>;
    onSubmitAsync?: FormAsyncValidateOrFn<TFormData, TFormValidator>;
}
export interface FormTransform<TFormData, TFormValidator extends Validator<TFormData, unknown> | undefined = undefined> {
    fn: (formBase: FormApi<TFormData, TFormValidator>) => FormApi<TFormData, TFormValidator>;
    deps: unknown[];
}
export interface FormOptions<TFormData, TFormValidator extends Validator<TFormData, unknown> | undefined = undefined> {
    defaultValues?: TFormData;
    defaultState?: Partial<FormState<TFormData>>;
    asyncAlways?: boolean;
    asyncDebounceMs?: number;
    validatorAdapter?: TFormValidator;
    validators?: FormValidators<TFormData, TFormValidator>;
    onSubmit?: (props: {
        value: TFormData;
        formApi: FormApi<TFormData, TFormValidator>;
    }) => any | Promise<any>;
    onSubmitInvalid?: (props: {
        value: TFormData;
        formApi: FormApi<TFormData, TFormValidator>;
    }) => void;
    transform?: FormTransform<TFormData, TFormValidator>;
}
export type ValidationMeta = {
    lastAbortController: AbortController;
};
export type FieldInfo<TFormData, TFormValidator extends Validator<TFormData, unknown> | undefined = undefined> = {
    instance: FieldApi<TFormData, any, Validator<unknown, unknown> | undefined, TFormValidator> | null;
    validationMetaMap: Record<ValidationErrorMapKeys, ValidationMeta | undefined>;
};
export type FormState<TFormData> = {
    values: TFormData;
    isFormValidating: boolean;
    isFormValid: boolean;
    errors: ValidationError[];
    errorMap: ValidationErrorMap;
    validationMetaMap: Record<ValidationErrorMapKeys, ValidationMeta | undefined>;
    fieldMeta: Record<DeepKeys<TFormData>, FieldMeta>;
    isFieldsValidating: boolean;
    isFieldsValid: boolean;
    isSubmitting: boolean;
    isTouched: boolean;
    isDirty: boolean;
    isPristine: boolean;
    isSubmitted: boolean;
    isValidating: boolean;
    isValid: boolean;
    canSubmit: boolean;
    submissionAttempts: number;
};
export declare class FormApi<TFormData, TFormValidator extends Validator<TFormData, unknown> | undefined = undefined> {
    options: FormOptions<TFormData, TFormValidator>;
    store: Store<FormState<TFormData>>;
    state: FormState<TFormData>;
    fieldInfo: Record<DeepKeys<TFormData>, FieldInfo<TFormData, TFormValidator>>;
    prevTransformArray: unknown[];
    constructor(opts?: FormOptions<TFormData, TFormValidator>);
    runValidator<TValue extends {
        value: TFormData;
        formApi: FormApi<any, any>;
    }, TType extends 'validate' | 'validateAsync'>(props: {
        validate: TType extends 'validate' ? FormValidateOrFn<TFormData, TFormValidator> : FormAsyncValidateOrFn<TFormData, TFormValidator>;
        value: TValue;
        type: TType;
    }): ReturnType<ReturnType<Validator<any>>[TType]>;
    mount: () => void;
    update: (options?: FormOptions<TFormData, TFormValidator>) => void;
    reset: () => void;
    validateAllFields: (cause: ValidationCause) => Promise<ValidationError[]>;
    validateSync: (cause: ValidationCause) => {
        hasErrored: boolean;
    };
    validateAsync: (cause: ValidationCause) => Promise<ValidationError[]>;
    validate: (cause: ValidationCause) => ValidationError[] | Promise<ValidationError[]>;
    handleSubmit: () => Promise<void>;
    getFieldValue: <TField extends DeepKeys<TFormData>>(field: TField) => DeepValue<TFormData, TField>;
    getFieldMeta: <TField extends DeepKeys<TFormData>>(field: TField) => FieldMeta | undefined;
    getFieldInfo: <TField extends DeepKeys<TFormData>>(field: TField) => FieldInfo<TFormData, TFormValidator>;
    setFieldMeta: <TField extends DeepKeys<TFormData>>(field: TField, updater: Updater<FieldMeta>) => void;
    resetFieldMeta: <TField extends DeepKeys<TFormData>>(fieldMeta: Record<TField, FieldMeta>) => Record<TField, FieldMeta>;
    setFieldValue: <TField extends DeepKeys<TFormData>>(field: TField, updater: Updater<DeepValue<TFormData, TField>>, opts?: {
        touch?: boolean;
    }) => void;
    deleteField: <TField extends DeepKeys<TFormData>>(field: TField) => void;
    pushFieldValue: <TField extends DeepKeys<TFormData>>(field: TField, value: DeepValue<TFormData, TField> extends any[] ? DeepValue<TFormData, TField>[number] : never, opts?: {
        touch?: boolean;
    }) => void;
    insertFieldValue: <TField extends DeepKeys<TFormData>>(field: TField, index: number, value: DeepValue<TFormData, TField> extends any[] ? DeepValue<TFormData, TField>[number] : never, opts?: {
        touch?: boolean;
    }) => void;
    removeFieldValue: <TField extends DeepKeys<TFormData>>(field: TField, index: number, opts?: {
        touch?: boolean;
    }) => void;
    swapFieldValues: <TField extends DeepKeys<TFormData>>(field: TField, index1: number, index2: number) => void;
    moveFieldValues: <TField extends DeepKeys<TFormData>>(field: TField, index1: number, index2: number) => void;
}
