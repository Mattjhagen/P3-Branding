{"version":3,"file":"FormApi.cjs","sources":["../../src/FormApi.ts"],"sourcesContent":["import { Store } from '@tanstack/store'\nimport {\n  deleteBy,\n  functionalUpdate,\n  getAsyncValidatorArray,\n  getBy,\n  getSyncValidatorArray,\n  isNonEmptyArray,\n  setBy,\n} from './utils'\nimport type { Updater } from './utils'\nimport type { DeepKeys, DeepValue } from './util-types'\nimport type { FieldApi, FieldMeta } from './FieldApi'\nimport type {\n  ValidationCause,\n  ValidationError,\n  ValidationErrorMap,\n  ValidationErrorMapKeys,\n  Validator,\n} from './types'\n\nexport type FormValidateFn<\n  TFormData,\n  TFormValidator extends Validator<TFormData, unknown> | undefined = undefined,\n> = (props: {\n  value: TFormData\n  formApi: FormApi<TFormData, TFormValidator>\n}) => ValidationError\n\nexport type FormValidateOrFn<\n  TFormData,\n  TFormValidator extends Validator<TFormData, unknown> | undefined = undefined,\n> = TFormValidator extends Validator<TFormData, infer TFN>\n  ? TFN\n  : FormValidateFn<TFormData, TFormValidator>\n\nexport type FormValidateAsyncFn<\n  TFormData,\n  TFormValidator extends Validator<TFormData, unknown> | undefined = undefined,\n> = (props: {\n  value: TFormData\n  formApi: FormApi<TFormData, TFormValidator>\n  signal: AbortSignal\n}) => ValidationError | Promise<ValidationError>\n\nexport type FormAsyncValidateOrFn<\n  TFormData,\n  TFormValidator extends Validator<TFormData, unknown> | undefined = undefined,\n> = TFormValidator extends Validator<TFormData, infer FFN>\n  ? FFN | FormValidateAsyncFn<TFormData, TFormValidator>\n  : FormValidateAsyncFn<TFormData, TFormValidator>\n\nexport interface FormValidators<\n  TFormData,\n  TFormValidator extends Validator<TFormData, unknown> | undefined = undefined,\n> {\n  onMount?: FormValidateOrFn<TFormData, TFormValidator>\n  onChange?: FormValidateOrFn<TFormData, TFormValidator>\n  onChangeAsync?: FormAsyncValidateOrFn<TFormData, TFormValidator>\n  onChangeAsyncDebounceMs?: number\n  onBlur?: FormValidateOrFn<TFormData, TFormValidator>\n  onBlurAsync?: FormAsyncValidateOrFn<TFormData, TFormValidator>\n  onBlurAsyncDebounceMs?: number\n  onSubmit?: FormValidateOrFn<TFormData, TFormValidator>\n  onSubmitAsync?: FormAsyncValidateOrFn<TFormData, TFormValidator>\n}\n\nexport interface FormTransform<\n  TFormData,\n  TFormValidator extends Validator<TFormData, unknown> | undefined = undefined,\n> {\n  fn: (\n    formBase: FormApi<TFormData, TFormValidator>,\n  ) => FormApi<TFormData, TFormValidator>\n  deps: unknown[]\n}\n\nexport interface FormOptions<\n  TFormData,\n  TFormValidator extends Validator<TFormData, unknown> | undefined = undefined,\n> {\n  defaultValues?: TFormData\n  defaultState?: Partial<FormState<TFormData>>\n  asyncAlways?: boolean\n  asyncDebounceMs?: number\n  validatorAdapter?: TFormValidator\n  validators?: FormValidators<TFormData, TFormValidator>\n  onSubmit?: (props: {\n    value: TFormData\n    formApi: FormApi<TFormData, TFormValidator>\n  }) => any | Promise<any>\n  onSubmitInvalid?: (props: {\n    value: TFormData\n    formApi: FormApi<TFormData, TFormValidator>\n  }) => void\n  transform?: FormTransform<TFormData, TFormValidator>\n}\n\nexport type ValidationMeta = {\n  lastAbortController: AbortController\n}\n\nexport type FieldInfo<\n  TFormData,\n  TFormValidator extends Validator<TFormData, unknown> | undefined = undefined,\n> = {\n  instance: FieldApi<\n    TFormData,\n    any,\n    Validator<unknown, unknown> | undefined,\n    TFormValidator\n  > | null\n  validationMetaMap: Record<ValidationErrorMapKeys, ValidationMeta | undefined>\n}\n\nexport type FormState<TFormData> = {\n  values: TFormData\n  // Form Validation\n  isFormValidating: boolean\n  isFormValid: boolean\n  errors: ValidationError[]\n  errorMap: ValidationErrorMap\n  validationMetaMap: Record<ValidationErrorMapKeys, ValidationMeta | undefined>\n  // Fields\n  fieldMeta: Record<DeepKeys<TFormData>, FieldMeta>\n  isFieldsValidating: boolean\n  isFieldsValid: boolean\n  isSubmitting: boolean\n  // General\n  isTouched: boolean\n  isDirty: boolean\n  isPristine: boolean\n  isSubmitted: boolean\n  isValidating: boolean\n  isValid: boolean\n  canSubmit: boolean\n  submissionAttempts: number\n}\n\nfunction getDefaultFormState<TFormData>(\n  defaultState: Partial<FormState<TFormData>>,\n): FormState<TFormData> {\n  return {\n    values: defaultState.values ?? ({} as never),\n    errors: defaultState.errors ?? [],\n    errorMap: defaultState.errorMap ?? {},\n    fieldMeta: defaultState.fieldMeta ?? ({} as never),\n    canSubmit: defaultState.canSubmit ?? true,\n    isFieldsValid: defaultState.isFieldsValid ?? false,\n    isFieldsValidating: defaultState.isFieldsValidating ?? false,\n    isFormValid: defaultState.isFormValid ?? false,\n    isFormValidating: defaultState.isFormValidating ?? false,\n    isSubmitted: defaultState.isSubmitted ?? false,\n    isSubmitting: defaultState.isSubmitting ?? false,\n    isTouched: defaultState.isTouched ?? false,\n    isPristine: defaultState.isPristine ?? true,\n    isDirty: defaultState.isDirty ?? false,\n    isValid: defaultState.isValid ?? false,\n    isValidating: defaultState.isValidating ?? false,\n    submissionAttempts: defaultState.submissionAttempts ?? 0,\n    validationMetaMap: defaultState.validationMetaMap ?? {\n      onChange: undefined,\n      onBlur: undefined,\n      onSubmit: undefined,\n      onMount: undefined,\n      onServer: undefined,\n    },\n  }\n}\n\nexport class FormApi<\n  TFormData,\n  TFormValidator extends Validator<TFormData, unknown> | undefined = undefined,\n> {\n  options: FormOptions<TFormData, TFormValidator> = {}\n  store!: Store<FormState<TFormData>>\n  // Do not use __state directly, as it is not reactive.\n  // Please use form.useStore() utility to subscribe to state\n  state!: FormState<TFormData>\n  // // This carries the context for nested fields\n  fieldInfo: Record<DeepKeys<TFormData>, FieldInfo<TFormData, TFormValidator>> =\n    {} as any\n\n  prevTransformArray: unknown[] = []\n\n  constructor(opts?: FormOptions<TFormData, TFormValidator>) {\n    this.store = new Store<FormState<TFormData>>(\n      getDefaultFormState({\n        ...(opts?.defaultState as any),\n        values: opts?.defaultValues ?? opts?.defaultState?.values,\n        isFormValid: true,\n      }),\n      {\n        onUpdate: () => {\n          let { state } = this.store\n          // Computed state\n          const fieldMetaValues = Object.values(state.fieldMeta) as (\n            | FieldMeta\n            | undefined\n          )[]\n\n          const isFieldsValidating = fieldMetaValues.some(\n            (field) => field?.isValidating,\n          )\n\n          const isFieldsValid = !fieldMetaValues.some(\n            (field) =>\n              field?.errorMap &&\n              isNonEmptyArray(Object.values(field.errorMap).filter(Boolean)),\n          )\n\n          const isTouched = fieldMetaValues.some((field) => field?.isTouched)\n\n          const isDirty = fieldMetaValues.some((field) => field?.isDirty)\n          const isPristine = !isDirty\n\n          const isValidating = isFieldsValidating || state.isFormValidating\n          state.errors = Object.values(state.errorMap).filter(\n            (val: unknown) => val !== undefined,\n          )\n          const isFormValid = state.errors.length === 0\n          const isValid = isFieldsValid && isFormValid\n          const canSubmit =\n            (state.submissionAttempts === 0 && !isTouched) ||\n            (!isValidating && !state.isSubmitting && isValid)\n\n          state = {\n            ...state,\n            isFieldsValidating,\n            isFieldsValid,\n            isFormValid,\n            isValid,\n            canSubmit,\n            isTouched,\n            isPristine,\n            isDirty,\n          }\n\n          this.state = state\n          this.store.state = this.state\n\n          // Only run transform if state has shallowly changed - IE how React.useEffect works\n          const transformArray = this.options.transform?.deps ?? []\n          const shouldTransform =\n            transformArray.length !== this.prevTransformArray.length ||\n            transformArray.some((val, i) => val !== this.prevTransformArray[i])\n\n          if (shouldTransform) {\n            // This mutates the state\n            this.options.transform?.fn(this)\n            this.store.state = this.state\n            this.prevTransformArray = transformArray\n          }\n        },\n      },\n    )\n\n    this.state = this.store.state\n\n    this.update(opts || {})\n  }\n\n  runValidator<\n    TValue extends { value: TFormData; formApi: FormApi<any, any> },\n    TType extends 'validate' | 'validateAsync',\n  >(props: {\n    validate: TType extends 'validate'\n      ? FormValidateOrFn<TFormData, TFormValidator>\n      : FormAsyncValidateOrFn<TFormData, TFormValidator>\n    value: TValue\n    type: TType\n  }): ReturnType<ReturnType<Validator<any>>[TType]> {\n    const adapter = this.options.validatorAdapter\n    if (adapter && typeof props.validate !== 'function') {\n      return adapter()[props.type](props.value, props.validate) as never\n    }\n\n    return (props.validate as FormValidateFn<any, any>)(props.value) as never\n  }\n\n  mount = () => {\n    const { onMount } = this.options.validators || {}\n    if (!onMount) return\n    const error = this.runValidator({\n      validate: onMount,\n      value: {\n        value: this.state.values,\n        formApi: this,\n      },\n      type: 'validate',\n    })\n    if (error) {\n      this.store.setState((prev) => ({\n        ...prev,\n        errorMap: { ...prev.errorMap, onMount: error },\n      }))\n    }\n  }\n\n  update = (options?: FormOptions<TFormData, TFormValidator>) => {\n    if (!options) return\n\n    const oldOptions = this.options\n\n    // Options need to be updated first so that when the store is updated, the state is correct for the derived state\n    this.options = options\n\n    this.store.batch(() => {\n      const shouldUpdateValues =\n        options.defaultValues &&\n        options.defaultValues !== oldOptions.defaultValues &&\n        !this.state.isTouched\n\n      const shouldUpdateState =\n        options.defaultState !== oldOptions.defaultState &&\n        !this.state.isTouched\n\n      this.store.setState(() =>\n        getDefaultFormState(\n          Object.assign(\n            {},\n            this.state as any,\n\n            shouldUpdateState ? options.defaultState : {},\n\n            shouldUpdateValues\n              ? {\n                  values: options.defaultValues,\n                }\n              : {},\n          ),\n        ),\n      )\n    })\n  }\n\n  reset = () => {\n    const { fieldMeta: currentFieldMeta } = this.state\n    const fieldMeta = this.resetFieldMeta(currentFieldMeta)\n    this.store.setState(() =>\n      getDefaultFormState({\n        ...(this.options.defaultState as any),\n        values: this.options.defaultValues ?? this.options.defaultState?.values,\n        fieldMeta,\n      }),\n    )\n  }\n\n  validateAllFields = async (cause: ValidationCause) => {\n    const fieldValidationPromises: Promise<ValidationError[]>[] = [] as any\n    this.store.batch(() => {\n      void (\n        Object.values(this.fieldInfo) as FieldInfo<any, TFormValidator>[]\n      ).forEach((field) => {\n        if (!field.instance) return\n        const fieldInstance = field.instance\n        // Validate the field\n        fieldValidationPromises.push(\n          Promise.resolve().then(() => fieldInstance.validate(cause)),\n        )\n        // If any fields are not touched\n        if (!field.instance.state.meta.isTouched) {\n          // Mark them as touched\n          field.instance.setMeta((prev) => ({ ...prev, isTouched: true }))\n        }\n      })\n    })\n\n    const fieldErrorMapMap = await Promise.all(fieldValidationPromises)\n    return fieldErrorMapMap.flat()\n  }\n\n  // TODO: This code is copied from FieldApi, we should refactor to share\n  validateSync = (cause: ValidationCause) => {\n    const validates = getSyncValidatorArray(cause, this.options)\n    let hasErrored = false as boolean\n\n    this.store.batch(() => {\n      for (const validateObj of validates) {\n        if (!validateObj.validate) continue\n\n        const error = normalizeError(\n          this.runValidator({\n            validate: validateObj.validate,\n            value: {\n              value: this.state.values,\n              formApi: this,\n            },\n            type: 'validate',\n          }),\n        )\n        const errorMapKey = getErrorMapKey(validateObj.cause)\n        if (this.state.errorMap[errorMapKey] !== error) {\n          this.store.setState((prev) => ({\n            ...prev,\n            errorMap: {\n              ...prev.errorMap,\n              [errorMapKey]: error,\n            },\n          }))\n        }\n        if (error) {\n          hasErrored = true\n        }\n      }\n    })\n\n    /**\n     *  when we have an error for onSubmit in the state, we want\n     *  to clear the error as soon as the user enters a valid value in the field\n     */\n    const submitErrKey = getErrorMapKey('submit')\n    if (\n      this.state.errorMap[submitErrKey] &&\n      cause !== 'submit' &&\n      !hasErrored\n    ) {\n      this.store.setState((prev) => ({\n        ...prev,\n        errorMap: {\n          ...prev.errorMap,\n          [submitErrKey]: undefined,\n        },\n      }))\n    }\n\n    return { hasErrored }\n  }\n\n  validateAsync = async (\n    cause: ValidationCause,\n  ): Promise<ValidationError[]> => {\n    const validates = getAsyncValidatorArray(cause, this.options)\n\n    if (!this.state.isFormValidating) {\n      this.store.setState((prev) => ({ ...prev, isFormValidating: true }))\n    }\n\n    /**\n     * We have to use a for loop and generate our promises this way, otherwise it won't be sync\n     * when there are no validators needed to be run\n     */\n    const promises: Promise<ValidationError | undefined>[] = []\n\n    for (const validateObj of validates) {\n      if (!validateObj.validate) continue\n      const key = getErrorMapKey(validateObj.cause)\n      const fieldValidatorMeta = this.state.validationMetaMap[key]\n\n      fieldValidatorMeta?.lastAbortController.abort()\n      const controller = new AbortController()\n\n      this.state.validationMetaMap[key] = {\n        lastAbortController: controller,\n      }\n\n      promises.push(\n        new Promise<ValidationError | undefined>(async (resolve) => {\n          let rawError!: ValidationError | undefined\n          try {\n            rawError = await new Promise((rawResolve, rawReject) => {\n              setTimeout(async () => {\n                if (controller.signal.aborted) return rawResolve(undefined)\n                try {\n                  rawResolve(\n                    await this.runValidator({\n                      validate: validateObj.validate!,\n                      value: {\n                        value: this.state.values,\n                        formApi: this,\n                        signal: controller.signal,\n                      },\n                      type: 'validateAsync',\n                    }),\n                  )\n                } catch (e) {\n                  rawReject(e)\n                }\n              }, validateObj.debounceMs)\n            })\n          } catch (e: unknown) {\n            rawError = e as ValidationError\n          }\n          const error = normalizeError(rawError)\n          this.store.setState((prev) => ({\n            ...prev,\n            errorMap: {\n              ...prev.errorMap,\n              [getErrorMapKey(cause)]: error,\n            },\n          }))\n\n          resolve(error)\n        }),\n      )\n    }\n\n    let results: ValidationError[] = []\n    if (promises.length) {\n      results = await Promise.all(promises)\n    }\n\n    this.store.setState((prev) => ({\n      ...prev,\n      isFormValidating: false,\n    }))\n\n    return results.filter(Boolean)\n  }\n\n  validate = (\n    cause: ValidationCause,\n  ): ValidationError[] | Promise<ValidationError[]> => {\n    // Attempt to sync validate first\n    const { hasErrored } = this.validateSync(cause)\n\n    if (hasErrored && !this.options.asyncAlways) {\n      return this.state.errors\n    }\n\n    // No error? Attempt async validation\n    return this.validateAsync(cause)\n  }\n\n  handleSubmit = async () => {\n    // Check to see that the form and all fields have been touched\n    // If they have not, touch them all and run validation\n    // Run form validation\n    // Submit the form\n\n    this.store.setState((old) => ({\n      ...old,\n      // Submission attempts mark the form as not submitted\n      isSubmitted: false,\n      // Count submission attempts\n      submissionAttempts: old.submissionAttempts + 1,\n    }))\n\n    // Don't let invalid forms submit\n    if (!this.state.canSubmit) return\n\n    this.store.setState((d) => ({ ...d, isSubmitting: true }))\n\n    const done = () => {\n      this.store.setState((prev) => ({ ...prev, isSubmitting: false }))\n    }\n\n    // Validate all fields\n    await this.validateAllFields('submit')\n\n    // Fields are invalid, do not submit\n    if (!this.state.isFieldsValid) {\n      done()\n      this.options.onSubmitInvalid?.({\n        value: this.state.values,\n        formApi: this,\n      })\n      return\n    }\n\n    // Run validation for the form\n    await this.validate('submit')\n\n    if (!this.state.isValid) {\n      done()\n      this.options.onSubmitInvalid?.({\n        value: this.state.values,\n        formApi: this,\n      })\n      return\n    }\n\n    try {\n      // Run the submit code\n      await this.options.onSubmit?.({ value: this.state.values, formApi: this })\n\n      this.store.batch(() => {\n        this.store.setState((prev) => ({ ...prev, isSubmitted: true }))\n        done()\n      })\n    } catch (err) {\n      done()\n      throw err\n    }\n  }\n\n  getFieldValue = <TField extends DeepKeys<TFormData>>(\n    field: TField,\n  ): DeepValue<TFormData, TField> => getBy(this.state.values, field)\n\n  getFieldMeta = <TField extends DeepKeys<TFormData>>(\n    field: TField,\n  ): FieldMeta | undefined => {\n    return this.state.fieldMeta[field]\n  }\n\n  getFieldInfo = <TField extends DeepKeys<TFormData>>(\n    field: TField,\n  ): FieldInfo<TFormData, TFormValidator> => {\n    // eslint-disable-next-line  @typescript-eslint/no-unnecessary-condition\n    return (this.fieldInfo[field] ||= {\n      instance: null,\n      validationMetaMap: {\n        onChange: undefined,\n        onBlur: undefined,\n        onSubmit: undefined,\n        onMount: undefined,\n        onServer: undefined,\n      },\n    })\n  }\n\n  setFieldMeta = <TField extends DeepKeys<TFormData>>(\n    field: TField,\n    updater: Updater<FieldMeta>,\n  ) => {\n    this.store.setState((prev) => {\n      return {\n        ...prev,\n        fieldMeta: {\n          ...prev.fieldMeta,\n          [field]: functionalUpdate(updater, prev.fieldMeta[field]),\n        },\n      }\n    })\n  }\n\n  resetFieldMeta = <TField extends DeepKeys<TFormData>>(\n    fieldMeta: Record<TField, FieldMeta>,\n  ): Record<TField, FieldMeta> => {\n    return Object.keys(fieldMeta).reduce(\n      (acc: Record<TField, FieldMeta>, key) => {\n        const fieldKey = key as TField\n        acc[fieldKey] = {\n          isValidating: false,\n          isTouched: false,\n          isDirty: false,\n          isPristine: true,\n          touchedErrors: [],\n          errors: [],\n          errorMap: {},\n        }\n        return acc\n      },\n      {} as Record<TField, FieldMeta>,\n    )\n  }\n\n  setFieldValue = <TField extends DeepKeys<TFormData>>(\n    field: TField,\n    updater: Updater<DeepValue<TFormData, TField>>,\n    opts?: { touch?: boolean },\n  ) => {\n    const touch = opts?.touch\n\n    this.store.batch(() => {\n      if (touch) {\n        this.setFieldMeta(field, (prev) => ({\n          ...prev,\n          isTouched: true,\n          isDirty: true,\n        }))\n      }\n\n      this.store.setState((prev) => {\n        return {\n          ...prev,\n          values: setBy(prev.values, field, updater),\n        }\n      })\n    })\n  }\n\n  deleteField = <TField extends DeepKeys<TFormData>>(field: TField) => {\n    this.store.setState((prev) => {\n      const newState = { ...prev }\n      newState.values = deleteBy(newState.values, field)\n      delete newState.fieldMeta[field]\n\n      return newState\n    })\n    delete this.fieldInfo[field]\n  }\n\n  pushFieldValue = <TField extends DeepKeys<TFormData>>(\n    field: TField,\n    value: DeepValue<TFormData, TField> extends any[]\n      ? DeepValue<TFormData, TField>[number]\n      : never,\n    opts?: { touch?: boolean },\n  ) => {\n    return this.setFieldValue(\n      field,\n      (prev) => [...(Array.isArray(prev) ? prev : []), value] as any,\n      opts,\n    )\n  }\n\n  insertFieldValue = <TField extends DeepKeys<TFormData>>(\n    field: TField,\n    index: number,\n    value: DeepValue<TFormData, TField> extends any[]\n      ? DeepValue<TFormData, TField>[number]\n      : never,\n    opts?: { touch?: boolean },\n  ) => {\n    this.setFieldValue(\n      field,\n      (prev) => {\n        return (prev as DeepValue<TFormData, TField>[]).map((d, i) =>\n          i === index ? value : d,\n        ) as any\n      },\n      opts,\n    )\n  }\n\n  removeFieldValue = <TField extends DeepKeys<TFormData>>(\n    field: TField,\n    index: number,\n    opts?: { touch?: boolean },\n  ) => {\n    this.setFieldValue(\n      field,\n      (prev) => {\n        return (prev as DeepValue<TFormData, TField>[]).filter(\n          (_d, i) => i !== index,\n        ) as any\n      },\n      opts,\n    )\n  }\n\n  swapFieldValues = <TField extends DeepKeys<TFormData>>(\n    field: TField,\n    index1: number,\n    index2: number,\n  ) => {\n    this.setFieldValue(field, (prev: any) => {\n      const prev1 = prev[index1]!\n      const prev2 = prev[index2]!\n      return setBy(setBy(prev, `${index1}`, prev2), `${index2}`, prev1)\n    })\n  }\n\n  moveFieldValues = <TField extends DeepKeys<TFormData>>(\n    field: TField,\n    index1: number,\n    index2: number,\n  ) => {\n    this.setFieldValue(field, (prev: any) => {\n      prev.splice(index2, 0, prev.splice(index1, 1)[0])\n      return prev\n    })\n  }\n}\n\nfunction normalizeError(rawError?: ValidationError) {\n  if (rawError) {\n    if (typeof rawError !== 'string') {\n      return 'Invalid Form Values'\n    }\n\n    return rawError\n  }\n\n  return undefined\n}\n\nfunction getErrorMapKey(cause: ValidationCause) {\n  switch (cause) {\n    case 'submit':\n      return 'onSubmit'\n    case 'blur':\n      return 'onBlur'\n    case 'mount':\n      return 'onMount'\n    case 'server':\n      return 'onServer'\n    case 'change':\n    default:\n      return 'onChange'\n  }\n}\n"],"names":["_a","getSyncValidatorArray","getAsyncValidatorArray","getBy","functionalUpdate","opts","setBy","deleteBy","Store","isNonEmptyArray"],"mappings":"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"}