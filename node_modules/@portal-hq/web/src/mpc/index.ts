import { PortalMpcError } from './errors'

import Portal, { BackupMethods } from '../index'
import type {
  BackupArgs,
  Balance,
  ClientWithCustodianData,
  GenerateArgs,
  GetTransactionsOrder,
  IframeConfigurationOptions,
  LegacyRecoverArgs,
  MpcOptions,
  MpcStatus,
  NFT,
  PortalError,
  ProgressCallback,
  QuoteArgs,
  QuoteResponse,
  RecoverArgs,
  SignArgs,
  SimulateTransactionParam,
  SimulatedTransaction,
  Transaction,
  WorkerResult,
} from '../../types'

const WEB_SDK_VERSION = '0.0.8'

class Mpc {
  public iframe?: HTMLIFrameElement

  private portal: Portal

  constructor({ portal }: MpcOptions) {
    this.portal = portal

    // Handle scoping of certain functions
    this.configureIframe = this.configureIframe.bind(this)

    // Create the iFrame for MPC operations
    this.appendIframe()
  }

  /*******************************
   * Wallet Methods
   *******************************/

  public async backup(
    data: BackupArgs,
    progress: ProgressCallback = () => {
      // Noop
    },
  ): Promise<string> {
    const message = {
      type: 'portal:wasm:backup',
      data,
    }

    // validates password config for password backup
    this.validateBackupConfig(data)

    return new Promise((resolve, reject) => {
      // Create a function to be bound when backup is triggered
      const handleBackup = (event: MessageEvent<WorkerResult>) => {
        const { type, data: result } = event.data
        const { origin } = event

        // ignore any broadcast postMessages
        if (origin !== this.getOrigin()) {
          return
        }

        if (type === 'portal:wasm:backupError') {
          // Remove the event listeners
          window.removeEventListener('message', handleBackup)
          window.removeEventListener('message', handleProgress)

          // Reject the promise with the error
          return reject(new PortalMpcError(result as PortalError))
        } else if (type === 'portal:wasm:backupResult') {
          // Remove the event listeners
          window.removeEventListener('message', handleBackup)
          window.removeEventListener('message', handleProgress)

          // Resolve the promise with the result
          resolve(result as string)
        }
      }

      const handleProgress = (message: MessageEvent<WorkerResult>) => {
        const { type, data: status } = message.data
        const { origin } = message

        // ignore any broadcast postMessages
        if (origin !== this.getOrigin()) {
          return
        }

        if (type === 'portal:wasm:backupProgress') {
          void progress(status as MpcStatus)
        }
      }

      // Bind the function to the message event
      window.addEventListener('message', handleBackup)
      window.addEventListener('message', handleProgress)

      // Send the request to the iframe
      this.postMessage(message)
    })
  }

  public clearLocalWallet(): Promise<boolean> {
    return new Promise((resolve) => {
      const handleClearLocalWallet = (event: MessageEvent<WorkerResult>) => {
        const { type } = event.data
        const { origin } = event

        // ignore any broadcast postMessages
        if (origin !== this.getOrigin()) {
          return
        }

        if (type === 'portal:destroyResult') {
          // Remove the event listener
          window.removeEventListener('message', handleClearLocalWallet)

          // Resolve the promise with the result
          resolve(true)
        }
      }

      // Bind the function to the message event
      window.addEventListener('message', handleClearLocalWallet)

      // Send the request to the iframe
      this.postMessage({
        type: 'portal:destroy',
        data: {},
      })
    })
  }

  public async generate(
    data: GenerateArgs,
    progress: ProgressCallback = () => {
      // Noop
    },
  ): Promise<string> {
    const message = {
      type: 'portal:wasm:generate',
      data,
    }

    return new Promise((resolve, reject) => {
      // Create a function to be bound when generate is triggered
      const handleGenerate = (event: MessageEvent<WorkerResult>) => {
        const { type, data: result } = event.data
        const { origin } = event

        // ignore any broadcast postMessages
        if (origin !== this.getOrigin()) {
          return
        }

        // Handle errors
        if (type === 'portal:wasm:generateError') {
          // Remove the event listeners
          window.removeEventListener('message', handleGenerate)
          window.removeEventListener('message', handleProgress)

          // Reject the promise with the error
          return reject(new PortalMpcError(result as PortalError))
        } else if (type === 'portal:wasm:generateResult') {
          // Remove the event listeners
          window.removeEventListener('message', handleGenerate)
          window.removeEventListener('message', handleProgress)

          // Resolve the promise with the result
          resolve(result as string)
        }
      }

      const handleProgress = (message: MessageEvent<WorkerResult>) => {
        const { type, data: status } = message.data
        const { origin } = message

        // ignore any broadcast postMessages
        if (origin !== this.getOrigin()) {
          return
        }

        if (type === 'portal:wasm:generateProgress') {
          void progress(status as MpcStatus)
        }
      }

      // Bind the function to the message event
      window.addEventListener('message', handleGenerate)
      window.addEventListener('message', handleProgress)

      // Send the request to the iframe
      this.postMessage(message)
    })
  }

  public async getAddress(): Promise<string> {
    const message = {
      type: 'portal:address',
      data: {},
    }

    return new Promise((resolve) => {
      // Create a function to be bound when getAddress is triggered
      const handleGetAddress = (event: MessageEvent<WorkerResult>) => {
        const { type, data: result } = event.data
        const { origin } = event

        // ignore any broadcast postMessages
        if (origin !== this.getOrigin()) {
          return
        }

        // Check that the message is the one we're looking for
        if (type === 'portal:addressResult') {
          // Remove the event listener
          window.removeEventListener('message', handleGetAddress)

          // Resolve the promise with the result
          resolve(result as string)
        }
      }

      // Bind the function to the message event
      window.addEventListener('message', handleGetAddress)

      // Send the request to the iframe
      this.postMessage(message)
    })
  }

  public async recover(
    data: RecoverArgs,
    progress: ProgressCallback = () => {
      // Noop
    },
  ): Promise<string> {
    return new Promise((resolve, reject) => {
      const handleRecover = (message: MessageEvent<WorkerResult>) => {
        const { type, data } = message.data
        const { origin } = message

        // ignore any broadcast postMessages
        if (origin !== this.getOrigin()) {
          return
        }

        if (type === 'portal:wasm:recoverError') {
          // Remove the event listeners
          window.removeEventListener('message', handleRecover)
          window.removeEventListener('message', handleProgress)

          reject(new PortalMpcError(data as PortalError))
        } else if (type === 'portal:wasm:recoverResult') {
          // Remove the event listeners
          window.removeEventListener('message', handleRecover)
          window.removeEventListener('message', handleProgress)

          resolve(data as string)
        }
      }

      const handleProgress = (message: MessageEvent<WorkerResult>) => {
        const { type, data: status } = message.data
        const { origin } = message

        // ignore any broadcast postMessages
        if (origin !== this.getOrigin()) {
          return
        }

        if (type === 'portal:wasm:recoverProgress') {
          void progress(status as MpcStatus)
        }
      }

      window.addEventListener('message', handleRecover)
      window.addEventListener('message', handleProgress)

      this.postMessage({
        type: 'portal:wasm:recover',
        data,
      })
    })
  }

  public async legacyRecover(
    data: LegacyRecoverArgs,
    progress: ProgressCallback = () => {
      // Noop
    },
  ): Promise<string> {
    return new Promise((resolve, reject) => {
      const handleRecover = (message: MessageEvent<WorkerResult>) => {
        const { type, data } = message.data
        const { origin } = message

        // ignore any broadcast postMessages
        if (origin !== this.getOrigin()) {
          return
        }

        if (type === 'portal:wasm:legacyRecoverError') {
          // Remove the event listeners
          window.removeEventListener('message', handleRecover)
          window.removeEventListener('message', handleProgress)

          reject(new PortalMpcError(data as PortalError))
        } else if (type === 'portal:wasm:legacyRecoverResult') {
          // Remove the event listeners
          window.removeEventListener('message', handleRecover)
          window.removeEventListener('message', handleProgress)

          resolve(data as string)
        }
      }

      const handleProgress = (message: MessageEvent<WorkerResult>) => {
        const { type, data: status } = message.data
        const { origin } = message

        // ignore any broadcast postMessages
        if (origin !== this.getOrigin()) {
          return
        }

        if (type === 'portal:wasm:legacyRecoverProgress') {
          void progress(status as MpcStatus)
        }
      }

      window.addEventListener('message', handleRecover)
      window.addEventListener('message', handleProgress)

      this.postMessage({
        type: 'portal:wasm:legacyRecover',
        data,
      })
    })
  }

  public async sign(
    data: SignArgs,
    progress: ProgressCallback = () => {
      // Noop
    },
  ): Promise<string> {
    const message = {
      type: 'portal:wasm:sign',
      data,
    }

    return new Promise((resolve, reject) => {
      // Create a function to be bound when sign is triggered
      const handleSign = (event: MessageEvent<WorkerResult>) => {
        const { type, data: result } = event.data
        const { origin } = event

        // ignore any broadcast postMessages
        if (origin !== this.getOrigin()) {
          return
        }

        if (type === 'portal:wasm:signError') {
          // Remove the event listeners
          window.removeEventListener('message', handleSign)
          window.removeEventListener('message', handleProgress)

          // Reject the promise with the error
          return reject(new PortalMpcError(result as PortalError))
        } else if (type === 'portal:wasm:signResult') {
          // Remove the event listeners
          window.removeEventListener('message', handleSign)
          window.removeEventListener('message', handleProgress)

          // Resolve the promise with the result
          resolve(result as string)
        }
      }

      const handleProgress = (message: MessageEvent<WorkerResult>) => {
        const { type, data: status } = message.data
        const { origin } = message

        // ignore any broadcast postMessages
        if (origin !== this.getOrigin()) {
          return
        }

        if (type === 'portal:wasm:signProgress') {
          void progress(status as MpcStatus)
        }
      }

      // Bind the functions to the message event
      window.addEventListener('message', handleSign)
      window.addEventListener('message', handleProgress)

      // Send the request to the iframe
      this.postMessage(message)
    })
  }

  /*******************************
   * API Methods
   *******************************/

  public async getBalances(): Promise<Balance[]> {
    return new Promise((resolve, reject) => {
      const handleGetBalances = (event: MessageEvent<WorkerResult>) => {
        const { type, data } = event.data
        const { origin } = event

        // ignore any broadcast postMessages
        if (origin !== this.getOrigin()) {
          return
        }

        if (type === 'portal:getBalancesError') {
          // Remove the event listener
          window.removeEventListener('message', handleGetBalances)

          // Reject the promise with the error
          return reject(new PortalMpcError(data as PortalError))
        } else if (type === 'portal:getBalancesResult') {
          // Remove the event listener
          window.removeEventListener('message', handleGetBalances)

          // Resolve the promise with the result
          resolve(data as Balance[])
        }
      }

      // Bind the function to the message event
      window.addEventListener('message', handleGetBalances)

      // Send the request to the iframe
      this.postMessage({
        type: 'portal:getBalances',
        data: {},
      })
    })
  }

  public async getClient(): Promise<ClientWithCustodianData> {
    return new Promise((resolve, reject) => {
      const handleGetClient = (event: MessageEvent<WorkerResult>) => {
        const { type, data } = event.data
        const { origin } = event

        // ignore any broadcast postMessages
        if (origin !== this.getOrigin()) {
          return
        }

        if (type === 'portal:getClientError') {
          // Remove the event listener
          window.removeEventListener('message', handleGetClient)

          // Reject the promise with the error
          return reject(new PortalMpcError(data as PortalError))
        } else if (type === 'portal:getClientResult') {
          // Remove the event listener
          window.removeEventListener('message', handleGetClient)

          // Resolve the promise with the result
          resolve(data as ClientWithCustodianData)
        }
      }

      // Bind the function to the message event
      window.addEventListener('message', handleGetClient)

      // Send the request to the iframe
      this.postMessage({
        type: 'portal:getClient',
        data: {},
      })
    })
  }

  public async getNFTs(): Promise<NFT[]> {
    return new Promise((resolve, reject) => {
      const handleGetNFTs = (event: MessageEvent<WorkerResult>) => {
        const { type, data } = event.data
        const { origin } = event

        // ignore any broadcast postMessages
        if (origin !== this.getOrigin()) {
          return
        }

        if (type === 'portal:getNFTsError') {
          // Remove the event listener
          window.removeEventListener('message', handleGetNFTs)

          // Reject the promise with the error
          return reject(new PortalMpcError(data as PortalError))
        } else if (type === 'portal:getNFTsResult') {
          // Remove the event listener
          window.removeEventListener('message', handleGetNFTs)

          // Resolve the promise with the result
          resolve(data as NFT[])
        }
      }

      // Bind the function to the message event
      window.addEventListener('message', handleGetNFTs)

      // Send the request to the iframe
      this.postMessage({
        type: 'portal:getNFTs',
        data: {},
      })
    })
  }

  public async getQuote(
    apiKey: string,
    args: QuoteArgs,
  ): Promise<QuoteResponse> {
    return new Promise((resolve, reject) => {
      const handleGetQuote = (event: MessageEvent<WorkerResult>) => {
        const { type, data: result } = event.data
        const { origin } = event

        // ignore any broadcast postMessages
        if (origin !== this.getOrigin()) {
          return
        }
        if (type === 'portal:swaps:getQuoteError') {
          // Remove the event listener
          window.removeEventListener('message', handleGetQuote)

          // Reject the promise with the error
          return reject(new PortalMpcError(result as PortalError))
        } else if (type === 'portal:swaps:getQuoteResult') {
          // Remove the event listener
          window.removeEventListener('message', handleGetQuote)

          // Resolve the promise with the result
          resolve(result as QuoteResponse)
        }
      }

      // Bind the function to the message event
      window.addEventListener('message', handleGetQuote)

      // Send the request to the iframe
      this.postMessage({
        type: 'portal:swaps:getQuote',
        data: {
          apiKey,
          args,
        },
      })
    })
  }

  public async getSources(apiKey: string): Promise<Record<string, string>> {
    return new Promise((resolve, reject) => {
      const handleGetSources = (event: MessageEvent<WorkerResult>) => {
        const { type, data: result } = event.data
        const { origin } = event

        // ignore any broadcast postMessages
        if (origin !== this.getOrigin()) {
          return
        }
        if (type === 'portal:swaps:getSourcesError') {
          // Remove the event listener
          window.removeEventListener('message', handleGetSources)

          // Reject the promise with the error
          return reject(new PortalMpcError(result as PortalError))
        } else if (type === 'portal:swaps:getSourcesResult') {
          // Remove the event listener
          window.removeEventListener('message', handleGetSources)

          // Resolve the promise with the result
          resolve(result as Record<string, string>)
        }
      }

      // Bind the function to the message event
      window.addEventListener('message', handleGetSources)

      // Send the request to the iframe
      this.postMessage({
        type: 'portal:swaps:getSources',
        data: {
          apiKey,
        },
      })
    })
  }

  public async getTransactions(
    limit?: number,
    offset?: number,
    order?: GetTransactionsOrder,
    chainId?: number,
  ): Promise<Transaction[]> {
    return new Promise((resolve, reject) => {
      const handleGetTransactions = (event: MessageEvent<WorkerResult>) => {
        const { type, data } = event.data
        const { origin } = event

        // ignore any broadcast postMessages
        if (origin !== this.getOrigin()) {
          return
        }

        if (type === 'portal:getTransactionsError') {
          // Remove the event listener
          window.removeEventListener('message', handleGetTransactions)

          // Reject the promise with the error
          return reject(new PortalMpcError(data as PortalError))
        } else if (type === 'portal:getTransactionsResult') {
          // Remove the event listener
          window.removeEventListener('message', handleGetTransactions)

          // Resolve the promise with the result
          resolve(data as Transaction[])
        }
      }

      // Bind the function to the message event
      window.addEventListener('message', handleGetTransactions)

      // Send the request to the iframe
      this.postMessage({
        type: 'portal:getTransactions',
        data: {
          limit,
          offset,
          order,
          chainId,
        },
      })
    })
  }

  public async simulateTransaction(
    transaction: SimulateTransactionParam,
  ): Promise<SimulatedTransaction> {
    return new Promise((resolve, reject) => {
      const handleSimulateTransaction = (event: MessageEvent<WorkerResult>) => {
        const { type, data } = event.data
        const { origin } = event

        // ignore any broadcast postMessages
        if (origin !== this.getOrigin()) {
          return
        }

        if (type === 'portal:simulateTransactionError') {
          // Remove the event listener
          window.removeEventListener('message', handleSimulateTransaction)

          // Reject the promise with the error
          return reject(new PortalMpcError(data as PortalError))
        } else if (type === 'portal:simulateTransactionResult') {
          // Remove the event listener
          window.removeEventListener('message', handleSimulateTransaction)

          // Resolve the promise with the result
          resolve(data as SimulatedTransaction)
        }
      }

      // Bind the function to the message event
      window.addEventListener('message', handleSimulateTransaction)

      // Send the request to the iframe
      this.postMessage({
        type: 'portal:simulateTransaction',
        data: transaction,
      })
    })
  }

  public storedClientBackupShare(success: boolean): Promise<void> {
    return new Promise((resolve, reject) => {
      const handleStoredClientBackupShare = (
        event: MessageEvent<WorkerResult>,
      ) => {
        const { type, data } = event.data
        const { origin } = event

        // ignore any broadcast postMessages
        if (origin !== this.getOrigin()) {
          return
        }

        if (type === 'portal:storedClientBackupShareError') {
          // Remove the event listener
          window.removeEventListener('message', handleStoredClientBackupShare)

          // Reject the promise with the error
          return reject(new PortalMpcError(data as PortalError))
        } else if (type === 'portal:storedClientBackupShareResult') {
          // Remove the event listener
          window.removeEventListener('message', handleStoredClientBackupShare)

          // Resolve the promise with the result
          resolve()
        }
      }

      // Bind the function to the message event
      window.addEventListener('message', handleStoredClientBackupShare)

      // Send the request to the iframe
      this.postMessage({
        type: 'portal:storedClientBackupShare',
        data: success,
      })
    })
  }

  /***************************
   * Private Methods
   ***************************/

  /**
   * Appends the iframe to the document body
   */
  private appendIframe() {
    // Attempt authentication before appending the iframe
    const host = this.portal.host
    const source = host.startsWith('localhost:')
      ? `http://${host}/${WEB_SDK_VERSION}/iframe/index.html?parentOrigin=${window.location.origin}`
      : `https://${host}/${WEB_SDK_VERSION}/iframe/index.html?parentOrigin=${window.location.origin}`

    const iframe = document.createElement('iframe')
    iframe.height = '0'
    iframe.width = '0'
    iframe.src = source
    iframe.addEventListener('load', this.configureIframe)

    document.body.appendChild(iframe)

    this.iframe = iframe
  }

  private configureIframe = () => {
    const config: IframeConfigurationOptions = {
      apiKey: this.portal.apiKey,
      authToken: this.portal.authToken,
      authUrl: this.portal.authUrl,
      autoApprove: this.portal.autoApprove,
      chainId: this.portal.chainId,
      gdrive: this.portal.gDriveConfig,
      host: this.portal.host,
      rpcUrl: this.portal.getRpcUrl(),
      featureFlags: this.portal.featureFlags,
    }

    const message = {
      type: 'portal:configure',
      data: config,
    }

    this.postMessage(message)

    this.waitForReadyMessage()
  }

  private getOrigin(): string {
    const host = this.portal.host
    const origin = host.startsWith('localhost:')
      ? `http://${host}`
      : `https://${host}`

    return origin
  }

  private postMessage(event: { type: string; data: any }) {
    this.iframe?.contentWindow?.postMessage(event, this.getOrigin())
  }

  private waitForReadyMessage() {
    const handleError = (message: MessageEvent<WorkerResult>) => {
      const { type, data } = message.data
      const { origin } = message

      // ignore any broadcast postMessages
      if (origin !== this.getOrigin()) {
        return
      }

      if (
        type === 'portal:wasm:error' ||
        type === 'portal:authenticationError'
      ) {
        window.removeEventListener('message', handleError)
        window.removeEventListener('message', handleReady)

        this.portal.triggerError(data as string)
      }
    }
    const handleReady = async (message: MessageEvent<WorkerResult>) => {
      const { type, data } = message.data
      const { origin } = message

      // ignore any broadcast postMessages
      if (origin !== this.getOrigin()) {
        return
      }

      if (type === 'portal:ready' && data === true) {
        // Unbind the event listener
        window.removeEventListener('message', handleReady)
        window.removeEventListener('message', handleError)

        // Update ready state
        this.portal.ready = true

        // Update the address
        const address = await this.getAddress()
        this.portal.address = address

        // Trigger the ready callback
        this.portal.triggerReady()
      }
    }

    window.addEventListener('message', handleReady)
    window.addEventListener('message', handleError)
  }

  private validateBackupConfig(data: BackupArgs) {
    if (data.backupMethod === BackupMethods.password) {
      if (!data.backupConfigs.passwordStorage) {
        throw new Error('Password storage config is required')
      }

      if (!data.backupConfigs.passwordStorage.password) {
        throw new Error('Password is required')
      }

      if (data.backupConfigs.passwordStorage.password.length < 4) {
        throw new Error('Password must be at least 4 characters')
      }
    }
  }
}

export { MpcError, MpcErrorCodes } from './errors'

export default Mpc
