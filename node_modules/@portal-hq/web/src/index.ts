import type {
  BackupConfigs,
  Balance,
  ClientWithCustodianData,
  EthereumTransaction,
  FeatureFlags,
  GDriveConfig,
  GatewayLike,
  GetTransactionsOrder,
  NFT,
  PortalOptions,
  ProgressCallback,
  QuoteArgs,
  QuoteResponse,
  SimulateTransactionParam,
  SimulatedTransaction,
  Transaction,
  TypedData,
} from '../types'
import Mpc from './mpc'
import Provider from './provider'

class Portal {
  public address?: string
  public apiKey?: string
  public authToken?: string
  public authUrl?: string
  public autoApprove: boolean
  public chainId: number
  public gDriveConfig?: GDriveConfig
  public host: string
  public mpc: Mpc
  public mpcVersion: string
  public provider: Provider
  public ready = false
  public featureFlags: FeatureFlags

  private errorCallbacks: ((reason: string) => any | Promise<any>)[] = []
  private gatewayConfig: GatewayLike
  private readyCallbacks: (() => any | Promise<any>)[] = []

  constructor({
    // Required
    gatewayConfig,

    // Optional
    apiKey,
    authToken,
    authUrl,
    autoApprove = false,
    chainId = 1,
    gdrive,
    host = 'web.portalhq.io',
    mpcVersion = 'v5',
    featureFlags = {
      optimized: false,
    },
  }: PortalOptions) {
    this.apiKey = apiKey
    this.authToken = authToken
    this.authUrl = authUrl
    this.autoApprove = autoApprove
    this.chainId = chainId
    this.gatewayConfig = gatewayConfig
    this.host = host
    this.mpcVersion = mpcVersion
    this.featureFlags = featureFlags

    if (gdrive) {
      this.gDriveConfig = gdrive
    }

    this.mpc = new Mpc({
      portal: this,
    })

    this.provider = new Provider({
      portal: this,
    })
  }

  /*****************************
   * Initialization Methods
   *****************************/

  public onInitializationError(
    callback: (reason: string) => any | Promise<any>,
  ): () => void {
    if (!this.ready) {
      this.errorCallbacks.push(callback)
    }

    return () => {
      this.errorCallbacks = this.errorCallbacks.filter((cb) => cb !== callback)
    }
  }

  public onReady(callback: () => any | Promise<any>): () => void {
    if (this.ready) {
      callback()
    } else {
      this.readyCallbacks.push(callback)
    }

    return () => {
      this.readyCallbacks = this.readyCallbacks.filter((cb) => cb !== callback)
    }
  }

  public triggerError(data: string) {
    if (!this.ready && this.errorCallbacks.length > 0) {
      this.errorCallbacks.forEach((callback) => {
        callback(data)
      })
    }
  }

  public triggerReady() {
    if (this.ready && this.readyCallbacks.length > 0) {
      this.readyCallbacks.forEach((callback) => {
        callback()
      })

      this.readyCallbacks = []
    }
  }

  /*****************************
   * Wallet Methods
   *****************************/

  public async clearLocalWallet(): Promise<boolean> {
    return await this.mpc.clearLocalWallet()
  }

  public async createWallet(
    progress: ProgressCallback = () => {
      // Noop
    },
  ): Promise<string> {
    const address = await this.mpc.generate(
      {
        host: this.host,
        mpcVersion: this.mpcVersion,
        featureFlags: this.featureFlags,
      },
      progress,
    )

    this.address = address

    return address
  }

  public async backupWallet(
    backupMethod: BackupMethods,
    progress: ProgressCallback = () => {
      // Noop
    },
    backupConfigs: BackupConfigs = {},
  ): Promise<string> {
    const cipherText = await this.mpc.backup(
      {
        backupMethod,
        backupConfigs,
        host: this.host,
        mpcVersion: this.mpcVersion,
        featureFlags: this.featureFlags,
      },
      progress,
    )

    return cipherText
  }

  public async recoverWallet(
    cipherText: string,
    backupMethod: BackupMethods,
    backupConfigs: BackupConfigs,
    progress: ProgressCallback = () => {
      // Noop
    },
  ): Promise<string> {
    const address = await this.mpc.recover(
      {
        cipherText,
        backupMethod,
        backupConfigs,
        host: this.host,
        mpcVersion: this.mpcVersion,
        featureFlags: this.featureFlags,
      },
      progress,
    )

    return address
  }

  /**
   * @deprecated This method is deprecated and will be removed in a future version.
   * Use the `recoverWallet` method instead.
   */
  public async legacyRecoverWallet(
    cipherText: string,
    progress: ProgressCallback = () => {
      // Noop
    },
  ): Promise<string> {
    const recoveredCipherText = await this.mpc.legacyRecover(
      {
        cipherText,
        host: this.host,
        mpcVersion: this.mpcVersion,
        featureFlags: this.featureFlags,
      },
      progress,
    )

    this.address = await this.mpc.getAddress()

    return recoveredCipherText
  }

  public async provisionWallet(
    cipherText: string,
    backupMethod: BackupMethods,
    backupConfigs: BackupConfigs,
    progress: ProgressCallback = () => {
      // Noop
    },
  ): Promise<string> {
    return this.recoverWallet(cipherText, backupMethod, backupConfigs, progress)
  }

  /****************************
   * Provider Methods
   ****************************/

  public async ethEstimateGas(transaction: EthereumTransaction): Promise<any> {
    return this.provider.request({
      method: 'eth_estimateGas',
      params: transaction,
    })
  }

  public async ethGasPrice(): Promise<string> {
    return this.provider.request({
      method: 'eth_gasPrice',
      params: [],
    }) as Promise<string>
  }

  public async ethGetBalance(): Promise<string> {
    return this.provider.request({
      method: 'eth_getBalance',
      params: [this.address, 'latest'],
    }) as Promise<string>
  }

  public async ethSendTransaction(
    transaction: EthereumTransaction,
  ): Promise<string> {
    return this.provider.request({
      method: 'eth_sendTransaction',
      params: transaction,
    }) as Promise<string>
  }

  public async ethSign(message: string): Promise<string> {
    return this.provider.request({
      method: 'eth_sign',
      params: [this.address, this.stringToHex(message)],
    }) as Promise<string>
  }

  public async ethSignTransaction(
    transaction: EthereumTransaction,
  ): Promise<string> {
    return this.provider.request({
      method: 'eth_signTransaction',
      params: transaction,
    }) as Promise<string>
  }

  public async ethSignTypedData(data: TypedData): Promise<string> {
    return this.provider.request({
      method: 'eth_signTypedData',
      params: [this.address, data],
    }) as Promise<string>
  }

  public async ethSignTypedDataV3(data: TypedData): Promise<string> {
    return this.provider.request({
      method: 'eth_signTypedData_v3',
      params: [this.address, data],
    }) as Promise<string>
  }

  public async ethSignTypedDataV4(data: TypedData): Promise<string> {
    return this.provider.request({
      method: 'eth_signTypedData_v4',
      params: [this.address, data],
    }) as Promise<string>
  }

  public async personalSign(message: string): Promise<string> {
    return this.provider.request({
      method: 'personal_sign',
      params: [this.stringToHex(message), this.address],
    }) as Promise<string>
  }

  /*******************************
   * API Methods
   *******************************/

  public async getBalances(): Promise<Balance[]> {
    return await this.mpc?.getBalances()
  }

  public async getClient(): Promise<ClientWithCustodianData> {
    return this.mpc?.getClient()
  }

  public async getNFTs(): Promise<NFT[]> {
    return this.mpc?.getNFTs()
  }

  public async getTransactions(
    limit?: number,
    offset?: number,
    order?: GetTransactionsOrder,
    chainId?: number,
  ): Promise<Transaction[]> {
    return this.mpc?.getTransactions(limit, offset, order, chainId)
  }

  public async simulateTransaction(
    transaction: SimulateTransactionParam,
  ): Promise<SimulatedTransaction> {
    return this.mpc?.simulateTransaction(transaction)
  }

  /*******************************
   * Swaps Methods
   *******************************/

  public async getQuote(
    apiKey: string,
    args: QuoteArgs,
  ): Promise<QuoteResponse> {
    return this.mpc?.getQuote(apiKey, args)
  }

  public async getSources(apiKey: string): Promise<Record<string, string>> {
    return this.mpc?.getSources(apiKey)
  }

  /*******************************
   * Wallet Safeguarding Methods
   *******************************/

  public async storedClientBackupShare(status: boolean): Promise<void> {
    return await this.mpc?.storedClientBackupShare(status)
  }

  /****************************
   * RPC Methods
   ****************************/

  public getRpcUrl() {
    if (typeof this.gatewayConfig === 'string') {
      // If the gatewayConfig is just a static URL, return that
      return this.gatewayConfig
    } else if (
      typeof this.gatewayConfig === 'object' &&
      // eslint-disable-next-line no-prototype-builtins
      !this.gatewayConfig.hasOwnProperty(this.chainId)
    ) {
      // If there's no explicit mapping for the current chainId, error out
      throw new Error(
        `[PortalProvider] No RPC endpoint configured for chainId: ${this.chainId}`,
      )
    }

    // Get the entry for the current chainId from the gatewayConfig
    const config = this.gatewayConfig[this.chainId]

    if (typeof config === 'string') {
      return config
    }

    // If we got this far, there's no way to support the chain with the current config
    throw new Error(
      `[PortalProvider] Could not find a valid gatewayConfig entry for chainId: ${this.chainId}`,
    )
  }

  /**************************
   * RPC Encoding Methods
   **************************/

  private stringToHex(str: string): string {
    if (str.startsWith('0x')) {
      return str
    }

    let hex = '0x'

    for (let i = 0; i < str.length; i++) {
      const charCode = str.charCodeAt(i)
      const hexValue = charCode.toString(16)
      hex += hexValue.padStart(2, '0') // Ensure two-digit hex value
    }

    return hex
  }
}

export { MpcError, MpcErrorCodes } from './mpc'
export {
  type Address,
  type Dapp,
  type MpcStatus,
  type PortalOptions,
} from '../types'

export enum MpcStatuses {
  DecryptingShare = 'Decrypting share',
  Done = 'Done',
  EncryptingShare = 'Encrypting share',
  GeneratingShare = 'Generating share',
  ParsingShare = 'Parsing share',
  ReadingShare = 'Reading share',
  RecoveringBackupShare = 'Recovering backup share',
  RecoveringSigningShare = 'Recovering signing share',
  StoringShare = 'Storing share',
}

export enum BackupMethods {
  gdrive = 'GDRIVE',
  password = 'PASSWORD',
}

export default Portal
