import { ProviderRpcError, RpcErrorCodes } from './errors'

import Portal from '../index'

import type {
  EventHandler,
  ProviderOptions,
  RegisteredEventHandler,
  RequestArguments,
  RpcErrorOptions,
} from '../../types'

const passiveSignerMethods = [
  'eth_accounts',
  'eth_chainId',
  'eth_requestAccounts',
]

const signerMethods = [
  'eth_accounts',
  'eth_chainId',
  'eth_requestAccounts',
  'eth_sendTransaction',
  'eth_sign',
  'eth_signTransaction',
  'eth_signTypedData_v3',
  'eth_signTypedData_v4',
  'personal_sign',
]

class Provider {
  public events: Record<string, RegisteredEventHandler[]>

  private portal: Portal

  constructor({ portal }: ProviderOptions) {
    this.events = {}
    this.portal = portal
  }

  /**
   * Invokes all registered event handlers with the data provided
   * - If any `once` handlers exist, they are removed after all handlers are invoked
   *
   * @param event The name of the event to be handled
   * @param data The data to be passed to registered event handlers
   * @returns BaseProvider
   */
  public emit(event: string, data: any): Provider {
    // Grab the registered event handlers if any are available
    const handlers = this.events[event] || []

    // Execute every event handler
    for (const registeredEventHandler of handlers) {
      void registeredEventHandler.handler(data)
    }

    // Remove any registered event handlers with the `once` flag
    this.events[event] = handlers.filter((handler) => !handler.once)

    return this
  }

  /**
   * Registers an event handler for the provided event
   *
   * @param event The event name to add a handler to
   * @param callback The callback to be invoked when the event is emitted
   * @returns BaseProvider
   */
  public on(event: string, callback: EventHandler): Provider {
    // If no handlers are registered for this event, create an entry for the event
    if (!this.events[event]) {
      this.events[event] = []
    }

    // Register event handler with the rudimentary event bus
    if (typeof callback !== 'undefined') {
      this.events[event].push({
        handler: callback,
        once: false,
      })
    }

    return this
  }

  public removeEventListener(
    event: string,
    listenerToRemove?: EventHandler,
  ): void {
    if (!this.events[event]) {
      return
    }

    if (!listenerToRemove) {
      this.events[event] = []
    } else {
      const filterEventHandlers = (
        registeredEventHandler: RegisteredEventHandler,
      ) => {
        return registeredEventHandler.handler !== listenerToRemove
      }

      this.events[event] = this.events[event].filter(filterEventHandlers)
    }
  }

  /**
   * Handles request routing in compliance with the EIP-1193 Ethereum Javascript Provider API
   * - See here for more info: https://eips.ethereum.org/EIPS/eip-1193
   *
   * @param args The arguments of the request being made
   * @returns Promise<any>
   */
  public async request({ method, params }: RequestArguments): Promise<any> {
    if (method === 'eth_chainId') {
      return this.portal.chainId
    }

    const isSignerMethod = signerMethods.includes(method)

    let result: any
    if (!isSignerMethod && !method.startsWith('wallet_')) {
      // Send to Gateway for RPC calls
      const response = await this.handleGatewayRequest({ method, params })

      this.emit('portal_signatureReceived', {
        method,
        params,
        signature: response,
      })

      if (response.error) {
        throw new ProviderRpcError(response.error as RpcErrorOptions)
      }

      result = response.result
    } else if (isSignerMethod) {
      // Handle signing
      const transactionHash = await this.handleSigningRequest({
        method,
        params,
      })

      if (transactionHash) {
        this.emit('portal_signatureReceived', {
          method,
          params,
          signature: transactionHash,
        })

        result = transactionHash
      }
    } else {
      // Unsupported method
      throw new ProviderRpcError({
        code: RpcErrorCodes.UnsupportedMethod,
        data: {
          method,
          params,
        },
      })
    }

    return result
  }

  /************************
   * Private Methods
   ************************/

  /**
   * Kicks off the approval flow for a given request
   *
   * @param args The arguments of the request being made
   */
  protected async getApproval({
    method,
    params,
  }: RequestArguments): Promise<boolean> {
    // If autoApprove is enabled, just resolve to true
    if (this.portal.autoApprove) {
      return true
    }

    const signingHandlers = this.events['portal_signingRequested']

    if (!signingHandlers || signingHandlers.length === 0) {
      throw new Error(
        `[PortalProvider] Auto-approve is disabled. Cannot perform signing requests without an event handler for the 'portal_signingRequested' event.`,
      )
    }

    return new Promise((resolve) => {
      // Remove already used listeners
      this.removeEventListener('portal_signingApproved')
      this.removeEventListener('portal_signingRejected')

      const handleApproval = ({
        method: approvedMethod,
        params: approvedParams,
      }: RequestArguments) => {
        // Remove already used listeners
        this.removeEventListener('portal_signingApproved')
        this.removeEventListener('portal_signingRejected')

        // First verify that this is the same signing request
        if (
          method === approvedMethod &&
          JSON.stringify(params) === JSON.stringify(approvedParams)
        ) {
          resolve(true)
        }
      }

      const handleRejection = ({
        method: rejectedMethod,
        params: rejectedParams,
      }: RequestArguments) => {
        // Remove already used listeners
        this.removeEventListener('portal_signingApproved')
        this.removeEventListener('portal_signingRejected')

        // First verify that this is the same signing request
        if (
          method === rejectedMethod &&
          JSON.stringify(params) === JSON.stringify(rejectedParams)
        ) {
          resolve(false)
        }
      }

      // If the signing has been approved, resolve to true
      this.on('portal_signingApproved', handleApproval)

      // If the signing request has been rejected, resolve to false
      this.on('portal_signingRejected', handleRejection)

      // Tell any listening clients that signing has been requested
      this.emit('portal_signingRequested', {
        method,
        params,
      })
    })
  }

  /**
   * Sends the provided request payload along to the RPC HttpRequester
   *
   * @param args The arguments of the request being made
   * @returns Promise<any>
   */
  private async handleGatewayRequest({
    method,
    params,
  }: RequestArguments): Promise<any> {
    // Pass request off to the gateway
    const result = await fetch(this.portal.getRpcUrl(), {
      body: JSON.stringify({
        jsonrpc: '2.0',
        id: this.portal.chainId,
        method,
        params,
      }),
      method: 'POST',
    })

    return result.json()
  }

  /**
   * Sends the provided request payload along to the Signer
   *
   * @param args The arguments of the request being made
   * @returns Promise<any>
   */
  private async handleSigningRequest({
    method,
    params,
  }: RequestArguments): Promise<any> {
    const isApproved = passiveSignerMethods.includes(method)
      ? true
      : await this.getApproval({ method, params })

    if (!isApproved) {
      console.warn(
        `[PortalProvider] Request for signing method '${method}' could not be completed because it was not approved by the user.`,
      )
      return
    }

    switch (method) {
      case 'eth_chainId':
        return `0x${this.portal.chainId.toString(16)}`
      case 'eth_accounts':
      case 'eth_requestAccounts':
        return [this.portal.address]
      case 'eth_sendTransaction':
      case 'eth_sign':
      case 'eth_signTransaction':
      case 'eth_signTypedData_v3':
      case 'eth_signTypedData_v4':
      case 'personal_sign': {
        const result = await this.portal.mpc.sign({
          host: this.portal.host,
          method,
          mpcVersion: this.portal.mpcVersion,
          params: this.buildParams(method, params),
          featureFlags: this.portal.featureFlags,
        })

        return result
      }
      default:
        throw new Error(
          '[PortalProvider] Method "' + method + '" not supported',
        )
    }
  }

  private buildParams = (method: string, txParams: any) => {
    let params = txParams

    switch (method) {
      case 'eth_sign':
      case 'personal_sign':
      case 'eth_signTypedData_v3':
      case 'eth_signTypedData_v4':
        if (!Array.isArray(txParams)) {
          params = [txParams]
        }
        break
      default:
        if (Array.isArray(txParams)) {
          params = txParams[0]
        }
    }

    return params
  }
}

export default Provider
