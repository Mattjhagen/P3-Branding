var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import Mpc from './mpc';
import Provider from './provider';
class Portal {
    constructor({ 
    // Required
    gatewayConfig, 
    // Optional
    apiKey, authToken, authUrl, autoApprove = false, chainId = 1, gdrive, host = 'web.portalhq.io', mpcVersion = 'v5', featureFlags = {
        optimized: false,
    }, }) {
        this.ready = false;
        this.errorCallbacks = [];
        this.readyCallbacks = [];
        this.apiKey = apiKey;
        this.authToken = authToken;
        this.authUrl = authUrl;
        this.autoApprove = autoApprove;
        this.chainId = chainId;
        this.gatewayConfig = gatewayConfig;
        this.host = host;
        this.mpcVersion = mpcVersion;
        this.featureFlags = featureFlags;
        if (gdrive) {
            this.gDriveConfig = gdrive;
        }
        this.mpc = new Mpc({
            portal: this,
        });
        this.provider = new Provider({
            portal: this,
        });
    }
    /*****************************
     * Initialization Methods
     *****************************/
    onInitializationError(callback) {
        if (!this.ready) {
            this.errorCallbacks.push(callback);
        }
        return () => {
            this.errorCallbacks = this.errorCallbacks.filter((cb) => cb !== callback);
        };
    }
    onReady(callback) {
        if (this.ready) {
            callback();
        }
        else {
            this.readyCallbacks.push(callback);
        }
        return () => {
            this.readyCallbacks = this.readyCallbacks.filter((cb) => cb !== callback);
        };
    }
    triggerError(data) {
        if (!this.ready && this.errorCallbacks.length > 0) {
            this.errorCallbacks.forEach((callback) => {
                callback(data);
            });
        }
    }
    triggerReady() {
        if (this.ready && this.readyCallbacks.length > 0) {
            this.readyCallbacks.forEach((callback) => {
                callback();
            });
            this.readyCallbacks = [];
        }
    }
    /*****************************
     * Wallet Methods
     *****************************/
    clearLocalWallet() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.mpc.clearLocalWallet();
        });
    }
    createWallet(progress = () => {
        // Noop
    }) {
        return __awaiter(this, void 0, void 0, function* () {
            const address = yield this.mpc.generate({
                host: this.host,
                mpcVersion: this.mpcVersion,
                featureFlags: this.featureFlags,
            }, progress);
            this.address = address;
            return address;
        });
    }
    backupWallet(backupMethod, progress = () => {
        // Noop
    }, backupConfigs = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const cipherText = yield this.mpc.backup({
                backupMethod,
                backupConfigs,
                host: this.host,
                mpcVersion: this.mpcVersion,
                featureFlags: this.featureFlags,
            }, progress);
            return cipherText;
        });
    }
    recoverWallet(cipherText, backupMethod, backupConfigs, progress = () => {
        // Noop
    }) {
        return __awaiter(this, void 0, void 0, function* () {
            const address = yield this.mpc.recover({
                cipherText,
                backupMethod,
                backupConfigs,
                host: this.host,
                mpcVersion: this.mpcVersion,
                featureFlags: this.featureFlags,
            }, progress);
            return address;
        });
    }
    /**
     * @deprecated This method is deprecated and will be removed in a future version.
     * Use the `recoverWallet` method instead.
     */
    legacyRecoverWallet(cipherText, progress = () => {
        // Noop
    }) {
        return __awaiter(this, void 0, void 0, function* () {
            const recoveredCipherText = yield this.mpc.legacyRecover({
                cipherText,
                host: this.host,
                mpcVersion: this.mpcVersion,
                featureFlags: this.featureFlags,
            }, progress);
            this.address = yield this.mpc.getAddress();
            return recoveredCipherText;
        });
    }
    provisionWallet(cipherText, backupMethod, backupConfigs, progress = () => {
        // Noop
    }) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.recoverWallet(cipherText, backupMethod, backupConfigs, progress);
        });
    }
    /****************************
     * Provider Methods
     ****************************/
    ethEstimateGas(transaction) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.provider.request({
                method: 'eth_estimateGas',
                params: transaction,
            });
        });
    }
    ethGasPrice() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.provider.request({
                method: 'eth_gasPrice',
                params: [],
            });
        });
    }
    ethGetBalance() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.provider.request({
                method: 'eth_getBalance',
                params: [this.address, 'latest'],
            });
        });
    }
    ethSendTransaction(transaction) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.provider.request({
                method: 'eth_sendTransaction',
                params: transaction,
            });
        });
    }
    ethSign(message) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.provider.request({
                method: 'eth_sign',
                params: [this.address, this.stringToHex(message)],
            });
        });
    }
    ethSignTransaction(transaction) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.provider.request({
                method: 'eth_signTransaction',
                params: transaction,
            });
        });
    }
    ethSignTypedData(data) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.provider.request({
                method: 'eth_signTypedData',
                params: [this.address, data],
            });
        });
    }
    ethSignTypedDataV3(data) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.provider.request({
                method: 'eth_signTypedData_v3',
                params: [this.address, data],
            });
        });
    }
    ethSignTypedDataV4(data) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.provider.request({
                method: 'eth_signTypedData_v4',
                params: [this.address, data],
            });
        });
    }
    personalSign(message) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.provider.request({
                method: 'personal_sign',
                params: [this.stringToHex(message), this.address],
            });
        });
    }
    /*******************************
     * API Methods
     *******************************/
    getBalances() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            return yield ((_a = this.mpc) === null || _a === void 0 ? void 0 : _a.getBalances());
        });
    }
    getClient() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            return (_a = this.mpc) === null || _a === void 0 ? void 0 : _a.getClient();
        });
    }
    getNFTs() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            return (_a = this.mpc) === null || _a === void 0 ? void 0 : _a.getNFTs();
        });
    }
    getTransactions(limit, offset, order, chainId) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            return (_a = this.mpc) === null || _a === void 0 ? void 0 : _a.getTransactions(limit, offset, order, chainId);
        });
    }
    simulateTransaction(transaction) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            return (_a = this.mpc) === null || _a === void 0 ? void 0 : _a.simulateTransaction(transaction);
        });
    }
    /*******************************
     * Swaps Methods
     *******************************/
    getQuote(apiKey, args) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            return (_a = this.mpc) === null || _a === void 0 ? void 0 : _a.getQuote(apiKey, args);
        });
    }
    getSources(apiKey) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            return (_a = this.mpc) === null || _a === void 0 ? void 0 : _a.getSources(apiKey);
        });
    }
    /*******************************
     * Wallet Safeguarding Methods
     *******************************/
    storedClientBackupShare(status) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            return yield ((_a = this.mpc) === null || _a === void 0 ? void 0 : _a.storedClientBackupShare(status));
        });
    }
    /****************************
     * RPC Methods
     ****************************/
    getRpcUrl() {
        if (typeof this.gatewayConfig === 'string') {
            // If the gatewayConfig is just a static URL, return that
            return this.gatewayConfig;
        }
        else if (typeof this.gatewayConfig === 'object' &&
            // eslint-disable-next-line no-prototype-builtins
            !this.gatewayConfig.hasOwnProperty(this.chainId)) {
            // If there's no explicit mapping for the current chainId, error out
            throw new Error(`[PortalProvider] No RPC endpoint configured for chainId: ${this.chainId}`);
        }
        // Get the entry for the current chainId from the gatewayConfig
        const config = this.gatewayConfig[this.chainId];
        if (typeof config === 'string') {
            return config;
        }
        // If we got this far, there's no way to support the chain with the current config
        throw new Error(`[PortalProvider] Could not find a valid gatewayConfig entry for chainId: ${this.chainId}`);
    }
    /**************************
     * RPC Encoding Methods
     **************************/
    stringToHex(str) {
        if (str.startsWith('0x')) {
            return str;
        }
        let hex = '0x';
        for (let i = 0; i < str.length; i++) {
            const charCode = str.charCodeAt(i);
            const hexValue = charCode.toString(16);
            hex += hexValue.padStart(2, '0'); // Ensure two-digit hex value
        }
        return hex;
    }
}
export { MpcError, MpcErrorCodes } from './mpc';
export var MpcStatuses;
(function (MpcStatuses) {
    MpcStatuses["DecryptingShare"] = "Decrypting share";
    MpcStatuses["Done"] = "Done";
    MpcStatuses["EncryptingShare"] = "Encrypting share";
    MpcStatuses["GeneratingShare"] = "Generating share";
    MpcStatuses["ParsingShare"] = "Parsing share";
    MpcStatuses["ReadingShare"] = "Reading share";
    MpcStatuses["RecoveringBackupShare"] = "Recovering backup share";
    MpcStatuses["RecoveringSigningShare"] = "Recovering signing share";
    MpcStatuses["StoringShare"] = "Storing share";
})(MpcStatuses || (MpcStatuses = {}));
export var BackupMethods;
(function (BackupMethods) {
    BackupMethods["gdrive"] = "GDRIVE";
    BackupMethods["password"] = "PASSWORD";
})(BackupMethods || (BackupMethods = {}));
export default Portal;
