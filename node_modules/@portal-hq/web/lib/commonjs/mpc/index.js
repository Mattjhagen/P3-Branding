"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MpcErrorCodes = exports.MpcError = void 0;
const errors_1 = require("./errors");
const index_1 = require("../index");
const WEB_SDK_VERSION = '0.0.8';
class Mpc {
    constructor({ portal }) {
        this.configureIframe = () => {
            const config = {
                apiKey: this.portal.apiKey,
                authToken: this.portal.authToken,
                authUrl: this.portal.authUrl,
                autoApprove: this.portal.autoApprove,
                chainId: this.portal.chainId,
                gdrive: this.portal.gDriveConfig,
                host: this.portal.host,
                rpcUrl: this.portal.getRpcUrl(),
                featureFlags: this.portal.featureFlags,
            };
            const message = {
                type: 'portal:configure',
                data: config,
            };
            this.postMessage(message);
            this.waitForReadyMessage();
        };
        this.portal = portal;
        // Handle scoping of certain functions
        this.configureIframe = this.configureIframe.bind(this);
        // Create the iFrame for MPC operations
        this.appendIframe();
    }
    /*******************************
     * Wallet Methods
     *******************************/
    backup(data, progress = () => {
        // Noop
    }) {
        return __awaiter(this, void 0, void 0, function* () {
            const message = {
                type: 'portal:wasm:backup',
                data,
            };
            // validates password config for password backup
            this.validateBackupConfig(data);
            return new Promise((resolve, reject) => {
                // Create a function to be bound when backup is triggered
                const handleBackup = (event) => {
                    const { type, data: result } = event.data;
                    const { origin } = event;
                    // ignore any broadcast postMessages
                    if (origin !== this.getOrigin()) {
                        return;
                    }
                    if (type === 'portal:wasm:backupError') {
                        // Remove the event listeners
                        window.removeEventListener('message', handleBackup);
                        window.removeEventListener('message', handleProgress);
                        // Reject the promise with the error
                        return reject(new errors_1.PortalMpcError(result));
                    }
                    else if (type === 'portal:wasm:backupResult') {
                        // Remove the event listeners
                        window.removeEventListener('message', handleBackup);
                        window.removeEventListener('message', handleProgress);
                        // Resolve the promise with the result
                        resolve(result);
                    }
                };
                const handleProgress = (message) => {
                    const { type, data: status } = message.data;
                    const { origin } = message;
                    // ignore any broadcast postMessages
                    if (origin !== this.getOrigin()) {
                        return;
                    }
                    if (type === 'portal:wasm:backupProgress') {
                        void progress(status);
                    }
                };
                // Bind the function to the message event
                window.addEventListener('message', handleBackup);
                window.addEventListener('message', handleProgress);
                // Send the request to the iframe
                this.postMessage(message);
            });
        });
    }
    clearLocalWallet() {
        return new Promise((resolve) => {
            const handleClearLocalWallet = (event) => {
                const { type } = event.data;
                const { origin } = event;
                // ignore any broadcast postMessages
                if (origin !== this.getOrigin()) {
                    return;
                }
                if (type === 'portal:destroyResult') {
                    // Remove the event listener
                    window.removeEventListener('message', handleClearLocalWallet);
                    // Resolve the promise with the result
                    resolve(true);
                }
            };
            // Bind the function to the message event
            window.addEventListener('message', handleClearLocalWallet);
            // Send the request to the iframe
            this.postMessage({
                type: 'portal:destroy',
                data: {},
            });
        });
    }
    generate(data, progress = () => {
        // Noop
    }) {
        return __awaiter(this, void 0, void 0, function* () {
            const message = {
                type: 'portal:wasm:generate',
                data,
            };
            return new Promise((resolve, reject) => {
                // Create a function to be bound when generate is triggered
                const handleGenerate = (event) => {
                    const { type, data: result } = event.data;
                    const { origin } = event;
                    // ignore any broadcast postMessages
                    if (origin !== this.getOrigin()) {
                        return;
                    }
                    // Handle errors
                    if (type === 'portal:wasm:generateError') {
                        // Remove the event listeners
                        window.removeEventListener('message', handleGenerate);
                        window.removeEventListener('message', handleProgress);
                        // Reject the promise with the error
                        return reject(new errors_1.PortalMpcError(result));
                    }
                    else if (type === 'portal:wasm:generateResult') {
                        // Remove the event listeners
                        window.removeEventListener('message', handleGenerate);
                        window.removeEventListener('message', handleProgress);
                        // Resolve the promise with the result
                        resolve(result);
                    }
                };
                const handleProgress = (message) => {
                    const { type, data: status } = message.data;
                    const { origin } = message;
                    // ignore any broadcast postMessages
                    if (origin !== this.getOrigin()) {
                        return;
                    }
                    if (type === 'portal:wasm:generateProgress') {
                        void progress(status);
                    }
                };
                // Bind the function to the message event
                window.addEventListener('message', handleGenerate);
                window.addEventListener('message', handleProgress);
                // Send the request to the iframe
                this.postMessage(message);
            });
        });
    }
    getAddress() {
        return __awaiter(this, void 0, void 0, function* () {
            const message = {
                type: 'portal:address',
                data: {},
            };
            return new Promise((resolve) => {
                // Create a function to be bound when getAddress is triggered
                const handleGetAddress = (event) => {
                    const { type, data: result } = event.data;
                    const { origin } = event;
                    // ignore any broadcast postMessages
                    if (origin !== this.getOrigin()) {
                        return;
                    }
                    // Check that the message is the one we're looking for
                    if (type === 'portal:addressResult') {
                        // Remove the event listener
                        window.removeEventListener('message', handleGetAddress);
                        // Resolve the promise with the result
                        resolve(result);
                    }
                };
                // Bind the function to the message event
                window.addEventListener('message', handleGetAddress);
                // Send the request to the iframe
                this.postMessage(message);
            });
        });
    }
    recover(data, progress = () => {
        // Noop
    }) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                const handleRecover = (message) => {
                    const { type, data } = message.data;
                    const { origin } = message;
                    // ignore any broadcast postMessages
                    if (origin !== this.getOrigin()) {
                        return;
                    }
                    if (type === 'portal:wasm:recoverError') {
                        // Remove the event listeners
                        window.removeEventListener('message', handleRecover);
                        window.removeEventListener('message', handleProgress);
                        reject(new errors_1.PortalMpcError(data));
                    }
                    else if (type === 'portal:wasm:recoverResult') {
                        // Remove the event listeners
                        window.removeEventListener('message', handleRecover);
                        window.removeEventListener('message', handleProgress);
                        resolve(data);
                    }
                };
                const handleProgress = (message) => {
                    const { type, data: status } = message.data;
                    const { origin } = message;
                    // ignore any broadcast postMessages
                    if (origin !== this.getOrigin()) {
                        return;
                    }
                    if (type === 'portal:wasm:recoverProgress') {
                        void progress(status);
                    }
                };
                window.addEventListener('message', handleRecover);
                window.addEventListener('message', handleProgress);
                this.postMessage({
                    type: 'portal:wasm:recover',
                    data,
                });
            });
        });
    }
    legacyRecover(data, progress = () => {
        // Noop
    }) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                const handleRecover = (message) => {
                    const { type, data } = message.data;
                    const { origin } = message;
                    // ignore any broadcast postMessages
                    if (origin !== this.getOrigin()) {
                        return;
                    }
                    if (type === 'portal:wasm:legacyRecoverError') {
                        // Remove the event listeners
                        window.removeEventListener('message', handleRecover);
                        window.removeEventListener('message', handleProgress);
                        reject(new errors_1.PortalMpcError(data));
                    }
                    else if (type === 'portal:wasm:legacyRecoverResult') {
                        // Remove the event listeners
                        window.removeEventListener('message', handleRecover);
                        window.removeEventListener('message', handleProgress);
                        resolve(data);
                    }
                };
                const handleProgress = (message) => {
                    const { type, data: status } = message.data;
                    const { origin } = message;
                    // ignore any broadcast postMessages
                    if (origin !== this.getOrigin()) {
                        return;
                    }
                    if (type === 'portal:wasm:legacyRecoverProgress') {
                        void progress(status);
                    }
                };
                window.addEventListener('message', handleRecover);
                window.addEventListener('message', handleProgress);
                this.postMessage({
                    type: 'portal:wasm:legacyRecover',
                    data,
                });
            });
        });
    }
    sign(data, progress = () => {
        // Noop
    }) {
        return __awaiter(this, void 0, void 0, function* () {
            const message = {
                type: 'portal:wasm:sign',
                data,
            };
            return new Promise((resolve, reject) => {
                // Create a function to be bound when sign is triggered
                const handleSign = (event) => {
                    const { type, data: result } = event.data;
                    const { origin } = event;
                    // ignore any broadcast postMessages
                    if (origin !== this.getOrigin()) {
                        return;
                    }
                    if (type === 'portal:wasm:signError') {
                        // Remove the event listeners
                        window.removeEventListener('message', handleSign);
                        window.removeEventListener('message', handleProgress);
                        // Reject the promise with the error
                        return reject(new errors_1.PortalMpcError(result));
                    }
                    else if (type === 'portal:wasm:signResult') {
                        // Remove the event listeners
                        window.removeEventListener('message', handleSign);
                        window.removeEventListener('message', handleProgress);
                        // Resolve the promise with the result
                        resolve(result);
                    }
                };
                const handleProgress = (message) => {
                    const { type, data: status } = message.data;
                    const { origin } = message;
                    // ignore any broadcast postMessages
                    if (origin !== this.getOrigin()) {
                        return;
                    }
                    if (type === 'portal:wasm:signProgress') {
                        void progress(status);
                    }
                };
                // Bind the functions to the message event
                window.addEventListener('message', handleSign);
                window.addEventListener('message', handleProgress);
                // Send the request to the iframe
                this.postMessage(message);
            });
        });
    }
    /*******************************
     * API Methods
     *******************************/
    getBalances() {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                const handleGetBalances = (event) => {
                    const { type, data } = event.data;
                    const { origin } = event;
                    // ignore any broadcast postMessages
                    if (origin !== this.getOrigin()) {
                        return;
                    }
                    if (type === 'portal:getBalancesError') {
                        // Remove the event listener
                        window.removeEventListener('message', handleGetBalances);
                        // Reject the promise with the error
                        return reject(new errors_1.PortalMpcError(data));
                    }
                    else if (type === 'portal:getBalancesResult') {
                        // Remove the event listener
                        window.removeEventListener('message', handleGetBalances);
                        // Resolve the promise with the result
                        resolve(data);
                    }
                };
                // Bind the function to the message event
                window.addEventListener('message', handleGetBalances);
                // Send the request to the iframe
                this.postMessage({
                    type: 'portal:getBalances',
                    data: {},
                });
            });
        });
    }
    getClient() {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                const handleGetClient = (event) => {
                    const { type, data } = event.data;
                    const { origin } = event;
                    // ignore any broadcast postMessages
                    if (origin !== this.getOrigin()) {
                        return;
                    }
                    if (type === 'portal:getClientError') {
                        // Remove the event listener
                        window.removeEventListener('message', handleGetClient);
                        // Reject the promise with the error
                        return reject(new errors_1.PortalMpcError(data));
                    }
                    else if (type === 'portal:getClientResult') {
                        // Remove the event listener
                        window.removeEventListener('message', handleGetClient);
                        // Resolve the promise with the result
                        resolve(data);
                    }
                };
                // Bind the function to the message event
                window.addEventListener('message', handleGetClient);
                // Send the request to the iframe
                this.postMessage({
                    type: 'portal:getClient',
                    data: {},
                });
            });
        });
    }
    getNFTs() {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                const handleGetNFTs = (event) => {
                    const { type, data } = event.data;
                    const { origin } = event;
                    // ignore any broadcast postMessages
                    if (origin !== this.getOrigin()) {
                        return;
                    }
                    if (type === 'portal:getNFTsError') {
                        // Remove the event listener
                        window.removeEventListener('message', handleGetNFTs);
                        // Reject the promise with the error
                        return reject(new errors_1.PortalMpcError(data));
                    }
                    else if (type === 'portal:getNFTsResult') {
                        // Remove the event listener
                        window.removeEventListener('message', handleGetNFTs);
                        // Resolve the promise with the result
                        resolve(data);
                    }
                };
                // Bind the function to the message event
                window.addEventListener('message', handleGetNFTs);
                // Send the request to the iframe
                this.postMessage({
                    type: 'portal:getNFTs',
                    data: {},
                });
            });
        });
    }
    getQuote(apiKey, args) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                const handleGetQuote = (event) => {
                    const { type, data: result } = event.data;
                    const { origin } = event;
                    // ignore any broadcast postMessages
                    if (origin !== this.getOrigin()) {
                        return;
                    }
                    if (type === 'portal:swaps:getQuoteError') {
                        // Remove the event listener
                        window.removeEventListener('message', handleGetQuote);
                        // Reject the promise with the error
                        return reject(new errors_1.PortalMpcError(result));
                    }
                    else if (type === 'portal:swaps:getQuoteResult') {
                        // Remove the event listener
                        window.removeEventListener('message', handleGetQuote);
                        // Resolve the promise with the result
                        resolve(result);
                    }
                };
                // Bind the function to the message event
                window.addEventListener('message', handleGetQuote);
                // Send the request to the iframe
                this.postMessage({
                    type: 'portal:swaps:getQuote',
                    data: {
                        apiKey,
                        args,
                    },
                });
            });
        });
    }
    getSources(apiKey) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                const handleGetSources = (event) => {
                    const { type, data: result } = event.data;
                    const { origin } = event;
                    // ignore any broadcast postMessages
                    if (origin !== this.getOrigin()) {
                        return;
                    }
                    if (type === 'portal:swaps:getSourcesError') {
                        // Remove the event listener
                        window.removeEventListener('message', handleGetSources);
                        // Reject the promise with the error
                        return reject(new errors_1.PortalMpcError(result));
                    }
                    else if (type === 'portal:swaps:getSourcesResult') {
                        // Remove the event listener
                        window.removeEventListener('message', handleGetSources);
                        // Resolve the promise with the result
                        resolve(result);
                    }
                };
                // Bind the function to the message event
                window.addEventListener('message', handleGetSources);
                // Send the request to the iframe
                this.postMessage({
                    type: 'portal:swaps:getSources',
                    data: {
                        apiKey,
                    },
                });
            });
        });
    }
    getTransactions(limit, offset, order, chainId) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                const handleGetTransactions = (event) => {
                    const { type, data } = event.data;
                    const { origin } = event;
                    // ignore any broadcast postMessages
                    if (origin !== this.getOrigin()) {
                        return;
                    }
                    if (type === 'portal:getTransactionsError') {
                        // Remove the event listener
                        window.removeEventListener('message', handleGetTransactions);
                        // Reject the promise with the error
                        return reject(new errors_1.PortalMpcError(data));
                    }
                    else if (type === 'portal:getTransactionsResult') {
                        // Remove the event listener
                        window.removeEventListener('message', handleGetTransactions);
                        // Resolve the promise with the result
                        resolve(data);
                    }
                };
                // Bind the function to the message event
                window.addEventListener('message', handleGetTransactions);
                // Send the request to the iframe
                this.postMessage({
                    type: 'portal:getTransactions',
                    data: {
                        limit,
                        offset,
                        order,
                        chainId,
                    },
                });
            });
        });
    }
    simulateTransaction(transaction) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                const handleSimulateTransaction = (event) => {
                    const { type, data } = event.data;
                    const { origin } = event;
                    // ignore any broadcast postMessages
                    if (origin !== this.getOrigin()) {
                        return;
                    }
                    if (type === 'portal:simulateTransactionError') {
                        // Remove the event listener
                        window.removeEventListener('message', handleSimulateTransaction);
                        // Reject the promise with the error
                        return reject(new errors_1.PortalMpcError(data));
                    }
                    else if (type === 'portal:simulateTransactionResult') {
                        // Remove the event listener
                        window.removeEventListener('message', handleSimulateTransaction);
                        // Resolve the promise with the result
                        resolve(data);
                    }
                };
                // Bind the function to the message event
                window.addEventListener('message', handleSimulateTransaction);
                // Send the request to the iframe
                this.postMessage({
                    type: 'portal:simulateTransaction',
                    data: transaction,
                });
            });
        });
    }
    storedClientBackupShare(success) {
        return new Promise((resolve, reject) => {
            const handleStoredClientBackupShare = (event) => {
                const { type, data } = event.data;
                const { origin } = event;
                // ignore any broadcast postMessages
                if (origin !== this.getOrigin()) {
                    return;
                }
                if (type === 'portal:storedClientBackupShareError') {
                    // Remove the event listener
                    window.removeEventListener('message', handleStoredClientBackupShare);
                    // Reject the promise with the error
                    return reject(new errors_1.PortalMpcError(data));
                }
                else if (type === 'portal:storedClientBackupShareResult') {
                    // Remove the event listener
                    window.removeEventListener('message', handleStoredClientBackupShare);
                    // Resolve the promise with the result
                    resolve();
                }
            };
            // Bind the function to the message event
            window.addEventListener('message', handleStoredClientBackupShare);
            // Send the request to the iframe
            this.postMessage({
                type: 'portal:storedClientBackupShare',
                data: success,
            });
        });
    }
    /***************************
     * Private Methods
     ***************************/
    /**
     * Appends the iframe to the document body
     */
    appendIframe() {
        // Attempt authentication before appending the iframe
        const host = this.portal.host;
        const source = host.startsWith('localhost:')
            ? `http://${host}/${WEB_SDK_VERSION}/iframe/index.html?parentOrigin=${window.location.origin}`
            : `https://${host}/${WEB_SDK_VERSION}/iframe/index.html?parentOrigin=${window.location.origin}`;
        const iframe = document.createElement('iframe');
        iframe.height = '0';
        iframe.width = '0';
        iframe.src = source;
        iframe.addEventListener('load', this.configureIframe);
        document.body.appendChild(iframe);
        this.iframe = iframe;
    }
    getOrigin() {
        const host = this.portal.host;
        const origin = host.startsWith('localhost:')
            ? `http://${host}`
            : `https://${host}`;
        return origin;
    }
    postMessage(event) {
        var _a, _b;
        (_b = (_a = this.iframe) === null || _a === void 0 ? void 0 : _a.contentWindow) === null || _b === void 0 ? void 0 : _b.postMessage(event, this.getOrigin());
    }
    waitForReadyMessage() {
        const handleError = (message) => {
            const { type, data } = message.data;
            const { origin } = message;
            // ignore any broadcast postMessages
            if (origin !== this.getOrigin()) {
                return;
            }
            if (type === 'portal:wasm:error' ||
                type === 'portal:authenticationError') {
                window.removeEventListener('message', handleError);
                window.removeEventListener('message', handleReady);
                this.portal.triggerError(data);
            }
        };
        const handleReady = (message) => __awaiter(this, void 0, void 0, function* () {
            const { type, data } = message.data;
            const { origin } = message;
            // ignore any broadcast postMessages
            if (origin !== this.getOrigin()) {
                return;
            }
            if (type === 'portal:ready' && data === true) {
                // Unbind the event listener
                window.removeEventListener('message', handleReady);
                window.removeEventListener('message', handleError);
                // Update ready state
                this.portal.ready = true;
                // Update the address
                const address = yield this.getAddress();
                this.portal.address = address;
                // Trigger the ready callback
                this.portal.triggerReady();
            }
        });
        window.addEventListener('message', handleReady);
        window.addEventListener('message', handleError);
    }
    validateBackupConfig(data) {
        if (data.backupMethod === index_1.BackupMethods.password) {
            if (!data.backupConfigs.passwordStorage) {
                throw new Error('Password storage config is required');
            }
            if (!data.backupConfigs.passwordStorage.password) {
                throw new Error('Password is required');
            }
            if (data.backupConfigs.passwordStorage.password.length < 4) {
                throw new Error('Password must be at least 4 characters');
            }
        }
    }
}
var errors_2 = require("./errors");
Object.defineProperty(exports, "MpcError", { enumerable: true, get: function () { return errors_2.MpcError; } });
Object.defineProperty(exports, "MpcErrorCodes", { enumerable: true, get: function () { return errors_2.MpcErrorCodes; } });
exports.default = Mpc;
