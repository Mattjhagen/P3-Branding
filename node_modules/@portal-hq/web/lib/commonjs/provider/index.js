"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const errors_1 = require("./errors");
const passiveSignerMethods = [
    'eth_accounts',
    'eth_chainId',
    'eth_requestAccounts',
];
const signerMethods = [
    'eth_accounts',
    'eth_chainId',
    'eth_requestAccounts',
    'eth_sendTransaction',
    'eth_sign',
    'eth_signTransaction',
    'eth_signTypedData_v3',
    'eth_signTypedData_v4',
    'personal_sign',
];
class Provider {
    constructor({ portal }) {
        this.buildParams = (method, txParams) => {
            let params = txParams;
            switch (method) {
                case 'eth_sign':
                case 'personal_sign':
                case 'eth_signTypedData_v3':
                case 'eth_signTypedData_v4':
                    if (!Array.isArray(txParams)) {
                        params = [txParams];
                    }
                    break;
                default:
                    if (Array.isArray(txParams)) {
                        params = txParams[0];
                    }
            }
            return params;
        };
        this.events = {};
        this.portal = portal;
    }
    /**
     * Invokes all registered event handlers with the data provided
     * - If any `once` handlers exist, they are removed after all handlers are invoked
     *
     * @param event The name of the event to be handled
     * @param data The data to be passed to registered event handlers
     * @returns BaseProvider
     */
    emit(event, data) {
        // Grab the registered event handlers if any are available
        const handlers = this.events[event] || [];
        // Execute every event handler
        for (const registeredEventHandler of handlers) {
            void registeredEventHandler.handler(data);
        }
        // Remove any registered event handlers with the `once` flag
        this.events[event] = handlers.filter((handler) => !handler.once);
        return this;
    }
    /**
     * Registers an event handler for the provided event
     *
     * @param event The event name to add a handler to
     * @param callback The callback to be invoked when the event is emitted
     * @returns BaseProvider
     */
    on(event, callback) {
        // If no handlers are registered for this event, create an entry for the event
        if (!this.events[event]) {
            this.events[event] = [];
        }
        // Register event handler with the rudimentary event bus
        if (typeof callback !== 'undefined') {
            this.events[event].push({
                handler: callback,
                once: false,
            });
        }
        return this;
    }
    removeEventListener(event, listenerToRemove) {
        if (!this.events[event]) {
            return;
        }
        if (!listenerToRemove) {
            this.events[event] = [];
        }
        else {
            const filterEventHandlers = (registeredEventHandler) => {
                return registeredEventHandler.handler !== listenerToRemove;
            };
            this.events[event] = this.events[event].filter(filterEventHandlers);
        }
    }
    /**
     * Handles request routing in compliance with the EIP-1193 Ethereum Javascript Provider API
     * - See here for more info: https://eips.ethereum.org/EIPS/eip-1193
     *
     * @param args The arguments of the request being made
     * @returns Promise<any>
     */
    request({ method, params }) {
        return __awaiter(this, void 0, void 0, function* () {
            if (method === 'eth_chainId') {
                return this.portal.chainId;
            }
            const isSignerMethod = signerMethods.includes(method);
            let result;
            if (!isSignerMethod && !method.startsWith('wallet_')) {
                // Send to Gateway for RPC calls
                const response = yield this.handleGatewayRequest({ method, params });
                this.emit('portal_signatureReceived', {
                    method,
                    params,
                    signature: response,
                });
                if (response.error) {
                    throw new errors_1.ProviderRpcError(response.error);
                }
                result = response.result;
            }
            else if (isSignerMethod) {
                // Handle signing
                const transactionHash = yield this.handleSigningRequest({
                    method,
                    params,
                });
                if (transactionHash) {
                    this.emit('portal_signatureReceived', {
                        method,
                        params,
                        signature: transactionHash,
                    });
                    result = transactionHash;
                }
            }
            else {
                // Unsupported method
                throw new errors_1.ProviderRpcError({
                    code: errors_1.RpcErrorCodes.UnsupportedMethod,
                    data: {
                        method,
                        params,
                    },
                });
            }
            return result;
        });
    }
    /************************
     * Private Methods
     ************************/
    /**
     * Kicks off the approval flow for a given request
     *
     * @param args The arguments of the request being made
     */
    getApproval({ method, params, }) {
        return __awaiter(this, void 0, void 0, function* () {
            // If autoApprove is enabled, just resolve to true
            if (this.portal.autoApprove) {
                return true;
            }
            const signingHandlers = this.events['portal_signingRequested'];
            if (!signingHandlers || signingHandlers.length === 0) {
                throw new Error(`[PortalProvider] Auto-approve is disabled. Cannot perform signing requests without an event handler for the 'portal_signingRequested' event.`);
            }
            return new Promise((resolve) => {
                // Remove already used listeners
                this.removeEventListener('portal_signingApproved');
                this.removeEventListener('portal_signingRejected');
                const handleApproval = ({ method: approvedMethod, params: approvedParams, }) => {
                    // Remove already used listeners
                    this.removeEventListener('portal_signingApproved');
                    this.removeEventListener('portal_signingRejected');
                    // First verify that this is the same signing request
                    if (method === approvedMethod &&
                        JSON.stringify(params) === JSON.stringify(approvedParams)) {
                        resolve(true);
                    }
                };
                const handleRejection = ({ method: rejectedMethod, params: rejectedParams, }) => {
                    // Remove already used listeners
                    this.removeEventListener('portal_signingApproved');
                    this.removeEventListener('portal_signingRejected');
                    // First verify that this is the same signing request
                    if (method === rejectedMethod &&
                        JSON.stringify(params) === JSON.stringify(rejectedParams)) {
                        resolve(false);
                    }
                };
                // If the signing has been approved, resolve to true
                this.on('portal_signingApproved', handleApproval);
                // If the signing request has been rejected, resolve to false
                this.on('portal_signingRejected', handleRejection);
                // Tell any listening clients that signing has been requested
                this.emit('portal_signingRequested', {
                    method,
                    params,
                });
            });
        });
    }
    /**
     * Sends the provided request payload along to the RPC HttpRequester
     *
     * @param args The arguments of the request being made
     * @returns Promise<any>
     */
    handleGatewayRequest({ method, params, }) {
        return __awaiter(this, void 0, void 0, function* () {
            // Pass request off to the gateway
            const result = yield fetch(this.portal.getRpcUrl(), {
                body: JSON.stringify({
                    jsonrpc: '2.0',
                    id: this.portal.chainId,
                    method,
                    params,
                }),
                method: 'POST',
            });
            return result.json();
        });
    }
    /**
     * Sends the provided request payload along to the Signer
     *
     * @param args The arguments of the request being made
     * @returns Promise<any>
     */
    handleSigningRequest({ method, params, }) {
        return __awaiter(this, void 0, void 0, function* () {
            const isApproved = passiveSignerMethods.includes(method)
                ? true
                : yield this.getApproval({ method, params });
            if (!isApproved) {
                console.warn(`[PortalProvider] Request for signing method '${method}' could not be completed because it was not approved by the user.`);
                return;
            }
            switch (method) {
                case 'eth_chainId':
                    return `0x${this.portal.chainId.toString(16)}`;
                case 'eth_accounts':
                case 'eth_requestAccounts':
                    return [this.portal.address];
                case 'eth_sendTransaction':
                case 'eth_sign':
                case 'eth_signTransaction':
                case 'eth_signTypedData_v3':
                case 'eth_signTypedData_v4':
                case 'personal_sign': {
                    const result = yield this.portal.mpc.sign({
                        host: this.portal.host,
                        method,
                        mpcVersion: this.portal.mpcVersion,
                        params: this.buildParams(method, params),
                        featureFlags: this.portal.featureFlags,
                    });
                    return result;
                }
                default:
                    throw new Error('[PortalProvider] Method "' + method + '" not supported');
            }
        });
    }
}
exports.default = Provider;
