import { type DkgData, PortalError } from '@portal-hq/utils'
import type { MpcErrorCodes } from './src/mpc/errors'

import Api from '../iframe/core/api'
import GDriveStorage from '../iframe/core/storage/gdrive'
import Portal from './src/index'
import Provider from './src/provider'

export type GatewayLike = GatewayConfig | string
export type EventHandler = (event: Event<any>) => void | Promise<void>
export type EthereumTransaction = EIP1559Transaction | LegacyTransaction
export type MessageData =
  | BackupArgs
  | DecryptArgs
  | EncryptArgs
  | GenerateArgs
  | RecoverArgs
  | SignArgs
export type ProgressCallback = (status: MpcStatus) => void | Promise<void>
export type ValidRpcErrorCodes = 4001 | 4100 | 4200 | 4900 | 4901

// Interfaces

export interface FeatureFlags {
  optimized: boolean = false
}

export interface AddressResult {
  data: string
  type: string
}

export interface BackupArgs extends MpcOperationArgs {
  backupMethod: BackupMethods
  backupConfigs: BackupConfigs = {}
}

export interface BackupConfigs {
  passwordStorage?: PasswordConfig
}

export interface PasswordConfig {
  password: string
}

export interface BackupData {
  share: string
}

export interface BackupResult {
  error: PortalError
  data: BackupData
}

export interface Bk {
  X: string
  Rank: number
}

export interface Address {
  id: string
  network: Network
  value: string
}

export interface Balance {
  contractAddress: string
  balance: string
}

export interface ClientWithCustodianData {
  id: string
  address: string
  backupStatus?: string | null
  custodian: {
    id: string
    name: string
  }
  signingStatus?: string | null
}

export interface DappOnNetwork {
  clientUrl?: string
  dapp: Dapp
  id: string
  network: Network
}

export interface Dapp {
  id: string
  name: string

  addresses: Address[]
  dappOnNetworks: DappOnNetwork[]
  image: DappImage
}

export interface DappImage {
  id: string
  filename: string
  data: string
}

export interface DecryptArgs {
  cipherText: string
  key: string
}

export interface DkgData {
  allY: Pubkey[]
  bks: Bk[]
  p: string
  partialPubKey: Pubkey[]
  pederson: PedersonParams[]
  pubkey: Pubkey
  q: string
  share: string
  signingSharePairId?: string
  ssid: string
}

export interface EIP1559Transaction {
  from: string
  to: string

  // Optional
  data?: string
  gasLimit?: string
  maxFeePerGas?: string
  maxPriorityFeePerGas?: string
  nonce?: string
  value?: string
}

export interface EncryptArgs {
  dkgData: string
}

export interface EncryptedWithPasswordData {
  cipherText: string
}

export interface EncryptedData {
  cipherText: string
  key: string
}

export interface EncryptedResult {
  data: EncryptData
  error: PortalError
}

export interface EncryptedWithPasswordResult {
  data: EncryptedWithPasswordData
  error: PortalError
}

export interface DecryptData {
  plaintext: string
}

export interface DecryptResult {
  data: DecryptData
  error: PortalError
}

export interface GatewayConfig {
  [key: number]: string
}

export interface GDriveConfig {
  clientId: string
}

export interface GDriveStorageOptions {
  portal: Portal
}

export type GenerateArgs = MpcOperationArgs

export interface GenerateData {
  address: string
  dkgResult: DkgData
}

export interface GenerateResult {
  data: GenerateData
  error: PortalError
}

export interface GenerateResponse {
  address: string
  cipherText?: string
  share?: string
}

export interface IframeConfigurationOptions {
  autoApprove: boolean
  chainId: number
  featureFlags?: FeatureFlags
  gdrive?: GDriveConfig
  host: string
  rpcUrl: string

  // One of these three is required for authentication
  apiKey?: string
  authToken?: string
  authUrl?: string
}

export interface LegacyTransaction {
  from: string
  to: string

  // Optional
  data?: string
  gasLimit?: string
  gasPrice?: string
  nonce?: string
  value?: string
}

export interface MpcErrorData {
  code: MpcErrorCodes
  message: (str?: string) => string
}

export interface MpcOperationArgs {
  host: string
  mpcVersion: string
  featureFlags?: FeatureFlags
}

export interface MpcOptions {
  portal: Portal
}

export interface MpcStatus {
  status: MpcStatuses
  done: boolean
}

export interface Network {
  id: string
  chainId: string
  name: string
}

export interface NFT {
  contract: NFTContract
  id: TokenId
  balance: string
  title: string
  description: string
  tokenUri: TokenUri
  media: Media[]
  metadata: Metadata
  timeLastUpdated: string
  contractMetadata: ContractMetadata
}

export interface NFTContract {
  address: string
}

export interface PedersonParams {
  n: string
  s: string
  t: string
}

export interface PortalApiOptions {
  apiKey: string
  baseUrl: string
  chainId: number
  host: string
  portal: Portal
}

export interface PortalError {
  code: number
  message: string
}

export interface PortalOptions {
  // Required options
  gatewayConfig: GatewayLike

  // Optional options
  apiKey?: string
  authToken?: string
  authUrl?: string
  autoApprove?: boolean
  chainId?: number
  gdrive?: GDriveConfig
  host?: string
  keychain?: KeychainAdapter
  mpcVersion?: string
  featureFlags?: FeatureFlags
}

export interface ProviderOptions {
  // Required options
  portal: Portal
}

export interface Pubkey {
  X: string
  Y: string
}

export interface QuoteArgs {
  affiliateAddress?: string
  buyAmount?: number
  buyToken: string
  buyTokenPercentageFee?: number
  enableSlippageProtection?: boolean
  excludedSources?: string
  feeRecipient?: string
  gasPrice?: number
  includedSources?: string
  intentOnFilling?: boolean
  priceImpactProtectionPercentage?: number
  sellAmount?: number
  sellToken: string
  skipValidation?: boolean
  slippagePercentage?: number
  takerAddress?: string
}

export interface QuoteResponse {
  allowanceTarget: string
  cost: string
  transaction: Eip1559 | LegacyTx
}

export interface RegisteredEventHandler {
  handler: EventHandler
  once?: boolean
}

export interface RequestArguments {
  method: string
  params?: unknown[] | SigningRequestParams
}

export interface LegacyRecoverArgs extends MpcOperationArgs {
  cipherText: string
}
export interface RecoverArgs extends MpcOperationArgs {
  cipherText: string
  backupMethod: BackupMethods
  backupConfigs: BackupConfigs
  featureFlags?: FeatureFlags // TODO: Remove this
}

export interface RotateResult {
  data: RotateData
  error: PortalError
}

export interface RotateData {
  address: string
  dkgResult: DkgData
}

export interface RpcErrorDefinition {
  description: string
  name: string
}

export interface RpcErrorOptions {
  code: ValidProviderRpcErrorCodes
  data?: unknown
}

export interface SignArgs extends MpcOperationArgs {
  method: string
  params: string
  featureFlags?: FeatureFlags
}

export interface SignData {
  R: string
  S: string
}

export interface SignResult {
  data: string
  error: PortalError
}

export interface SignerOptions {
  portal: Portal
}

export interface SimulateTransactionParam {
  to: string
  value?: string
  data?: string
  gas?: string
  gasPrice?: string
  maxFeePerGas?: string
  maxPriorityFeePerGas?: string
}

export interface SimulatedTransactionChange {
  amount?: string
  assetType?: string
  changeType?: string
  contractAddress?: string
  decimals?: number
  from?: string
  name?: string
  rawAmount?: string
  symbol?: string
  to?: string
  tokenId?: number
}

export interface SimulatedTransactionError {
  message: string
}

export interface SimulatedTransaction {
  changes: SimulatedTransactionChange[]
  gasUsed?: string
  error?: SimulatedTransactionError
  requestError?: SimulatedTransactionError
}

export enum GetTransactionsOrder {
  ASC = 'asc',
  DESC = 'desc',
}

export interface Transaction {
  asset: string
  blockNum: string
  category: string
  chainId: number
  erc1155Metadata: null | string
  erc721TokenId: null | string
  from: string
  hash: string
  metadata: {
    blockTimestamp: string
  }
  rawContract: {
    address: string
    decimal: string
    value: string
  }
  to: string
  tokenId: null | string
  uniqueId: string
  value: number
}

export interface SwitchEthereumChainParameter {
  chainId: number
}

export interface TypedData {
  types: Type[]
  primaryType: string
  domain: string
  message: string
}

export interface Type {
  name: string
  type: string
}

export interface WorkerMessage {
  type: string
  data:
    | BackupArgs
    | DecryptArgs
    | EncryptArgs
    | GenerateArgs
    | RecoverArgs
    | SignArgs
}

export interface WorkerResult {
  type: string
  data:
    | boolean
    | string
    | BackupResult
    | DecryptResult
    | EncryptedResult
    | EncryptedWithPasswordResult
    | GenerateResult
    | MpcStatus
    | PortalError
    | ReadyResult
    | RecoverResult
    | SignResult
}
