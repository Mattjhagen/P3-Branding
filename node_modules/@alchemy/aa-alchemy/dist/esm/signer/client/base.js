import { ConnectionConfigSchema, } from "@alchemy/aa-core";
import { TurnkeyClient } from "@turnkey/http";
import EventEmitter from "eventemitter3";
import { NotAuthenticatedError } from "../errors.js";
import { base64UrlEncode } from "../utils/base64UrlEncode.js";
export class BaseSignerClient {
    constructor(params) {
        Object.defineProperty(this, "_user", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "connectionConfig", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "turnkeyClient", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "rootOrg", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "eventEmitter", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "on", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: (event, listener) => {
                this.eventEmitter.on(event, listener);
                return () => this.eventEmitter.removeListener(event, listener);
            }
        });
        Object.defineProperty(this, "addPasskey", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: async (options) => {
                if (!this.user) {
                    throw new NotAuthenticatedError();
                }
                const { attestation, challenge } = await this.getWebAuthnAttestation(options);
                const { activity } = await this.turnkeyClient.createAuthenticators({
                    type: "ACTIVITY_TYPE_CREATE_AUTHENTICATORS_V2",
                    timestampMs: Date.now().toString(),
                    organizationId: this.user.orgId,
                    parameters: {
                        userId: this.user.userId,
                        authenticators: [
                            {
                                attestation,
                                authenticatorName: `passkey-${Date.now().toString()}`,
                                challenge: base64UrlEncode(challenge),
                            },
                        ],
                    },
                });
                const { authenticatorIds } = await this.pollActivityCompletion(activity, this.user.orgId, "createAuthenticatorsResult");
                return authenticatorIds;
            }
        });
        Object.defineProperty(this, "whoami", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: async (orgId = this.user?.orgId) => {
                if (this.user) {
                    return this.user;
                }
                if (!orgId) {
                    throw new Error("No orgId provided");
                }
                const stampedRequest = await this.turnkeyClient.stampGetWhoami({
                    organizationId: orgId,
                });
                const user = await this.request("/v1/whoami", {
                    stampedRequest,
                });
                const credentialId = (() => {
                    try {
                        return JSON.parse(stampedRequest?.stamp.stampHeaderValue)
                            .credentialId;
                    }
                    catch (e) {
                        return undefined;
                    }
                })();
                this.user = {
                    ...user,
                    credentialId,
                };
                return this.user;
            }
        });
        Object.defineProperty(this, "lookupUserByEmail", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: async (email) => {
                return this.request("/v1/lookup", { email });
            }
        });
        Object.defineProperty(this, "signRawMessage", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: async (msg) => {
                if (!this.user) {
                    throw new NotAuthenticatedError();
                }
                const stampedRequest = await this.turnkeyClient.stampSignRawPayload({
                    organizationId: this.user.orgId,
                    type: "ACTIVITY_TYPE_SIGN_RAW_PAYLOAD_V2",
                    timestampMs: Date.now().toString(),
                    parameters: {
                        encoding: "PAYLOAD_ENCODING_HEXADECIMAL",
                        hashFunction: "HASH_FUNCTION_NO_OP",
                        payload: msg,
                        signWith: this.user.address,
                    },
                });
                const { signature } = await this.request("/v1/sign-payload", {
                    stampedRequest,
                });
                return signature;
            }
        });
        Object.defineProperty(this, "getUser", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: () => {
                return this.user ?? null;
            }
        });
        Object.defineProperty(this, "request", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: async (route, body) => {
                const url = this.connectionConfig.rpcUrl ?? "https://api.g.alchemy.com";
                const basePath = "/signer";
                const headers = new Headers();
                headers.append("Content-Type", "application/json");
                if (this.connectionConfig.apiKey) {
                    headers.append("Authorization", `Bearer ${this.connectionConfig.apiKey}`);
                }
                else if (this.connectionConfig.jwt) {
                    headers.append("Authorization", `Bearer ${this.connectionConfig.jwt}`);
                }
                const response = await fetch(`${url}${basePath}${route}`, {
                    method: "POST",
                    body: JSON.stringify(body),
                    headers,
                });
                if (!response.ok) {
                    throw new Error(await response.text());
                }
                const json = await response.json();
                return json;
            }
        });
        Object.defineProperty(this, "exportAsSeedPhrase", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: async (stamper) => {
                if (!this.user) {
                    throw new NotAuthenticatedError();
                }
                const { wallets } = await this.turnkeyClient.getWallets({
                    organizationId: this.user.orgId,
                });
                const walletAccounts = await Promise.all(wallets.map(({ walletId }) => this.turnkeyClient.getWalletAccounts({
                    organizationId: this.user.orgId,
                    walletId,
                }))).then((x) => x.flatMap((x) => x.accounts));
                const walletAccount = walletAccounts.find((x) => x.address === this.user.address);
                if (!walletAccount) {
                    throw new Error(`Could not find wallet associated with ${this.user.address}`);
                }
                const { activity } = await this.turnkeyClient.exportWallet({
                    organizationId: this.user.orgId,
                    type: "ACTIVITY_TYPE_EXPORT_WALLET",
                    timestampMs: Date.now().toString(),
                    parameters: {
                        walletId: walletAccount.walletId,
                        targetPublicKey: stamper.publicKey(),
                    },
                });
                const { exportBundle } = await this.pollActivityCompletion(activity, this.user.orgId, "exportWalletResult");
                const result = await stamper.injectWalletExportBundle(exportBundle);
                if (!result) {
                    throw new Error("Failed to inject wallet export bundle");
                }
                return result;
            }
        });
        Object.defineProperty(this, "exportAsPrivateKey", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: async (stamper) => {
                if (!this.user) {
                    throw new NotAuthenticatedError();
                }
                const { activity } = await this.turnkeyClient.exportWalletAccount({
                    organizationId: this.user.orgId,
                    type: "ACTIVITY_TYPE_EXPORT_WALLET_ACCOUNT",
                    timestampMs: Date.now().toString(),
                    parameters: {
                        address: this.user.address,
                        targetPublicKey: stamper.publicKey(),
                    },
                });
                const { exportBundle } = await this.pollActivityCompletion(activity, this.user.orgId, "exportWalletAccountResult");
                const result = await stamper.injectKeyExportBundle(exportBundle);
                if (!result) {
                    throw new Error("Failed to inject wallet export bundle");
                }
                return result;
            }
        });
        Object.defineProperty(this, "pollActivityCompletion", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: async (activity, organizationId, resultKey) => {
                if (activity.status === "ACTIVITY_STATUS_COMPLETED") {
                    return activity.result[resultKey];
                }
                const { activity: { status, id, result }, } = await this.turnkeyClient.getActivity({
                    activityId: activity.id,
                    organizationId,
                });
                if (status === "ACTIVITY_STATUS_COMPLETED") {
                    return result[resultKey];
                }
                if (status === "ACTIVITY_STATUS_FAILED" ||
                    status === "ACTIVITY_STATUS_REJECTED" ||
                    status === "ACTIVITY_STATUS_CONSENSUS_NEEDED") {
                    throw new Error(`Failed to get activity with with id ${id} (status: ${status})`);
                }
                await new Promise((resolve) => setTimeout(resolve, 500));
                return this.pollActivityCompletion(activity, organizationId, resultKey);
            }
        });
        const { stamper, connection, rootOrgId } = params;
        this.rootOrg = rootOrgId ?? "24c1acf5-810f-41e0-a503-d5d13fa8e830";
        this.eventEmitter = new EventEmitter();
        this.connectionConfig = ConnectionConfigSchema.parse(connection);
        this.turnkeyClient = new TurnkeyClient({ baseUrl: "https://api.turnkey.com" }, stamper);
    }
    get user() {
        return this._user;
    }
    set user(user) {
        if (user && !this._user) {
            this.eventEmitter.emit("connected", user);
        }
        else if (!user && this._user) {
            this.eventEmitter.emit("disconnected");
        }
        this._user = user;
    }
    setStamper(stamper) {
        this.turnkeyClient.stamper = stamper;
    }
    exportWalletInner(params) {
        switch (params.exportAs) {
            case "PRIVATE_KEY":
                return this.exportAsPrivateKey(params.exportStamper);
            case "SEED_PHRASE":
                return this.exportAsSeedPhrase(params.exportStamper);
        }
    }
}
//# sourceMappingURL=base.js.map