{"version":3,"file":"manager.js","sourceRoot":"","sources":["../../../../src/signer/session/manager.ts"],"names":[],"mappings":"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","sourcesContent":["import EventEmitter from \"eventemitter3\";\nimport { z } from \"zod\";\nimport {\n  createJSONStorage,\n  persist,\n  subscribeWithSelector,\n} from \"zustand/middleware\";\nimport { createStore, type Mutate, type StoreApi } from \"zustand/vanilla\";\nimport type { BaseSignerClient } from \"../client/base\";\nimport type { User } from \"../client/types\";\nimport type { Session, SessionManagerEvents } from \"./types\";\n\nexport const DEFAULT_SESSION_MS = 15 * 60 * 1000; // 15 minutes\n\nexport const SessionManagerParamsSchema = z.object({\n  sessionKey: z.string().default(\"alchemy-signer-session\"),\n  storage: z\n    .enum([\"localStorage\", \"sessionStorage\"])\n    .default(\"localStorage\")\n    .or(z.custom<Storage>()),\n  expirationTimeMs: z\n    .number()\n    .default(DEFAULT_SESSION_MS)\n    .describe(\n      \"The time in milliseconds that a session should last before expiring [default: 15 minutes]\"\n    ),\n  client: z.custom<BaseSignerClient>(),\n});\n\nexport type SessionManagerParams = z.input<typeof SessionManagerParamsSchema>;\n\ntype SessionState = {\n  session: Session | null;\n};\n\ntype Store = Mutate<\n  StoreApi<SessionState>,\n  [[\"zustand/subscribeWithSelector\", never], [\"zustand/persist\", SessionState]]\n>;\n\nexport class SessionManager {\n  private sessionKey: string;\n  private client: BaseSignerClient;\n  private eventEmitter: EventEmitter<SessionManagerEvents>;\n  readonly expirationTimeMs: number;\n  private store: Store;\n\n  constructor(params: SessionManagerParams) {\n    const {\n      sessionKey,\n      storage: storageType,\n      expirationTimeMs,\n      client,\n    } = SessionManagerParamsSchema.parse(params);\n    this.sessionKey = sessionKey;\n    const storage =\n      typeof storageType === \"string\"\n        ? storageType === \"localStorage\"\n          ? localStorage\n          : sessionStorage\n        : storageType;\n    this.expirationTimeMs = expirationTimeMs;\n    this.client = client;\n    this.eventEmitter = new EventEmitter<SessionManagerEvents>();\n\n    this.store = createStore(\n      subscribeWithSelector(\n        persist(this.getInitialState, {\n          name: this.sessionKey,\n          storage: createJSONStorage<SessionState>(() => storage),\n        })\n      )\n    );\n\n    this.registerEventListeners();\n  }\n\n  public getSessionUser = async (): Promise<User | null> => {\n    const existingSession = this.getSession();\n    if (existingSession == null) {\n      return null;\n    }\n\n    switch (existingSession.type) {\n      case \"email\": {\n        const result = await this.client\n          .completeEmailAuth({\n            bundle: existingSession.bundle,\n            orgId: existingSession.user.orgId,\n          })\n          .catch((e) => {\n            console.warn(\"Failed to load user from session\", e);\n            return null;\n          });\n\n        if (!result) {\n          this.clearSession();\n          return null;\n        }\n\n        return result;\n      }\n      case \"passkey\": {\n        // we don't need to do much here if we already have a user\n        // this will setup the client with the user context, but\n        // requests still have to be signed by the user on first request\n        // so this is fine\n        return this.client.lookupUserWithPasskey(existingSession.user);\n      }\n      default:\n        throw new Error(\"Unknown session type\");\n    }\n  };\n\n  public clearSession = () => {\n    this.store.setState({ session: null });\n  };\n\n  public setTemporarySession = (session: { orgId: string }) => {\n    // temporary session must be placed in localStorage so that it can be accessed across tabs\n    localStorage.setItem(\n      `${this.sessionKey}:temporary`,\n      JSON.stringify(session)\n    );\n  };\n\n  public getTemporarySession = (): { orgId: string } | null => {\n    // temporary session must be placed in localStorage so that it can be accessed across tabs\n    const sessionStr = localStorage.getItem(`${this.sessionKey}:temporary`);\n\n    if (!sessionStr) {\n      return null;\n    }\n\n    return JSON.parse(sessionStr);\n  };\n\n  on = <E extends keyof SessionManagerEvents>(\n    event: E,\n    listener: SessionManagerEvents[E]\n  ) => {\n    this.eventEmitter.on(event, listener as any);\n\n    return () => this.eventEmitter.removeListener(event, listener as any);\n  };\n\n  private getSession = (): Session | null => {\n    const session = this.store.getState().session;\n\n    if (!session) {\n      return null;\n    }\n\n    /**\n     * TODO: this isn't really good enough\n     * A user's session could be about to expire and we would still return it\n     *\n     * Instead we should check if a session is about to expire and refresh it\n     * We should revisit this later\n     */\n    if (session.expirationDateMs < Date.now()) {\n      this.store.setState({ session: null });\n      return null;\n    }\n\n    return session;\n  };\n\n  private setSession = (\n    session:\n      | Omit<Extract<Session, { type: \"email\" }>, \"expirationDateMs\">\n      | Omit<Extract<Session, { type: \"passkey\" }>, \"expirationDateMs\">\n  ) => {\n    this.store.setState({\n      session: {\n        ...session,\n        expirationDateMs: Date.now() + this.expirationTimeMs,\n      },\n    });\n  };\n\n  public initialize() {\n    this.getSessionUser()\n      .then((user) => {\n        // once we complete auth we can update the state of the session to connected or disconnected\n        if (user) this.eventEmitter.emit(\"connected\", this.getSession()!);\n        else this.eventEmitter.emit(\"disconnected\");\n      })\n      .finally(() => {\n        this.eventEmitter.emit(\"initialized\");\n      });\n  }\n\n  private getInitialState(): SessionState {\n    return {\n      session: null,\n    };\n  }\n\n  private registerEventListeners = () => {\n    this.store.subscribe(\n      ({ session }) => session,\n      (session, prevSession) => {\n        if (session != null && prevSession == null) {\n          this.eventEmitter.emit(\"connected\", session);\n        } else if (session == null && prevSession != null) {\n          this.eventEmitter.emit(\"disconnected\");\n        }\n      }\n    );\n\n    this.client.on(\"disconnected\", () => this.clearSession());\n\n    this.client.on(\"connectedEmail\", (user, bundle) => {\n      const existingSession = this.getSession();\n      if (\n        existingSession != null &&\n        existingSession.type === \"email\" &&\n        existingSession.user.userId === user.userId &&\n        // if the bundle is different, then we've refreshed the session\n        // so we need to reset the session\n        existingSession.bundle === bundle\n      ) {\n        return;\n      }\n\n      this.setSession({ type: \"email\", user, bundle });\n    });\n\n    this.client.on(\"connectedPasskey\", (user) => {\n      const existingSession = this.getSession();\n      if (\n        existingSession != null &&\n        existingSession.type === \"passkey\" &&\n        existingSession.user.userId === user.userId\n      ) {\n        return;\n      }\n\n      this.setSession({ type: \"passkey\", user });\n    });\n\n    // sync local state if persisted state has changed from another tab\n    window.addEventListener(\"focus\", () => {\n      this.store.persist.rehydrate();\n      this.initialize();\n    });\n  };\n}\n"]}