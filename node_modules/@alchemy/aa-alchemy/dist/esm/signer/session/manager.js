import EventEmitter from "eventemitter3";
import { z } from "zod";
import { createJSONStorage, persist, subscribeWithSelector, } from "zustand/middleware";
import { createStore } from "zustand/vanilla";
export const DEFAULT_SESSION_MS = 15 * 60 * 1000;
export const SessionManagerParamsSchema = z.object({
    sessionKey: z.string().default("alchemy-signer-session"),
    storage: z
        .enum(["localStorage", "sessionStorage"])
        .default("localStorage")
        .or(z.custom()),
    expirationTimeMs: z
        .number()
        .default(DEFAULT_SESSION_MS)
        .describe("The time in milliseconds that a session should last before expiring [default: 15 minutes]"),
    client: z.custom(),
});
export class SessionManager {
    constructor(params) {
        Object.defineProperty(this, "sessionKey", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "client", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "eventEmitter", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "expirationTimeMs", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "store", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "getSessionUser", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: async () => {
                const existingSession = this.getSession();
                if (existingSession == null) {
                    return null;
                }
                switch (existingSession.type) {
                    case "email": {
                        const result = await this.client
                            .completeEmailAuth({
                            bundle: existingSession.bundle,
                            orgId: existingSession.user.orgId,
                        })
                            .catch((e) => {
                            console.warn("Failed to load user from session", e);
                            return null;
                        });
                        if (!result) {
                            this.clearSession();
                            return null;
                        }
                        return result;
                    }
                    case "passkey": {
                        return this.client.lookupUserWithPasskey(existingSession.user);
                    }
                    default:
                        throw new Error("Unknown session type");
                }
            }
        });
        Object.defineProperty(this, "clearSession", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: () => {
                this.store.setState({ session: null });
            }
        });
        Object.defineProperty(this, "setTemporarySession", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: (session) => {
                localStorage.setItem(`${this.sessionKey}:temporary`, JSON.stringify(session));
            }
        });
        Object.defineProperty(this, "getTemporarySession", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: () => {
                const sessionStr = localStorage.getItem(`${this.sessionKey}:temporary`);
                if (!sessionStr) {
                    return null;
                }
                return JSON.parse(sessionStr);
            }
        });
        Object.defineProperty(this, "on", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: (event, listener) => {
                this.eventEmitter.on(event, listener);
                return () => this.eventEmitter.removeListener(event, listener);
            }
        });
        Object.defineProperty(this, "getSession", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: () => {
                const session = this.store.getState().session;
                if (!session) {
                    return null;
                }
                if (session.expirationDateMs < Date.now()) {
                    this.store.setState({ session: null });
                    return null;
                }
                return session;
            }
        });
        Object.defineProperty(this, "setSession", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: (session) => {
                this.store.setState({
                    session: {
                        ...session,
                        expirationDateMs: Date.now() + this.expirationTimeMs,
                    },
                });
            }
        });
        Object.defineProperty(this, "registerEventListeners", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: () => {
                this.store.subscribe(({ session }) => session, (session, prevSession) => {
                    if (session != null && prevSession == null) {
                        this.eventEmitter.emit("connected", session);
                    }
                    else if (session == null && prevSession != null) {
                        this.eventEmitter.emit("disconnected");
                    }
                });
                this.client.on("disconnected", () => this.clearSession());
                this.client.on("connectedEmail", (user, bundle) => {
                    const existingSession = this.getSession();
                    if (existingSession != null &&
                        existingSession.type === "email" &&
                        existingSession.user.userId === user.userId &&
                        existingSession.bundle === bundle) {
                        return;
                    }
                    this.setSession({ type: "email", user, bundle });
                });
                this.client.on("connectedPasskey", (user) => {
                    const existingSession = this.getSession();
                    if (existingSession != null &&
                        existingSession.type === "passkey" &&
                        existingSession.user.userId === user.userId) {
                        return;
                    }
                    this.setSession({ type: "passkey", user });
                });
                window.addEventListener("focus", () => {
                    this.store.persist.rehydrate();
                    this.initialize();
                });
            }
        });
        const { sessionKey, storage: storageType, expirationTimeMs, client, } = SessionManagerParamsSchema.parse(params);
        this.sessionKey = sessionKey;
        const storage = typeof storageType === "string"
            ? storageType === "localStorage"
                ? localStorage
                : sessionStorage
            : storageType;
        this.expirationTimeMs = expirationTimeMs;
        this.client = client;
        this.eventEmitter = new EventEmitter();
        this.store = createStore(subscribeWithSelector(persist(this.getInitialState, {
            name: this.sessionKey,
            storage: createJSONStorage(() => storage),
        })));
        this.registerEventListeners();
    }
    initialize() {
        this.getSessionUser()
            .then((user) => {
            if (user)
                this.eventEmitter.emit("connected", this.getSession());
            else
                this.eventEmitter.emit("disconnected");
        })
            .finally(() => {
            this.eventEmitter.emit("initialized");
        });
    }
    getInitialState() {
        return {
            session: null,
        };
    }
}
//# sourceMappingURL=manager.js.map