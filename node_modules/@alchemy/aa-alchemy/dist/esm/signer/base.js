import { takeBytes } from "@alchemy/aa-core";
import { hashMessage, hashTypedData, keccak256, serializeTransaction, } from "viem";
import { toAccount } from "viem/accounts";
import { subscribeWithSelector } from "zustand/middleware";
import { createStore } from "zustand/vanilla";
import { NotAuthenticatedError } from "./errors.js";
import { SessionManager, } from "./session/manager.js";
import { AlchemySignerStatus, } from "./types.js";
export class BaseAlchemySigner {
    constructor({ client, sessionConfig }) {
        Object.defineProperty(this, "signerType", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "alchemy-signer"
        });
        Object.defineProperty(this, "inner", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "sessionManager", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "store", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "on", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: (event, listener) => {
                switch (event) {
                    case "connected":
                        return this.store.subscribe(({ status }) => status, (status) => status === AlchemySignerStatus.CONNECTED &&
                            listener(this.store.getState().user), { fireImmediately: true });
                    case "disconnected":
                        return this.store.subscribe(({ status }) => status, (status) => status === AlchemySignerStatus.DISCONNECTED &&
                            listener(), { fireImmediately: true });
                    case "statusChanged":
                        return this.store.subscribe(({ status }) => status, listener, { fireImmediately: true });
                    default:
                        throw new Error(`Uknown event type ${event}`);
                }
            }
        });
        Object.defineProperty(this, "authenticate", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: async (params) => {
                if (params.type === "email") {
                    return this.authenticateWithEmail(params);
                }
                return this.authenticateWithPasskey(params);
            }
        });
        Object.defineProperty(this, "disconnect", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: async () => {
                await this.inner.disconnect();
            }
        });
        Object.defineProperty(this, "getAuthDetails", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: async () => {
                const sessionUser = await this.sessionManager.getSessionUser();
                if (sessionUser != null) {
                    return sessionUser;
                }
                return this.inner.whoami();
            }
        });
        Object.defineProperty(this, "getAddress", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: async () => {
                const { address } = await this.inner.whoami();
                return address;
            }
        });
        Object.defineProperty(this, "signMessage", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: async (msg) => {
                const messageHash = hashMessage(msg);
                return this.inner.signRawMessage(messageHash);
            }
        });
        Object.defineProperty(this, "signTypedData", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: async (params) => {
                const messageHash = hashTypedData(params);
                return this.inner.signRawMessage(messageHash);
            }
        });
        Object.defineProperty(this, "signTransaction", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: async (tx, args) => {
                const serializeFn = args?.serializer ?? serializeTransaction;
                const serializedTx = serializeFn(tx);
                const signatureHex = await this.inner.signRawMessage(keccak256(serializedTx));
                const signature = {
                    r: takeBytes(signatureHex, { count: 32 }),
                    s: takeBytes(signatureHex, { count: 32, offset: 32 }),
                    v: BigInt(takeBytes(signatureHex, { count: 1, offset: 64 })),
                };
                return serializeFn(tx, signature);
            }
        });
        Object.defineProperty(this, "getUser", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: async (email) => {
                const result = await this.inner.lookupUserByEmail(email);
                if (result.orgId == null) {
                    return null;
                }
                return {
                    orgId: result.orgId,
                };
            }
        });
        Object.defineProperty(this, "addPasskey", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: async (params) => {
                return this.inner.addPasskey(params ?? {});
            }
        });
        Object.defineProperty(this, "exportWallet", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: async (params) => {
                return this.inner.exportWallet(params);
            }
        });
        Object.defineProperty(this, "toViemAccount", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: () => {
                if (!this.inner.getUser()) {
                    throw new NotAuthenticatedError();
                }
                return toAccount({
                    address: this.inner.getUser().address,
                    signMessage: (msg) => this.signMessage(msg.message),
                    signTypedData: (typedDataDefinition) => this.signTypedData(typedDataDefinition),
                    signTransaction: this.signTransaction,
                });
            }
        });
        Object.defineProperty(this, "authenticateWithEmail", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: async (params) => {
                if ("email" in params) {
                    const existingUser = await this.getUser(params.email);
                    const { orgId } = existingUser
                        ? await this.inner.initEmailAuth({
                            email: params.email,
                            expirationSeconds: this.sessionManager.expirationTimeMs,
                            redirectParams: params.redirectParams,
                        })
                        : await this.inner.createAccount({
                            type: "email",
                            email: params.email,
                            expirationSeconds: this.sessionManager.expirationTimeMs,
                            redirectParams: params.redirectParams,
                        });
                    this.sessionManager.setTemporarySession({ orgId });
                    this.store.setState({ status: AlchemySignerStatus.AWAITING_EMAIL_AUTH });
                    return new Promise((resolve) => {
                        const removeListener = this.sessionManager.on("connected", (session) => {
                            resolve(session.user);
                            removeListener();
                        });
                    });
                }
                else {
                    const temporarySession = params.orgId
                        ? { orgId: params.orgId }
                        : this.sessionManager.getTemporarySession();
                    if (!temporarySession) {
                        this.store.setState({ status: AlchemySignerStatus.DISCONNECTED });
                        throw new Error("Could not find email auth init session!");
                    }
                    const user = await this.inner.completeEmailAuth({
                        bundle: params.bundle,
                        orgId: temporarySession.orgId,
                    });
                    return user;
                }
            }
        });
        Object.defineProperty(this, "authenticateWithPasskey", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: async (args) => {
                let user;
                if (args.createNew) {
                    const result = await this.inner.createAccount(args);
                    user = {
                        address: result.address,
                        userId: result.userId,
                        orgId: result.orgId,
                    };
                }
                else {
                    user = await this.inner.lookupUserWithPasskey();
                    if (!user) {
                        this.store.setState({ status: AlchemySignerStatus.DISCONNECTED });
                        throw new Error("No user found");
                    }
                }
                return user;
            }
        });
        Object.defineProperty(this, "registerListeners", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: () => {
                this.sessionManager.on("connected", (session) => {
                    this.store.setState({
                        user: session.user,
                        status: AlchemySignerStatus.CONNECTED,
                    });
                });
                this.sessionManager.on("disconnected", () => {
                    this.store.setState({
                        user: null,
                        status: AlchemySignerStatus.DISCONNECTED,
                    });
                });
                this.sessionManager.on("initialized", () => {
                    this.store.setState((state) => ({
                        status: state.user
                            ? AlchemySignerStatus.CONNECTED
                            : AlchemySignerStatus.DISCONNECTED,
                    }));
                });
                this.inner.on("authenticating", () => {
                    this.store.setState({ status: AlchemySignerStatus.AUTHENTICATING });
                });
            }
        });
        this.inner = client;
        this.store = createStore(subscribeWithSelector(() => ({
            user: null,
            status: AlchemySignerStatus.INITIALIZING,
        })));
        this.sessionManager = new SessionManager({
            ...sessionConfig,
            client: this.inner,
        });
        this.store = createStore(subscribeWithSelector(() => ({
            user: null,
            status: AlchemySignerStatus.INITIALIZING,
        })));
        this.registerListeners();
        this.sessionManager.initialize();
    }
}
//# sourceMappingURL=base.js.map