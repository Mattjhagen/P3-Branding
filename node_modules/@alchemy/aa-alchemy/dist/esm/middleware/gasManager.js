import { bypassPaymasterAndDataEmptyHex, deepHexlify, defaultGasEstimator, filterUndefined, isBigNumberish, isMultiplier, resolveProperties, } from "@alchemy/aa-core";
import { concat, fromHex, isHex } from "viem";
import { getAlchemyPaymasterAddress } from "../gas-manager.js";
import { alchemyFeeEstimator } from "./feeEstimator.js";
const dummyPaymasterAndData = (client, config) => () => {
    const paymaster = config.paymasterAddress ?? getAlchemyPaymasterAddress(client.chain);
    const paymasterData = config.dummyData ??
        "0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0000000000000000000000000000000007aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa1c";
    return concat([paymaster, paymasterData]);
};
export function alchemyGasManagerMiddleware(client, config) {
    const gasEstimationOptions = config.gasEstimationOptions;
    const disableGasEstimation = gasEstimationOptions?.disableGasEstimation ?? false;
    const fallbackFeeDataGetter = gasEstimationOptions?.fallbackFeeDataGetter ?? alchemyFeeEstimator(client);
    const fallbackGasEstimator = gasEstimationOptions?.fallbackGasEstimator ??
        defaultGasEstimator(client);
    return {
        gasEstimator: disableGasEstimation
            ? fallbackGasEstimator
            : async (struct, { overrides, account, feeOptions }) => {
                if (bypassPaymasterAndDataEmptyHex(overrides)) {
                    return {
                        ...struct,
                        ...(await fallbackGasEstimator(struct, {
                            overrides,
                            account,
                            feeOptions,
                            client,
                        })),
                    };
                }
                return struct;
            },
        feeEstimator: disableGasEstimation
            ? fallbackFeeDataGetter
            : async (struct, { overrides, account, feeOptions }) => {
                let maxFeePerGas = await struct.maxFeePerGas;
                let maxPriorityFeePerGas = await struct.maxPriorityFeePerGas;
                if (bypassPaymasterAndDataEmptyHex(overrides)) {
                    const result = await fallbackFeeDataGetter(struct, {
                        overrides,
                        feeOptions,
                        account,
                        client,
                    });
                    maxFeePerGas = (await result.maxFeePerGas) ?? maxFeePerGas;
                    maxPriorityFeePerGas =
                        (await result.maxPriorityFeePerGas) ?? maxPriorityFeePerGas;
                }
                return {
                    ...struct,
                    maxFeePerGas,
                    maxPriorityFeePerGas,
                };
            },
        paymasterAndData: disableGasEstimation
            ? requestPaymasterAndData(client, config)
            : requestGasAndPaymasterData(client, config),
    };
}
const overrideField = (field, overrides, feeOptions, userOperation) => {
    let _field = field;
    if (overrides?.[_field] != null) {
        if (isBigNumberish(overrides[_field])) {
            return deepHexlify(overrides[_field]);
        }
        else {
            return {
                multiplier: Number(overrides[_field].multiplier),
            };
        }
    }
    if (isMultiplier(feeOptions?.[field])) {
        return {
            multiplier: Number(feeOptions[field].multiplier),
        };
    }
    const userOpField = userOperation[field];
    if (isHex(userOpField) && fromHex(userOpField, "bigint") > 0n) {
        return userOpField;
    }
    return undefined;
};
function requestGasAndPaymasterData(client, config) {
    return {
        dummyPaymasterAndData: dummyPaymasterAndData(client, config),
        paymasterAndData: async (struct, { overrides: overrides_, feeOptions, account }) => {
            const userOperation = deepHexlify(await resolveProperties(struct));
            const overrides = filterUndefined({
                maxFeePerGas: overrideField("maxFeePerGas", overrides_, feeOptions, userOperation),
                maxPriorityFeePerGas: overrideField("maxPriorityFeePerGas", overrides_, feeOptions, userOperation),
                callGasLimit: overrideField("callGasLimit", overrides_, feeOptions, userOperation),
                verificationGasLimit: overrideField("verificationGasLimit", overrides_, feeOptions, userOperation),
                preVerificationGas: overrideField("preVerificationGas", overrides_, feeOptions, userOperation),
            });
            if (account.getEntryPoint().version === "0.7.0") {
                const paymasterVerificationGasLimit = overrideField("paymasterVerificationGasLimit", overrides_, feeOptions, userOperation);
                if (paymasterVerificationGasLimit != null) {
                    overrides.paymasterVerificationGasLimit = paymasterVerificationGasLimit;
                }
                const paymasterPostOpGasLimit = overrideField("paymasterPostOpGasLimit", overrides_, feeOptions, userOperation);
                if (paymasterPostOpGasLimit != null) {
                    overrides.paymasterPostOpGasLimit = paymasterPostOpGasLimit;
                }
            }
            const result = await client.request({
                method: "alchemy_requestGasAndPaymasterAndData",
                params: [
                    {
                        policyId: config.policyId,
                        entryPoint: account.getEntryPoint().address,
                        userOperation,
                        dummySignature: userOperation.signature,
                        overrides,
                    },
                ],
            });
            return {
                ...struct,
                ...result,
            };
        },
    };
}
const requestPaymasterAndData = (client, config) => ({
    dummyPaymasterAndData: dummyPaymasterAndData(client, config),
    paymasterAndData: async (struct, { account }) => {
        const result = await client.request({
            method: "alchemy_requestPaymasterAndData",
            params: [
                {
                    policyId: config.policyId,
                    entryPoint: account.getEntryPoint().address,
                    userOperation: deepHexlify(await resolveProperties(struct)),
                },
            ],
        });
        return {
            ...struct,
            ...result,
        };
    },
});
//# sourceMappingURL=gasManager.js.map