import { createJSONStorage, persist, subscribeWithSelector, } from "zustand/middleware";
import { createStore } from "zustand/vanilla";
import { AlchemySigner } from "../../signer/signer.js";
import { AlchemySignerStatus } from "../../signer/types.js";
import { DEFAULT_IFRAME_CONTAINER_ID } from "../createConfig.js";
import { bigintMapReplacer } from "../utils/replacer.js";
import { bigintMapReviver } from "../utils/reviver.js";
import { DEFAULT_STORAGE_KEY, } from "./types.js";
export const createClientStore = (config) => {
    const { storage = typeof window !== "undefined" ? localStorage : undefined, ssr, } = config;
    const clientStore = createStore(subscribeWithSelector(storage
        ? persist(() => createInitialClientState(config), {
            name: DEFAULT_STORAGE_KEY,
            storage: createJSONStorage(() => storage, {
                replacer: bigintMapReplacer,
                reviver: bigintMapReviver,
            }),
            skipHydration: ssr,
            partialize: ({ signer, accounts, ...writeableState }) => writeableState,
            version: 1,
        })
        : () => createInitialClientState(config)));
    addClientSideStoreListeners(clientStore);
    return clientStore;
};
export const createSigner = (params) => {
    const { client, sessionConfig } = params;
    const { iframeContainerId } = client.iframeConfig ?? {
        iframeContainerId: DEFAULT_IFRAME_CONTAINER_ID,
    };
    let iframeContainer = document.getElementById(iframeContainerId);
    if (iframeContainer !== null) {
        iframeContainer.innerHTML = "";
        iframeContainer.style.display = "none";
    }
    else {
        iframeContainer = document.createElement("div");
        iframeContainer.id = iframeContainerId;
        iframeContainer.style.display = "none";
        document.body.appendChild(iframeContainer);
    }
    const signer = new AlchemySigner({
        client: {
            ...client,
            iframeConfig: {
                ...client.iframeConfig,
                iframeContainerId,
            },
        },
        sessionConfig,
    });
    const search = new URLSearchParams(window.location.search);
    if (search.has("bundle")) {
        signer.authenticate({ type: "email", bundle: search.get("bundle") });
    }
    return signer;
};
export const convertSignerStatusToState = (alchemySignerStatus) => ({
    status: alchemySignerStatus,
    isInitializing: alchemySignerStatus === AlchemySignerStatus.INITIALIZING,
    isAuthenticating: alchemySignerStatus === AlchemySignerStatus.AUTHENTICATING ||
        alchemySignerStatus === AlchemySignerStatus.AWAITING_EMAIL_AUTH,
    isConnected: alchemySignerStatus === AlchemySignerStatus.CONNECTED,
    isDisconnected: alchemySignerStatus === AlchemySignerStatus.DISCONNECTED,
});
const staticState = {
    status: "DISCONNECTED",
    account: undefined,
};
export const defaultAccountState = () => staticState;
const createInitialClientState = (params) => {
    const accountConfigs = createEmptyAccountConfigState(params.chains);
    const baseState = {
        accountConfigs,
        config: params,
        signerStatus: convertSignerStatusToState(AlchemySignerStatus.INITIALIZING),
    };
    if (typeof window === "undefined") {
        return baseState;
    }
    const accounts = createDefaultAccountState(params.chains);
    return {
        accounts,
        ...baseState,
    };
};
const addClientSideStoreListeners = (store) => {
    if (typeof window === "undefined") {
        return;
    }
    store.subscribe(({ signer }) => signer, (signer) => {
        if (!signer)
            return;
        signer.on("statusChanged", (status) => {
            store.setState({ signerStatus: convertSignerStatusToState(status) });
        });
        signer.on("connected", (user) => store.setState({ user }));
        signer.on("disconnected", () => {
            store.setState({
                user: undefined,
                accountConfigs: createEmptyAccountConfigState(store.getState().config.chains),
                accounts: createDefaultAccountState(store.getState().config.chains),
            });
        });
    }, { fireImmediately: true });
};
const createEmptyAccountConfigState = (chains) => {
    return chains.reduce((acc, chain) => {
        acc[chain.id] = {};
        return acc;
    }, {});
};
export const createDefaultAccountState = (chains) => {
    return chains.reduce((acc, chain) => {
        acc[chain.id] = {
            LightAccount: defaultAccountState(),
            MultiOwnerModularAccount: defaultAccountState(),
        };
        return acc;
    }, {});
};
//# sourceMappingURL=client.js.map