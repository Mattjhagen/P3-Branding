import { type SmartAccountAuthenticator } from "@alchemy/aa-core";
import { type CustomSource, type Hex, type LocalAccount, type SignableMessage, type TypedData, type TypedDataDefinition } from "viem";
import type { BaseSignerClient } from "./client/base";
import type { User } from "./client/types";
import { type SessionManagerParams } from "./session/manager.js";
import type { AuthParams } from "./signer";
import { type AlchemySignerEvents } from "./types.js";
export interface BaseAlchemySignerParams<TClient extends BaseSignerClient> {
    client: TClient;
    sessionConfig?: Omit<SessionManagerParams, "client">;
}
export declare abstract class BaseAlchemySigner<TClient extends BaseSignerClient> implements SmartAccountAuthenticator<AuthParams, User, TClient> {
    signerType: string;
    inner: TClient;
    private sessionManager;
    private store;
    constructor({ client, sessionConfig }: BaseAlchemySignerParams<TClient>);
    /**
     * Allows you to subscribe to events emitted by the signer
     *
     * @param event the event to subscribe to
     * @param listener the function to run when the event is emitted
     * @returns a function to remove the listener
     */
    on: <E extends keyof AlchemySignerEvents>(event: E, listener: AlchemySignerEvents[E]) => () => void;
    /**
     * Authenticate a user with either an email or a passkey and create a session for that user
     *
     * @param params - undefined if passkey login, otherwise an object with email and bundle to resolve
     * @returns the user that was authenticated
     */
    authenticate: (params: AuthParams) => Promise<User>;
    /**
     * NOTE: right now this only clears the session locally.
     */
    disconnect: () => Promise<void>;
    /**
     * Gets the current logged in user
     * If a user has an ongoing session, it will use that session and
     * try to authenticate
     *
     * @throws if there is no user logged in
     * @returns the current user
     */
    getAuthDetails: () => Promise<User>;
    getAddress: () => Promise<`0x${string}`>;
    signMessage: (msg: SignableMessage) => Promise<`0x${string}`>;
    signTypedData: <const TTypedData extends TypedData | {
        [key: string]: unknown;
    }, TPrimaryType extends keyof TTypedData | "EIP712Domain" = keyof TTypedData>(params: TypedDataDefinition<TTypedData, TPrimaryType>) => Promise<Hex>;
    signTransaction: CustomSource["signTransaction"];
    /**
     * Unauthenticated call to look up a user's organizationId by email
     *
     * @param email the email to lookup
     * @returns the organization id for the user if they exist
     */
    getUser: (email: string) => Promise<{
        orgId: string;
    } | null>;
    /**
     * Adds a passkey to the user's account
     *
     * @param params optional parameters for the passkey creation
     * @returns an array of the authenticator ids added to the user
     */
    addPasskey: (params?: CredentialCreationOptions) => Promise<string[]>;
    /**
     * Used to export the wallet for a given user
     * If the user is authenticated with an Email, this will return a seed phrase
     * If the user is authenticated with a Passkey, this will return a private key
     *
     * @param params export wallet parameters
     * @returns true if the wallet was exported successfully
     */
    exportWallet: (params: Parameters<(typeof this.inner)["exportWallet"]>[0]) => Promise<boolean>;
    /**
     * This method lets you adapt your AlchemySigner to a viem LocalAccount, which
     * will let you use the signer as an EOA directly.
     *
     * @throws if your signer is not authenticated
     * @returns a LocalAccount object that can be used with viem's wallet client
     */
    toViemAccount: () => LocalAccount;
    private authenticateWithEmail;
    private authenticateWithPasskey;
    private registerListeners;
}
//# sourceMappingURL=base.d.ts.map