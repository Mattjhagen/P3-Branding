import type { Chain, Client, Transport } from "viem";
import type { SupportedAccounts } from "../../config";
import type { UseSmartAccountClientResult } from "./useSmartAccountClient";
export type UseClientActionsProps<TTransport extends Transport = Transport, TChain extends Chain | undefined = Chain | undefined, TActions extends {
    [x: string]: (...args: any[]) => unknown;
} = {
    [x: string]: (...args: any[]) => unknown;
}> = {
    client?: UseSmartAccountClientResult<TTransport, TChain, SupportedAccounts>["client"];
    actions: (client: Client<TTransport, TChain, SupportedAccounts>) => TActions;
};
export type UseClientActionsResult<TActions extends {
    [x: string]: (...args: any[]) => unknown;
} = {
    [x: string]: (...args: any[]) => unknown;
}> = {
    executeAction: <TFunctionName extends ExecutableFunctionName<TActions>>(params: ClientActionParameters<TActions, TFunctionName>) => void;
    executeActionAsync: <TFunctionName extends ExecutableFunctionName<TActions>>(params: ClientActionParameters<TActions, TFunctionName>) => Promise<ExecuteableFunctionResult<TFunctionName>>;
    data: ReturnType<TActions[keyof TActions]> | undefined;
    isExecutingAction: boolean;
    error?: Error | null;
};
export type ExecutableFunctionName<TActions extends {
    [x: string]: (...args: any[]) => unknown;
} = {
    [x: string]: (...args: any[]) => unknown;
}> = keyof TActions extends infer functionName extends string ? [functionName] extends [never] ? string : functionName : string;
export type ExecuteableFunctionResult<TFunctionName extends ExecutableFunctionName<TActions>, TActions extends {
    [x: string]: (...args: any[]) => unknown;
} = {
    [x: string]: (...args: any[]) => unknown;
}> = ReturnType<TActions[TFunctionName]>;
export type ExecutableFunctionArgs<TActions extends {
    [x: string]: (...args: any[]) => unknown;
} = {
    [x: string]: (...args: any[]) => unknown;
}, TFunctionName extends ExecutableFunctionName<TActions> = ExecutableFunctionName<TActions>> = Parameters<TActions[TFunctionName]>;
export type ClientActionParameters<TActions extends {
    [x: string]: (...args: any[]) => unknown;
} = {
    [x: string]: (...args: any[]) => unknown;
}, TFunctionName extends ExecutableFunctionName<TActions> = ExecutableFunctionName<TActions>, allArgs = ExecutableFunctionArgs<TActions, TFunctionName extends ExecutableFunctionName<TActions> ? TFunctionName : ExecutableFunctionName<TActions>>> = {
    functionName: TFunctionName;
    args: allArgs;
};
/**
 * A hook that allows you to leverage client decorators to execute actions
 * and await them in your UX. This is particularly useful for using Plugins
 * with Modular Accounts.
 *
 * @example
 * ```tsx
 * const Foo = () => {
 *  const { client } = useSmartAccountClient({ type: "MultiOwnerModularAccount" });
 *  const { executeAction } = useClientActions({
 *    client,
 *    pluginActions: sessionKeyPluginActions,
 *  });
 *
 *  executeAction({
 *    functionName: "isAccountSessionKey",
 *    args: [{ key: "0x0" }],
 *  });
 * };
 * ```
 *
 * @param args the hooks arguments highlighted below
 * @param args.client the smart account client returned from {@link useSmartAccountClient}
 * @param args.actions the smart account client decorator you want to execute actions from
 * @returns an object containing methods to execute the actions as well loading and error states (see: {@link UseClientActionsResult})
 */
export declare function useClientActions<TTransport extends Transport = Transport, TChain extends Chain | undefined = Chain | undefined, TActions extends {
    [x: string]: (...args: any[]) => any;
} = {
    [x: string]: (...args: any[]) => any;
}>(args: UseClientActionsProps<TTransport, TChain, TActions>): UseClientActionsResult<TActions>;
//# sourceMappingURL=useClientActions.d.ts.map