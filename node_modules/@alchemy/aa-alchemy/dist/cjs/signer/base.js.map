{"version":3,"file":"base.js","sourceRoot":"","sources":["../../../src/signer/base.ts"],"names":[],"mappings":"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","sourcesContent":["import { takeBytes, type SmartAccountAuthenticator } from \"@alchemy/aa-core\";\nimport {\n  hashMessage,\n  hashTypedData,\n  keccak256,\n  serializeTransaction,\n  type CustomSource,\n  type Hex,\n  type LocalAccount,\n  type SignableMessage,\n  type TypedData,\n  type TypedDataDefinition,\n} from \"viem\";\nimport { toAccount } from \"viem/accounts\";\nimport type { Mutate, StoreApi } from \"zustand\";\nimport { subscribeWithSelector } from \"zustand/middleware\";\nimport { createStore } from \"zustand/vanilla\";\nimport type { BaseSignerClient } from \"./client/base\";\nimport type { User } from \"./client/types\";\nimport { NotAuthenticatedError } from \"./errors.js\";\nimport {\n  SessionManager,\n  type SessionManagerParams,\n} from \"./session/manager.js\";\nimport type { AuthParams } from \"./signer\";\nimport {\n  AlchemySignerStatus,\n  type AlchemySignerEvent,\n  type AlchemySignerEvents,\n} from \"./types.js\";\n\nexport interface BaseAlchemySignerParams<TClient extends BaseSignerClient> {\n  client: TClient;\n  sessionConfig?: Omit<SessionManagerParams, \"client\">;\n}\n\ntype AlchemySignerStore = {\n  user: User | null;\n  status: AlchemySignerStatus;\n};\n\ntype InternalStore = Mutate<\n  StoreApi<AlchemySignerStore>,\n  [[\"zustand/subscribeWithSelector\", never]]\n>;\n\nexport abstract class BaseAlchemySigner<TClient extends BaseSignerClient>\n  implements SmartAccountAuthenticator<AuthParams, User, TClient>\n{\n  signerType: string = \"alchemy-signer\";\n  inner: TClient;\n  private sessionManager: SessionManager;\n  private store: InternalStore;\n\n  constructor({ client, sessionConfig }: BaseAlchemySignerParams<TClient>) {\n    this.inner = client;\n    this.store = createStore(\n      subscribeWithSelector(\n        () =>\n          ({\n            user: null,\n            status: AlchemySignerStatus.INITIALIZING,\n          } satisfies AlchemySignerStore)\n      )\n    );\n    // NOTE: it's important that the session manager share a client\n    // with the signer. The SessionManager leverages the Signer's client\n    // to manage session state.\n    this.sessionManager = new SessionManager({\n      ...sessionConfig,\n      client: this.inner,\n    });\n    this.store = createStore(\n      subscribeWithSelector(\n        () =>\n          ({\n            user: null,\n            status: AlchemySignerStatus.INITIALIZING,\n          } satisfies AlchemySignerStore)\n      )\n    );\n    // register listeners first\n    this.registerListeners();\n    // then initialize so that we can catch those events\n    this.sessionManager.initialize();\n  }\n\n  /**\n   * Allows you to subscribe to events emitted by the signer\n   *\n   * @param event the event to subscribe to\n   * @param listener the function to run when the event is emitted\n   * @returns a function to remove the listener\n   */\n  on = <E extends AlchemySignerEvent>(\n    event: E,\n    listener: AlchemySignerEvents[E]\n  ) => {\n    // NOTE: we're using zustand here to handle this because we are able to use the fireImmediately\n    // option which deals with a possible race condition where the listener is added after the event\n    // is fired. In the Client and SessionManager we use EventEmitter because it's easier to handle internally\n    switch (event) {\n      case \"connected\":\n        return this.store.subscribe(\n          ({ status }) => status,\n          (status) =>\n            status === AlchemySignerStatus.CONNECTED &&\n            (listener as AlchemySignerEvents[\"connected\"])(\n              this.store.getState().user!\n            ),\n          { fireImmediately: true }\n        );\n      case \"disconnected\":\n        return this.store.subscribe(\n          ({ status }) => status,\n          (status) =>\n            status === AlchemySignerStatus.DISCONNECTED &&\n            (listener as AlchemySignerEvents[\"disconnected\"])(),\n          { fireImmediately: true }\n        );\n      case \"statusChanged\":\n        return this.store.subscribe(\n          ({ status }) => status,\n          listener as AlchemySignerEvents[\"statusChanged\"],\n          { fireImmediately: true }\n        );\n      default:\n        throw new Error(`Uknown event type ${event}`);\n    }\n  };\n\n  /**\n   * Authenticate a user with either an email or a passkey and create a session for that user\n   *\n   * @param params - undefined if passkey login, otherwise an object with email and bundle to resolve\n   * @returns the user that was authenticated\n   */\n  authenticate: (params: AuthParams) => Promise<User> = async (params) => {\n    if (params.type === \"email\") {\n      return this.authenticateWithEmail(params);\n    }\n\n    return this.authenticateWithPasskey(params);\n  };\n\n  /**\n   * NOTE: right now this only clears the session locally.\n   */\n  disconnect: () => Promise<void> = async () => {\n    await this.inner.disconnect();\n  };\n\n  /**\n   * Gets the current logged in user\n   * If a user has an ongoing session, it will use that session and\n   * try to authenticate\n   *\n   * @throws if there is no user logged in\n   * @returns the current user\n   */\n  getAuthDetails: () => Promise<User> = async () => {\n    const sessionUser = await this.sessionManager.getSessionUser();\n    if (sessionUser != null) {\n      return sessionUser;\n    }\n\n    return this.inner.whoami();\n  };\n\n  getAddress: () => Promise<`0x${string}`> = async () => {\n    const { address } = await this.inner.whoami();\n\n    return address;\n  };\n\n  signMessage: (msg: SignableMessage) => Promise<`0x${string}`> = async (\n    msg\n  ) => {\n    const messageHash = hashMessage(msg);\n\n    return this.inner.signRawMessage(messageHash);\n  };\n\n  signTypedData: <\n    const TTypedData extends TypedData | { [key: string]: unknown },\n    TPrimaryType extends keyof TTypedData | \"EIP712Domain\" = keyof TTypedData\n  >(\n    params: TypedDataDefinition<TTypedData, TPrimaryType>\n  ) => Promise<Hex> = async (params) => {\n    const messageHash = hashTypedData(params);\n\n    return this.inner.signRawMessage(messageHash);\n  };\n\n  signTransaction: CustomSource[\"signTransaction\"] = async (tx, args) => {\n    const serializeFn = args?.serializer ?? serializeTransaction;\n    const serializedTx = serializeFn(tx);\n    const signatureHex = await this.inner.signRawMessage(\n      keccak256(serializedTx)\n    );\n\n    const signature = {\n      r: takeBytes(signatureHex, { count: 32 }),\n      s: takeBytes(signatureHex, { count: 32, offset: 32 }),\n      v: BigInt(takeBytes(signatureHex, { count: 1, offset: 64 })),\n    };\n\n    return serializeFn(tx, signature);\n  };\n\n  /**\n   * Unauthenticated call to look up a user's organizationId by email\n   *\n   * @param email the email to lookup\n   * @returns the organization id for the user if they exist\n   */\n  getUser: (email: string) => Promise<{ orgId: string } | null> = async (\n    email\n  ) => {\n    const result = await this.inner.lookupUserByEmail(email);\n\n    if (result.orgId == null) {\n      return null;\n    }\n\n    return {\n      orgId: result.orgId,\n    };\n  };\n\n  /**\n   * Adds a passkey to the user's account\n   *\n   * @param params optional parameters for the passkey creation\n   * @returns an array of the authenticator ids added to the user\n   */\n  addPasskey: (params?: CredentialCreationOptions) => Promise<string[]> =\n    async (params) => {\n      return this.inner.addPasskey(params ?? {});\n    };\n\n  /**\n   * Used to export the wallet for a given user\n   * If the user is authenticated with an Email, this will return a seed phrase\n   * If the user is authenticated with a Passkey, this will return a private key\n   *\n   * @param params export wallet parameters\n   * @returns true if the wallet was exported successfully\n   */\n  exportWallet: (\n    params: Parameters<(typeof this.inner)[\"exportWallet\"]>[0]\n  ) => Promise<boolean> = async (params) => {\n    return this.inner.exportWallet(params);\n  };\n\n  /**\n   * This method lets you adapt your AlchemySigner to a viem LocalAccount, which\n   * will let you use the signer as an EOA directly.\n   *\n   * @throws if your signer is not authenticated\n   * @returns a LocalAccount object that can be used with viem's wallet client\n   */\n  toViemAccount: () => LocalAccount = () => {\n    // if we want this method to be synchronous, then we need to do this check here\n    // otherwise we can use the sessionManager to get the user\n    if (!this.inner.getUser()) {\n      throw new NotAuthenticatedError();\n    }\n\n    return toAccount({\n      address: this.inner.getUser()!.address,\n      signMessage: (msg) => this.signMessage(msg.message),\n      signTypedData: <\n        const typedData extends TypedData | Record<string, unknown>,\n        primaryType extends keyof typedData | \"EIP712Domain\" = keyof typedData\n      >(\n        typedDataDefinition: TypedDataDefinition<typedData, primaryType>\n      ) => this.signTypedData<typedData, primaryType>(typedDataDefinition),\n      signTransaction: this.signTransaction,\n    });\n  };\n\n  private authenticateWithEmail = async (\n    params: Extract<AuthParams, { type: \"email\" }>\n  ): Promise<User> => {\n    if (\"email\" in params) {\n      const existingUser = await this.getUser(params.email);\n\n      const { orgId } = existingUser\n        ? await this.inner.initEmailAuth({\n            email: params.email,\n            expirationSeconds: this.sessionManager.expirationTimeMs,\n            redirectParams: params.redirectParams,\n          })\n        : await this.inner.createAccount({\n            type: \"email\",\n            email: params.email,\n            expirationSeconds: this.sessionManager.expirationTimeMs,\n            redirectParams: params.redirectParams,\n          });\n\n      this.sessionManager.setTemporarySession({ orgId });\n      this.store.setState({ status: AlchemySignerStatus.AWAITING_EMAIL_AUTH });\n\n      // We wait for the session manager to emit a connected event if\n      // cross tab sessions are permitted\n      return new Promise<User>((resolve) => {\n        const removeListener = this.sessionManager.on(\n          \"connected\",\n          (session) => {\n            resolve(session.user);\n            removeListener();\n          }\n        );\n      });\n    } else {\n      const temporarySession = params.orgId\n        ? { orgId: params.orgId }\n        : this.sessionManager.getTemporarySession();\n\n      if (!temporarySession) {\n        this.store.setState({ status: AlchemySignerStatus.DISCONNECTED });\n        throw new Error(\"Could not find email auth init session!\");\n      }\n\n      const user = await this.inner.completeEmailAuth({\n        bundle: params.bundle,\n        orgId: temporarySession.orgId,\n      });\n\n      return user;\n    }\n  };\n\n  private authenticateWithPasskey = async (\n    args: Extract<AuthParams, { type: \"passkey\" }>\n  ) => {\n    let user: User;\n    if (args.createNew) {\n      const result = await this.inner.createAccount(args);\n      // account creation for passkeys returns the whoami response so we don't have to\n      // call it again after signup\n      user = {\n        address: result.address!,\n        userId: result.userId!,\n        orgId: result.orgId,\n      };\n    } else {\n      user = await this.inner.lookupUserWithPasskey();\n      if (!user) {\n        this.store.setState({ status: AlchemySignerStatus.DISCONNECTED });\n        throw new Error(\"No user found\");\n      }\n    }\n\n    return user;\n  };\n\n  private registerListeners = () => {\n    this.sessionManager.on(\"connected\", (session) => {\n      this.store.setState({\n        user: session.user,\n        status: AlchemySignerStatus.CONNECTED,\n      });\n    });\n\n    this.sessionManager.on(\"disconnected\", () => {\n      this.store.setState({\n        user: null,\n        status: AlchemySignerStatus.DISCONNECTED,\n      });\n    });\n\n    this.sessionManager.on(\"initialized\", () => {\n      this.store.setState((state) => ({\n        status: state.user\n          ? AlchemySignerStatus.CONNECTED\n          : AlchemySignerStatus.DISCONNECTED,\n      }));\n    });\n\n    this.inner.on(\"authenticating\", () => {\n      this.store.setState({ status: AlchemySignerStatus.AUTHENTICATING });\n    });\n  };\n}\n"]}