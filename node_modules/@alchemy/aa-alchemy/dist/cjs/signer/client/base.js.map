{"version":3,"file":"base.js","sourceRoot":"","sources":["../../../../src/signer/client/base.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  type ConnectionConfig,\n  ConnectionConfigSchema,\n} from \"@alchemy/aa-core\";\nimport { TurnkeyClient } from \"@turnkey/http\";\nimport EventEmitter from \"eventemitter3\";\nimport type { Hex } from \"viem\";\nimport { NotAuthenticatedError } from \"../errors.js\";\nimport { base64UrlEncode } from \"../utils/base64UrlEncode.js\";\nimport type {\n  AlchemySignerClientEvent,\n  AlchemySignerClientEvents,\n  CreateAccountParams,\n  EmailAuthParams,\n  GetWebAuthnAttestationResult,\n  SignerBody,\n  SignerResponse,\n  SignerRoutes,\n  SignupResponse,\n  User,\n} from \"./types\";\n\nexport interface BaseSignerClientParams {\n  stamper: TurnkeyClient[\"stamper\"];\n  connection: ConnectionConfig;\n  rootOrgId?: string;\n  rpId?: string;\n}\n\nexport type ExportWalletStamper = TurnkeyClient[\"stamper\"] & {\n  injectWalletExportBundle(bundle: string): Promise<boolean>;\n  injectKeyExportBundle(bundle: string): Promise<boolean>;\n  publicKey(): string | null;\n};\n\nexport abstract class BaseSignerClient<TExportWalletParams = unknown> {\n  private _user: User | undefined;\n  private connectionConfig: ConnectionConfig;\n  protected turnkeyClient: TurnkeyClient;\n  protected rootOrg: string;\n  protected eventEmitter: EventEmitter<AlchemySignerClientEvents>;\n\n  constructor(params: BaseSignerClientParams) {\n    const { stamper, connection, rootOrgId } = params;\n\n    this.rootOrg = rootOrgId ?? \"24c1acf5-810f-41e0-a503-d5d13fa8e830\";\n    this.eventEmitter = new EventEmitter<AlchemySignerClientEvents>();\n    this.connectionConfig = ConnectionConfigSchema.parse(connection);\n    this.turnkeyClient = new TurnkeyClient(\n      { baseUrl: \"https://api.turnkey.com\" },\n      stamper\n    );\n  }\n\n  protected get user() {\n    return this._user;\n  }\n\n  protected set user(user: User | undefined) {\n    if (user && !this._user) {\n      this.eventEmitter.emit(\"connected\", user);\n    } else if (!user && this._user) {\n      this.eventEmitter.emit(\"disconnected\");\n    }\n\n    this._user = user;\n  }\n\n  protected setStamper(stamper: TurnkeyClient[\"stamper\"]) {\n    this.turnkeyClient.stamper = stamper;\n  }\n\n  protected exportWalletInner(params: {\n    exportStamper: ExportWalletStamper;\n    exportAs: \"SEED_PHRASE\" | \"PRIVATE_KEY\";\n  }): Promise<boolean> {\n    switch (params.exportAs) {\n      case \"PRIVATE_KEY\":\n        return this.exportAsPrivateKey(params.exportStamper);\n      case \"SEED_PHRASE\":\n        return this.exportAsSeedPhrase(params.exportStamper);\n    }\n  }\n\n  // #region ABSTRACT METHODS\n\n  public abstract createAccount(\n    params: CreateAccountParams\n  ): Promise<SignupResponse>;\n\n  public abstract initEmailAuth(\n    params: Omit<EmailAuthParams, \"targetPublicKey\">\n  ): Promise<{ orgId: string }>;\n\n  public abstract completeEmailAuth(params: {\n    bundle: string;\n    orgId: string;\n  }): Promise<User>;\n\n  public abstract disconnect(): Promise<void>;\n\n  public abstract exportWallet(params: TExportWalletParams): Promise<boolean>;\n\n  public abstract lookupUserWithPasskey(user?: User): Promise<User>;\n\n  protected abstract getWebAuthnAttestation(\n    options: CredentialCreationOptions,\n    userDetails?: { username: string }\n  ): Promise<GetWebAuthnAttestationResult>;\n\n  // #endregion\n\n  // #region PUBLIC METHODS\n\n  /**\n   * Listen to events emitted by the client\n   *\n   * @param event the event you want to listen to\n   * @param listener the callback function to execute when an event is fired\n   * @returns a function that will remove the listener when called\n   */\n  public on = <E extends AlchemySignerClientEvent>(\n    event: E,\n    listener: AlchemySignerClientEvents[E]\n  ) => {\n    this.eventEmitter.on(event, listener as any);\n\n    return () => this.eventEmitter.removeListener(event, listener as any);\n  };\n\n  public addPasskey = async (options: CredentialCreationOptions) => {\n    if (!this.user) {\n      throw new NotAuthenticatedError();\n    }\n    const { attestation, challenge } = await this.getWebAuthnAttestation(\n      options\n    );\n\n    const { activity } = await this.turnkeyClient.createAuthenticators({\n      type: \"ACTIVITY_TYPE_CREATE_AUTHENTICATORS_V2\",\n      timestampMs: Date.now().toString(),\n      organizationId: this.user.orgId,\n      parameters: {\n        userId: this.user.userId,\n        authenticators: [\n          {\n            attestation,\n            authenticatorName: `passkey-${Date.now().toString()}`,\n            challenge: base64UrlEncode(challenge),\n          },\n        ],\n      },\n    });\n\n    const { authenticatorIds } = await this.pollActivityCompletion(\n      activity,\n      this.user.orgId,\n      \"createAuthenticatorsResult\"\n    );\n\n    return authenticatorIds;\n  };\n\n  public whoami = async (orgId = this.user?.orgId): Promise<User> => {\n    if (this.user) {\n      return this.user;\n    }\n\n    if (!orgId) {\n      throw new Error(\"No orgId provided\");\n    }\n\n    const stampedRequest = await this.turnkeyClient.stampGetWhoami({\n      organizationId: orgId,\n    });\n\n    const user = await this.request(\"/v1/whoami\", {\n      stampedRequest,\n    });\n\n    const credentialId = (() => {\n      try {\n        return JSON.parse(stampedRequest?.stamp.stampHeaderValue)\n          .credentialId as string;\n      } catch (e) {\n        return undefined;\n      }\n    })();\n\n    this.user = {\n      ...user,\n      credentialId,\n    };\n\n    return this.user;\n  };\n\n  public lookupUserByEmail = async (email: string) => {\n    return this.request(\"/v1/lookup\", { email });\n  };\n\n  /**\n   * This will sign a message with the user's private key, without doing any transformations on the message.\n   * For SignMessage or SignTypedData, the caller should hash the message before calling this method and pass\n   * that result here.\n   *\n   * @param msg the hex representation of the bytes to sign\n   * @returns the signature over the raw hex\n   */\n  public signRawMessage = async (msg: Hex) => {\n    if (!this.user) {\n      throw new NotAuthenticatedError();\n    }\n\n    const stampedRequest = await this.turnkeyClient.stampSignRawPayload({\n      organizationId: this.user.orgId,\n      type: \"ACTIVITY_TYPE_SIGN_RAW_PAYLOAD_V2\",\n      timestampMs: Date.now().toString(),\n      parameters: {\n        encoding: \"PAYLOAD_ENCODING_HEXADECIMAL\",\n        hashFunction: \"HASH_FUNCTION_NO_OP\",\n        payload: msg,\n        signWith: this.user.address,\n      },\n    });\n\n    const { signature } = await this.request(\"/v1/sign-payload\", {\n      stampedRequest,\n    });\n\n    return signature;\n  };\n\n  public getUser = (): User | null => {\n    return this.user ?? null;\n  };\n\n  public request = async <R extends SignerRoutes>(\n    route: R,\n    body: SignerBody<R>\n  ): Promise<SignerResponse<R>> => {\n    const url = this.connectionConfig.rpcUrl ?? \"https://api.g.alchemy.com\";\n    const basePath = \"/signer\";\n\n    const headers = new Headers();\n    headers.append(\"Content-Type\", \"application/json\");\n    if (this.connectionConfig.apiKey) {\n      headers.append(\"Authorization\", `Bearer ${this.connectionConfig.apiKey}`);\n    } else if (this.connectionConfig.jwt) {\n      headers.append(\"Authorization\", `Bearer ${this.connectionConfig.jwt}`);\n    }\n\n    const response = await fetch(`${url}${basePath}${route}`, {\n      method: \"POST\",\n      body: JSON.stringify(body),\n      headers,\n    });\n\n    if (!response.ok) {\n      throw new Error(await response.text());\n    }\n\n    const json = await response.json();\n\n    return json as SignerResponse<R>;\n  };\n\n  // #endregion\n\n  // #region PRIVATE METHODS\n  private exportAsSeedPhrase = async (stamper: ExportWalletStamper) => {\n    if (!this.user) {\n      throw new NotAuthenticatedError();\n    }\n\n    const { wallets } = await this.turnkeyClient.getWallets({\n      organizationId: this.user.orgId,\n    });\n\n    const walletAccounts = await Promise.all(\n      wallets.map(({ walletId }) =>\n        this.turnkeyClient.getWalletAccounts({\n          organizationId: this.user!.orgId,\n          walletId,\n        })\n      )\n    ).then((x) => x.flatMap((x) => x.accounts));\n\n    const walletAccount = walletAccounts.find(\n      (x) => x.address === this.user!.address\n    );\n\n    if (!walletAccount) {\n      throw new Error(\n        `Could not find wallet associated with ${this.user.address}`\n      );\n    }\n\n    const { activity } = await this.turnkeyClient.exportWallet({\n      organizationId: this.user.orgId,\n      type: \"ACTIVITY_TYPE_EXPORT_WALLET\",\n      timestampMs: Date.now().toString(),\n      parameters: {\n        walletId: walletAccount!.walletId,\n        targetPublicKey: stamper.publicKey()!,\n      },\n    });\n\n    const { exportBundle } = await this.pollActivityCompletion(\n      activity,\n      this.user.orgId,\n      \"exportWalletResult\"\n    );\n\n    const result = await stamper.injectWalletExportBundle(exportBundle);\n\n    if (!result) {\n      throw new Error(\"Failed to inject wallet export bundle\");\n    }\n\n    return result;\n  };\n\n  private exportAsPrivateKey = async (stamper: ExportWalletStamper) => {\n    if (!this.user) {\n      throw new NotAuthenticatedError();\n    }\n\n    const { activity } = await this.turnkeyClient.exportWalletAccount({\n      organizationId: this.user.orgId,\n      type: \"ACTIVITY_TYPE_EXPORT_WALLET_ACCOUNT\",\n      timestampMs: Date.now().toString(),\n      parameters: {\n        address: this.user.address,\n        targetPublicKey: stamper.publicKey()!,\n      },\n    });\n\n    const { exportBundle } = await this.pollActivityCompletion(\n      activity,\n      this.user.orgId,\n      \"exportWalletAccountResult\"\n    );\n\n    const result = await stamper.injectKeyExportBundle(exportBundle);\n\n    if (!result) {\n      throw new Error(\"Failed to inject wallet export bundle\");\n    }\n\n    return result;\n  };\n\n  protected pollActivityCompletion = async <\n    T extends keyof Awaited<\n      ReturnType<(typeof this.turnkeyClient)[\"getActivity\"]>\n    >[\"activity\"][\"result\"]\n  >(\n    activity: Awaited<\n      ReturnType<(typeof this.turnkeyClient)[\"getActivity\"]>\n    >[\"activity\"],\n    organizationId: string,\n    resultKey: T\n  ): Promise<\n    NonNullable<\n      Awaited<\n        ReturnType<(typeof this.turnkeyClient)[\"getActivity\"]>\n      >[\"activity\"][\"result\"][T]\n    >\n  > => {\n    if (activity.status === \"ACTIVITY_STATUS_COMPLETED\") {\n      return activity.result[resultKey]!;\n    }\n\n    const {\n      activity: { status, id, result },\n    } = await this.turnkeyClient.getActivity({\n      activityId: activity.id,\n      organizationId,\n    });\n\n    if (status === \"ACTIVITY_STATUS_COMPLETED\") {\n      return result[resultKey]!;\n    }\n\n    if (\n      status === \"ACTIVITY_STATUS_FAILED\" ||\n      status === \"ACTIVITY_STATUS_REJECTED\" ||\n      status === \"ACTIVITY_STATUS_CONSENSUS_NEEDED\"\n    ) {\n      throw new Error(\n        `Failed to get activity with with id ${id} (status: ${status})`\n      );\n    }\n\n    // TODO: add ability to configure this + add exponential backoff\n    await new Promise((resolve) => setTimeout(resolve, 500));\n\n    return this.pollActivityCompletion(activity, organizationId, resultKey);\n  };\n  // #endregion\n}\n"]}