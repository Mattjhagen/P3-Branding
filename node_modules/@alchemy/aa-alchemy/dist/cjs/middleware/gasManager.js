"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.alchemyGasManagerMiddleware = void 0;
const aa_core_1 = require("@alchemy/aa-core");
const viem_1 = require("viem");
const gas_manager_js_1 = require("../gas-manager.js");
const feeEstimator_js_1 = require("./feeEstimator.js");
const dummyPaymasterAndData = (client, config) => () => {
    const paymaster = config.paymasterAddress ?? (0, gas_manager_js_1.getAlchemyPaymasterAddress)(client.chain);
    const paymasterData = config.dummyData ??
        "0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0000000000000000000000000000000007aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa1c";
    return (0, viem_1.concat)([paymaster, paymasterData]);
};
function alchemyGasManagerMiddleware(client, config) {
    const gasEstimationOptions = config.gasEstimationOptions;
    const disableGasEstimation = gasEstimationOptions?.disableGasEstimation ?? false;
    const fallbackFeeDataGetter = gasEstimationOptions?.fallbackFeeDataGetter ?? (0, feeEstimator_js_1.alchemyFeeEstimator)(client);
    const fallbackGasEstimator = gasEstimationOptions?.fallbackGasEstimator ??
        (0, aa_core_1.defaultGasEstimator)(client);
    return {
        gasEstimator: disableGasEstimation
            ? fallbackGasEstimator
            : async (struct, { overrides, account, feeOptions }) => {
                if ((0, aa_core_1.bypassPaymasterAndDataEmptyHex)(overrides)) {
                    return {
                        ...struct,
                        ...(await fallbackGasEstimator(struct, {
                            overrides,
                            account,
                            feeOptions,
                            client,
                        })),
                    };
                }
                return struct;
            },
        feeEstimator: disableGasEstimation
            ? fallbackFeeDataGetter
            : async (struct, { overrides, account, feeOptions }) => {
                let maxFeePerGas = await struct.maxFeePerGas;
                let maxPriorityFeePerGas = await struct.maxPriorityFeePerGas;
                if ((0, aa_core_1.bypassPaymasterAndDataEmptyHex)(overrides)) {
                    const result = await fallbackFeeDataGetter(struct, {
                        overrides,
                        feeOptions,
                        account,
                        client,
                    });
                    maxFeePerGas = (await result.maxFeePerGas) ?? maxFeePerGas;
                    maxPriorityFeePerGas =
                        (await result.maxPriorityFeePerGas) ?? maxPriorityFeePerGas;
                }
                return {
                    ...struct,
                    maxFeePerGas,
                    maxPriorityFeePerGas,
                };
            },
        paymasterAndData: disableGasEstimation
            ? requestPaymasterAndData(client, config)
            : requestGasAndPaymasterData(client, config),
    };
}
exports.alchemyGasManagerMiddleware = alchemyGasManagerMiddleware;
const overrideField = (field, overrides, feeOptions, userOperation) => {
    let _field = field;
    if (overrides?.[_field] != null) {
        if ((0, aa_core_1.isBigNumberish)(overrides[_field])) {
            return (0, aa_core_1.deepHexlify)(overrides[_field]);
        }
        else {
            return {
                multiplier: Number(overrides[_field].multiplier),
            };
        }
    }
    if ((0, aa_core_1.isMultiplier)(feeOptions?.[field])) {
        return {
            multiplier: Number(feeOptions[field].multiplier),
        };
    }
    const userOpField = userOperation[field];
    if ((0, viem_1.isHex)(userOpField) && (0, viem_1.fromHex)(userOpField, "bigint") > 0n) {
        return userOpField;
    }
    return undefined;
};
function requestGasAndPaymasterData(client, config) {
    return {
        dummyPaymasterAndData: dummyPaymasterAndData(client, config),
        paymasterAndData: async (struct, { overrides: overrides_, feeOptions, account }) => {
            const userOperation = (0, aa_core_1.deepHexlify)(await (0, aa_core_1.resolveProperties)(struct));
            const overrides = (0, aa_core_1.filterUndefined)({
                maxFeePerGas: overrideField("maxFeePerGas", overrides_, feeOptions, userOperation),
                maxPriorityFeePerGas: overrideField("maxPriorityFeePerGas", overrides_, feeOptions, userOperation),
                callGasLimit: overrideField("callGasLimit", overrides_, feeOptions, userOperation),
                verificationGasLimit: overrideField("verificationGasLimit", overrides_, feeOptions, userOperation),
                preVerificationGas: overrideField("preVerificationGas", overrides_, feeOptions, userOperation),
            });
            if (account.getEntryPoint().version === "0.7.0") {
                const paymasterVerificationGasLimit = overrideField("paymasterVerificationGasLimit", overrides_, feeOptions, userOperation);
                if (paymasterVerificationGasLimit != null) {
                    overrides.paymasterVerificationGasLimit = paymasterVerificationGasLimit;
                }
                const paymasterPostOpGasLimit = overrideField("paymasterPostOpGasLimit", overrides_, feeOptions, userOperation);
                if (paymasterPostOpGasLimit != null) {
                    overrides.paymasterPostOpGasLimit = paymasterPostOpGasLimit;
                }
            }
            const result = await client.request({
                method: "alchemy_requestGasAndPaymasterAndData",
                params: [
                    {
                        policyId: config.policyId,
                        entryPoint: account.getEntryPoint().address,
                        userOperation,
                        dummySignature: userOperation.signature,
                        overrides,
                    },
                ],
            });
            return {
                ...struct,
                ...result,
            };
        },
    };
}
const requestPaymasterAndData = (client, config) => ({
    dummyPaymasterAndData: dummyPaymasterAndData(client, config),
    paymasterAndData: async (struct, { account }) => {
        const result = await client.request({
            method: "alchemy_requestPaymasterAndData",
            params: [
                {
                    policyId: config.policyId,
                    entryPoint: account.getEntryPoint().address,
                    userOperation: (0, aa_core_1.deepHexlify)(await (0, aa_core_1.resolveProperties)(struct)),
                },
            ],
        });
        return {
            ...struct,
            ...result,
        };
    },
});
//# sourceMappingURL=gasManager.js.map