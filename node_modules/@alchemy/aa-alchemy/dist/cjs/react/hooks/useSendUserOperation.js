"use strict";
"use client";
Object.defineProperty(exports, "__esModule", { value: true });
exports.useSendUserOperation = void 0;
const aa_core_1 = require("@alchemy/aa-core");
const react_query_1 = require("@tanstack/react-query");
const core_1 = require("@wagmi/core");
const wagmi_1 = require("wagmi");
const context_js_1 = require("../context.js");
const errors_js_1 = require("../errors.js");
function useSendUserOperation(params) {
    const { client, waitForTxn = false, ...mutationArgs } = params;
    const { queryClient, config: { _internal: { wagmiConfig }, }, } = (0, context_js_1.useAlchemyAccountContext)();
    const { isConnected } = (0, wagmi_1.useAccount)({ config: wagmiConfig });
    const { mutate: sendUserOperation, mutateAsync: sendUserOperationAsync, data: sendUserOperationResult, isPending: isSendingUserOperation, error, } = (0, react_query_1.useMutation)({
        mutationFn: async (params) => {
            if (isConnected) {
                console.warn("useSendUserOperation: connected to an EOA, sending as a transaction instead");
                const { uo } = params;
                if (Array.isArray(uo)) {
                    throw new errors_js_1.UnsupportedEOAActionError("useSendUserOperation", "batch execute");
                }
                if (typeof uo === "string") {
                    throw new errors_js_1.UnsupportedEOAActionError("useSendUserOperation", "hex user operation");
                }
                const tx = await (0, core_1.sendTransaction)(wagmiConfig, {
                    to: uo.target,
                    data: uo.data,
                    value: uo.value,
                });
                return {
                    hash: tx,
                };
            }
            if (!client) {
                throw new errors_js_1.ClientUndefinedHookError("useSendUserOperation");
            }
            if (!waitForTxn) {
                return client.sendUserOperation(params);
            }
            const { hash, request } = await client.sendUserOperation(params);
            const txnHash = await client
                .waitForUserOperationTransaction({ hash })
                .catch((e) => {
                throw new aa_core_1.WaitForUserOperationError(request, e);
            });
            return {
                hash: txnHash,
                request,
            };
        },
        ...mutationArgs,
    }, queryClient);
    return {
        sendUserOperation,
        sendUserOperationAsync,
        sendUserOperationResult,
        isSendingUserOperation,
        error,
    };
}
exports.useSendUserOperation = useSendUserOperation;
//# sourceMappingURL=useSendUserOperation.js.map