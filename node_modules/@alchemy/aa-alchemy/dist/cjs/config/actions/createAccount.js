"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createAccount = void 0;
const aa_accounts_1 = require("@alchemy/aa-accounts");
const viem_1 = require("viem");
const errors_js_1 = require("../errors.js");
const getBundlerClient_js_1 = require("./getBundlerClient.js");
const getSigner_js_1 = require("./getSigner.js");
const getSignerStatus_js_1 = require("./getSignerStatus.js");
async function createAccount({ type, accountParams: params }, config) {
    const clientStore = config.clientStore;
    const accounts = clientStore.getState().accounts;
    if (!accounts) {
        throw new errors_js_1.ClientOnlyPropertyError("account");
    }
    const bundlerClient = (0, getBundlerClient_js_1.getBundlerClient)(config);
    const transport = (0, viem_1.custom)(bundlerClient);
    const chain = bundlerClient.chain;
    const signer = (0, getSigner_js_1.getSigner)(config);
    const signerStatus = (0, getSignerStatus_js_1.getSignerStatus)(config);
    if (!signerStatus.isConnected || !signer) {
        throw new Error("Signer not connected");
    }
    const cachedAccount = accounts[chain.id]?.[type];
    if (cachedAccount.status !== "RECONNECTING" && cachedAccount.account) {
        return cachedAccount.account;
    }
    const cachedConfig = clientStore.getState().accountConfigs[chain.id]?.[type];
    const accountPromise = (() => {
        switch (type) {
            case "LightAccount":
                return (0, aa_accounts_1.createLightAccount)({
                    ...params,
                    ...cachedConfig,
                    signer,
                    transport: (opts) => transport({ ...opts, retryCount: 0 }),
                    chain,
                });
            case "MultiOwnerModularAccount":
                return (0, aa_accounts_1.createMultiOwnerModularAccount)({
                    ...params,
                    ...cachedConfig,
                    signer,
                    transport: (opts) => transport({ ...opts, retryCount: 0 }),
                    chain,
                });
            default:
                throw new Error("Unsupported account type");
        }
    })();
    if (cachedAccount.status !== "RECONNECTING") {
        clientStore.setState(() => ({
            accounts: {
                ...accounts,
                [chain.id]: {
                    ...accounts[chain.id],
                    [type]: {
                        status: "INITIALIZING",
                        account: accountPromise,
                    },
                },
            },
        }));
    }
    try {
        const account = await accountPromise;
        const initCode = await account.getInitCode();
        clientStore.setState((state) => ({
            accounts: {
                ...accounts,
                [chain.id]: {
                    ...accounts[chain.id],
                    [type]: {
                        status: "READY",
                        account,
                    },
                },
            },
            accountConfigs: {
                ...state.accountConfigs,
                [chain.id]: {
                    ...state.accountConfigs[chain.id],
                    [type]: {
                        ...params,
                        accountAddress: account.address,
                        initCode,
                    },
                },
            },
        }));
    }
    catch (error) {
        clientStore.setState(() => ({
            accounts: {
                ...accounts,
                [chain.id]: {
                    ...accounts[chain.id],
                    [type]: {
                        status: "ERROR",
                        error,
                    },
                },
            },
        }));
    }
    return accountPromise;
}
exports.createAccount = createAccount;
//# sourceMappingURL=createAccount.js.map