"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.hydrate = void 0;
const core_1 = require("@wagmi/core");
const index_js_1 = require("../signer/index.js");
const reconnect_js_1 = require("./actions/reconnect.js");
const client_js_1 = require("./store/client.js");
function hydrate(config, initialState) {
    const initialAlchemyState = initialState != null && "alchemy" in initialState
        ? initialState.alchemy
        : initialState;
    if (initialAlchemyState && !config.clientStore.persist.hasHydrated()) {
        const { accountConfigs, signerStatus, ...rest } = initialAlchemyState;
        const shouldReconnectAccounts = signerStatus.isConnected || signerStatus.isAuthenticating;
        config.clientStore.setState({
            ...rest,
            accountConfigs,
            signerStatus: (0, client_js_1.convertSignerStatusToState)(index_js_1.AlchemySignerStatus.INITIALIZING),
            accounts: hydrateAccountState(accountConfigs, shouldReconnectAccounts, config),
        });
    }
    const initialWagmiState = initialState != null && "wagmi" in initialState
        ? initialState.wagmi
        : undefined;
    const { onMount: wagmi_onMount } = (0, core_1.hydrate)(config._internal.wagmiConfig, {
        initialState: initialWagmiState,
        reconnectOnMount: true,
    });
    return {
        async onMount() {
            if (config._internal.ssr) {
                await config.clientStore.persist.rehydrate();
                await config.coreStore.persist.rehydrate();
            }
            await wagmi_onMount();
            await (0, reconnect_js_1.reconnect)(config);
        },
    };
}
exports.hydrate = hydrate;
const reconnectingState = (address) => ({
    status: "RECONNECTING",
    account: {
        address,
    },
});
const hydrateAccountState = (accountConfigs, shouldReconnectAccounts, config) => {
    const chains = Array.from(config.coreStore.getState().connections.entries()).map(([, cnx]) => cnx.chain);
    const initialState = (0, client_js_1.createDefaultAccountState)(chains);
    return Object.entries(accountConfigs).reduce((acc, [chainKey, config]) => {
        const chainId = Number(chainKey);
        acc[chainId] = {
            LightAccount: config.LightAccount && shouldReconnectAccounts
                ? reconnectingState(config.LightAccount.accountAddress)
                : (0, client_js_1.defaultAccountState)(),
            MultiOwnerModularAccount: config.MultiOwnerModularAccount && shouldReconnectAccounts
                ? reconnectingState(config.MultiOwnerModularAccount.accountAddress)
                : (0, client_js_1.defaultAccountState)(),
        };
        return acc;
    }, initialState);
};
//# sourceMappingURL=hydrate.js.map