"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isMultisigModularAccount = exports.createMultisigModularAccount = exports.MULTISIG_ACCOUNT_SOURCE = void 0;
const aa_core_1 = require("@alchemy/aa-core");
const viem_1 = require("viem");
const MultisigModularAccountFactory_js_1 = require("../abis/MultisigModularAccountFactory.js");
const signer_js_1 = require("../plugins/multisig/signer.js");
const utils_js_1 = require("../utils.js");
const standardExecutor_js_1 = require("./standardExecutor.js");
exports.MULTISIG_ACCOUNT_SOURCE = "MultisigModularAccount";
async function createMultisigModularAccount({ transport, chain, signer, accountAddress, initCode, entryPoint = (0, aa_core_1.getEntryPoint)(chain, { version: "0.6.0" }), factoryAddress = (0, utils_js_1.getDefaultMultisigModularAccountFactoryAddress)(chain), owners = [], salt = 0n, threshold, }) {
    const client = (0, aa_core_1.createBundlerClient)({
        transport,
        chain,
    });
    const getAccountInitCode = async () => {
        if (initCode) {
            return initCode;
        }
        const sigAddress = await signer.getAddress();
        const sigs_ = Array.from(new Set([...owners, sigAddress]))
            .filter((x) => (0, viem_1.hexToBigInt)(x) !== 0n)
            .sort((a, b) => {
            const bigintA = (0, viem_1.hexToBigInt)(a);
            const bigintB = (0, viem_1.hexToBigInt)(b);
            return bigintA < bigintB ? -1 : bigintA > bigintB ? 1 : 0;
        });
        return (0, viem_1.concatHex)([
            factoryAddress,
            (0, viem_1.encodeFunctionData)({
                abi: MultisigModularAccountFactory_js_1.MultisigModularAccountFactoryAbi,
                functionName: "createAccount",
                args: [salt, sigs_, threshold],
            }),
        ]);
    };
    accountAddress = await (0, aa_core_1.getAccountAddress)({
        client,
        entryPoint,
        accountAddress: accountAddress,
        getAccountInitCode,
    });
    const baseAccount = await (0, aa_core_1.toSmartContractAccount)({
        transport,
        chain,
        entryPoint,
        accountAddress,
        source: exports.MULTISIG_ACCOUNT_SOURCE,
        getAccountInitCode,
        ...standardExecutor_js_1.standardExecutor,
        ...(0, signer_js_1.multisigSignMethods)({
            client,
            accountAddress,
            threshold,
            signer: () => signer,
        }),
    });
    return {
        ...baseAccount,
        getLocalThreshold: () => threshold,
        publicKey: await signer.getAddress(),
        getSigner: () => signer,
    };
}
exports.createMultisigModularAccount = createMultisigModularAccount;
const isMultisigModularAccount = (acct) => {
    return acct.source === exports.MULTISIG_ACCOUNT_SOURCE;
};
exports.isMultisigModularAccount = isMultisigModularAccount;
//# sourceMappingURL=multisigAccount.js.map