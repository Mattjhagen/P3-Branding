"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.proposeUserOperation = void 0;
const aa_core_1 = require("@alchemy/aa-core");
const index_js_1 = require("../index.js");
async function proposeUserOperation(client, { uo, account = client.account, overrides: overrides_, }) {
    const overrides = {
        maxFeePerGas: { multiplier: 3 },
        maxPriorityFeePerGas: { multiplier: 2 },
        preVerificationGas: { multiplier: 1000 },
        ...overrides_,
    };
    if (!account) {
        throw new aa_core_1.AccountNotFoundError();
    }
    if (!(0, aa_core_1.isSmartAccountClient)(client)) {
        throw new aa_core_1.IncompatibleClientError("SmartAccountClient", "proposeUserOperation", client);
    }
    if (!(0, aa_core_1.isSmartAccountWithSigner)(account)) {
        throw new aa_core_1.SmartAccountWithSignerRequiredError();
    }
    const builtUo = await client.buildUserOperation({
        account,
        uo,
        overrides,
    });
    const request = await client.signUserOperation({
        uoStruct: builtUo,
        account,
        context: {
            userOpSignatureType: "UPPERLIMIT",
        },
    });
    const splitSignatures = await (0, index_js_1.splitAggregatedSignature)({
        request,
        aggregatedSignature: request.signature,
        account,
        threshold: 2,
    });
    return {
        request,
        signatureObj: splitSignatures.signatures[0],
        aggregatedSignature: request.signature,
    };
}
exports.proposeUserOperation = proposeUserOperation;
//# sourceMappingURL=proposeUserOperation.js.map