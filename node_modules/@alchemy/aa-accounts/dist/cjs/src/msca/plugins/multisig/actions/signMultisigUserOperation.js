"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.signMultisigUserOperation = void 0;
const aa_core_1 = require("@alchemy/aa-core");
const errors_js_1 = require("../../../errors.js");
const index_js_1 = require("../index.js");
async function signMultisigUserOperation(client, params) {
    const { account = client.account, signatures, userOperationRequest } = params;
    if (!account) {
        throw new aa_core_1.AccountNotFoundError();
    }
    if (!(0, aa_core_1.isSmartAccountClient)(client)) {
        throw new aa_core_1.IncompatibleClientError("SmartAccountClient", "signMultisigUserOperation", client);
    }
    if (!(0, aa_core_1.isSmartAccountWithSigner)(account)) {
        throw new aa_core_1.SmartAccountWithSignerRequiredError();
    }
    if (!signatures.length) {
        throw new errors_js_1.MultisigMissingSignatureError();
    }
    const signerAddress = await account.getSigner().getAddress();
    const signedRequest = await client.signUserOperation({
        account,
        uoStruct: userOperationRequest,
        context: {
            aggregatedSignature: (0, index_js_1.combineSignatures)({
                signatures,
                upperLimitMaxFeePerGas: userOperationRequest.maxFeePerGas,
                upperLimitMaxPriorityFeePerGas: userOperationRequest.maxPriorityFeePerGas,
                upperLimitPvg: userOperationRequest.preVerificationGas,
                usingMaxValues: false,
            }),
            signatures,
            userOpSignatureType: "UPPERLIMIT",
        },
    });
    const splitSignatures = await (0, index_js_1.splitAggregatedSignature)({
        account,
        request: signedRequest,
        aggregatedSignature: signedRequest.signature,
        threshold: signatures.length + 2,
    });
    const signatureObj = splitSignatures.signatures.find((x) => x.signer === signerAddress);
    if (!signatureObj) {
        throw new Error("INTERNAL ERROR: signature not found in split signatures, this is an internal bug please report");
    }
    return {
        signatureObj,
        signature: signatureObj.signature,
        aggregatedSignature: signedRequest.signature,
    };
}
exports.signMultisigUserOperation = signMultisigUserOperation;
//# sourceMappingURL=signMultisigUserOperation.js.map