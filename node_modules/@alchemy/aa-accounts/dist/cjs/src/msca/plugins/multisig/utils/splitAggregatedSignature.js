"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.splitAggregatedSignature = void 0;
const aa_core_1 = require("@alchemy/aa-core");
const viem_1 = require("viem");
const errors_js_1 = require("../../../errors.js");
const splitAggregatedSignature = async (args) => {
    const { aggregatedSignature, threshold, account, request } = args;
    if (aggregatedSignature.length < 192 + (65 * threshold - 1)) {
        throw new errors_js_1.InvalidAggregatedSignatureError();
    }
    const pvg = (0, aa_core_1.takeBytes)(aggregatedSignature, { count: 32 });
    const maxFeePerGas = (0, aa_core_1.takeBytes)(aggregatedSignature, {
        count: 32,
        offset: 32,
    });
    const maxPriorityFeePerGas = (0, aa_core_1.takeBytes)(aggregatedSignature, {
        count: 32,
        offset: 64,
    });
    const signaturesAndData = (0, aa_core_1.takeBytes)(aggregatedSignature, {
        offset: 96,
    });
    const signatureHexes = (() => {
        const signatureStr = (0, aa_core_1.takeBytes)(signaturesAndData, {
            count: 65 * threshold - 1,
        });
        const signatures = [];
        for (let i = 0; i < threshold - 1; i++) {
            signatures.push((0, aa_core_1.takeBytes)(signatureStr, { count: 65, offset: i * 65 }));
        }
        return signatures;
    })();
    const signatures = signatureHexes.map(async (signature) => {
        const v = BigInt((0, aa_core_1.takeBytes)(signature, { count: 1, offset: 64 }));
        const signerType = v === 0n ? "CONTRACT" : "EOA";
        if (signerType === "EOA") {
            const hash = (0, viem_1.hashMessage)({
                raw: account.getEntryPoint().getUserOperationHash({
                    ...request,
                    preVerificationGas: pvg,
                    maxFeePerGas,
                    maxPriorityFeePerGas,
                }),
            });
            return {
                signer: await (0, viem_1.recoverAddress)({ hash, signature }),
                signature,
                signerType,
                userOpSigType: "UPPERLIMIT",
            };
        }
        const signer = (0, aa_core_1.takeBytes)(signature, { count: 20, offset: 12 });
        const offset = (0, viem_1.fromHex)((0, aa_core_1.takeBytes)(signature, { count: 32, offset: 32 }), "number");
        const signatureLength = (0, viem_1.fromHex)((0, aa_core_1.takeBytes)(signaturesAndData, { count: 32, offset }), "number");
        return {
            signer,
            signerType,
            userOpSigType: "UPPERLIMIT",
            signature: (0, aa_core_1.takeBytes)(signaturesAndData, {
                count: signatureLength,
                offset: offset + 32,
            }),
        };
    });
    return {
        upperLimitPvg: pvg,
        upperLimitMaxFeePerGas: maxFeePerGas,
        upperLimitMaxPriorityFeePerGas: maxPriorityFeePerGas,
        signatures: await Promise.all(signatures),
    };
};
exports.splitAggregatedSignature = splitAggregatedSignature;
//# sourceMappingURL=splitAggregatedSignature.js.map