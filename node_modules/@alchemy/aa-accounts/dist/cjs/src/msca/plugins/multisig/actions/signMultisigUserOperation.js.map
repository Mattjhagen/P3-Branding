{"version":3,"file":"signMultisigUserOperation.js","sourceRoot":"","sources":["../../../../../../../src/msca/plugins/multisig/actions/signMultisigUserOperation.ts"],"names":[],"mappings":";;;AAAA,8CAO0B;AAE1B,kDAAmE;AACnE,0CAA0E;AAMnE,KAAK,UAAU,yBAAyB,CAO7C,MAA4C,EAC5C,MAAiD;IAEjD,MAAM,EAAE,OAAO,GAAG,MAAM,CAAC,OAAO,EAAE,UAAU,EAAE,oBAAoB,EAAE,GAAG,MAAM,CAAC;IAE9E,IAAI,CAAC,OAAO,EAAE,CAAC;QACb,MAAM,IAAI,8BAAoB,EAAE,CAAC;IACnC,CAAC;IAED,IAAI,CAAC,IAAA,8BAAoB,EAAC,MAAM,CAAC,EAAE,CAAC;QAClC,MAAM,IAAI,iCAAuB,CAC/B,oBAAoB,EACpB,2BAA2B,EAC3B,MAAM,CACP,CAAC;IACJ,CAAC;IAED,IAAI,CAAC,IAAA,kCAAwB,EAAC,OAAO,CAAC,EAAE,CAAC;QACvC,MAAM,IAAI,6CAAmC,EAAE,CAAC;IAClD,CAAC;IAED,IAAI,CAAC,UAAU,CAAC,MAAM,EAAE,CAAC;QACvB,MAAM,IAAI,yCAA6B,EAAE,CAAC;IAC5C,CAAC;IAED,MAAM,aAAa,GAAG,MAAM,OAAO,CAAC,SAAS,EAAE,CAAC,UAAU,EAAE,CAAC;IAE7D,MAAM,aAAa,GAAG,MAAM,MAAM,CAAC,iBAAiB,CAAC;QACnD,OAAO;QACP,QAAQ,EAAE,oBAAoB;QAC9B,OAAO,EAAE;YACP,mBAAmB,EAAE,IAAA,4BAAiB,EAAC;gBACrC,UAAU;gBACV,sBAAsB,EAAE,oBAAoB,CAAC,YAAY;gBACzD,8BAA8B,EAC5B,oBAAoB,CAAC,oBAAoB;gBAC3C,aAAa,EAAE,oBAAoB,CAAC,kBAAkB;gBACtD,cAAc,EAAE,KAAK;aACtB,CAAC;YACF,UAAU;YACV,mBAAmB,EAAE,YAAY;SAClC;KACF,CAAC,CAAC;IAEH,MAAM,eAAe,GAAG,MAAM,IAAA,mCAAwB,EAAC;QACrD,OAAO;QACP,OAAO,EAAE,aAAa;QACtB,mBAAmB,EAAE,aAAa,CAAC,SAAS;QAG5C,SAAS,EAAE,UAAU,CAAC,MAAM,GAAG,CAAC;KACjC,CAAC,CAAC;IAEH,MAAM,YAAY,GAAG,eAAe,CAAC,UAAU,CAAC,IAAI,CAClD,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,MAAM,KAAK,aAAa,CAClC,CAAC;IAEF,IAAI,CAAC,YAAY,EAAE,CAAC;QAElB,MAAM,IAAI,KAAK,CACb,gGAAgG,CACjG,CAAC;IACJ,CAAC;IAED,OAAO;QACL,YAAY;QACZ,SAAS,EAAE,YAAY,CAAC,SAAS;QACjC,mBAAmB,EAAE,aAAa,CAAC,SAAS;KAC7C,CAAC;AACJ,CAAC;AA5ED,8DA4EC","sourcesContent":["import {\n  AccountNotFoundError,\n  IncompatibleClientError,\n  SmartAccountWithSignerRequiredError,\n  isSmartAccountClient,\n  isSmartAccountWithSigner,\n  type SmartContractAccount,\n} from \"@alchemy/aa-core\";\nimport { type Chain, type Client, type Transport } from \"viem\";\nimport { MultisigMissingSignatureError } from \"../../../errors.js\";\nimport { combineSignatures, splitAggregatedSignature } from \"../index.js\";\nimport {\n  type SignMultisigUserOperationParams,\n  type SignMultisigUserOperationResult,\n} from \"../types.js\";\n\nexport async function signMultisigUserOperation<\n  TTransport extends Transport = Transport,\n  TChain extends Chain | undefined = Chain | undefined,\n  TAccount extends SmartContractAccount | undefined =\n    | SmartContractAccount\n    | undefined\n>(\n  client: Client<TTransport, TChain, TAccount>,\n  params: SignMultisigUserOperationParams<TAccount>\n): Promise<SignMultisigUserOperationResult> {\n  const { account = client.account, signatures, userOperationRequest } = params;\n\n  if (!account) {\n    throw new AccountNotFoundError();\n  }\n\n  if (!isSmartAccountClient(client)) {\n    throw new IncompatibleClientError(\n      \"SmartAccountClient\",\n      \"signMultisigUserOperation\",\n      client\n    );\n  }\n\n  if (!isSmartAccountWithSigner(account)) {\n    throw new SmartAccountWithSignerRequiredError();\n  }\n\n  if (!signatures.length) {\n    throw new MultisigMissingSignatureError();\n  }\n\n  const signerAddress = await account.getSigner().getAddress();\n\n  const signedRequest = await client.signUserOperation({\n    account,\n    uoStruct: userOperationRequest,\n    context: {\n      aggregatedSignature: combineSignatures({\n        signatures,\n        upperLimitMaxFeePerGas: userOperationRequest.maxFeePerGas,\n        upperLimitMaxPriorityFeePerGas:\n          userOperationRequest.maxPriorityFeePerGas,\n        upperLimitPvg: userOperationRequest.preVerificationGas,\n        usingMaxValues: false,\n      }),\n      signatures,\n      userOpSignatureType: \"UPPERLIMIT\",\n    },\n  });\n\n  const splitSignatures = await splitAggregatedSignature({\n    account,\n    request: signedRequest,\n    aggregatedSignature: signedRequest.signature,\n    // split works on the assumption that we have t - 1 signatures\n    // we have signatures.length + 1 signatures now, so we need sl + 1 + 1\n    threshold: signatures.length + 2,\n  });\n\n  const signatureObj = splitSignatures.signatures.find(\n    (x) => x.signer === signerAddress\n  );\n\n  if (!signatureObj) {\n    // TODO: strongly type this\n    throw new Error(\n      \"INTERNAL ERROR: signature not found in split signatures, this is an internal bug please report\"\n    );\n  }\n\n  return {\n    signatureObj,\n    signature: signatureObj.signature,\n    aggregatedSignature: signedRequest.signature,\n  };\n}\n"]}