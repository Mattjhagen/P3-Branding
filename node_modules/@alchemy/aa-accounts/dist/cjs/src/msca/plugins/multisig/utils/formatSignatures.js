"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.formatSignatures = void 0;
const aa_core_1 = require("@alchemy/aa-core");
const viem_1 = require("viem");
const formatSignatures = (signatures, usingMaxValues = false) => {
    let eoaSigs = "";
    let contractSigs = "";
    let offset = BigInt(65 * signatures.length);
    signatures
        .sort((a, b) => {
        const bigintA = (0, viem_1.hexToBigInt)(a.signer);
        const bigintB = (0, viem_1.hexToBigInt)(b.signer);
        return bigintA < bigintB ? -1 : bigintA > bigintB ? 1 : 0;
    })
        .forEach((sig) => {
        const addV = sig.userOpSigType === "ACTUAL" && !usingMaxValues ? 32 : 0;
        if (sig.signerType === "EOA") {
            let v = parseInt((0, aa_core_1.takeBytes)(sig.signature, { count: 1, offset: 64 })) + addV;
            eoaSigs += (0, viem_1.concat)([
                (0, aa_core_1.takeBytes)(sig.signature, { count: 64 }),
                (0, viem_1.toHex)(v, { size: 1 }),
            ]).slice(2);
        }
        else {
            const sigLen = BigInt(sig.signature.slice(2).length / 2);
            eoaSigs += (0, viem_1.concat)([
                (0, viem_1.pad)(sig.signer),
                (0, viem_1.toHex)(offset, { size: 32 }),
                (0, viem_1.toHex)(addV, { size: 1 }),
            ]).slice(2);
            contractSigs += (0, viem_1.concat)([
                (0, viem_1.toHex)(sigLen, { size: 32 }),
                sig.signature,
            ]).slice(2);
            offset += sigLen;
        }
    });
    return ("0x" + eoaSigs + contractSigs);
};
exports.formatSignatures = formatSignatures;
//# sourceMappingURL=formatSignatures.js.map