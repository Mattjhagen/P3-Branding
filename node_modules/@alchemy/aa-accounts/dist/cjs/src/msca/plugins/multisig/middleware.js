"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.multisigSignatureMiddleware = void 0;
const aa_core_1 = require("@alchemy/aa-core");
const multisigAccount_js_1 = require("../../account/multisigAccount.js");
const errors_js_1 = require("../../errors.js");
const index_js_1 = require("./index.js");
const multisigSignatureMiddleware = async (struct, { account, client, context }) => {
    if (!context ||
        (context.userOpSignatureType === "ACTUAL" &&
            !context.signatures &&
            !context.aggregatedSignature)) {
        throw new errors_js_1.InvalidContextSignatureError();
    }
    if (!(0, aa_core_1.isSmartAccountWithSigner)(account)) {
        throw new aa_core_1.SmartAccountWithSignerRequiredError();
    }
    if (!(0, multisigAccount_js_1.isMultisigModularAccount)(account)) {
        throw new errors_js_1.MultisigAccountExpectedError();
    }
    const resolvedStruct = await (0, aa_core_1.resolveProperties)(struct);
    const request = (0, aa_core_1.deepHexlify)(resolvedStruct);
    if (!(0, aa_core_1.isValidRequest)(request)) {
        throw new aa_core_1.InvalidUserOperationError(resolvedStruct);
    }
    const signature = await account.signUserOperationHash(account.getEntryPoint().getUserOperationHash(request));
    const signerType = await (0, index_js_1.getSignerType)({
        client,
        signature: signature,
        signer: account.getSigner(),
    });
    if (context.userOpSignatureType === "UPPERLIMIT" &&
        context?.signatures?.length == null &&
        context?.aggregatedSignature == null) {
        return {
            ...resolvedStruct,
            signature: (0, index_js_1.combineSignatures)({
                signatures: [
                    {
                        signature,
                        signer: await account.getSigner().getAddress(),
                        signerType,
                        userOpSigType: context.userOpSignatureType,
                    },
                ],
                upperLimitMaxFeePerGas: request.maxFeePerGas,
                upperLimitMaxPriorityFeePerGas: request.maxPriorityFeePerGas,
                upperLimitPvg: request.preVerificationGas,
                usingMaxValues: false,
            }),
        };
    }
    if (context.aggregatedSignature == null || context.signatures == null) {
        throw new errors_js_1.InvalidContextSignatureError();
    }
    const { upperLimitPvg, upperLimitMaxFeePerGas, upperLimitMaxPriorityFeePerGas, } = await (0, index_js_1.splitAggregatedSignature)({
        aggregatedSignature: context.aggregatedSignature,
        threshold: context.signatures.length + 1,
        account,
        request,
    });
    const finalSignature = (0, index_js_1.combineSignatures)({
        signatures: context.signatures.concat({
            userOpSigType: context.userOpSignatureType,
            signerType,
            signature,
            signer: await account.getSigner().getAddress(),
        }),
        upperLimitPvg,
        upperLimitMaxFeePerGas,
        upperLimitMaxPriorityFeePerGas,
        usingMaxValues: isUsingMaxValues(request, {
            upperLimitPvg,
            upperLimitMaxFeePerGas,
            upperLimitMaxPriorityFeePerGas,
        }),
    });
    return {
        ...resolvedStruct,
        signature: finalSignature,
    };
};
exports.multisigSignatureMiddleware = multisigSignatureMiddleware;
const isUsingMaxValues = (request, upperLimits) => {
    if (BigInt(request.preVerificationGas) !== BigInt(upperLimits.upperLimitPvg)) {
        return false;
    }
    if (BigInt(request.maxFeePerGas) !== BigInt(upperLimits.upperLimitMaxFeePerGas)) {
        return false;
    }
    if (BigInt(request.maxPriorityFeePerGas) !==
        BigInt(upperLimits.upperLimitMaxPriorityFeePerGas)) {
        return false;
    }
    return true;
};
//# sourceMappingURL=middleware.js.map