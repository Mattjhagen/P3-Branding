"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MultisigMissingSignatureError = exports.MultisigAccountExpectedError = exports.InvalidContextSignatureError = exports.InvalidAggregatedSignatureError = void 0;
const aa_core_1 = require("@alchemy/aa-core");
class InvalidAggregatedSignatureError extends aa_core_1.BaseError {
    constructor() {
        super("Invalid aggregated signature");
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "InvalidAggregatedSignatureError"
        });
    }
}
exports.InvalidAggregatedSignatureError = InvalidAggregatedSignatureError;
class InvalidContextSignatureError extends aa_core_1.BaseError {
    constructor() {
        super("Expected context.signature to be a hex string");
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "InvalidContextSignatureError"
        });
    }
}
exports.InvalidContextSignatureError = InvalidContextSignatureError;
class MultisigAccountExpectedError extends aa_core_1.BaseError {
    constructor() {
        super("Expected account to be a multisig modular account");
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "MultisigAccountExpectedError"
        });
    }
}
exports.MultisigAccountExpectedError = MultisigAccountExpectedError;
class MultisigMissingSignatureError extends aa_core_1.BaseError {
    constructor() {
        super("UserOp must have at least one signature already");
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "MultisigMissingSignatureError"
        });
    }
}
exports.MultisigMissingSignatureError = MultisigMissingSignatureError;
//# sourceMappingURL=errors.js.map