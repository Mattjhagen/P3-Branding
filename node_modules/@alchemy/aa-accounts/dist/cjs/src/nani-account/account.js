"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createNaniAccount = void 0;
const aa_core_1 = require("@alchemy/aa-core");
const viem_1 = require("viem");
const NaniAccountAbi_js_1 = require("./abis/NaniAccountAbi.js");
const NaniAccountFactoryAbi_js_1 = require("./abis/NaniAccountFactoryAbi.js");
class NaniAccount_ extends aa_core_1.BaseSmartContractAccount {
    constructor(params) {
        const client = (0, aa_core_1.createBundlerClient)({
            transport: params.transport,
            chain: params.chain,
        });
        super({ ...params, rpcClient: client });
        Object.defineProperty(this, "signer", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "index", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "salt", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.index = params.index ?? 0n;
        this.signer = params.signer;
        this.salt = params.salt;
    }
    async signTypedData(params) {
        return this.signer.signTypedData(params);
    }
    async getOwnerAddress() {
        const callResult = await this.rpcProvider.call({
            to: await this.getAddress(),
            data: (0, viem_1.encodeFunctionData)({
                abi: NaniAccountAbi_js_1.NaniAccountAbi,
                functionName: "owner",
            }),
        });
        if (callResult.data == null) {
            throw new Error("could not get on-chain owner");
        }
        const decodedCallResult = (0, viem_1.decodeFunctionResult)({
            abi: NaniAccountAbi_js_1.NaniAccountAbi,
            functionName: "owner",
            data: callResult.data,
        });
        if (decodedCallResult !== (await this.signer.getAddress())) {
            throw new Error("current account signer does not match the on-chain owner");
        }
        return decodedCallResult;
    }
    async getAddress() {
        const callResult = await this.rpcProvider.call({
            to: this.factoryAddress,
            data: (0, viem_1.encodeFunctionData)({
                abi: NaniAccountFactoryAbi_js_1.NaniAccountFactoryAbi,
                functionName: "getAddress",
                args: [await this.getSalt()],
            }),
        });
        if (callResult.data == null) {
            throw new Error("could not get deterministic address");
        }
        const decodedCallResult = (0, viem_1.decodeFunctionResult)({
            abi: NaniAccountFactoryAbi_js_1.NaniAccountFactoryAbi,
            functionName: "getAddress",
            data: callResult.data,
        });
        return decodedCallResult;
    }
    getDummySignature() {
        return "0xfffffffffffffffffffffffffffffff0000000000000000000000000000000007aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa1c";
    }
    signMessage(msg) {
        return this.signer.signMessage(typeof msg === "string" && !(0, viem_1.isHex)(msg) ? msg : { raw: msg });
    }
    async encodeExecute(target, value, data) {
        return (0, viem_1.encodeFunctionData)({
            abi: NaniAccountAbi_js_1.NaniAccountAbi,
            functionName: "execute",
            args: [target, value, data],
        });
    }
    async encodeBatchExecute(calls) {
        return (0, viem_1.encodeFunctionData)({
            abi: NaniAccountAbi_js_1.NaniAccountAbi,
            functionName: "executeBatch",
            args: [
                calls.map((call) => ({
                    ...call,
                    value: call.value ?? 0n,
                })),
            ],
        });
    }
    static encodeExecuteDelegate(delegate, data) {
        return (0, viem_1.encodeFunctionData)({
            abi: NaniAccountAbi_js_1.NaniAccountAbi,
            functionName: "delegateExecute",
            args: [delegate, data],
        });
    }
    static encodeTransferOwnership(newOwner) {
        return (0, viem_1.encodeFunctionData)({
            abi: NaniAccountAbi_js_1.NaniAccountAbi,
            functionName: "transferOwnership",
            args: [newOwner],
        });
    }
    async getAccountInitCode() {
        const result = (0, viem_1.concatHex)([
            this.factoryAddress,
            await this.getFactoryInitCode(),
        ]);
        return result;
    }
    async getSalt() {
        if (this.salt) {
            if (this.salt.slice(0, 42) !== (await this.signer.getAddress())) {
                throw new Error("Salt does not match the current signer address");
            }
            else {
                return this.salt;
            }
        }
        return (0, viem_1.concatHex)([
            await this.signer.getAddress(),
            (0, viem_1.numberToHex)(this.index, { size: 12 }),
        ]);
    }
    async getFactoryInitCode() {
        try {
            return (0, viem_1.encodeFunctionData)({
                abi: NaniAccountFactoryAbi_js_1.NaniAccountFactoryAbi,
                functionName: "createAccount",
                args: [await this.signer.getAddress(), await this.getSalt()],
            });
        }
        catch (err) {
            throw new Error("Factory Code generation failed");
        }
    }
}
const createNaniAccount = async (params) => {
    if (!params.signer)
        throw new Error("Owner must be provided.");
    const naniAccount = new NaniAccount_(params);
    const base = await (0, aa_core_1.toSmartContractAccount)({
        source: "NaniAccount",
        transport: params.transport,
        chain: params.chain,
        accountAddress: params.accountAddress,
        entryPoint: (0, aa_core_1.getEntryPoint)(params.chain, {
            addressOverride: naniAccount.getEntryPointAddress(),
        }),
        encodeBatchExecute: naniAccount.encodeBatchExecute.bind(naniAccount),
        encodeExecute: (tx) => naniAccount.encodeExecute(tx.target, tx.value ?? 0n, tx.data),
        getAccountInitCode: async () => {
            if (params.initCode)
                return params.initCode;
            return naniAccount.getAccountInitCode();
        },
        getDummySignature: naniAccount.getDummySignature.bind(naniAccount),
        signMessage: ({ message }) => naniAccount.signMessage(typeof message === "string" ? message : message.raw),
        signTypedData: (params) => naniAccount.signTypedData(params),
    });
    return {
        ...base,
        getSigner: () => naniAccount.getSigner(),
        encodeExecuteDelegate: NaniAccount_.encodeExecuteDelegate,
        encodeTransferOwnership: NaniAccount_.encodeTransferOwnership,
    };
};
exports.createNaniAccount = createNaniAccount;
//# sourceMappingURL=account.js.map