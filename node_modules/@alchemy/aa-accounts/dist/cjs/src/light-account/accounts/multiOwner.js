"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createMultiOwnerLightAccount = void 0;
const aa_core_1 = require("@alchemy/aa-core");
const viem_1 = require("viem");
const MultiOwnerLightAccountAbi_js_1 = require("../abis/MultiOwnerLightAccountAbi.js");
const MultiOwnerLightAccountFactoryAbi_js_1 = require("../abis/MultiOwnerLightAccountFactoryAbi.js");
const utils_js_1 = require("../utils.js");
const base_js_1 = require("./base.js");
async function createMultiOwnerLightAccount({ transport, chain, signer, initCode, version = (0, utils_js_1.defaultLightAccountVersion)("MultiOwnerLightAccount"), entryPoint = (0, aa_core_1.getEntryPoint)(chain, {
    version: utils_js_1.AccountVersionRegistry["MultiOwnerLightAccount"][version]
        .entryPointVersion,
}), accountAddress, factoryAddress = utils_js_1.AccountVersionRegistry["MultiOwnerLightAccount"][version]
    .address[chain.id].factory, salt: salt_ = 0n, owners = [], }) {
    const client = (0, aa_core_1.createBundlerClient)({
        transport,
        chain,
    });
    const getAccountInitCode = async () => {
        if (initCode)
            return initCode;
        const ownerAddress = await signer.getAddress();
        const owners_ = Array.from(new Set([...owners, ownerAddress]))
            .filter((x) => (0, viem_1.hexToBigInt)(x) !== 0n)
            .sort((a, b) => {
            const bigintA = (0, viem_1.hexToBigInt)(a);
            const bigintB = (0, viem_1.hexToBigInt)(b);
            return bigintA < bigintB ? -1 : bigintA > bigintB ? 1 : 0;
        });
        return (0, viem_1.concatHex)([
            factoryAddress,
            (0, viem_1.encodeFunctionData)({
                abi: MultiOwnerLightAccountFactoryAbi_js_1.MultiOwnerLightAccountFactoryAbi,
                functionName: "createAccount",
                args: [owners_, salt_],
            }),
        ]);
    };
    const address = await (0, aa_core_1.getAccountAddress)({
        client,
        entryPoint,
        accountAddress,
        getAccountInitCode,
    });
    const account = await (0, base_js_1.createLightAccountBase)({
        transport,
        chain,
        signer,
        abi: MultiOwnerLightAccountAbi_js_1.MultiOwnerLightAccountAbi,
        version: utils_js_1.AccountVersionRegistry["MultiOwnerLightAccount"][version],
        entryPoint,
        accountAddress: address,
        getAccountInitCode,
    });
    return {
        ...account,
        encodeUpdateOwners: (ownersToAdd, ownersToRemove) => {
            return (0, viem_1.encodeFunctionData)({
                abi: MultiOwnerLightAccountAbi_js_1.MultiOwnerLightAccountAbi,
                functionName: "updateOwners",
                args: [ownersToAdd, ownersToRemove],
            });
        },
        async getOwnerAddresses() {
            const callResult = await client.readContract({
                address,
                abi: MultiOwnerLightAccountAbi_js_1.MultiOwnerLightAccountAbi,
                functionName: "owners",
            });
            if (callResult == null) {
                throw new Error("could not get on-chain owners");
            }
            if (!callResult.includes(await signer.getAddress())) {
                throw new Error("on-chain owners does not include the current signer");
            }
            return callResult;
        },
    };
}
exports.createMultiOwnerLightAccount = createMultiOwnerLightAccount;
//# sourceMappingURL=multiOwner.js.map