"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PluginActionsGenPhase = void 0;
const aa_core_1 = require("@alchemy/aa-core");
const change_case_1 = require("change-case");
const dedent_1 = __importDefault(require("dedent"));
const utils_js_1 = require("../../utils.js");
const management_actions_js_1 = require("./management-actions.js");
const read_actions_js_1 = require("./read-actions.js");
const PluginActionsGenPhase = async (input) => {
    const { plugin, contract, addImport, addType } = input;
    const { executionFunctions } = await plugin.read.pluginManifest();
    const executionAbiConst = `${contract.name}ExecutionFunctionAbi`;
    const executionAbi = (0, utils_js_1.extractExecutionAbi)(executionFunctions, contract.abi);
    addImport("viem", { name: "EncodeFunctionDataParameters", isType: true });
    addImport("viem", { name: "Transport", isType: true });
    addImport("viem", { name: "Chain", isType: true });
    addImport("viem", { name: "Client", isType: true });
    addImport("@alchemy/aa-core", {
        name: "SmartContractAccount",
        isType: true,
    });
    addImport("@alchemy/aa-core", {
        name: "GetAccountParameter",
        isType: true,
    });
    addImport("@alchemy/aa-core", {
        name: "SendUserOperationResult",
        isType: true,
    });
    addImport("@alchemy/aa-core", {
        name: "GetEntryPointFromAccount",
        isType: true,
    });
    addImport("@alchemy/aa-core", {
        name: "UserOperationOverridesParameter",
        isType: true,
    });
    addImport("@alchemy/aa-core", {
        name: "UserOperationContext",
        isType: true,
    });
    addImport("@alchemy/aa-core", { name: "AccountNotFoundError" });
    addImport("@alchemy/aa-core", { name: "isSmartAccountClient" });
    addImport("@alchemy/aa-core", { name: "IncompatibleClientError" });
    addImport("@alchemy/aa-core", { name: "GetContextParameter", isType: true });
    const providerFunctionDefs = [];
    const providerFunctions = executionAbi
        .filter((n) => n.stateMutability !== "view")
        .map((n) => {
        const argsParamString = n.inputs.length > 0
            ? (0, dedent_1.default) `{
                  args,
                  overrides,
                  context,
                  account = client.account
              }`
            : (0, dedent_1.default) `{
                  overrides,
                  context,
                  account = client.account
              }`;
        const argsEncodeString = n.inputs.length > 0 ? "args," : "";
        providerFunctionDefs.push((0, dedent_1.default) `
          ${(0, change_case_1.camelCase)(n.name)}: (args: Pick<EncodeFunctionDataParameters<typeof ${executionAbiConst}, "${n.name}">, "args"> & UserOperationOverridesParameter<TEntryPointVersion> &
        GetAccountParameter<TAccount> & GetContextParameter<TContext>) =>
          Promise<SendUserOperationResult<TEntryPointVersion>>
      `);
        const methodName = (0, change_case_1.camelCase)(n.name);
        return (0, dedent_1.default) `
              ${methodName}(${argsParamString}) {
                if (!account) {
                  throw new AccountNotFoundError();
                }
                if (!isSmartAccountClient(client)) {
                  throw new IncompatibleClientError("SmartAccountClient", "${methodName}", client);
                }

                const uo = encodeFunctionData({
                  abi: ${executionAbiConst},
                  functionName: "${n.name}",
                  ${argsEncodeString}
                });

                return client.sendUserOperation({ uo, overrides, account, context });
              }
            `;
    });
    addType(`ExecutionActions<
      TAccount extends SmartContractAccount | undefined =
        SmartContractAccount | undefined,
      TContext extends UserOperationContext | undefined = UserOperationContext | undefined,
      TEntryPointVersion extends GetEntryPointFromAccount<TAccount> = GetEntryPointFromAccount<TAccount>
    >`, (0, dedent_1.default) `{
        ${providerFunctionDefs.join(";\n\n")}
      }`);
    const { hasReadMethods } = await (0, aa_core_1.asyncPipe)(management_actions_js_1.ManagementActionsGenPhase, read_actions_js_1.AccountReadActionsGenPhase)({
        ...input,
        content: providerFunctions,
    });
    addType(`${contract.name}Actions<
      TAccount extends SmartContractAccount | undefined =
          | SmartContractAccount
          | undefined,
      TContext extends UserOperationContext | undefined =
          | UserOperationContext
          | undefined
    >`, (0, dedent_1.default) `
      ExecutionActions<TAccount, TContext> & ManagementActions<TAccount, TContext> & ReadAndEncodeActions${hasReadMethods ? "<TAccount>" : ""}
  `, true);
    input.content.push((0, dedent_1.default) `
    export const ${(0, change_case_1.camelCase)(contract.name)}Actions: <
        TTransport extends Transport = Transport,
        TChain extends Chain | undefined = Chain | undefined,
        TAccount extends SmartContractAccount | undefined =
            | SmartContractAccount
            | undefined,
        TContext extends UserOperationContext | undefined = UserOperationContext | undefined
    >(
        client: Client<TTransport, TChain, TAccount>
    ) => ${contract.name}Actions<TAccount, TContext> = (client) => ({ ${providerFunctions.join(",\n")} });
  `);
    return input;
};
exports.PluginActionsGenPhase = PluginActionsGenPhase;
//# sourceMappingURL=index.js.map