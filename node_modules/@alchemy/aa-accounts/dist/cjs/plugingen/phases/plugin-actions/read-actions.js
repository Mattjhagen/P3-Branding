"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AccountReadActionsGenPhase = void 0;
const change_case_1 = require("change-case");
const dedent_1 = __importDefault(require("dedent"));
const utils_js_1 = require("../../utils.js");
const AccountReadActionsGenPhase = async (input) => {
    const { plugin, contract, addImport, addType } = input;
    const { executionFunctions } = await plugin.read.pluginManifest();
    const executionAbiConst = `${contract.name}ExecutionFunctionAbi`;
    const executionAbi = (0, utils_js_1.extractExecutionAbi)(executionFunctions, contract.abi);
    addImport("viem", { name: "EncodeFunctionDataParameters", isType: true });
    addImport("viem", { name: "encodeFunctionData" });
    addImport("viem", { name: "Hex", isType: true });
    const accountFunctionActionDefs = [];
    const accountFunctions = executionAbi.map((n) => {
        const methodContent = [];
        const argsParamString = n.inputs.length > 0 ? `{ args }` : "";
        const argsEncodeString = n.inputs.length > 0 ? "args," : "";
        const isViewFunction = n.stateMutability === "view";
        const encodeMethodName = `encode${(0, change_case_1.pascalCase)(n.name)}`;
        accountFunctionActionDefs.push((0, dedent_1.default) `${encodeMethodName}: (args: Pick<EncodeFunctionDataParameters<typeof ${executionAbiConst}, "${n.name}">, "args">) => Hex`);
        methodContent.push((0, dedent_1.default) `
      ${encodeMethodName}(${argsParamString}) {
          return encodeFunctionData({
              abi: ${executionAbiConst},
              functionName: "${n.name}",
              ${argsEncodeString}
          });
      }
    `);
        const readArgsParamString = n.inputs.length > 0
            ? `{ args, account = client.account }`
            : "{ account = client.account }";
        if (isViewFunction) {
            addImport("viem", { name: "ReadContractReturnType", isType: true });
            input.hasReadMethods = true;
            const readMethodName = `read${(0, change_case_1.pascalCase)(n.name)}`;
            accountFunctionActionDefs.push(n.inputs.length > 0
                ? (0, dedent_1.default) `${readMethodName}: (args: Pick<EncodeFunctionDataParameters<typeof ${executionAbiConst}, "${n.name}">, "args"> & GetAccountParameter<TAccount>) => Promise<ReadContractReturnType<typeof ${executionAbiConst}, "${n.name}">>`
                : (0, dedent_1.default) `${readMethodName}: (args: GetAccountParameter<TAccount>) => Promise<ReadContractReturnType<typeof ${executionAbiConst}, "${n.name}">>`);
            methodContent.push((0, dedent_1.default) `
        async ${readMethodName} (${readArgsParamString}) {
          if (!account) {
            throw new AccountNotFoundError();
          }

          if (!isSmartAccountClient(client)) {
            throw new IncompatibleClientError("SmartAccountClient", "${readMethodName}", client);
          }

          return client.readContract({
            address: account.address,
            abi: ${executionAbiConst},
            functionName: "${n.name}",
            ${argsEncodeString}
          });
        }
      `);
        }
        return methodContent.join(",\n\n");
    });
    const typeName = input.hasReadMethods
        ? `ReadAndEncodeActions<
        TAccount extends SmartContractAccount | undefined =
          SmartContractAccount | undefined,
      >`
        : "ReadAndEncodeActions";
    addType(typeName, (0, dedent_1.default) `{
    ${accountFunctionActionDefs.join(";\n\n")}
  }`);
    input.content.push(...accountFunctions);
    return input;
};
exports.AccountReadActionsGenPhase = AccountReadActionsGenPhase;
//# sourceMappingURL=read-actions.js.map