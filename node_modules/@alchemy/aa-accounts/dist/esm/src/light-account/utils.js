import { DefaultFactoryNotDefinedError, arbitrum, arbitrumGoerli, arbitrumSepolia, base, baseGoerli, baseSepolia, fraxtal, fraxtalSepolia, goerli, mainnet, optimism, optimismGoerli, optimismSepolia, polygon, polygonAmoy, polygonMumbai, sepolia, toRecord, zora, zoraSepolia, } from "@alchemy/aa-core";
import { fromHex } from "viem";
export const supportedChains = [
    mainnet,
    sepolia,
    goerli,
    polygon,
    polygonAmoy,
    polygonMumbai,
    optimism,
    optimismGoerli,
    optimismSepolia,
    arbitrum,
    arbitrumGoerli,
    arbitrumSepolia,
    base,
    baseGoerli,
    baseSepolia,
    fraxtal,
    fraxtalSepolia,
    zora,
    zoraSepolia,
];
export const AccountVersionRegistry = {
    LightAccount: {
        "v1.0.1": {
            type: "LightAccount",
            version: "v1.0.1",
            address: toRecord(supportedChains, "id", () => ({
                factory: "0x000000893A26168158fbeaDD9335Be5bC96592E2".toLowerCase(),
                impl: "0xc1b2fc4197c9187853243e6e4eb5a4af8879a1c0".toLowerCase(),
            })),
            entryPointVersion: "0.6.0",
        },
        "v1.0.2": {
            type: "LightAccount",
            version: "v1.0.2",
            address: toRecord(supportedChains, "id", () => ({
                factory: "0x00000055C0b4fA41dde26A74435ff03692292FBD".toLowerCase(),
                impl: "0x5467b1947F47d0646704EB801E075e72aeAe8113".toLowerCase(),
            })),
            entryPointVersion: "0.6.0",
        },
        "v1.1.0": {
            type: "LightAccount",
            version: "v1.1.0",
            address: toRecord(supportedChains, "id", () => ({
                factory: "0x00004EC70002a32400f8ae005A26081065620D20".toLowerCase(),
                impl: "0xae8c656ad28F2B59a196AB61815C16A0AE1c3cba".toLowerCase(),
            })),
            entryPointVersion: "0.6.0",
        },
        "v2.0.0": {
            type: "LightAccount",
            version: "v2.0.0",
            address: toRecord(supportedChains, "id", () => ({
                factory: "0x0000000000400CdFef5E2714E63d8040b700BC24".toLowerCase(),
                impl: "0x8E8e658E22B12ada97B402fF0b044D6A325013C7".toLowerCase(),
            })),
            entryPointVersion: "0.7.0",
        },
    },
    MultiOwnerLightAccount: {
        "v2.0.0": {
            type: "MultiOwnerLightAccount",
            version: "v2.0.0",
            address: toRecord(supportedChains, "id", () => ({
                factory: "0x000000000019d2Ee9F2729A65AfE20bb0020AefC".toLowerCase(),
                impl: "0xd2c27F9eE8E4355f71915ffD5568cB3433b6823D".toLowerCase(),
            })),
            entryPointVersion: "0.7.0",
        },
    },
};
export const defaultLightAccountVersion = (type) => (type === "LightAccount"
    ? "v1.1.0"
    : "v2.0.0");
export const getDefaultLightAccountFactoryAddress = (chain, version = "v1.1.0") => {
    const address = AccountVersionRegistry.LightAccount[version].address[chain.id];
    if (!address)
        throw new DefaultFactoryNotDefinedError("LightAccount", chain, "0.6.0");
    return address.factory;
};
export const LightAccountUnsupported1271Impls = [
    AccountVersionRegistry.LightAccount["v1.0.1"],
    AccountVersionRegistry.LightAccount["v1.0.2"],
];
export const LightAccountUnsupported1271Factories = new Set(LightAccountUnsupported1271Impls.map((x) => Object.values(x.address).map((addr) => addr.factory)).flat());
export async function getLightAccountVersionDef(account, chain) {
    const accountType = account.source;
    const factoryAddress = await account.getFactoryAddress();
    const implAddress = await account.getImplementationAddress();
    const implToVersion = new Map(Object.entries(AccountVersionRegistry[accountType])
        .map((pair) => {
        const [version, def] = pair;
        return chain.id in def.address
            ? [def.address[chain.id].impl, version]
            : [null, version];
    })
        .filter(([impl]) => impl !== null));
    const factoryToVersion = new Map(Object.entries(AccountVersionRegistry[accountType])
        .map((pair) => {
        const [version, def] = pair;
        return chain.id in def.address
            ? [def.address[chain.id].factory, version]
            : [null, version];
    })
        .filter(([impl]) => impl !== null));
    const version = fromHex(implAddress, "bigint") === 0n
        ? factoryToVersion.get(factoryAddress.toLowerCase())
        : implToVersion.get(implAddress.toLowerCase());
    if (!version) {
        throw new Error(`Could not determine ${account.source} version for chain ${chain.id}`);
    }
    return AccountVersionRegistry[accountType][version];
}
export async function getLightAccountVersion(account, chain = supportedChains[0]) {
    return (await getLightAccountVersionDef(account, chain)).version;
}
//# sourceMappingURL=utils.js.map