import { FailedToGetStorageSlotError, createBundlerClient, toSmartContractAccount, } from "@alchemy/aa-core";
import { concat, encodeFunctionData, fromHex, hashMessage, hashTypedData, trim, } from "viem";
import { AccountVersionRegistry } from "../utils.js";
var SignatureType;
(function (SignatureType) {
    SignatureType["EOA"] = "0x00";
    SignatureType["CONTRACT"] = "0x01";
    SignatureType["CONTRACT_WITH_ADDR"] = "0x02";
})(SignatureType || (SignatureType = {}));
export async function createLightAccountBase({ transport, chain, signer, abi, version: { version, type }, entryPoint, accountAddress, getAccountInitCode, }) {
    const client = createBundlerClient({
        transport,
        chain,
    });
    const encodeUpgradeToAndCall = async ({ upgradeToAddress, upgradeToInitData, }) => {
        const storage = await client.getStorageAt({
            address: accountAddress,
            slot: "0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc",
        });
        if (storage == null) {
            throw new FailedToGetStorageSlotError("0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc", "Proxy Implementation Address");
        }
        const implementationAddresses = Object.values(AccountVersionRegistry[type]).map((x) => x.address[chain.id].impl);
        if (fromHex(storage, "number") !== 0 &&
            !implementationAddresses.some((x) => x === trim(storage))) {
            throw new Error(`could not determine if smart account implementation is ${type} ${version}`);
        }
        return encodeFunctionData({
            abi,
            functionName: "upgradeToAndCall",
            args: [upgradeToAddress, upgradeToInitData],
        });
    };
    const signWith1271WrapperV1 = async (hashedMessage) => {
        return signer.signTypedData({
            domain: {
                chainId: Number(client.chain.id),
                name: type,
                verifyingContract: accountAddress,
                version: "1",
            },
            types: {
                LightAccountMessage: [{ name: "message", type: "bytes" }],
            },
            message: {
                message: hashedMessage,
            },
            primaryType: "LightAccountMessage",
        });
    };
    const account = await toSmartContractAccount({
        transport,
        chain,
        entryPoint,
        accountAddress,
        source: type,
        getAccountInitCode,
        encodeExecute: async ({ target, data, value }) => {
            return encodeFunctionData({
                abi,
                functionName: "execute",
                args: [target, value ?? 0n, data],
            });
        },
        encodeBatchExecute: async (txs) => {
            const [targets, values, datas] = txs.reduce((accum, curr) => {
                accum[0].push(curr.target);
                accum[1].push(curr.value ?? 0n);
                accum[2].push(curr.data);
                return accum;
            }, [[], [], []]);
            return encodeFunctionData({
                abi,
                functionName: "executeBatch",
                args: [targets, values, datas],
            });
        },
        signUserOperationHash: async (uoHash) => {
            const signature = await signer.signMessage({ raw: uoHash });
            switch (version) {
                case "v2.0.0":
                    return concat([SignatureType.EOA, signature]);
                default:
                    return signature;
            }
        },
        async signMessage({ message }) {
            switch (version) {
                case "v1.0.1":
                    return signer.signMessage(message);
                case "v1.0.2":
                    throw new Error(`${type} ${version} doesn't support 1271`);
                case "v1.1.0":
                    return signWith1271WrapperV1(hashMessage(message));
                case "v2.0.0":
                    const signature = await signWith1271WrapperV1(hashMessage(message));
                    return concat([SignatureType.EOA, signature]);
                default:
                    throw new Error(`Unknown version ${type} of ${version}`);
            }
        },
        async signTypedData(params) {
            switch (version) {
                case "v1.0.1":
                    return signer.signTypedData(params);
                case "v1.0.2":
                    throw new Error(`Version ${version} of LightAccount doesn't support 1271`);
                case "v1.1.0":
                    return signWith1271WrapperV1(hashTypedData(params));
                case "v2.0.0":
                    const signature = await signWith1271WrapperV1(hashTypedData(params));
                    return concat([SignatureType.EOA, signature]);
                default:
                    throw new Error(`Unknown version ${version} of LightAccount`);
            }
        },
        getDummySignature: () => {
            const signature = "0xfffffffffffffffffffffffffffffff0000000000000000000000000000000007aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa1c";
            switch (version) {
                case "v1.0.1":
                case "v1.0.2":
                case "v1.1.0":
                    return signature;
                case "v2.0.0":
                    return concat([SignatureType.EOA, signature]);
                default:
                    throw new Error(`Unknown version ${type} of ${version}`);
            }
        },
        encodeUpgradeToAndCall,
    });
    return {
        ...account,
        source: type,
        getLightAccountVersion: () => version,
        getSigner: () => signer,
    };
}
//# sourceMappingURL=base.js.map