import { createBundlerClient, getAccountAddress, getEntryPoint, } from "@alchemy/aa-core";
import { concatHex, encodeFunctionData, hexToBigInt, } from "viem";
import { MultiOwnerLightAccountAbi } from "../abis/MultiOwnerLightAccountAbi.js";
import { MultiOwnerLightAccountFactoryAbi } from "../abis/MultiOwnerLightAccountFactoryAbi.js";
import { AccountVersionRegistry, defaultLightAccountVersion, } from "../utils.js";
import { createLightAccountBase, } from "./base.js";
export async function createMultiOwnerLightAccount({ transport, chain, signer, initCode, version = defaultLightAccountVersion("MultiOwnerLightAccount"), entryPoint = getEntryPoint(chain, {
    version: AccountVersionRegistry["MultiOwnerLightAccount"][version]
        .entryPointVersion,
}), accountAddress, factoryAddress = AccountVersionRegistry["MultiOwnerLightAccount"][version]
    .address[chain.id].factory, salt: salt_ = 0n, owners = [], }) {
    const client = createBundlerClient({
        transport,
        chain,
    });
    const getAccountInitCode = async () => {
        if (initCode)
            return initCode;
        const ownerAddress = await signer.getAddress();
        const owners_ = Array.from(new Set([...owners, ownerAddress]))
            .filter((x) => hexToBigInt(x) !== 0n)
            .sort((a, b) => {
            const bigintA = hexToBigInt(a);
            const bigintB = hexToBigInt(b);
            return bigintA < bigintB ? -1 : bigintA > bigintB ? 1 : 0;
        });
        return concatHex([
            factoryAddress,
            encodeFunctionData({
                abi: MultiOwnerLightAccountFactoryAbi,
                functionName: "createAccount",
                args: [owners_, salt_],
            }),
        ]);
    };
    const address = await getAccountAddress({
        client,
        entryPoint,
        accountAddress,
        getAccountInitCode,
    });
    const account = await createLightAccountBase({
        transport,
        chain,
        signer,
        abi: MultiOwnerLightAccountAbi,
        version: AccountVersionRegistry["MultiOwnerLightAccount"][version],
        entryPoint,
        accountAddress: address,
        getAccountInitCode,
    });
    return {
        ...account,
        encodeUpdateOwners: (ownersToAdd, ownersToRemove) => {
            return encodeFunctionData({
                abi: MultiOwnerLightAccountAbi,
                functionName: "updateOwners",
                args: [ownersToAdd, ownersToRemove],
            });
        },
        async getOwnerAddresses() {
            const callResult = await client.readContract({
                address,
                abi: MultiOwnerLightAccountAbi,
                functionName: "owners",
            });
            if (callResult == null) {
                throw new Error("could not get on-chain owners");
            }
            if (!callResult.includes(await signer.getAddress())) {
                throw new Error("on-chain owners does not include the current signer");
            }
            return callResult;
        },
    };
}
//# sourceMappingURL=multiOwner.js.map