import { takeBytes, } from "@alchemy/aa-core";
import { fromHex, hashMessage, recoverAddress } from "viem";
import { InvalidAggregatedSignatureError } from "../../../errors.js";
export const splitAggregatedSignature = async (args) => {
    const { aggregatedSignature, threshold, account, request } = args;
    if (aggregatedSignature.length < 192 + (65 * threshold - 1)) {
        throw new InvalidAggregatedSignatureError();
    }
    const pvg = takeBytes(aggregatedSignature, { count: 32 });
    const maxFeePerGas = takeBytes(aggregatedSignature, {
        count: 32,
        offset: 32,
    });
    const maxPriorityFeePerGas = takeBytes(aggregatedSignature, {
        count: 32,
        offset: 64,
    });
    const signaturesAndData = takeBytes(aggregatedSignature, {
        offset: 96,
    });
    const signatureHexes = (() => {
        const signatureStr = takeBytes(signaturesAndData, {
            count: 65 * threshold - 1,
        });
        const signatures = [];
        for (let i = 0; i < threshold - 1; i++) {
            signatures.push(takeBytes(signatureStr, { count: 65, offset: i * 65 }));
        }
        return signatures;
    })();
    const signatures = signatureHexes.map(async (signature) => {
        const v = BigInt(takeBytes(signature, { count: 1, offset: 64 }));
        const signerType = v === 0n ? "CONTRACT" : "EOA";
        if (signerType === "EOA") {
            const hash = hashMessage({
                raw: account.getEntryPoint().getUserOperationHash({
                    ...request,
                    preVerificationGas: pvg,
                    maxFeePerGas,
                    maxPriorityFeePerGas,
                }),
            });
            return {
                signer: await recoverAddress({ hash, signature }),
                signature,
                signerType,
                userOpSigType: "UPPERLIMIT",
            };
        }
        const signer = takeBytes(signature, { count: 20, offset: 12 });
        const offset = fromHex(takeBytes(signature, { count: 32, offset: 32 }), "number");
        const signatureLength = fromHex(takeBytes(signaturesAndData, { count: 32, offset }), "number");
        return {
            signer,
            signerType,
            userOpSigType: "UPPERLIMIT",
            signature: takeBytes(signaturesAndData, {
                count: signatureLength,
                offset: offset + 32,
            }),
        };
    });
    return {
        upperLimitPvg: pvg,
        upperLimitMaxFeePerGas: maxFeePerGas,
        upperLimitMaxPriorityFeePerGas: maxPriorityFeePerGas,
        signatures: await Promise.all(signatures),
    };
};
//# sourceMappingURL=splitAggregatedSignature.js.map