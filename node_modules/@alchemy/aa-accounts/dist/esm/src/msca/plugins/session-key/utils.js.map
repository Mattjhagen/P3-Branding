{"version":3,"file":"utils.js","sourceRoot":"","sources":["../../../../../../src/msca/plugins/session-key/utils.ts"],"names":[],"mappings":"AAIA,OAAO,EAAE,oBAAoB,EAAE,MAAM,kBAAkB,CAAC;AAExD,OAAO,EAAE,gBAAgB,EAAE,MAAM,aAAa,CAAC;AAI/C,MAAM,CAAC,MAAM,8BAA8B,GAYqB,KAAK,EACnE,MAAM,EACN,EAAE,IAAI,EAAE,aAAa,EAAE,OAAO,GAAG,MAAM,CAAC,OAAO,EAAE,EACjD,EAAE;IACF,IAAI,CAAC,OAAO;QAAE,MAAM,IAAI,oBAAoB,EAAE,CAAC;IAE/C,MAAM,QAAQ,GAAG,gBAAgB,CAAC,WAAW,CAAC,MAAM,EAAE,aAAa,CAAC,CAAC;IACrE,OAAO,CACL,MAAM,OAAO,CAAC,GAAG,CACf,IAAI,CAAC,GAAG,CAAC,KAAK,EAAE,GAAG,EAAE,EAAE;QACrB,OAAO;YACL,GAAG;YACH,MAAM,QAAQ,CAAC,IAAI,CAAC,eAAe,CAAC,CAAC,OAAO,CAAC,OAAO,EAAE,GAAG,CAAC,CAAC;SAC5D,CAAC;IACJ,CAAC,CAAC,CACH,CACF,CAAC,GAAG,CAAC,CAAC,CAAC,GAAG,EAAE,WAAW,CAAC,EAAE,EAAE,CAAC,CAAC;QAC7B,UAAU,EAAE,GAAG;QACf,WAAW;KACZ,CAAC,CAAC,CAAC;AACN,CAAC,CAAC","sourcesContent":["import type {\n  GetAccountParameter,\n  SmartContractAccount,\n} from \"@alchemy/aa-core\";\nimport { AccountNotFoundError } from \"@alchemy/aa-core\";\nimport type { Address, Chain, Client, Transport } from \"viem\";\nimport { SessionKeyPlugin } from \"./plugin.js\";\n\n// find predecessors for each keys and returned the struct `ISessionKeyPlugin.SessionKeyToRemove[]`\n// where SessionKeyToRemove = { sessionKey: Address, predecessor: Hex }\nexport const buildSessionKeysToRemoveStruct: <\n  TTransport extends Transport = Transport,\n  TChain extends Chain | undefined = Chain | undefined,\n  TAccount extends SmartContractAccount | undefined =\n    | SmartContractAccount\n    | undefined\n>(\n  client: Client<TTransport, TChain, TAccount>,\n  args: {\n    keys: ReadonlyArray<Address>;\n    pluginAddress?: Address;\n  } & GetAccountParameter<TAccount>\n) => Promise<{ sessionKey: Address; predecessor: Address }[]> = async (\n  client,\n  { keys, pluginAddress, account = client.account }\n) => {\n  if (!account) throw new AccountNotFoundError();\n\n  const contract = SessionKeyPlugin.getContract(client, pluginAddress);\n  return (\n    await Promise.all(\n      keys.map(async (key) => {\n        return [\n          key,\n          await contract.read.findPredecessor([account.address, key]),\n        ];\n      })\n    )\n  ).map(([key, predecessor]) => ({\n    sessionKey: key,\n    predecessor,\n  }));\n};\n"]}