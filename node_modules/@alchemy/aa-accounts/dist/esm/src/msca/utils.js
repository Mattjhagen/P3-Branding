import { AccountNotFoundError, ChainNotFoundError, arbitrum, arbitrumSepolia, base, baseSepolia, mainnet, optimism, optimismSepolia, polygon, polygonAmoy, sepolia, } from "@alchemy/aa-core";
import { custom, encodeAbiParameters, encodeFunctionData, encodeFunctionResult, keccak256, parseAbiParameters, } from "viem";
import { IPluginAbi } from "./abis/IPlugin.js";
import { MultiOwnerModularAccountFactoryAbi } from "./abis/MultiOwnerModularAccountFactory.js";
import { UpgradeableModularAccountAbi } from "./abis/UpgradeableModularAccount.js";
import { createMultiOwnerModularAccount, } from "./account/multiOwnerAccount.js";
import { MultiOwnerPlugin } from "./plugins/multi-owner/plugin.js";
export const getDefaultMultisigModularAccountFactoryAddress = (chain) => {
    switch (chain.id) {
        case sepolia.id:
        case baseSepolia.id:
        case polygon.id:
        case mainnet.id:
        case polygonAmoy.id:
        case optimism.id:
        case optimismSepolia.id:
        case arbitrum.id:
        case arbitrumSepolia.id:
        case base.id:
        default:
            return "0x000000000000204327E6669f00901a57CE15aE15";
    }
};
export const getDefaultMultiOwnerModularAccountFactoryAddress = (chain) => {
    switch (chain.id) {
        default:
            return "0x000000e92D78D90000007F0082006FDA09BD5f11";
    }
};
export async function getMSCAUpgradeToData(client, args) {
    const { account: account_ = client.account, multiOwnerPluginAddress } = args;
    if (!account_) {
        throw new AccountNotFoundError();
    }
    const account = account_;
    const chain = client.chain;
    if (!chain) {
        throw new ChainNotFoundError();
    }
    const initData = await getMAInitializationData({
        client,
        multiOwnerPluginAddress,
        signerAddress: await account.getSigner().getAddress(),
    });
    return {
        ...initData,
        createMAAccount: async () => createMultiOwnerModularAccount({
            transport: custom(client.transport),
            chain: chain,
            signer: account.getSigner(),
            accountAddress: account.address,
        }),
    };
}
export async function getMAInitializationData({ client, multiOwnerPluginAddress, signerAddress, }) {
    if (!client.chain) {
        throw new ChainNotFoundError();
    }
    const factoryAddress = getDefaultMultiOwnerModularAccountFactoryAddress(client.chain);
    const implAddress = await client.readContract({
        abi: MultiOwnerModularAccountFactoryAbi,
        address: factoryAddress,
        functionName: "IMPL",
    });
    const multiOwnerAddress = multiOwnerPluginAddress ?? MultiOwnerPlugin.meta.addresses[client.chain.id];
    if (!multiOwnerAddress) {
        throw new Error("could not get multi owner plugin address");
    }
    const moPluginManifest = await client.readContract({
        abi: IPluginAbi,
        address: multiOwnerAddress,
        functionName: "pluginManifest",
    });
    const hashedMultiOwnerPluginManifest = keccak256(encodeFunctionResult({
        abi: IPluginAbi,
        functionName: "pluginManifest",
        result: moPluginManifest,
    }));
    const encodedOwner = encodeAbiParameters(parseAbiParameters("address[]"), Array.isArray(signerAddress) ? [signerAddress] : [[signerAddress]]);
    const encodedPluginInitData = encodeAbiParameters(parseAbiParameters("bytes32[], bytes[]"), [[hashedMultiOwnerPluginManifest], [encodedOwner]]);
    const encodedMSCAInitializeData = encodeFunctionData({
        abi: UpgradeableModularAccountAbi,
        functionName: "initialize",
        args: [[multiOwnerAddress], encodedPluginInitData],
    });
    return {
        implAddress,
        initializationData: encodedMSCAInitializeData,
    };
}
//# sourceMappingURL=utils.js.map