import { createBundlerClient, getAccountAddress, getEntryPoint, toSmartContractAccount, } from "@alchemy/aa-core";
import { concatHex, encodeFunctionData, hexToBigInt, } from "viem";
import { MultisigModularAccountFactoryAbi } from "../abis/MultisigModularAccountFactory.js";
import { multisigSignMethods } from "../plugins/multisig/signer.js";
import { getDefaultMultisigModularAccountFactoryAddress } from "../utils.js";
import { standardExecutor } from "./standardExecutor.js";
export const MULTISIG_ACCOUNT_SOURCE = "MultisigModularAccount";
export async function createMultisigModularAccount({ transport, chain, signer, accountAddress, initCode, entryPoint = getEntryPoint(chain, { version: "0.6.0" }), factoryAddress = getDefaultMultisigModularAccountFactoryAddress(chain), owners = [], salt = 0n, threshold, }) {
    const client = createBundlerClient({
        transport,
        chain,
    });
    const getAccountInitCode = async () => {
        if (initCode) {
            return initCode;
        }
        const sigAddress = await signer.getAddress();
        const sigs_ = Array.from(new Set([...owners, sigAddress]))
            .filter((x) => hexToBigInt(x) !== 0n)
            .sort((a, b) => {
            const bigintA = hexToBigInt(a);
            const bigintB = hexToBigInt(b);
            return bigintA < bigintB ? -1 : bigintA > bigintB ? 1 : 0;
        });
        return concatHex([
            factoryAddress,
            encodeFunctionData({
                abi: MultisigModularAccountFactoryAbi,
                functionName: "createAccount",
                args: [salt, sigs_, threshold],
            }),
        ]);
    };
    accountAddress = await getAccountAddress({
        client,
        entryPoint,
        accountAddress: accountAddress,
        getAccountInitCode,
    });
    const baseAccount = await toSmartContractAccount({
        transport,
        chain,
        entryPoint,
        accountAddress,
        source: MULTISIG_ACCOUNT_SOURCE,
        getAccountInitCode,
        ...standardExecutor,
        ...multisigSignMethods({
            client,
            accountAddress,
            threshold,
            signer: () => signer,
        }),
    });
    return {
        ...baseAccount,
        getLocalThreshold: () => threshold,
        publicKey: await signer.getAddress(),
        getSigner: () => signer,
    };
}
export const isMultisigModularAccount = (acct) => {
    return acct.source === MULTISIG_ACCOUNT_SOURCE;
};
//# sourceMappingURL=multisigAccount.js.map