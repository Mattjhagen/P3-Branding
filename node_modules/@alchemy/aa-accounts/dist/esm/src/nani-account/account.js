import { BaseSmartContractAccount, createBundlerClient, getEntryPoint, toSmartContractAccount, } from "@alchemy/aa-core";
import { concatHex, decodeFunctionResult, encodeFunctionData, isHex, numberToHex, } from "viem";
import { NaniAccountAbi } from "./abis/NaniAccountAbi.js";
import { NaniAccountFactoryAbi } from "./abis/NaniAccountFactoryAbi.js";
class NaniAccount_ extends BaseSmartContractAccount {
    constructor(params) {
        const client = createBundlerClient({
            transport: params.transport,
            chain: params.chain,
        });
        super({ ...params, rpcClient: client });
        Object.defineProperty(this, "signer", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "index", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "salt", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.index = params.index ?? 0n;
        this.signer = params.signer;
        this.salt = params.salt;
    }
    async signTypedData(params) {
        return this.signer.signTypedData(params);
    }
    async getOwnerAddress() {
        const callResult = await this.rpcProvider.call({
            to: await this.getAddress(),
            data: encodeFunctionData({
                abi: NaniAccountAbi,
                functionName: "owner",
            }),
        });
        if (callResult.data == null) {
            throw new Error("could not get on-chain owner");
        }
        const decodedCallResult = decodeFunctionResult({
            abi: NaniAccountAbi,
            functionName: "owner",
            data: callResult.data,
        });
        if (decodedCallResult !== (await this.signer.getAddress())) {
            throw new Error("current account signer does not match the on-chain owner");
        }
        return decodedCallResult;
    }
    async getAddress() {
        const callResult = await this.rpcProvider.call({
            to: this.factoryAddress,
            data: encodeFunctionData({
                abi: NaniAccountFactoryAbi,
                functionName: "getAddress",
                args: [await this.getSalt()],
            }),
        });
        if (callResult.data == null) {
            throw new Error("could not get deterministic address");
        }
        const decodedCallResult = decodeFunctionResult({
            abi: NaniAccountFactoryAbi,
            functionName: "getAddress",
            data: callResult.data,
        });
        return decodedCallResult;
    }
    getDummySignature() {
        return "0xfffffffffffffffffffffffffffffff0000000000000000000000000000000007aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa1c";
    }
    signMessage(msg) {
        return this.signer.signMessage(typeof msg === "string" && !isHex(msg) ? msg : { raw: msg });
    }
    async encodeExecute(target, value, data) {
        return encodeFunctionData({
            abi: NaniAccountAbi,
            functionName: "execute",
            args: [target, value, data],
        });
    }
    async encodeBatchExecute(calls) {
        return encodeFunctionData({
            abi: NaniAccountAbi,
            functionName: "executeBatch",
            args: [
                calls.map((call) => ({
                    ...call,
                    value: call.value ?? 0n,
                })),
            ],
        });
    }
    static encodeExecuteDelegate(delegate, data) {
        return encodeFunctionData({
            abi: NaniAccountAbi,
            functionName: "delegateExecute",
            args: [delegate, data],
        });
    }
    static encodeTransferOwnership(newOwner) {
        return encodeFunctionData({
            abi: NaniAccountAbi,
            functionName: "transferOwnership",
            args: [newOwner],
        });
    }
    async getAccountInitCode() {
        const result = concatHex([
            this.factoryAddress,
            await this.getFactoryInitCode(),
        ]);
        return result;
    }
    async getSalt() {
        if (this.salt) {
            if (this.salt.slice(0, 42) !== (await this.signer.getAddress())) {
                throw new Error("Salt does not match the current signer address");
            }
            else {
                return this.salt;
            }
        }
        return concatHex([
            await this.signer.getAddress(),
            numberToHex(this.index, { size: 12 }),
        ]);
    }
    async getFactoryInitCode() {
        try {
            return encodeFunctionData({
                abi: NaniAccountFactoryAbi,
                functionName: "createAccount",
                args: [await this.signer.getAddress(), await this.getSalt()],
            });
        }
        catch (err) {
            throw new Error("Factory Code generation failed");
        }
    }
}
export const createNaniAccount = async (params) => {
    if (!params.signer)
        throw new Error("Owner must be provided.");
    const naniAccount = new NaniAccount_(params);
    const base = await toSmartContractAccount({
        source: "NaniAccount",
        transport: params.transport,
        chain: params.chain,
        accountAddress: params.accountAddress,
        entryPoint: getEntryPoint(params.chain, {
            addressOverride: naniAccount.getEntryPointAddress(),
        }),
        encodeBatchExecute: naniAccount.encodeBatchExecute.bind(naniAccount),
        encodeExecute: (tx) => naniAccount.encodeExecute(tx.target, tx.value ?? 0n, tx.data),
        getAccountInitCode: async () => {
            if (params.initCode)
                return params.initCode;
            return naniAccount.getAccountInitCode();
        },
        getDummySignature: naniAccount.getDummySignature.bind(naniAccount),
        signMessage: ({ message }) => naniAccount.signMessage(typeof message === "string" ? message : message.raw),
        signTypedData: (params) => naniAccount.signTypedData(params),
    });
    return {
        ...base,
        getSigner: () => naniAccount.getSigner(),
        encodeExecuteDelegate: NaniAccount_.encodeExecuteDelegate,
        encodeTransferOwnership: NaniAccount_.encodeTransferOwnership,
    };
};
//# sourceMappingURL=account.js.map