{"version":3,"file":"account.js","sourceRoot":"","sources":["../../../../src/nani-account/account.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  BaseSmartContractAccount,\n  createBundlerClient,\n  getEntryPoint,\n  toSmartContractAccount,\n  type BaseSmartAccountParams,\n  type BatchUserOperationCallData,\n  type DefaultEntryPointVersion,\n  type SignTypedDataParams,\n  type SmartAccountSigner,\n  type SmartContractAccountWithSigner,\n  type ToSmartContractAccountParams,\n  type UserOperationCallData,\n} from \"@alchemy/aa-core\";\nimport {\n  concatHex,\n  decodeFunctionResult,\n  encodeFunctionData,\n  isHex,\n  numberToHex,\n  type Address,\n  type Chain,\n  type FallbackTransport,\n  type Hash,\n  type Hex,\n  type Transport,\n} from \"viem\";\nimport { NaniAccountAbi } from \"./abis/NaniAccountAbi.js\";\nimport { NaniAccountFactoryAbi } from \"./abis/NaniAccountFactoryAbi.js\";\n\nexport type NaniSmartAccountParams<\n  TTransport extends Transport | FallbackTransport = Transport\n> = Omit<BaseSmartAccountParams<TTransport>, \"rpcClient\"> & {\n  signer: SmartAccountSigner;\n  index?: bigint;\n  salt?: Hex;\n  transport: TTransport;\n  chain: Chain;\n};\n\nexport type NaniAccount = SmartContractAccountWithSigner<\n  \"NaniAccount\",\n  SmartAccountSigner,\n  \"0.6.0\"\n> & {\n  encodeExecuteDelegate: (delegate: Address, data: Hex) => Hex;\n  encodeTransferOwnership: (newOwner: Address) => Hex;\n};\n\nclass NaniAccount_<\n  TTransport extends Transport | FallbackTransport = Transport\n> extends BaseSmartContractAccount<TTransport> {\n  protected signer: SmartAccountSigner;\n  private readonly index: bigint;\n  protected salt?: Hex;\n\n  constructor(params: NaniSmartAccountParams<TTransport>) {\n    // This is a hack for now, we should kill the SimpleSmart Account when we kill Base Account\n    const client = createBundlerClient({\n      transport: params.transport as TTransport,\n      chain: params.chain,\n    });\n    super({ ...params, rpcClient: client });\n\n    this.index = params.index ?? 0n;\n    this.signer = params.signer;\n    this.salt = params.salt;\n  }\n\n  override async signTypedData(params: SignTypedDataParams): Promise<Hash> {\n    return this.signer.signTypedData(params);\n  }\n\n  /**\n   * Returns the on-chain owner address of the account.\n   *\n   * @returns the on-chain owner of the account\n   */\n  async getOwnerAddress(): Promise<Address> {\n    const callResult = await this.rpcProvider.call({\n      to: await this.getAddress(),\n      data: encodeFunctionData({\n        abi: NaniAccountAbi,\n        functionName: \"owner\",\n      }),\n    });\n\n    if (callResult.data == null) {\n      throw new Error(\"could not get on-chain owner\");\n    }\n\n    const decodedCallResult = decodeFunctionResult({\n      abi: NaniAccountAbi,\n      functionName: \"owner\",\n      data: callResult.data,\n    });\n\n    if (decodedCallResult !== (await this.signer.getAddress())) {\n      throw new Error(\n        \"current account signer does not match the on-chain owner\"\n      );\n    }\n\n    return decodedCallResult;\n  }\n\n  async getAddress(): Promise<Address> {\n    const callResult = await this.rpcProvider.call({\n      to: this.factoryAddress,\n      data: encodeFunctionData({\n        abi: NaniAccountFactoryAbi,\n        functionName: \"getAddress\",\n        args: [await this.getSalt()],\n      }),\n    });\n\n    if (callResult.data == null) {\n      throw new Error(\"could not get deterministic address\");\n    }\n\n    const decodedCallResult = decodeFunctionResult({\n      abi: NaniAccountFactoryAbi,\n      functionName: \"getAddress\",\n      data: callResult.data,\n    });\n\n    return decodedCallResult;\n  }\n\n  getDummySignature(): Hex {\n    return \"0xfffffffffffffffffffffffffffffff0000000000000000000000000000000007aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa1c\";\n  }\n\n  signMessage(msg: Uint8Array | string): Promise<Hex> {\n    return this.signer.signMessage(\n      typeof msg === \"string\" && !isHex(msg) ? msg : { raw: msg }\n    );\n  }\n\n  async encodeExecute(target: Hex, value: bigint, data: Hex): Promise<Hex> {\n    return encodeFunctionData({\n      abi: NaniAccountAbi,\n      functionName: \"execute\",\n      args: [target, value, data],\n    });\n  }\n\n  override async encodeBatchExecute(\n    calls: BatchUserOperationCallData\n  ): Promise<Hex> {\n    return encodeFunctionData({\n      abi: NaniAccountAbi,\n      functionName: \"executeBatch\",\n      args: [\n        calls.map((call: Exclude<UserOperationCallData, Hex>) => ({\n          ...call,\n          value: call.value ?? 0n,\n        })),\n      ],\n    });\n  }\n\n  /**\n   * Encodes the delegateExecute function call using Nani Account ABI.\n   *\n   * @param delegate - the delegate to execute the function call\n   * @param data - the data to be passed to the function call\n   * @returns the encoded function call\n   */\n  static encodeExecuteDelegate(delegate: Address, data: Hex): Hex {\n    return encodeFunctionData({\n      abi: NaniAccountAbi,\n      functionName: \"delegateExecute\",\n      args: [delegate, data],\n    });\n  }\n\n  /**\n   * Encodes the transferOwnership function call using Nani Account ABI.\n   *\n   * @param newOwner - the new owner of the account\n   * @returns the encoded function call\n   */\n  static encodeTransferOwnership(newOwner: Address): Hex {\n    return encodeFunctionData({\n      abi: NaniAccountAbi,\n      functionName: \"transferOwnership\",\n      args: [newOwner],\n    });\n  }\n\n  override async getAccountInitCode(): Promise<`0x${string}`> {\n    const result = concatHex([\n      this.factoryAddress,\n      await this.getFactoryInitCode(),\n    ]);\n\n    return result;\n  }\n\n  protected async getSalt(): Promise<Hex> {\n    if (this.salt) {\n      if (this.salt.slice(0, 42) !== (await this.signer.getAddress())) {\n        throw new Error(\"Salt does not match the current signer address\");\n      } else {\n        return this.salt;\n      }\n    }\n\n    return concatHex([\n      await this.signer.getAddress(),\n      numberToHex(this.index, { size: 12 }),\n    ]);\n  }\n\n  protected async getFactoryInitCode(): Promise<Hex> {\n    try {\n      return encodeFunctionData({\n        abi: NaniAccountFactoryAbi,\n        functionName: \"createAccount\",\n        args: [await this.signer.getAddress(), await this.getSalt()],\n      });\n    } catch (err: any) {\n      throw new Error(\"Factory Code generation failed\");\n    }\n  }\n}\n\nexport const createNaniAccount = async <TTransport extends Transport>(\n  params: Omit<NaniSmartAccountParams<TTransport>, \"rpcClient\" | \"chain\"> &\n    Pick<\n      ToSmartContractAccountParams<DefaultEntryPointVersion>,\n      \"chain\" | \"transport\"\n    >\n): Promise<NaniAccount> => {\n  if (!params.signer) throw new Error(\"Owner must be provided.\");\n\n  const naniAccount = new NaniAccount_(params);\n\n  const base = await toSmartContractAccount({\n    source: \"NaniAccount\",\n    transport: params.transport,\n    chain: params.chain,\n    accountAddress: params.accountAddress as Address | undefined,\n    entryPoint: getEntryPoint(params.chain, {\n      addressOverride: naniAccount.getEntryPointAddress(),\n    }),\n    encodeBatchExecute: naniAccount.encodeBatchExecute.bind(naniAccount),\n    encodeExecute: (tx) =>\n      naniAccount.encodeExecute(tx.target, tx.value ?? 0n, tx.data),\n    getAccountInitCode: async () => {\n      if (params.initCode) return params.initCode as Hex;\n      return naniAccount.getAccountInitCode();\n    },\n    getDummySignature: naniAccount.getDummySignature.bind(naniAccount),\n    signMessage: ({ message }) =>\n      naniAccount.signMessage(\n        typeof message === \"string\" ? message : message.raw\n      ),\n    // @ts-expect-error these types still represent the same thing, but they are just a little off in there definitions\n    signTypedData: (params) => naniAccount.signTypedData(params),\n  });\n\n  return {\n    ...base,\n    getSigner: () => naniAccount.getSigner() as SmartAccountSigner,\n    encodeExecuteDelegate: NaniAccount_.encodeExecuteDelegate,\n    encodeTransferOwnership: NaniAccount_.encodeTransferOwnership,\n  };\n};\n"]}