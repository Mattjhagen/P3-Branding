{"version":3,"file":"signer.js","sourceRoot":"","sources":["../../../src/lit-protocol/signer.ts"],"names":[],"mappings":"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","sourcesContent":["import { LitAbility, LitPKPResource } from \"@lit-protocol/auth-helpers\";\nimport { ALL_LIT_CHAINS } from \"@lit-protocol/constants\";\nimport { generateSessionKeyPair } from \"@lit-protocol/crypto\";\nimport { LitNodeClient } from \"@lit-protocol/lit-node-client\";\nimport { PKPEthersWallet } from \"@lit-protocol/pkp-ethers\";\nimport {\n  type AuthCallbackParams,\n  type AuthSig,\n  type LITEVMChain,\n  type SessionSigsMap,\n} from \"@lit-protocol/types\";\nimport {\n  type Address,\n  type Hex,\n  type SignableMessage,\n  type TypedData,\n  type TypedDataDefinition,\n  type TypedDataDomain,\n} from \"viem\";\nimport { signerTypePrefix } from \"../constants.js\";\nimport {\n  type LitAuthMethod,\n  type LitAuthenticateProps,\n  type LitConfig,\n  type LitSessionSigsMap,\n  type LitSmartAccountAuthenticator,\n  type LitUserMetadata,\n} from \"./types.js\";\n\nconst SIGNER_TYPE: string = `${signerTypePrefix}lit`;\n\n/**\n * Implementation of `SmartAccountAuthenticator` for lit protocol\n * This class requies:\n * `@lit-protocol/lit-node-client@cayenne`\n * `@lit-protocol/pkp-ethers@cayenne`\n * `@lit-protocol/crypto@cayenne`\n * `@lit-protocol/auth-helpers@cayenne`\n * `@lit-protocol/types@cayenne`\n */\nexport class LitSigner<C extends LitAuthMethod | LitSessionSigsMap>\n  implements LitSmartAccountAuthenticator<C>\n{\n  inner: LitNodeClient;\n  public signer: PKPEthersWallet | undefined;\n  private _pkpPublicKey: string;\n  private _rpcUrl: string;\n  private _authContext: C | undefined;\n  public session: SessionSigsMap | undefined;\n\n  constructor(params: LitConfig) {\n    this._pkpPublicKey = params.pkpPublicKey;\n    this.inner =\n      params.inner ??\n      new LitNodeClient({\n        litNetwork: params.network ?? \"cayenne\",\n        debug: params.debug ?? false,\n      });\n    this._rpcUrl = params.rpcUrl;\n  }\n  signerType: string = SIGNER_TYPE;\n\n  /**\n   * if generic type is `LitAuthMethod`, authenticates the supplied authentication material.\n   * if type `SessionSigsMap`, this implementation will respect the existing auth and use the session material.\n   *\n   * @param props {LitAuthenticateProps} Authentication params, only `context` is required\n   * @returns Authenticated session material\n   * @throws if authentication operations fail this error is thrown\n   */\n  authenticate = async (\n    props: LitAuthenticateProps<C>\n  ): Promise<LitUserMetadata> => {\n    if (!this.session) {\n      // runs authentication logic\n      await this._doAuthentication(props);\n    }\n\n    // check on internal state for authentication status\n    if (!this.session) {\n      throw new Error(\"Not Authenticated\");\n    }\n\n    return this.session;\n  };\n\n  getAuthDetails = async (): Promise<LitUserMetadata> => {\n    this._checkInternals();\n    return this._authContext as LitSessionSigsMap;\n  };\n\n  getAddress = async () => {\n    this._checkInternals();\n    return this.signer?.getAddress() as Promise<Address>;\n  };\n\n  signMessage = async (msg: SignableMessage) => {\n    this._checkInternals();\n\n    return this.signer?.signMessage(\n      typeof msg === \"string\" ? msg : msg.raw\n    ) as Promise<Hex>;\n  };\n\n  signTypedData = async <\n    const TTypedData extends TypedData | { [key: string]: unknown },\n    TPrimaryType extends string = string\n  >(\n    params: TypedDataDefinition<TTypedData, TPrimaryType>\n  ) => {\n    this._checkInternals();\n\n    return this.signer?._signTypedData(\n      params.domain as TypedDataDomain,\n      params.types as any,\n      params.message as Record<string, any>\n    ) as Promise<Hex>;\n  };\n\n  private _checkInternals() {\n    if (!this._authContext) {\n      throw new Error(\"Not Authenticated\");\n    }\n\n    if (!this.signer) {\n      throw new Error(\"Signer is not initialized, did you call authenticate?\");\n    }\n  }\n\n  /**\n   * Runs the Lit Protocol authentication operations for a given piece of authentication material\n   *\n   * AuthMethod -> authenticates the auth material and signs a session.\n   *\n   * SessionSigsMap -> uses the session to create a signer instance.\n   *\n   * For more information on Lit Authentication see below:\n   *\n   * https://developer.litprotocol.com/v3/sdk/authentication/overview\n   *\n   * @param props {LitAuthenticationProps<C>} properties for configuring authentication operations\n   */\n  private async _doAuthentication(props: LitAuthenticateProps<C>) {\n    /**\n     * Check if the object is structured as an auth method\n     * if so, we sign the session key with the auth method\n     * as the auth material. Otherwise, if a session signature\n     * is provided, then we skip this step.\n     */\n    if (Object.keys(props.context).indexOf(\"accessToken\") > 0) {\n      const resourceAbilities = [\n        {\n          resource: new LitPKPResource(\"*\"),\n          ability: LitAbility.PKPSigning,\n        },\n      ];\n      const sessionKeypair = props.sessionKeypair || generateSessionKeyPair();\n      const chain = props.chain || \"ethereum\";\n      const chainInfo = ALL_LIT_CHAINS[chain];\n\n      const chainId = (chainInfo as LITEVMChain).chainId ?? 1;\n      let authNeededCallback: any;\n      if (props.context?.authMethodType === 1) {\n        authNeededCallback = async (params: AuthCallbackParams) => {\n          const response = await this.inner.signSessionKey({\n            statement: params.statement,\n            authMethods: [props.context as LitAuthMethod],\n            authSig: JSON.parse(props.context.accessToken as string) as AuthSig,\n            pkpPublicKey: `0x${this._pkpPublicKey}`,\n            expiration: params.expiration,\n            resources: params.resources,\n            chainId: chainId,\n          });\n          return response.authSig;\n        };\n      } else {\n        authNeededCallback = async (params: AuthCallbackParams) => {\n          const response = await this.inner.signSessionKey({\n            statement: params.statement,\n            sessionKey: sessionKeypair,\n            authMethods: [props.context as LitAuthMethod],\n            pkpPublicKey: `0x${this._pkpPublicKey}`,\n            expiration: params.expiration,\n            resources: params.resources,\n            chainId: chainId,\n          });\n          return response.authSig;\n        };\n      }\n\n      if (!this.inner.ready) {\n        await this.inner.connect();\n      }\n\n      const sessionSigs = await this.inner\n        .getSessionSigs({\n          chain,\n          expiration:\n            props.expiration ??\n            // set default exp to 1 week if not provided\n            new Date(Date.now() + 60 * 60 * 24 * 7).toISOString(),\n          resourceAbilityRequests: resourceAbilities,\n          authNeededCallback,\n        })\n        .catch((err) => {\n          throw err;\n        });\n\n      this._authContext = props.context;\n      this.session = sessionSigs;\n\n      this.signer = new PKPEthersWallet({\n        pkpPubKey: this._pkpPublicKey,\n        rpc: this._rpcUrl,\n        controllerSessionSigs: sessionSigs as LitSessionSigsMap,\n      });\n\n      await this.signer.init();\n    } else {\n      this._authContext = props.context;\n      this.session = props.context as SessionSigsMap;\n\n      this.signer = new PKPEthersWallet({\n        pkpPubKey: this._pkpPublicKey,\n        rpc: this._rpcUrl,\n        controllerSessionSigs: this._authContext as LitSessionSigsMap,\n      });\n\n      await this.signer.init();\n    }\n  }\n}\n"]}