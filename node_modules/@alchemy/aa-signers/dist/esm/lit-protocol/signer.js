import { LitAbility, LitPKPResource } from "@lit-protocol/auth-helpers";
import { ALL_LIT_CHAINS } from "@lit-protocol/constants";
import { generateSessionKeyPair } from "@lit-protocol/crypto";
import { LitNodeClient } from "@lit-protocol/lit-node-client";
import { PKPEthersWallet } from "@lit-protocol/pkp-ethers";
import {} from "@lit-protocol/types";
import {} from "viem";
import { signerTypePrefix } from "../constants.js";
import {} from "./types.js";
const SIGNER_TYPE = `${signerTypePrefix}lit`;
export class LitSigner {
    constructor(params) {
        Object.defineProperty(this, "inner", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "signer", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_pkpPublicKey", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_rpcUrl", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_authContext", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "session", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "signerType", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: SIGNER_TYPE
        });
        Object.defineProperty(this, "authenticate", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: async (props) => {
                if (!this.session) {
                    await this._doAuthentication(props);
                }
                if (!this.session) {
                    throw new Error("Not Authenticated");
                }
                return this.session;
            }
        });
        Object.defineProperty(this, "getAuthDetails", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: async () => {
                this._checkInternals();
                return this._authContext;
            }
        });
        Object.defineProperty(this, "getAddress", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: async () => {
                this._checkInternals();
                return this.signer?.getAddress();
            }
        });
        Object.defineProperty(this, "signMessage", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: async (msg) => {
                this._checkInternals();
                return this.signer?.signMessage(typeof msg === "string" ? msg : msg.raw);
            }
        });
        Object.defineProperty(this, "signTypedData", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: async (params) => {
                this._checkInternals();
                return this.signer?._signTypedData(params.domain, params.types, params.message);
            }
        });
        this._pkpPublicKey = params.pkpPublicKey;
        this.inner =
            params.inner ??
                new LitNodeClient({
                    litNetwork: params.network ?? "cayenne",
                    debug: params.debug ?? false,
                });
        this._rpcUrl = params.rpcUrl;
    }
    _checkInternals() {
        if (!this._authContext) {
            throw new Error("Not Authenticated");
        }
        if (!this.signer) {
            throw new Error("Signer is not initialized, did you call authenticate?");
        }
    }
    async _doAuthentication(props) {
        if (Object.keys(props.context).indexOf("accessToken") > 0) {
            const resourceAbilities = [
                {
                    resource: new LitPKPResource("*"),
                    ability: LitAbility.PKPSigning,
                },
            ];
            const sessionKeypair = props.sessionKeypair || generateSessionKeyPair();
            const chain = props.chain || "ethereum";
            const chainInfo = ALL_LIT_CHAINS[chain];
            const chainId = chainInfo.chainId ?? 1;
            let authNeededCallback;
            if (props.context?.authMethodType === 1) {
                authNeededCallback = async (params) => {
                    const response = await this.inner.signSessionKey({
                        statement: params.statement,
                        authMethods: [props.context],
                        authSig: JSON.parse(props.context.accessToken),
                        pkpPublicKey: `0x${this._pkpPublicKey}`,
                        expiration: params.expiration,
                        resources: params.resources,
                        chainId: chainId,
                    });
                    return response.authSig;
                };
            }
            else {
                authNeededCallback = async (params) => {
                    const response = await this.inner.signSessionKey({
                        statement: params.statement,
                        sessionKey: sessionKeypair,
                        authMethods: [props.context],
                        pkpPublicKey: `0x${this._pkpPublicKey}`,
                        expiration: params.expiration,
                        resources: params.resources,
                        chainId: chainId,
                    });
                    return response.authSig;
                };
            }
            if (!this.inner.ready) {
                await this.inner.connect();
            }
            const sessionSigs = await this.inner
                .getSessionSigs({
                chain,
                expiration: props.expiration ??
                    new Date(Date.now() + 60 * 60 * 24 * 7).toISOString(),
                resourceAbilityRequests: resourceAbilities,
                authNeededCallback,
            })
                .catch((err) => {
                throw err;
            });
            this._authContext = props.context;
            this.session = sessionSigs;
            this.signer = new PKPEthersWallet({
                pkpPubKey: this._pkpPublicKey,
                rpc: this._rpcUrl,
                controllerSessionSigs: sessionSigs,
            });
            await this.signer.init();
        }
        else {
            this._authContext = props.context;
            this.session = props.context;
            this.signer = new PKPEthersWallet({
                pkpPubKey: this._pkpPublicKey,
                rpc: this._rpcUrl,
                controllerSessionSigs: this._authContext,
            });
            await this.signer.init();
        }
    }
}
//# sourceMappingURL=signer.js.map