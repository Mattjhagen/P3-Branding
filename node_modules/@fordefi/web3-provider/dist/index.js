"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  EIP1193EventMap: () => import_viem5.EIP1193EventMap,
  FordefiWeb3Provider: () => FordefiWeb3Provider
});
module.exports = __toCommonJS(src_exports);
var import_viem5 = require("viem");

// src/provider/provider.ts
var import_events = require("events");
var import_viem4 = require("viem");

// src/openapi/runtime.ts
var BASE_PATH = "http://localhost:8000".replace(/\/+$/, "");
var Configuration = class {
  constructor(configuration = {}) {
    this.configuration = configuration;
  }
  set config(configuration) {
    this.configuration = configuration;
  }
  get basePath() {
    return this.configuration.basePath != null ? this.configuration.basePath : BASE_PATH;
  }
  get fetchApi() {
    return this.configuration.fetchApi;
  }
  get middleware() {
    return this.configuration.middleware || [];
  }
  get queryParamsStringify() {
    return this.configuration.queryParamsStringify || querystring;
  }
  get username() {
    return this.configuration.username;
  }
  get password() {
    return this.configuration.password;
  }
  get apiKey() {
    const apiKey = this.configuration.apiKey;
    if (apiKey) {
      return typeof apiKey === "function" ? apiKey : () => apiKey;
    }
    return void 0;
  }
  get accessToken() {
    const accessToken = this.configuration.accessToken;
    if (accessToken) {
      return typeof accessToken === "function" ? accessToken : async () => accessToken;
    }
    return void 0;
  }
  get headers() {
    return this.configuration.headers;
  }
  get credentials() {
    return this.configuration.credentials;
  }
};
var DefaultConfig = new Configuration();
var _BaseAPI = class _BaseAPI {
  constructor(configuration = DefaultConfig) {
    this.configuration = configuration;
    this.fetchApi = async (url, init) => {
      let fetchParams = { url, init };
      for (const middleware of this.middleware) {
        if (middleware.pre) {
          fetchParams = await middleware.pre({
            fetch: this.fetchApi,
            ...fetchParams
          }) || fetchParams;
        }
      }
      let response = void 0;
      try {
        response = await (this.configuration.fetchApi || fetch)(fetchParams.url, fetchParams.init);
      } catch (e) {
        for (const middleware of this.middleware) {
          if (middleware.onError) {
            response = await middleware.onError({
              fetch: this.fetchApi,
              url: fetchParams.url,
              init: fetchParams.init,
              error: e,
              response: response ? response.clone() : void 0
            }) || response;
          }
        }
        if (response === void 0) {
          if (e instanceof Error) {
            throw new FetchError(e, "The request failed and the interceptors did not return an alternative response");
          } else {
            throw e;
          }
        }
      }
      for (const middleware of this.middleware) {
        if (middleware.post) {
          response = await middleware.post({
            fetch: this.fetchApi,
            url: fetchParams.url,
            init: fetchParams.init,
            response: response.clone()
          }) || response;
        }
      }
      return response;
    };
    this.middleware = configuration.middleware;
  }
  withMiddleware(...middlewares) {
    const next = this.clone();
    next.middleware = next.middleware.concat(...middlewares);
    return next;
  }
  withPreMiddleware(...preMiddlewares) {
    const middlewares = preMiddlewares.map((pre) => ({ pre }));
    return this.withMiddleware(...middlewares);
  }
  withPostMiddleware(...postMiddlewares) {
    const middlewares = postMiddlewares.map((post) => ({ post }));
    return this.withMiddleware(...middlewares);
  }
  /**
   * Check if the given MIME is a JSON MIME.
   * JSON MIME examples:
   *   application/json
   *   application/json; charset=UTF8
   *   APPLICATION/JSON
   *   application/vnd.company+json
   * @param mime - MIME (Multipurpose Internet Mail Extensions)
   * @return True if the given MIME is JSON, false otherwise.
   */
  isJsonMime(mime) {
    if (!mime) {
      return false;
    }
    return _BaseAPI.jsonRegex.test(mime);
  }
  async request(context, initOverrides) {
    const { url, init } = await this.createFetchParams(context, initOverrides);
    const response = await this.fetchApi(url, init);
    if (response && (response.status >= 200 && response.status < 300)) {
      return response;
    }
    throw new ResponseError(response, "Response returned an error code");
  }
  async createFetchParams(context, initOverrides) {
    let url = this.configuration.basePath + context.path;
    if (context.query !== void 0 && Object.keys(context.query).length !== 0) {
      url += "?" + this.configuration.queryParamsStringify(context.query);
    }
    const headers = Object.assign({}, this.configuration.headers, context.headers);
    Object.keys(headers).forEach((key) => headers[key] === void 0 ? delete headers[key] : {});
    const initOverrideFn = typeof initOverrides === "function" ? initOverrides : async () => initOverrides;
    const initParams = {
      method: context.method,
      headers,
      body: context.body,
      credentials: this.configuration.credentials
    };
    const overriddenInit = {
      ...initParams,
      ...await initOverrideFn({
        init: initParams,
        context
      })
    };
    let body;
    if (isFormData(overriddenInit.body) || overriddenInit.body instanceof URLSearchParams || isBlob(overriddenInit.body)) {
      body = overriddenInit.body;
    } else if (this.isJsonMime(headers["Content-Type"])) {
      body = JSON.stringify(overriddenInit.body);
    } else {
      body = overriddenInit.body;
    }
    const init = {
      ...overriddenInit,
      body
    };
    return { url, init };
  }
  /**
   * Create a shallow clone of `this` by constructing a new instance
   * and then shallow cloning data members.
   */
  clone() {
    const constructor = this.constructor;
    const next = new constructor(this.configuration);
    next.middleware = this.middleware.slice();
    return next;
  }
};
_BaseAPI.jsonRegex = new RegExp("^(:?application/json|[^;/ 	]+/[^;/ 	]+[+]json)[ 	]*(:?;.*)?$", "i");
var BaseAPI = _BaseAPI;
function isBlob(value) {
  return typeof Blob !== "undefined" && value instanceof Blob;
}
function isFormData(value) {
  return typeof FormData !== "undefined" && value instanceof FormData;
}
var ResponseError = class extends Error {
  constructor(response, msg) {
    super(msg);
    this.response = response;
    this.name = "ResponseError";
  }
};
var FetchError = class extends Error {
  constructor(cause, msg) {
    super(msg);
    this.cause = cause;
    this.name = "FetchError";
  }
};
var RequiredError = class extends Error {
  constructor(field, msg) {
    super(msg);
    this.field = field;
    this.name = "RequiredError";
  }
};
function querystring(params, prefix = "") {
  return Object.keys(params).map((key) => querystringSingleKey(key, params[key], prefix)).filter((part) => part.length > 0).join("&");
}
function querystringSingleKey(key, value, keyPrefix = "") {
  const fullKey = keyPrefix + (keyPrefix.length ? `[${key}]` : key);
  if (value instanceof Array) {
    const multiValue = value.map((singleValue) => encodeURIComponent(String(singleValue))).join(`&${encodeURIComponent(fullKey)}=`);
    return `${encodeURIComponent(fullKey)}=${multiValue}`;
  }
  if (value instanceof Set) {
    const valueAsArray = Array.from(value);
    return querystringSingleKey(key, valueAsArray, keyPrefix);
  }
  if (value instanceof Date) {
    return `${encodeURIComponent(fullKey)}=${encodeURIComponent(value.toISOString())}`;
  }
  if (value instanceof Object) {
    return querystring(value, fullKey);
  }
  return `${encodeURIComponent(fullKey)}=${encodeURIComponent(String(value))}`;
}
function mapValues(data, fn) {
  return Object.keys(data).reduce(
    (acc, key) => ({ ...acc, [key]: fn(data[key]) }),
    {}
  );
}
var JSONApiResponse = class {
  constructor(raw, transformer = (jsonValue) => jsonValue) {
    this.raw = raw;
    this.transformer = transformer;
  }
  async value() {
    return this.transformer(await this.raw.json());
  }
};
var VoidApiResponse = class {
  constructor(raw) {
    this.raw = raw;
  }
  async value() {
    return void 0;
  }
};
var TextApiResponse = class {
  constructor(raw) {
    this.raw = raw;
  }
  async value() {
    return await this.raw.text();
  }
};

// src/openapi/models/ApiSignerRef.ts
function ApiSignerRefFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "id": json["id"],
    "userType": json["user_type"],
    "name": json["name"],
    "state": json["state"]
  };
}

// src/openapi/models/UserRole.ts
function UserRoleFromJSON(json) {
  return UserRoleFromJSONTyped(json, false);
}
function UserRoleFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// src/openapi/models/ApiUserRef.ts
function ApiUserRefFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "id": json["id"],
    "userType": json["user_type"],
    "name": json["name"],
    "state": json["state"],
    "role": UserRoleFromJSON(json["role"])
  };
}

// src/openapi/models/EndUserRef.ts
function EndUserRefFromJSON(json) {
  return EndUserRefFromJSONTyped(json, false);
}
function EndUserRefFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "id": json["id"],
    "userType": json["user_type"],
    "externalId": json["external_id"],
    "state": json["state"]
  };
}

// src/openapi/models/UserState.ts
function UserStateFromJSON(json) {
  return UserStateFromJSONTyped(json, false);
}
function UserStateFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// src/openapi/models/PersonRef.ts
function PersonRefFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "id": json["id"],
    "userType": json["user_type"],
    "name": json["name"] == null ? void 0 : json["name"],
    "email": json["email"],
    "state": UserStateFromJSON(json["state"]),
    "role": UserRoleFromJSON(json["role"])
  };
}

// src/openapi/models/SystemUserRef.ts
function SystemUserRefFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "id": json["id"],
    "userType": json["user_type"],
    "name": json["name"]
  };
}

// src/openapi/models/UserRef.ts
function UserRefFromJSON(json) {
  return UserRefFromJSONTyped(json, false);
}
function UserRefFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  switch (json["user_type"]) {
    case "api_signer":
      return Object.assign({}, ApiSignerRefFromJSONTyped(json, true), { userType: "api_signer" });
    case "api_user":
      return Object.assign({}, ApiUserRefFromJSONTyped(json, true), { userType: "api_user" });
    case "end_user":
      return Object.assign({}, EndUserRefFromJSONTyped(json, true), { userType: "end_user" });
    case "person":
      return Object.assign({}, PersonRefFromJSONTyped(json, true), { userType: "person" });
    case "system":
      return Object.assign({}, SystemUserRefFromJSONTyped(json, true), { userType: "system" });
    default:
      throw new Error(`No variant of UserRef exists with 'userType=${json["userType"]}'`);
  }
}

// src/openapi/models/ActionSigner.ts
function ActionSignerFromJSON(json) {
  return ActionSignerFromJSONTyped(json, false);
}
function ActionSignerFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "user": UserRefFromJSON(json["user"]),
    "modifiedAt": new Date(json["modified_at"]),
    "hasSigned": json["has_signed"]
  };
}

// src/openapi/models/ActionSigningRequest.ts
function ActionSigningRequestFromJSON(json) {
  return ActionSigningRequestFromJSONTyped(json, false);
}
function ActionSigningRequestFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "signers": json["signers"].map(ActionSignerFromJSON)
  };
}

// src/openapi/models/AddEvmChainRequest.ts
function AddEvmChainRequestToJSON(json) {
  return AddEvmChainRequestToJSONTyped(json, false);
}
function AddEvmChainRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "chain_type": value["chainType"],
    "chain_id": value["chainId"],
    "chain_name": value["chainName"],
    "currency_symbol": value["currencySymbol"],
    "is_testnet": value["isTestnet"],
    "rpc_url": value["rpcUrl"],
    "blockchain_explorer_url": value["blockchainExplorerUrl"]
  };
}

// src/openapi/models/AddChainRequest.ts
function AddChainRequestToJSON(json) {
  return AddChainRequestToJSONTyped(json, false);
}
function AddChainRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  switch (value["chainType"]) {
    case "evm":
      return Object.assign({}, AddEvmChainRequestToJSON(value), { chainType: "evm" });
    default:
      throw new Error(`No variant of AddChainRequest exists with 'chainType=${value["chainType"]}'`);
  }
}

// src/openapi/models/ApprovalState.ts
function ApprovalStateFromJSON(json) {
  return ApprovalStateFromJSONTyped(json, false);
}
function ApprovalStateFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// src/openapi/models/RequestApproverUser.ts
function RequestApproverUserFromJSON(json) {
  return RequestApproverUserFromJSONTyped(json, false);
}
function RequestApproverUserFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  switch (json["user_type"]) {
    case "api_user":
      return Object.assign({}, ApiUserRefFromJSONTyped(json, true), { userType: "api_user" });
    case "person":
      return Object.assign({}, PersonRefFromJSONTyped(json, true), { userType: "person" });
    default:
      throw new Error(`No variant of RequestApproverUser exists with 'userType=${json["userType"]}'`);
  }
}

// src/openapi/models/RequestApprover.ts
function RequestApproverFromJSON(json) {
  return RequestApproverFromJSONTyped(json, false);
}
function RequestApproverFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "user": RequestApproverUserFromJSON(json["user"]),
    "modifiedAt": new Date(json["modified_at"]),
    "decision": json["decision"] == null ? void 0 : json["decision"],
    "state": ApprovalStateFromJSON(json["state"])
  };
}

// src/openapi/models/ApprovalRequestGroup.ts
function ApprovalRequestGroupFromJSON(json) {
  return ApprovalRequestGroupFromJSONTyped(json, false);
}
function ApprovalRequestGroupFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "quorumSize": json["quorum_size"],
    "approvers": json["approvers"].map(RequestApproverFromJSON)
  };
}

// src/openapi/models/ApprovalRequestState.ts
function ApprovalRequestStateFromJSON(json) {
  return ApprovalRequestStateFromJSONTyped(json, false);
}
function ApprovalRequestStateFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// src/openapi/models/ApprovalRequest.ts
function ApprovalRequestFromJSON(json) {
  return ApprovalRequestFromJSONTyped(json, false);
}
function ApprovalRequestFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "state": ApprovalRequestStateFromJSON(json["state"]),
    "quorumSize": json["quorum_size"] == null ? void 0 : json["quorum_size"],
    "approvers": json["approvers"] == null ? void 0 : json["approvers"].map(RequestApproverFromJSON),
    "requiredGroups": json["required_groups"],
    "approvalGroups": json["approval_groups"].map(ApprovalRequestGroupFromJSON),
    "errorMessage": json["error_message"] == null ? void 0 : json["error_message"]
  };
}

// src/openapi/models/VaultState.ts
function VaultStateFromJSON(json) {
  return VaultStateFromJSONTyped(json, false);
}
function VaultStateFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// src/openapi/models/VaultType.ts
var VaultType = {
  aptos: "aptos",
  blackBox: "black_box",
  cosmos: "cosmos",
  evm: "evm",
  solana: "solana",
  stacks: "stacks",
  starknet: "starknet",
  sui: "sui",
  ton: "ton",
  tron: "tron",
  utxo: "utxo",
  exchange: "exchange"
};
function VaultTypeFromJSON(json) {
  return VaultTypeFromJSONTyped(json, false);
}
function VaultTypeFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// src/openapi/models/VaultRef.ts
function VaultRefFromJSON(json) {
  return VaultRefFromJSONTyped(json, false);
}
function VaultRefFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "id": json["id"],
    "vaultGroupId": json["vault_group_id"],
    "name": json["name"],
    "address": json["address"] == null ? void 0 : json["address"],
    "state": VaultStateFromJSON(json["state"]),
    "type": VaultTypeFromJSON(json["type"]),
    "logoUrl": json["logo_url"] == null ? void 0 : json["logo_url"],
    "endUser": json["end_user"] == null ? void 0 : EndUserRefFromJSON(json["end_user"])
  };
}

// src/openapi/models/AptosChainUniqueId.ts
function AptosChainUniqueIdFromJSON(json) {
  return AptosChainUniqueIdFromJSONTyped(json, false);
}
function AptosChainUniqueIdFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}
function AptosChainUniqueIdToJSON(value) {
  return value;
}

// src/openapi/models/AptosChain.ts
function AptosChainFromJSON(json) {
  return AptosChainFromJSONTyped(json, false);
}
function AptosChainFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "chainType": json["chain_type"],
    "uniqueId": AptosChainUniqueIdFromJSON(json["unique_id"])
  };
}

// src/openapi/models/AptosAddressBookContactAddressRef.ts
function AptosAddressBookContactAddressRefFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "chainType": json["chain_type"],
    "address": json["address"],
    "chains": json["chains"].map(AptosChainFromJSON)
  };
}

// src/openapi/models/CosmosChainUniqueId.ts
function CosmosChainUniqueIdFromJSON(json) {
  return CosmosChainUniqueIdFromJSONTyped(json, false);
}
function CosmosChainUniqueIdFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}
function CosmosChainUniqueIdToJSON(value) {
  return value;
}

// src/openapi/models/CosmosChain.ts
function CosmosChainFromJSON(json) {
  return CosmosChainFromJSONTyped(json, false);
}
function CosmosChainFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "chainType": json["chain_type"],
    "uniqueId": CosmosChainUniqueIdFromJSON(json["unique_id"])
  };
}

// src/openapi/models/CosmosAddressBookContactAddressRef.ts
function CosmosAddressBookContactAddressRefFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "chainType": json["chain_type"],
    "address": json["address"],
    "chain": CosmosChainFromJSON(json["chain"])
  };
}

// src/openapi/models/EvmChain.ts
function EvmChainFromJSON(json) {
  return EvmChainFromJSONTyped(json, false);
}
function EvmChainFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "chainType": json["chain_type"],
    "namedChainId": json["named_chain_id"] == null ? void 0 : json["named_chain_id"],
    "chainId": json["chain_id"],
    "uniqueId": json["unique_id"]
  };
}

// src/openapi/models/EVMAddressBookContactAddressRef.ts
function EVMAddressBookContactAddressRefFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "chainType": json["chain_type"],
    "address": json["address"],
    "chains": json["chains"].map(EvmChainFromJSON)
  };
}

// src/openapi/models/SolanaChainUniqueId.ts
function SolanaChainUniqueIdFromJSON(json) {
  return SolanaChainUniqueIdFromJSONTyped(json, false);
}
function SolanaChainUniqueIdFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}
function SolanaChainUniqueIdToJSON(value) {
  return value;
}

// src/openapi/models/SolanaChain.ts
function SolanaChainFromJSON(json) {
  return SolanaChainFromJSONTyped(json, false);
}
function SolanaChainFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "chainType": json["chain_type"],
    "uniqueId": SolanaChainUniqueIdFromJSON(json["unique_id"])
  };
}

// src/openapi/models/SolanaAddressBookContactAddressRef.ts
function SolanaAddressBookContactAddressRefFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "chainType": json["chain_type"],
    "address": json["address"],
    "chains": json["chains"].map(SolanaChainFromJSON)
  };
}

// src/openapi/models/StacksChainUniqueId.ts
function StacksChainUniqueIdFromJSON(json) {
  return StacksChainUniqueIdFromJSONTyped(json, false);
}
function StacksChainUniqueIdFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}
function StacksChainUniqueIdToJSON(value) {
  return value;
}

// src/openapi/models/StacksChain.ts
function StacksChainFromJSON(json) {
  return StacksChainFromJSONTyped(json, false);
}
function StacksChainFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "chainType": json["chain_type"],
    "uniqueId": StacksChainUniqueIdFromJSON(json["unique_id"])
  };
}

// src/openapi/models/StacksAddressBookContactAddressRef.ts
function StacksAddressBookContactAddressRefFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "chainType": json["chain_type"],
    "address": json["address"],
    "chains": json["chains"].map(StacksChainFromJSON)
  };
}

// src/openapi/models/StarknetChainUniqueId.ts
function StarknetChainUniqueIdFromJSON(json) {
  return StarknetChainUniqueIdFromJSONTyped(json, false);
}
function StarknetChainUniqueIdFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}
function StarknetChainUniqueIdToJSON(value) {
  return value;
}

// src/openapi/models/StarknetChain.ts
function StarknetChainFromJSON(json) {
  return StarknetChainFromJSONTyped(json, false);
}
function StarknetChainFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "chainType": json["chain_type"],
    "uniqueId": StarknetChainUniqueIdFromJSON(json["unique_id"])
  };
}

// src/openapi/models/StarknetAddressBookContactAddressRef.ts
function StarknetAddressBookContactAddressRefFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "chainType": json["chain_type"],
    "address": json["address"],
    "chains": json["chains"].map(StarknetChainFromJSON)
  };
}

// src/openapi/models/SuiChainUniqueId.ts
function SuiChainUniqueIdFromJSON(json) {
  return SuiChainUniqueIdFromJSONTyped(json, false);
}
function SuiChainUniqueIdFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}
function SuiChainUniqueIdToJSON(value) {
  return value;
}

// src/openapi/models/SuiChain.ts
function SuiChainFromJSON(json) {
  return SuiChainFromJSONTyped(json, false);
}
function SuiChainFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "chainType": json["chain_type"],
    "uniqueId": SuiChainUniqueIdFromJSON(json["unique_id"])
  };
}

// src/openapi/models/SuiAddressBookContactAddressRef.ts
function SuiAddressBookContactAddressRefFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "chainType": json["chain_type"],
    "address": json["address"],
    "chains": json["chains"].map(SuiChainFromJSON)
  };
}

// src/openapi/models/TonChainUniqueId.ts
function TonChainUniqueIdFromJSON(json) {
  return TonChainUniqueIdFromJSONTyped(json, false);
}
function TonChainUniqueIdFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}
function TonChainUniqueIdToJSON(value) {
  return value;
}

// src/openapi/models/TonChain.ts
function TonChainFromJSON(json) {
  return TonChainFromJSONTyped(json, false);
}
function TonChainFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "chainType": json["chain_type"],
    "uniqueId": TonChainUniqueIdFromJSON(json["unique_id"])
  };
}

// src/openapi/models/TonAddressBookContactAddressRef.ts
function TonAddressBookContactAddressRefFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "chainType": json["chain_type"],
    "address": json["address"],
    "chains": json["chains"].map(TonChainFromJSON)
  };
}

// src/openapi/models/TronChainUniqueId.ts
function TronChainUniqueIdFromJSON(json) {
  return TronChainUniqueIdFromJSONTyped(json, false);
}
function TronChainUniqueIdFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}
function TronChainUniqueIdToJSON(value) {
  return value;
}

// src/openapi/models/TronChain.ts
function TronChainFromJSON(json) {
  return TronChainFromJSONTyped(json, false);
}
function TronChainFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "chainType": json["chain_type"],
    "uniqueId": TronChainUniqueIdFromJSON(json["unique_id"])
  };
}

// src/openapi/models/TronAddressBookContactAddressRef.ts
function TronAddressBookContactAddressRefFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "chainType": json["chain_type"],
    "address": json["address"],
    "chains": json["chains"].map(TronChainFromJSON)
  };
}

// src/openapi/models/UtxoChainUniqueId.ts
function UtxoChainUniqueIdFromJSON(json) {
  return UtxoChainUniqueIdFromJSONTyped(json, false);
}
function UtxoChainUniqueIdFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}
function UtxoChainUniqueIdToJSON(value) {
  return value;
}

// src/openapi/models/UtxoChain.ts
function UtxoChainFromJSON(json) {
  return UtxoChainFromJSONTyped(json, false);
}
function UtxoChainFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "chainType": json["chain_type"],
    "uniqueId": UtxoChainUniqueIdFromJSON(json["unique_id"])
  };
}
function UtxoChainToJSON(json) {
  return UtxoChainToJSONTyped(json, false);
}
function UtxoChainToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "chain_type": value["chainType"],
    "unique_id": UtxoChainUniqueIdToJSON(value["uniqueId"])
  };
}

// src/openapi/models/UtxoAddressBookContactAddressRef.ts
function UtxoAddressBookContactAddressRefFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "chainType": json["chain_type"],
    "address": json["address"],
    "chain": UtxoChainFromJSON(json["chain"])
  };
}

// src/openapi/models/ContactRefAddressRef.ts
function ContactRefAddressRefFromJSON(json) {
  return ContactRefAddressRefFromJSONTyped(json, false);
}
function ContactRefAddressRefFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  switch (json["chain_type"]) {
    case "aptos":
      return Object.assign({}, AptosAddressBookContactAddressRefFromJSONTyped(json, true), { chainType: "aptos" });
    case "cosmos":
      return Object.assign({}, CosmosAddressBookContactAddressRefFromJSONTyped(json, true), { chainType: "cosmos" });
    case "evm":
      return Object.assign({}, EVMAddressBookContactAddressRefFromJSONTyped(json, true), { chainType: "evm" });
    case "solana":
      return Object.assign({}, SolanaAddressBookContactAddressRefFromJSONTyped(json, true), { chainType: "solana" });
    case "stacks":
      return Object.assign({}, StacksAddressBookContactAddressRefFromJSONTyped(json, true), { chainType: "stacks" });
    case "starknet":
      return Object.assign({}, StarknetAddressBookContactAddressRefFromJSONTyped(json, true), { chainType: "starknet" });
    case "sui":
      return Object.assign({}, SuiAddressBookContactAddressRefFromJSONTyped(json, true), { chainType: "sui" });
    case "ton":
      return Object.assign({}, TonAddressBookContactAddressRefFromJSONTyped(json, true), { chainType: "ton" });
    case "tron":
      return Object.assign({}, TronAddressBookContactAddressRefFromJSONTyped(json, true), { chainType: "tron" });
    case "utxo":
      return Object.assign({}, UtxoAddressBookContactAddressRefFromJSONTyped(json, true), { chainType: "utxo" });
    default:
      throw new Error(`No variant of ContactRefAddressRef exists with 'chainType=${json["chainType"]}'`);
  }
}

// src/openapi/models/ContactRef.ts
function ContactRefFromJSON(json) {
  return ContactRefFromJSONTyped(json, false);
}
function ContactRefFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "id": json["id"],
    "name": json["name"],
    "addressRef": ContactRefAddressRefFromJSON(json["address_ref"])
  };
}

// src/openapi/models/BlockchainExplorer.ts
function BlockchainExplorerFromJSON(json) {
  return BlockchainExplorerFromJSONTyped(json, false);
}
function BlockchainExplorerFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "transactionUrl": json["transaction_url"],
    "addressUrl": json["address_url"],
    "rootUrl": json["root_url"],
    "transactionFormatUrl": json["transaction_format_url"] == null ? void 0 : json["transaction_format_url"],
    "addressFormatUrl": json["address_format_url"] == null ? void 0 : json["address_format_url"],
    "assetFormatUrl": json["asset_format_url"] == null ? void 0 : json["asset_format_url"]
  };
}

// src/openapi/models/EnrichedAptosChain.ts
function EnrichedAptosChainFromJSON(json) {
  return EnrichedAptosChainFromJSONTyped(json, false);
}
function EnrichedAptosChainFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "chainType": json["chain_type"],
    "uniqueId": AptosChainUniqueIdFromJSON(json["unique_id"]),
    "name": json["name"],
    "nativeCurrencySymbol": json["native_currency_symbol"],
    "nativeCurrencyName": json["native_currency_name"],
    "blockchainExplorer": json["blockchain_explorer"] == null ? void 0 : BlockchainExplorerFromJSON(json["blockchain_explorer"]),
    "logoUrl": json["logo_url"],
    "isTestnet": json["is_testnet"],
    "isEnabled": json["is_enabled"]
  };
}

// src/openapi/models/AptosCoinTypeRequest.ts
function AptosCoinTypeRequestFromJSON(json) {
  return AptosCoinTypeRequestFromJSONTyped(json, false);
}
function AptosCoinTypeRequestFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "chain": AptosChainUniqueIdFromJSON(json["chain"]),
    "coinTypeStr": json["coin_type_str"]
  };
}
function AptosCoinTypeRequestToJSON(json) {
  return AptosCoinTypeRequestToJSONTyped(json, false);
}
function AptosCoinTypeRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "chain": AptosChainUniqueIdToJSON(value["chain"]),
    "coin_type_str": value["coinTypeStr"]
  };
}

// src/openapi/models/AptosCoinAssetIdentifierRequest.ts
function AptosCoinAssetIdentifierRequestFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "type": json["type"],
    "coinType": AptosCoinTypeRequestFromJSON(json["coin_type"])
  };
}
function AptosCoinAssetIdentifierRequestToJSON(json) {
  return AptosCoinAssetIdentifierRequestToJSONTyped(json, false);
}
function AptosCoinAssetIdentifierRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "type": value["type"],
    "coin_type": AptosCoinTypeRequestToJSON(value["coinType"])
  };
}

// src/openapi/models/AptosNativeAssetIdentifierRequest.ts
function AptosNativeAssetIdentifierRequestFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "type": json["type"],
    "chain": AptosChainUniqueIdFromJSON(json["chain"])
  };
}
function AptosNativeAssetIdentifierRequestToJSON(json) {
  return AptosNativeAssetIdentifierRequestToJSONTyped(json, false);
}
function AptosNativeAssetIdentifierRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "type": value["type"],
    "chain": AptosChainUniqueIdToJSON(value["chain"])
  };
}

// src/openapi/models/AptosNewCoinTypeRequest.ts
function AptosNewCoinTypeRequestFromJSON(json) {
  return AptosNewCoinTypeRequestFromJSONTyped(json, false);
}
function AptosNewCoinTypeRequestFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "chain": AptosChainUniqueIdFromJSON(json["chain"]),
    "metadataAddress": json["metadata_address"]
  };
}
function AptosNewCoinTypeRequestToJSON(json) {
  return AptosNewCoinTypeRequestToJSONTyped(json, false);
}
function AptosNewCoinTypeRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "chain": AptosChainUniqueIdToJSON(value["chain"]),
    "metadata_address": value["metadataAddress"]
  };
}

// src/openapi/models/AptosNewCoinAssetIdentifierRequest.ts
function AptosNewCoinAssetIdentifierRequestFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "type": json["type"],
    "newCoinType": AptosNewCoinTypeRequestFromJSON(json["new_coin_type"])
  };
}
function AptosNewCoinAssetIdentifierRequestToJSON(json) {
  return AptosNewCoinAssetIdentifierRequestToJSONTyped(json, false);
}
function AptosNewCoinAssetIdentifierRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "type": value["type"],
    "new_coin_type": AptosNewCoinTypeRequestToJSON(value["newCoinType"])
  };
}

// src/openapi/models/AptosAssetIdentifierDetails.ts
function AptosAssetIdentifierDetailsFromJSON(json) {
  return AptosAssetIdentifierDetailsFromJSONTyped(json, false);
}
function AptosAssetIdentifierDetailsFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  switch (json["type"]) {
    case "coin":
      return Object.assign({}, AptosCoinAssetIdentifierRequestFromJSONTyped(json, true), { type: "coin" });
    case "native":
      return Object.assign({}, AptosNativeAssetIdentifierRequestFromJSONTyped(json, true), { type: "native" });
    case "new_coin":
      return Object.assign({}, AptosNewCoinAssetIdentifierRequestFromJSONTyped(json, true), { type: "new_coin" });
    default:
      throw new Error(`No variant of AptosAssetIdentifierDetails exists with 'type=${json["type"]}'`);
  }
}
function AptosAssetIdentifierDetailsToJSON(json) {
  return AptosAssetIdentifierDetailsToJSONTyped(json, false);
}
function AptosAssetIdentifierDetailsToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  switch (value["type"]) {
    case "coin":
      return Object.assign({}, AptosCoinAssetIdentifierRequestToJSON(value), { type: "coin" });
    case "native":
      return Object.assign({}, AptosNativeAssetIdentifierRequestToJSON(value), { type: "native" });
    case "new_coin":
      return Object.assign({}, AptosNewCoinAssetIdentifierRequestToJSON(value), { type: "new_coin" });
    default:
      throw new Error(`No variant of AptosAssetIdentifierDetails exists with 'type=${value["type"]}'`);
  }
}

// src/openapi/models/AptosAssetIdentifier.ts
function AptosAssetIdentifierFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "type": json["type"],
    "details": AptosAssetIdentifierDetailsFromJSON(json["details"]),
    "chain": EnrichedAptosChainFromJSON(json["chain"])
  };
}

// src/openapi/models/CosmosBech32Prefix.ts
function CosmosBech32PrefixFromJSON(json) {
  return CosmosBech32PrefixFromJSONTyped(json, false);
}
function CosmosBech32PrefixFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// src/openapi/models/EnrichedCosmosChain.ts
function EnrichedCosmosChainFromJSON(json) {
  return EnrichedCosmosChainFromJSONTyped(json, false);
}
function EnrichedCosmosChainFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "chainType": json["chain_type"],
    "uniqueId": CosmosChainUniqueIdFromJSON(json["unique_id"]),
    "name": json["name"],
    "nativeCurrencySymbol": json["native_currency_symbol"],
    "nativeCurrencyName": json["native_currency_name"],
    "blockchainExplorer": json["blockchain_explorer"] == null ? void 0 : BlockchainExplorerFromJSON(json["blockchain_explorer"]),
    "logoUrl": json["logo_url"],
    "isTestnet": json["is_testnet"],
    "isEnabled": json["is_enabled"],
    "baseDenom": json["base_denom"],
    "bech32Prefix": CosmosBech32PrefixFromJSON(json["bech32_prefix"])
  };
}

// src/openapi/models/CosmosNativeAssetIdentifierRequest.ts
function CosmosNativeAssetIdentifierRequestFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "type": json["type"],
    "chain": CosmosChainUniqueIdFromJSON(json["chain"])
  };
}
function CosmosNativeAssetIdentifierRequestToJSON(json) {
  return CosmosNativeAssetIdentifierRequestToJSONTyped(json, false);
}
function CosmosNativeAssetIdentifierRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "type": value["type"],
    "chain": CosmosChainUniqueIdToJSON(value["chain"])
  };
}

// src/openapi/models/CosmosTokenAssetIdentifierRequest.ts
function CosmosTokenAssetIdentifierRequestFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "type": json["type"],
    "chain": CosmosChainUniqueIdFromJSON(json["chain"]),
    "denom": json["denom"]
  };
}
function CosmosTokenAssetIdentifierRequestToJSON(json) {
  return CosmosTokenAssetIdentifierRequestToJSONTyped(json, false);
}
function CosmosTokenAssetIdentifierRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "type": value["type"],
    "chain": CosmosChainUniqueIdToJSON(value["chain"]),
    "denom": value["denom"]
  };
}

// src/openapi/models/CosmosAssetIdentifierDetails.ts
function CosmosAssetIdentifierDetailsFromJSON(json) {
  return CosmosAssetIdentifierDetailsFromJSONTyped(json, false);
}
function CosmosAssetIdentifierDetailsFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  switch (json["type"]) {
    case "native":
      return Object.assign({}, CosmosNativeAssetIdentifierRequestFromJSONTyped(json, true), { type: "native" });
    case "token":
      return Object.assign({}, CosmosTokenAssetIdentifierRequestFromJSONTyped(json, true), { type: "token" });
    default:
      throw new Error(`No variant of CosmosAssetIdentifierDetails exists with 'type=${json["type"]}'`);
  }
}
function CosmosAssetIdentifierDetailsToJSON(json) {
  return CosmosAssetIdentifierDetailsToJSONTyped(json, false);
}
function CosmosAssetIdentifierDetailsToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  switch (value["type"]) {
    case "native":
      return Object.assign({}, CosmosNativeAssetIdentifierRequestToJSON(value), { type: "native" });
    case "token":
      return Object.assign({}, CosmosTokenAssetIdentifierRequestToJSON(value), { type: "token" });
    default:
      throw new Error(`No variant of CosmosAssetIdentifierDetails exists with 'type=${value["type"]}'`);
  }
}

// src/openapi/models/CosmosAssetIdentifier.ts
function CosmosAssetIdentifierFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "type": json["type"],
    "details": CosmosAssetIdentifierDetailsFromJSON(json["details"]),
    "chain": EnrichedCosmosChainFromJSON(json["chain"])
  };
}

// src/openapi/models/EvmAddressRequest.ts
function EvmAddressRequestFromJSON(json) {
  return EvmAddressRequestFromJSONTyped(json, false);
}
function EvmAddressRequestFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "chain": json["chain"],
    "hexRepr": json["hex_repr"]
  };
}
function EvmAddressRequestToJSON(json) {
  return EvmAddressRequestToJSONTyped(json, false);
}
function EvmAddressRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "chain": value["chain"],
    "hex_repr": value["hexRepr"]
  };
}

// src/openapi/models/EvmErc1155AssetIdentifierRequest.ts
function EvmErc1155AssetIdentifierRequestFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "type": json["type"],
    "token": EvmAddressRequestFromJSON(json["token"]),
    "tokenId": json["token_id"]
  };
}
function EvmErc1155AssetIdentifierRequestToJSON(json) {
  return EvmErc1155AssetIdentifierRequestToJSONTyped(json, false);
}
function EvmErc1155AssetIdentifierRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "type": value["type"],
    "token": EvmAddressRequestToJSON(value["token"]),
    "token_id": value["tokenId"]
  };
}

// src/openapi/models/EvmErc20AssetIdentifierRequest.ts
function EvmErc20AssetIdentifierRequestFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "type": json["type"],
    "token": EvmAddressRequestFromJSON(json["token"])
  };
}
function EvmErc20AssetIdentifierRequestToJSON(json) {
  return EvmErc20AssetIdentifierRequestToJSONTyped(json, false);
}
function EvmErc20AssetIdentifierRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "type": value["type"],
    "token": EvmAddressRequestToJSON(value["token"])
  };
}

// src/openapi/models/EvmErc721AssetIdentifierRequest.ts
function EvmErc721AssetIdentifierRequestFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "type": json["type"],
    "token": EvmAddressRequestFromJSON(json["token"]),
    "tokenId": json["token_id"]
  };
}
function EvmErc721AssetIdentifierRequestToJSON(json) {
  return EvmErc721AssetIdentifierRequestToJSONTyped(json, false);
}
function EvmErc721AssetIdentifierRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "type": value["type"],
    "token": EvmAddressRequestToJSON(value["token"]),
    "token_id": value["tokenId"]
  };
}

// src/openapi/models/EvmHyperLiquidAssetIdentifierRequest.ts
function EvmHyperLiquidAssetIdentifierRequestFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "type": json["type"],
    "chain": json["chain"],
    "tokenId": json["token_id"],
    "index": json["index"]
  };
}
function EvmHyperLiquidAssetIdentifierRequestToJSON(json) {
  return EvmHyperLiquidAssetIdentifierRequestToJSONTyped(json, false);
}
function EvmHyperLiquidAssetIdentifierRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "type": value["type"],
    "chain": value["chain"],
    "token_id": value["tokenId"],
    "index": value["index"]
  };
}

// src/openapi/models/EvmNativeAssetIdentifierRequest.ts
function EvmNativeAssetIdentifierRequestFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "type": json["type"],
    "chain": json["chain"]
  };
}
function EvmNativeAssetIdentifierRequestToJSON(json) {
  return EvmNativeAssetIdentifierRequestToJSONTyped(json, false);
}
function EvmNativeAssetIdentifierRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "type": value["type"],
    "chain": value["chain"]
  };
}

// src/openapi/models/EvmAssetIdentifierDetails.ts
function EvmAssetIdentifierDetailsFromJSON(json) {
  return EvmAssetIdentifierDetailsFromJSONTyped(json, false);
}
function EvmAssetIdentifierDetailsFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  switch (json["type"]) {
    case "erc1155":
      return Object.assign({}, EvmErc1155AssetIdentifierRequestFromJSONTyped(json, true), { type: "erc1155" });
    case "erc20":
      return Object.assign({}, EvmErc20AssetIdentifierRequestFromJSONTyped(json, true), { type: "erc20" });
    case "erc721":
      return Object.assign({}, EvmErc721AssetIdentifierRequestFromJSONTyped(json, true), { type: "erc721" });
    case "hyperliquid":
      return Object.assign({}, EvmHyperLiquidAssetIdentifierRequestFromJSONTyped(json, true), { type: "hyperliquid" });
    case "native":
      return Object.assign({}, EvmNativeAssetIdentifierRequestFromJSONTyped(json, true), { type: "native" });
    default:
      throw new Error(`No variant of EvmAssetIdentifierDetails exists with 'type=${json["type"]}'`);
  }
}
function EvmAssetIdentifierDetailsToJSON(json) {
  return EvmAssetIdentifierDetailsToJSONTyped(json, false);
}
function EvmAssetIdentifierDetailsToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  switch (value["type"]) {
    case "erc1155":
      return Object.assign({}, EvmErc1155AssetIdentifierRequestToJSON(value), { type: "erc1155" });
    case "erc20":
      return Object.assign({}, EvmErc20AssetIdentifierRequestToJSON(value), { type: "erc20" });
    case "erc721":
      return Object.assign({}, EvmErc721AssetIdentifierRequestToJSON(value), { type: "erc721" });
    case "hyperliquid":
      return Object.assign({}, EvmHyperLiquidAssetIdentifierRequestToJSON(value), { type: "hyperliquid" });
    case "native":
      return Object.assign({}, EvmNativeAssetIdentifierRequestToJSON(value), { type: "native" });
    default:
      throw new Error(`No variant of EvmAssetIdentifierDetails exists with 'type=${value["type"]}'`);
  }
}

// src/openapi/models/ChainSource.ts
function ChainSourceFromJSON(json) {
  return ChainSourceFromJSONTyped(json, false);
}
function ChainSourceFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// src/openapi/models/GasType.ts
function GasTypeFromJSON(json) {
  return GasTypeFromJSONTyped(json, false);
}
function GasTypeFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// src/openapi/models/EnrichedEvmChain.ts
function EnrichedEvmChainFromJSON(json) {
  return EnrichedEvmChainFromJSONTyped(json, false);
}
function EnrichedEvmChainFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "chainType": json["chain_type"],
    "namedChainId": json["named_chain_id"] == null ? void 0 : json["named_chain_id"],
    "chainId": json["chain_id"],
    "uniqueId": json["unique_id"],
    "name": json["name"],
    "nativeCurrencySymbol": json["native_currency_symbol"],
    "nativeCurrencyName": json["native_currency_name"],
    "blockchainExplorer": json["blockchain_explorer"] == null ? void 0 : BlockchainExplorerFromJSON(json["blockchain_explorer"]),
    "logoUrl": json["logo_url"],
    "isTestnet": json["is_testnet"],
    "isEnabled": json["is_enabled"],
    "gasType": GasTypeFromJSON(json["gas_type"]),
    "supportsSecureNode": json["supports_secure_node"] == null ? void 0 : json["supports_secure_node"],
    "rpcUrl": json["rpc_url"] == null ? void 0 : json["rpc_url"],
    "source": ChainSourceFromJSON(json["source"])
  };
}

// src/openapi/models/EvmAssetIdentifier.ts
function EvmAssetIdentifierFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "type": json["type"],
    "details": EvmAssetIdentifierDetailsFromJSON(json["details"]),
    "chain": EnrichedEvmChainFromJSON(json["chain"])
  };
}

// src/openapi/models/ExchangeChainUniqueId.ts
function ExchangeChainUniqueIdFromJSON(json) {
  return ExchangeChainUniqueIdFromJSONTyped(json, false);
}
function ExchangeChainUniqueIdFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// src/openapi/models/EnrichedExchangeChain.ts
function EnrichedExchangeChainFromJSON(json) {
  return EnrichedExchangeChainFromJSONTyped(json, false);
}
function EnrichedExchangeChainFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "chainType": json["chain_type"],
    "uniqueId": ExchangeChainUniqueIdFromJSON(json["unique_id"]),
    "name": json["name"],
    "nativeCurrencySymbol": json["native_currency_symbol"],
    "nativeCurrencyName": json["native_currency_name"],
    "blockchainExplorer": json["blockchain_explorer"] == null ? void 0 : BlockchainExplorerFromJSON(json["blockchain_explorer"]),
    "logoUrl": json["logo_url"],
    "isTestnet": json["is_testnet"],
    "isEnabled": json["is_enabled"]
  };
}

// src/openapi/models/ExchangeType.ts
function ExchangeTypeFromJSON(json) {
  return ExchangeTypeFromJSONTyped(json, false);
}
function ExchangeTypeFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}
function ExchangeTypeToJSON(value) {
  return value;
}

// src/openapi/models/ExchangeAssetIdentifier.ts
function ExchangeAssetIdentifierFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "type": json["type"],
    "exchangeType": ExchangeTypeFromJSON(json["exchange_type"]),
    "assetSymbol": json["asset_symbol"],
    "chain": EnrichedExchangeChainFromJSON(json["chain"])
  };
}

// src/openapi/models/SolanaNativeAssetIdentifierRequest.ts
function SolanaNativeAssetIdentifierRequestFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "type": json["type"],
    "chain": SolanaChainUniqueIdFromJSON(json["chain"])
  };
}
function SolanaNativeAssetIdentifierRequestToJSON(json) {
  return SolanaNativeAssetIdentifierRequestToJSONTyped(json, false);
}
function SolanaNativeAssetIdentifierRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "type": value["type"],
    "chain": SolanaChainUniqueIdToJSON(value["chain"])
  };
}

// src/openapi/models/SolanaAddressRequest.ts
function SolanaAddressRequestFromJSON(json) {
  return SolanaAddressRequestFromJSONTyped(json, false);
}
function SolanaAddressRequestFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "chain": SolanaChainUniqueIdFromJSON(json["chain"]),
    "base58Repr": json["base58_repr"]
  };
}
function SolanaAddressRequestToJSON(json) {
  return SolanaAddressRequestToJSONTyped(json, false);
}
function SolanaAddressRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "chain": SolanaChainUniqueIdToJSON(value["chain"]),
    "base58_repr": value["base58Repr"]
  };
}

// src/openapi/models/SolanaSplTokenAssetIdentifierRequest.ts
function SolanaSplTokenAssetIdentifierRequestFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "type": json["type"],
    "token": SolanaAddressRequestFromJSON(json["token"])
  };
}
function SolanaSplTokenAssetIdentifierRequestToJSON(json) {
  return SolanaSplTokenAssetIdentifierRequestToJSONTyped(json, false);
}
function SolanaSplTokenAssetIdentifierRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "type": value["type"],
    "token": SolanaAddressRequestToJSON(value["token"])
  };
}

// src/openapi/models/SolanaAssetIdentifierDetails.ts
function SolanaAssetIdentifierDetailsFromJSON(json) {
  return SolanaAssetIdentifierDetailsFromJSONTyped(json, false);
}
function SolanaAssetIdentifierDetailsFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  switch (json["type"]) {
    case "native":
      return Object.assign({}, SolanaNativeAssetIdentifierRequestFromJSONTyped(json, true), { type: "native" });
    case "spl_token":
      return Object.assign({}, SolanaSplTokenAssetIdentifierRequestFromJSONTyped(json, true), { type: "spl_token" });
    default:
      throw new Error(`No variant of SolanaAssetIdentifierDetails exists with 'type=${json["type"]}'`);
  }
}
function SolanaAssetIdentifierDetailsToJSON(json) {
  return SolanaAssetIdentifierDetailsToJSONTyped(json, false);
}
function SolanaAssetIdentifierDetailsToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  switch (value["type"]) {
    case "native":
      return Object.assign({}, SolanaNativeAssetIdentifierRequestToJSON(value), { type: "native" });
    case "spl_token":
      return Object.assign({}, SolanaSplTokenAssetIdentifierRequestToJSON(value), { type: "spl_token" });
    default:
      throw new Error(`No variant of SolanaAssetIdentifierDetails exists with 'type=${value["type"]}'`);
  }
}

// src/openapi/models/EnrichedSolanaChain.ts
function EnrichedSolanaChainFromJSON(json) {
  return EnrichedSolanaChainFromJSONTyped(json, false);
}
function EnrichedSolanaChainFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "chainType": json["chain_type"],
    "uniqueId": SolanaChainUniqueIdFromJSON(json["unique_id"]),
    "name": json["name"],
    "nativeCurrencySymbol": json["native_currency_symbol"],
    "nativeCurrencyName": json["native_currency_name"],
    "blockchainExplorer": json["blockchain_explorer"] == null ? void 0 : BlockchainExplorerFromJSON(json["blockchain_explorer"]),
    "logoUrl": json["logo_url"],
    "isTestnet": json["is_testnet"],
    "isEnabled": json["is_enabled"]
  };
}

// src/openapi/models/SolanaAssetIdentifier.ts
function SolanaAssetIdentifierFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "type": json["type"],
    "details": SolanaAssetIdentifierDetailsFromJSON(json["details"]),
    "chain": EnrichedSolanaChainFromJSON(json["chain"])
  };
}

// src/openapi/models/EnrichedStacksChain.ts
function EnrichedStacksChainFromJSON(json) {
  return EnrichedStacksChainFromJSONTyped(json, false);
}
function EnrichedStacksChainFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "chainType": json["chain_type"],
    "uniqueId": StacksChainUniqueIdFromJSON(json["unique_id"]),
    "name": json["name"],
    "nativeCurrencySymbol": json["native_currency_symbol"],
    "nativeCurrencyName": json["native_currency_name"],
    "blockchainExplorer": json["blockchain_explorer"] == null ? void 0 : BlockchainExplorerFromJSON(json["blockchain_explorer"]),
    "logoUrl": json["logo_url"],
    "isTestnet": json["is_testnet"],
    "isEnabled": json["is_enabled"]
  };
}

// src/openapi/models/StacksNativeAssetIdentifierRequest.ts
function StacksNativeAssetIdentifierRequestFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "type": json["type"],
    "chain": StacksChainUniqueIdFromJSON(json["chain"])
  };
}
function StacksNativeAssetIdentifierRequestToJSON(json) {
  return StacksNativeAssetIdentifierRequestToJSONTyped(json, false);
}
function StacksNativeAssetIdentifierRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "type": value["type"],
    "chain": StacksChainUniqueIdToJSON(value["chain"])
  };
}

// src/openapi/models/StacksAddressRequest.ts
function StacksAddressRequestFromJSON(json) {
  return StacksAddressRequestFromJSONTyped(json, false);
}
function StacksAddressRequestFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "chain": StacksChainUniqueIdFromJSON(json["chain"]),
    "hexRepr": json["hex_repr"]
  };
}
function StacksAddressRequestToJSON(json) {
  return StacksAddressRequestToJSONTyped(json, false);
}
function StacksAddressRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "chain": StacksChainUniqueIdToJSON(value["chain"]),
    "hex_repr": value["hexRepr"]
  };
}

// src/openapi/models/StacksSip10AssetIdentifierRequest.ts
function StacksSip10AssetIdentifierRequestFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "type": json["type"],
    "sip10": StacksAddressRequestFromJSON(json["sip10"])
  };
}
function StacksSip10AssetIdentifierRequestToJSON(json) {
  return StacksSip10AssetIdentifierRequestToJSONTyped(json, false);
}
function StacksSip10AssetIdentifierRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "type": value["type"],
    "sip10": StacksAddressRequestToJSON(value["sip10"])
  };
}

// src/openapi/models/StacksAssetIdentifierDetails.ts
function StacksAssetIdentifierDetailsFromJSON(json) {
  return StacksAssetIdentifierDetailsFromJSONTyped(json, false);
}
function StacksAssetIdentifierDetailsFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  switch (json["type"]) {
    case "native":
      return Object.assign({}, StacksNativeAssetIdentifierRequestFromJSONTyped(json, true), { type: "native" });
    case "sip10":
      return Object.assign({}, StacksSip10AssetIdentifierRequestFromJSONTyped(json, true), { type: "sip10" });
    default:
      throw new Error(`No variant of StacksAssetIdentifierDetails exists with 'type=${json["type"]}'`);
  }
}
function StacksAssetIdentifierDetailsToJSON(json) {
  return StacksAssetIdentifierDetailsToJSONTyped(json, false);
}
function StacksAssetIdentifierDetailsToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  switch (value["type"]) {
    case "native":
      return Object.assign({}, StacksNativeAssetIdentifierRequestToJSON(value), { type: "native" });
    case "sip10":
      return Object.assign({}, StacksSip10AssetIdentifierRequestToJSON(value), { type: "sip10" });
    default:
      throw new Error(`No variant of StacksAssetIdentifierDetails exists with 'type=${value["type"]}'`);
  }
}

// src/openapi/models/StacksAssetIdentifier.ts
function StacksAssetIdentifierFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "type": json["type"],
    "details": StacksAssetIdentifierDetailsFromJSON(json["details"]),
    "chain": EnrichedStacksChainFromJSON(json["chain"])
  };
}

// src/openapi/models/EnrichedStarknetChain.ts
function EnrichedStarknetChainFromJSON(json) {
  return EnrichedStarknetChainFromJSONTyped(json, false);
}
function EnrichedStarknetChainFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "chainType": json["chain_type"],
    "uniqueId": StarknetChainUniqueIdFromJSON(json["unique_id"]),
    "name": json["name"],
    "nativeCurrencySymbol": json["native_currency_symbol"],
    "nativeCurrencyName": json["native_currency_name"],
    "blockchainExplorer": json["blockchain_explorer"] == null ? void 0 : BlockchainExplorerFromJSON(json["blockchain_explorer"]),
    "logoUrl": json["logo_url"],
    "isTestnet": json["is_testnet"],
    "isEnabled": json["is_enabled"]
  };
}

// src/openapi/models/StarknetAddressRequest.ts
function StarknetAddressRequestFromJSON(json) {
  return StarknetAddressRequestFromJSONTyped(json, false);
}
function StarknetAddressRequestFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "chain": StarknetChainUniqueIdFromJSON(json["chain"]),
    "hexRepr": json["hex_repr"]
  };
}
function StarknetAddressRequestToJSON(json) {
  return StarknetAddressRequestToJSONTyped(json, false);
}
function StarknetAddressRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "chain": StarknetChainUniqueIdToJSON(value["chain"]),
    "hex_repr": value["hexRepr"]
  };
}

// src/openapi/models/StarknetErc20AssetIdentifierRequest.ts
function StarknetErc20AssetIdentifierRequestFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "type": json["type"],
    "erc20": StarknetAddressRequestFromJSON(json["erc20"])
  };
}
function StarknetErc20AssetIdentifierRequestToJSON(json) {
  return StarknetErc20AssetIdentifierRequestToJSONTyped(json, false);
}
function StarknetErc20AssetIdentifierRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "type": value["type"],
    "erc20": StarknetAddressRequestToJSON(value["erc20"])
  };
}

// src/openapi/models/StarknetNativeAssetIdentifierRequest.ts
function StarknetNativeAssetIdentifierRequestFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "type": json["type"],
    "chain": StarknetChainUniqueIdFromJSON(json["chain"])
  };
}
function StarknetNativeAssetIdentifierRequestToJSON(json) {
  return StarknetNativeAssetIdentifierRequestToJSONTyped(json, false);
}
function StarknetNativeAssetIdentifierRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "type": value["type"],
    "chain": StarknetChainUniqueIdToJSON(value["chain"])
  };
}

// src/openapi/models/StarknetAssetIdentifierDetails.ts
function StarknetAssetIdentifierDetailsFromJSON(json) {
  return StarknetAssetIdentifierDetailsFromJSONTyped(json, false);
}
function StarknetAssetIdentifierDetailsFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  switch (json["type"]) {
    case "erc20":
      return Object.assign({}, StarknetErc20AssetIdentifierRequestFromJSONTyped(json, true), { type: "erc20" });
    case "native":
      return Object.assign({}, StarknetNativeAssetIdentifierRequestFromJSONTyped(json, true), { type: "native" });
    default:
      throw new Error(`No variant of StarknetAssetIdentifierDetails exists with 'type=${json["type"]}'`);
  }
}
function StarknetAssetIdentifierDetailsToJSON(json) {
  return StarknetAssetIdentifierDetailsToJSONTyped(json, false);
}
function StarknetAssetIdentifierDetailsToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  switch (value["type"]) {
    case "erc20":
      return Object.assign({}, StarknetErc20AssetIdentifierRequestToJSON(value), { type: "erc20" });
    case "native":
      return Object.assign({}, StarknetNativeAssetIdentifierRequestToJSON(value), { type: "native" });
    default:
      throw new Error(`No variant of StarknetAssetIdentifierDetails exists with 'type=${value["type"]}'`);
  }
}

// src/openapi/models/StarknetAssetIdentifier.ts
function StarknetAssetIdentifierFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "type": json["type"],
    "details": StarknetAssetIdentifierDetailsFromJSON(json["details"]),
    "chain": EnrichedStarknetChainFromJSON(json["chain"])
  };
}

// src/openapi/models/SuiCoinTypeRequest.ts
function SuiCoinTypeRequestFromJSON(json) {
  return SuiCoinTypeRequestFromJSONTyped(json, false);
}
function SuiCoinTypeRequestFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "chain": SuiChainUniqueIdFromJSON(json["chain"]),
    "coinTypeStr": json["coin_type_str"]
  };
}
function SuiCoinTypeRequestToJSON(json) {
  return SuiCoinTypeRequestToJSONTyped(json, false);
}
function SuiCoinTypeRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "chain": SuiChainUniqueIdToJSON(value["chain"]),
    "coin_type_str": value["coinTypeStr"]
  };
}

// src/openapi/models/SuiCoinAssetIdentifierRequest.ts
function SuiCoinAssetIdentifierRequestFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "type": json["type"],
    "coinType": SuiCoinTypeRequestFromJSON(json["coin_type"])
  };
}
function SuiCoinAssetIdentifierRequestToJSON(json) {
  return SuiCoinAssetIdentifierRequestToJSONTyped(json, false);
}
function SuiCoinAssetIdentifierRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "type": value["type"],
    "coin_type": SuiCoinTypeRequestToJSON(value["coinType"])
  };
}

// src/openapi/models/SuiNativeAssetIdentifierRequest.ts
function SuiNativeAssetIdentifierRequestFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "type": json["type"],
    "chain": SuiChainUniqueIdFromJSON(json["chain"])
  };
}
function SuiNativeAssetIdentifierRequestToJSON(json) {
  return SuiNativeAssetIdentifierRequestToJSONTyped(json, false);
}
function SuiNativeAssetIdentifierRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "type": value["type"],
    "chain": SuiChainUniqueIdToJSON(value["chain"])
  };
}

// src/openapi/models/SuiAssetIdentifierDetails.ts
function SuiAssetIdentifierDetailsFromJSON(json) {
  return SuiAssetIdentifierDetailsFromJSONTyped(json, false);
}
function SuiAssetIdentifierDetailsFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  switch (json["type"]) {
    case "coin":
      return Object.assign({}, SuiCoinAssetIdentifierRequestFromJSONTyped(json, true), { type: "coin" });
    case "native":
      return Object.assign({}, SuiNativeAssetIdentifierRequestFromJSONTyped(json, true), { type: "native" });
    default:
      throw new Error(`No variant of SuiAssetIdentifierDetails exists with 'type=${json["type"]}'`);
  }
}
function SuiAssetIdentifierDetailsToJSON(json) {
  return SuiAssetIdentifierDetailsToJSONTyped(json, false);
}
function SuiAssetIdentifierDetailsToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  switch (value["type"]) {
    case "coin":
      return Object.assign({}, SuiCoinAssetIdentifierRequestToJSON(value), { type: "coin" });
    case "native":
      return Object.assign({}, SuiNativeAssetIdentifierRequestToJSON(value), { type: "native" });
    default:
      throw new Error(`No variant of SuiAssetIdentifierDetails exists with 'type=${value["type"]}'`);
  }
}

// src/openapi/models/EnrichedSuiChain.ts
function EnrichedSuiChainFromJSON(json) {
  return EnrichedSuiChainFromJSONTyped(json, false);
}
function EnrichedSuiChainFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "chainType": json["chain_type"],
    "uniqueId": SuiChainUniqueIdFromJSON(json["unique_id"]),
    "name": json["name"],
    "nativeCurrencySymbol": json["native_currency_symbol"],
    "nativeCurrencyName": json["native_currency_name"],
    "blockchainExplorer": json["blockchain_explorer"] == null ? void 0 : BlockchainExplorerFromJSON(json["blockchain_explorer"]),
    "logoUrl": json["logo_url"],
    "isTestnet": json["is_testnet"],
    "isEnabled": json["is_enabled"]
  };
}

// src/openapi/models/SuiAssetIdentifier.ts
function SuiAssetIdentifierFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "type": json["type"],
    "details": SuiAssetIdentifierDetailsFromJSON(json["details"]),
    "chain": EnrichedSuiChainFromJSON(json["chain"])
  };
}

// src/openapi/models/EnrichedTonChain.ts
function EnrichedTonChainFromJSON(json) {
  return EnrichedTonChainFromJSONTyped(json, false);
}
function EnrichedTonChainFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "chainType": json["chain_type"],
    "uniqueId": TonChainUniqueIdFromJSON(json["unique_id"]),
    "name": json["name"],
    "nativeCurrencySymbol": json["native_currency_symbol"],
    "nativeCurrencyName": json["native_currency_name"],
    "blockchainExplorer": json["blockchain_explorer"] == null ? void 0 : BlockchainExplorerFromJSON(json["blockchain_explorer"]),
    "logoUrl": json["logo_url"],
    "isTestnet": json["is_testnet"],
    "isEnabled": json["is_enabled"]
  };
}

// src/openapi/models/TonAddressRequest.ts
function TonAddressRequestFromJSON(json) {
  return TonAddressRequestFromJSONTyped(json, false);
}
function TonAddressRequestFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "chain": TonChainUniqueIdFromJSON(json["chain"]),
    "address": json["address"]
  };
}
function TonAddressRequestToJSON(json) {
  return TonAddressRequestToJSONTyped(json, false);
}
function TonAddressRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "chain": TonChainUniqueIdToJSON(value["chain"]),
    "address": value["address"]
  };
}

// src/openapi/models/TonJettonAssetIdentifierRequest.ts
function TonJettonAssetIdentifierRequestFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "type": json["type"],
    "jetton": TonAddressRequestFromJSON(json["jetton"])
  };
}
function TonJettonAssetIdentifierRequestToJSON(json) {
  return TonJettonAssetIdentifierRequestToJSONTyped(json, false);
}
function TonJettonAssetIdentifierRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "type": value["type"],
    "jetton": TonAddressRequestToJSON(value["jetton"])
  };
}

// src/openapi/models/TonNativeAssetIdentifierRequest.ts
function TonNativeAssetIdentifierRequestFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "type": json["type"],
    "chain": TonChainUniqueIdFromJSON(json["chain"])
  };
}
function TonNativeAssetIdentifierRequestToJSON(json) {
  return TonNativeAssetIdentifierRequestToJSONTyped(json, false);
}
function TonNativeAssetIdentifierRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "type": value["type"],
    "chain": TonChainUniqueIdToJSON(value["chain"])
  };
}

// src/openapi/models/TonAssetIdentifierDetails.ts
function TonAssetIdentifierDetailsFromJSON(json) {
  return TonAssetIdentifierDetailsFromJSONTyped(json, false);
}
function TonAssetIdentifierDetailsFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  switch (json["type"]) {
    case "jetton":
      return Object.assign({}, TonJettonAssetIdentifierRequestFromJSONTyped(json, true), { type: "jetton" });
    case "native":
      return Object.assign({}, TonNativeAssetIdentifierRequestFromJSONTyped(json, true), { type: "native" });
    default:
      throw new Error(`No variant of TonAssetIdentifierDetails exists with 'type=${json["type"]}'`);
  }
}
function TonAssetIdentifierDetailsToJSON(json) {
  return TonAssetIdentifierDetailsToJSONTyped(json, false);
}
function TonAssetIdentifierDetailsToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  switch (value["type"]) {
    case "jetton":
      return Object.assign({}, TonJettonAssetIdentifierRequestToJSON(value), { type: "jetton" });
    case "native":
      return Object.assign({}, TonNativeAssetIdentifierRequestToJSON(value), { type: "native" });
    default:
      throw new Error(`No variant of TonAssetIdentifierDetails exists with 'type=${value["type"]}'`);
  }
}

// src/openapi/models/TonAssetIdentifier.ts
function TonAssetIdentifierFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "type": json["type"],
    "details": TonAssetIdentifierDetailsFromJSON(json["details"]),
    "chain": EnrichedTonChainFromJSON(json["chain"])
  };
}

// src/openapi/models/EnrichedTronChain.ts
function EnrichedTronChainFromJSON(json) {
  return EnrichedTronChainFromJSONTyped(json, false);
}
function EnrichedTronChainFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "chainType": json["chain_type"],
    "uniqueId": TronChainUniqueIdFromJSON(json["unique_id"]),
    "name": json["name"],
    "nativeCurrencySymbol": json["native_currency_symbol"],
    "nativeCurrencyName": json["native_currency_name"],
    "blockchainExplorer": json["blockchain_explorer"] == null ? void 0 : BlockchainExplorerFromJSON(json["blockchain_explorer"]),
    "logoUrl": json["logo_url"],
    "isTestnet": json["is_testnet"],
    "isEnabled": json["is_enabled"]
  };
}

// src/openapi/models/TronNativeAssetIdentifierRequest.ts
function TronNativeAssetIdentifierRequestFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "type": json["type"],
    "chain": TronChainUniqueIdFromJSON(json["chain"])
  };
}
function TronNativeAssetIdentifierRequestToJSON(json) {
  return TronNativeAssetIdentifierRequestToJSONTyped(json, false);
}
function TronNativeAssetIdentifierRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "type": value["type"],
    "chain": TronChainUniqueIdToJSON(value["chain"])
  };
}

// src/openapi/models/TronAddressRequest.ts
function TronAddressRequestFromJSON(json) {
  return TronAddressRequestFromJSONTyped(json, false);
}
function TronAddressRequestFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "chain": TronChainUniqueIdFromJSON(json["chain"]),
    "base58Repr": json["base58_repr"]
  };
}
function TronAddressRequestToJSON(json) {
  return TronAddressRequestToJSONTyped(json, false);
}
function TronAddressRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "chain": TronChainUniqueIdToJSON(value["chain"]),
    "base58_repr": value["base58Repr"]
  };
}

// src/openapi/models/TronTrc20AssetIdentifierRequest.ts
function TronTrc20AssetIdentifierRequestFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "type": json["type"],
    "trc20": TronAddressRequestFromJSON(json["trc20"])
  };
}
function TronTrc20AssetIdentifierRequestToJSON(json) {
  return TronTrc20AssetIdentifierRequestToJSONTyped(json, false);
}
function TronTrc20AssetIdentifierRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "type": value["type"],
    "trc20": TronAddressRequestToJSON(value["trc20"])
  };
}

// src/openapi/models/TronAssetIdentifierDetails.ts
function TronAssetIdentifierDetailsFromJSON(json) {
  return TronAssetIdentifierDetailsFromJSONTyped(json, false);
}
function TronAssetIdentifierDetailsFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  switch (json["type"]) {
    case "native":
      return Object.assign({}, TronNativeAssetIdentifierRequestFromJSONTyped(json, true), { type: "native" });
    case "trc20":
      return Object.assign({}, TronTrc20AssetIdentifierRequestFromJSONTyped(json, true), { type: "trc20" });
    default:
      throw new Error(`No variant of TronAssetIdentifierDetails exists with 'type=${json["type"]}'`);
  }
}
function TronAssetIdentifierDetailsToJSON(json) {
  return TronAssetIdentifierDetailsToJSONTyped(json, false);
}
function TronAssetIdentifierDetailsToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  switch (value["type"]) {
    case "native":
      return Object.assign({}, TronNativeAssetIdentifierRequestToJSON(value), { type: "native" });
    case "trc20":
      return Object.assign({}, TronTrc20AssetIdentifierRequestToJSON(value), { type: "trc20" });
    default:
      throw new Error(`No variant of TronAssetIdentifierDetails exists with 'type=${value["type"]}'`);
  }
}

// src/openapi/models/TronAssetIdentifier.ts
function TronAssetIdentifierFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "type": json["type"],
    "details": TronAssetIdentifierDetailsFromJSON(json["details"]),
    "chain": EnrichedTronChainFromJSON(json["chain"])
  };
}

// src/openapi/models/EnrichedUtxoChain.ts
function EnrichedUtxoChainFromJSON(json) {
  return EnrichedUtxoChainFromJSONTyped(json, false);
}
function EnrichedUtxoChainFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "chainType": json["chain_type"],
    "uniqueId": UtxoChainUniqueIdFromJSON(json["unique_id"]),
    "name": json["name"],
    "nativeCurrencySymbol": json["native_currency_symbol"],
    "nativeCurrencyName": json["native_currency_name"],
    "blockchainExplorer": json["blockchain_explorer"] == null ? void 0 : BlockchainExplorerFromJSON(json["blockchain_explorer"]),
    "logoUrl": json["logo_url"],
    "isTestnet": json["is_testnet"],
    "isEnabled": json["is_enabled"]
  };
}

// src/openapi/models/UtxoNativeAssetIdentifierRequest.ts
function UtxoNativeAssetIdentifierRequestFromJSON(json) {
  return UtxoNativeAssetIdentifierRequestFromJSONTyped(json, false);
}
function UtxoNativeAssetIdentifierRequestFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "type": json["type"],
    "chain": UtxoChainUniqueIdFromJSON(json["chain"])
  };
}

// src/openapi/models/UtxoAssetIdentifier.ts
function UtxoAssetIdentifierFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "type": json["type"],
    "details": UtxoNativeAssetIdentifierRequestFromJSON(json["details"]),
    "chain": EnrichedUtxoChainFromJSON(json["chain"])
  };
}

// src/openapi/models/AssetIdentifier.ts
function AssetIdentifierFromJSON(json) {
  return AssetIdentifierFromJSONTyped(json, false);
}
function AssetIdentifierFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  switch (json["type"]) {
    case "aptos":
      return Object.assign({}, AptosAssetIdentifierFromJSONTyped(json, true), { type: "aptos" });
    case "cosmos":
      return Object.assign({}, CosmosAssetIdentifierFromJSONTyped(json, true), { type: "cosmos" });
    case "evm":
      return Object.assign({}, EvmAssetIdentifierFromJSONTyped(json, true), { type: "evm" });
    case "exchange":
      return Object.assign({}, ExchangeAssetIdentifierFromJSONTyped(json, true), { type: "exchange" });
    case "solana":
      return Object.assign({}, SolanaAssetIdentifierFromJSONTyped(json, true), { type: "solana" });
    case "stacks":
      return Object.assign({}, StacksAssetIdentifierFromJSONTyped(json, true), { type: "stacks" });
    case "starknet":
      return Object.assign({}, StarknetAssetIdentifierFromJSONTyped(json, true), { type: "starknet" });
    case "sui":
      return Object.assign({}, SuiAssetIdentifierFromJSONTyped(json, true), { type: "sui" });
    case "ton":
      return Object.assign({}, TonAssetIdentifierFromJSONTyped(json, true), { type: "ton" });
    case "tron":
      return Object.assign({}, TronAssetIdentifierFromJSONTyped(json, true), { type: "tron" });
    case "utxo":
      return Object.assign({}, UtxoAssetIdentifierFromJSONTyped(json, true), { type: "utxo" });
    default:
      throw new Error(`No variant of AssetIdentifier exists with 'type=${json["type"]}'`);
  }
}

// src/openapi/models/AssetInfo.ts
function AssetInfoFromJSON(json) {
  return AssetInfoFromJSONTyped(json, false);
}
function AssetInfoFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "id": json["id"],
    "assetIdentifier": AssetIdentifierFromJSON(json["asset_identifier"]),
    "name": json["name"],
    "symbol": json["symbol"],
    "decimals": json["decimals"],
    "verified": json["verified"],
    "metadataUri": json["metadata_uri"] == null ? void 0 : json["metadata_uri"],
    "isSpam": json["is_spam"],
    "logoUrl": json["logo_url"] == null ? void 0 : json["logo_url"],
    "explorerUrl": json["explorer_url"] == null ? void 0 : json["explorer_url"]
  };
}

// src/openapi/models/SolanaAddress.ts
function SolanaAddressFromJSON(json) {
  return SolanaAddressFromJSONTyped(json, false);
}
function SolanaAddressFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "chain": SolanaChainFromJSON(json["chain"]),
    "base58Repr": json["base58_repr"]
  };
}

// src/openapi/models/SplToken.ts
function SplTokenFromJSON(json) {
  return SplTokenFromJSONTyped(json, false);
}
function SplTokenFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "type": json["type"],
    "address": SolanaAddressFromJSON(json["address"]),
    "name": json["name"],
    "symbol": json["symbol"],
    "decimals": json["decimals"],
    "logoUrl": json["logo_url"] == null ? void 0 : json["logo_url"]
  };
}

// src/openapi/models/Dapp.ts
function DappFromJSON(json) {
  return DappFromJSONTyped(json, false);
}
function DappFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "id": json["id"],
    "name": json["name"],
    "url": json["url"] == null ? void 0 : json["url"],
    "logoUrl": json["logo_url"] == null ? void 0 : json["logo_url"]
  };
}

// src/openapi/models/SolanaContractMetadata.ts
function SolanaContractMetadataFromJSON(json) {
  return SolanaContractMetadataFromJSONTyped(json, false);
}
function SolanaContractMetadataFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "name": json["name"] == null ? void 0 : json["name"],
    "dapp": json["dapp"] == null ? void 0 : DappFromJSON(json["dapp"]),
    "isVerified": json["is_verified"],
    "token": json["token"] == null ? void 0 : SplTokenFromJSON(json["token"])
  };
}

// src/openapi/models/EnrichedSolanaAddress.ts
function EnrichedSolanaAddressFromJSON(json) {
  return EnrichedSolanaAddressFromJSONTyped(json, false);
}
function EnrichedSolanaAddressFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "vault": json["vault"] == null ? void 0 : VaultRefFromJSON(json["vault"]),
    "explorerUrl": json["explorer_url"] == null ? void 0 : json["explorer_url"],
    "contact": json["contact"] == null ? void 0 : ContactRefFromJSON(json["contact"]),
    "type": json["type"],
    "address": json["address"],
    "contract": json["contract"] == null ? void 0 : SolanaContractMetadataFromJSON(json["contract"])
  };
}

// src/openapi/models/AddressLookupTableState.ts
function AddressLookupTableStateFromJSON(json) {
  return AddressLookupTableStateFromJSONTyped(json, false);
}
function AddressLookupTableStateFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "addresses": json["addresses"].map(EnrichedSolanaAddressFromJSON),
    "authority": json["authority"] == null ? void 0 : EnrichedSolanaAddressFromJSON(json["authority"]),
    "deactivationSlot": json["deactivation_slot"],
    "lastExtendedSlot": json["last_extended_slot"],
    "lastExtendedSlotStartIndex": json["last_extended_slot_start_index"]
  };
}

// src/openapi/models/EnrichedAptosAddress.ts
function EnrichedAptosAddressFromJSON(json) {
  return EnrichedAptosAddressFromJSONTyped(json, false);
}
function EnrichedAptosAddressFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "vault": json["vault"] == null ? void 0 : VaultRefFromJSON(json["vault"]),
    "explorerUrl": json["explorer_url"] == null ? void 0 : json["explorer_url"],
    "contact": json["contact"] == null ? void 0 : ContactRefFromJSON(json["contact"]),
    "type": json["type"],
    "address": json["address"]
  };
}

// src/openapi/models/CosmosKeyType.ts
function CosmosKeyTypeFromJSON(json) {
  return CosmosKeyTypeFromJSONTyped(json, false);
}
function CosmosKeyTypeFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}
function CosmosKeyTypeToJSON(value) {
  return value;
}

// src/openapi/models/CosmosBechAddress.ts
function CosmosBechAddressFromJSON(json) {
  return CosmosBechAddressFromJSONTyped(json, false);
}
function CosmosBechAddressFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "chain": CosmosChainUniqueIdFromJSON(json["chain"]),
    "address": json["address"],
    "hexRepr": json["hex_repr"] == null ? void 0 : json["hex_repr"],
    "keyType": json["key_type"] == null ? void 0 : CosmosKeyTypeFromJSON(json["key_type"])
  };
}
function CosmosBechAddressToJSON(json) {
  return CosmosBechAddressToJSONTyped(json, false);
}
function CosmosBechAddressToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "chain": CosmosChainUniqueIdToJSON(value["chain"]),
    "address": value["address"],
    "hex_repr": value["hexRepr"],
    "key_type": CosmosKeyTypeToJSON(value["keyType"])
  };
}

// src/openapi/models/EnrichedCosmosBechAddress.ts
function EnrichedCosmosBechAddressFromJSON(json) {
  return EnrichedCosmosBechAddressFromJSONTyped(json, false);
}
function EnrichedCosmosBechAddressFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "vault": json["vault"] == null ? void 0 : VaultRefFromJSON(json["vault"]),
    "explorerUrl": json["explorer_url"] == null ? void 0 : json["explorer_url"],
    "contact": json["contact"] == null ? void 0 : ContactRefFromJSON(json["contact"]),
    "type": json["type"],
    "address": CosmosBechAddressFromJSON(json["address"])
  };
}

// src/openapi/models/EvmAddress.ts
function EvmAddressFromJSON(json) {
  return EvmAddressFromJSONTyped(json, false);
}
function EvmAddressFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "chain": EvmChainFromJSON(json["chain"]),
    "hexRepr": json["hex_repr"]
  };
}

// src/openapi/models/Erc1155.ts
function Erc1155FromJSON(json) {
  return Erc1155FromJSONTyped(json, false);
}
function Erc1155FromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "address": EvmAddressFromJSON(json["address"]),
    "name": json["name"],
    "symbol": json["symbol"],
    "type": json["type"]
  };
}

// src/openapi/models/Erc20.ts
function Erc20FromJSON(json) {
  return Erc20FromJSONTyped(json, false);
}
function Erc20FromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "address": EvmAddressFromJSON(json["address"]),
    "name": json["name"],
    "symbol": json["symbol"],
    "type": json["type"],
    "decimals": json["decimals"],
    "logoUrl": json["logo_url"] == null ? void 0 : json["logo_url"]
  };
}

// src/openapi/models/Erc721.ts
function Erc721FromJSON(json) {
  return Erc721FromJSONTyped(json, false);
}
function Erc721FromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "address": EvmAddressFromJSON(json["address"]),
    "name": json["name"],
    "symbol": json["symbol"],
    "type": json["type"]
  };
}

// src/openapi/models/EvmContractMetadataToken.ts
function EvmContractMetadataTokenFromJSON(json) {
  return EvmContractMetadataTokenFromJSONTyped(json, false);
}
function EvmContractMetadataTokenFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  switch (json["type"]) {
    case "erc1155":
      return Object.assign({}, Erc1155FromJSONTyped(json, true), { type: "erc1155" });
    case "erc20":
      return Object.assign({}, Erc20FromJSONTyped(json, true), { type: "erc20" });
    case "erc721":
      return Object.assign({}, Erc721FromJSONTyped(json, true), { type: "erc721" });
    default:
      throw new Error(`No variant of EvmContractMetadataToken exists with 'type=${json["type"]}'`);
  }
}

// src/openapi/models/EvmContractMetadata.ts
function EvmContractMetadataFromJSON(json) {
  return EvmContractMetadataFromJSONTyped(json, false);
}
function EvmContractMetadataFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "name": json["name"] == null ? void 0 : json["name"],
    "dapp": json["dapp"] == null ? void 0 : DappFromJSON(json["dapp"]),
    "isVerified": json["is_verified"],
    "token": json["token"] == null ? void 0 : EvmContractMetadataTokenFromJSON(json["token"])
  };
}

// src/openapi/models/EnrichedEvmAddress.ts
function EnrichedEvmAddressFromJSON(json) {
  return EnrichedEvmAddressFromJSONTyped(json, false);
}
function EnrichedEvmAddressFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "vault": json["vault"] == null ? void 0 : VaultRefFromJSON(json["vault"]),
    "explorerUrl": json["explorer_url"] == null ? void 0 : json["explorer_url"],
    "contact": json["contact"] == null ? void 0 : ContactRefFromJSON(json["contact"]),
    "type": json["type"],
    "address": json["address"],
    "contract": json["contract"] == null ? void 0 : EvmContractMetadataFromJSON(json["contract"])
  };
}

// src/openapi/models/EnrichedExchangeAddress.ts
function EnrichedExchangeAddressFromJSON(json) {
  return EnrichedExchangeAddressFromJSONTyped(json, false);
}
function EnrichedExchangeAddressFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "vault": json["vault"] == null ? void 0 : VaultRefFromJSON(json["vault"]),
    "explorerUrl": json["explorer_url"] == null ? void 0 : json["explorer_url"],
    "contact": json["contact"] == null ? void 0 : ContactRefFromJSON(json["contact"]),
    "type": json["type"],
    "exchangeType": ExchangeTypeFromJSON(json["exchange_type"])
  };
}

// src/openapi/models/EnrichedStacksAddress.ts
function EnrichedStacksAddressFromJSON(json) {
  return EnrichedStacksAddressFromJSONTyped(json, false);
}
function EnrichedStacksAddressFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "vault": json["vault"] == null ? void 0 : VaultRefFromJSON(json["vault"]),
    "explorerUrl": json["explorer_url"] == null ? void 0 : json["explorer_url"],
    "contact": json["contact"] == null ? void 0 : ContactRefFromJSON(json["contact"]),
    "type": json["type"],
    "address": json["address"]
  };
}

// src/openapi/models/EnrichedStarknetAddress.ts
function EnrichedStarknetAddressFromJSON(json) {
  return EnrichedStarknetAddressFromJSONTyped(json, false);
}
function EnrichedStarknetAddressFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "vault": json["vault"] == null ? void 0 : VaultRefFromJSON(json["vault"]),
    "explorerUrl": json["explorer_url"] == null ? void 0 : json["explorer_url"],
    "contact": json["contact"] == null ? void 0 : ContactRefFromJSON(json["contact"]),
    "type": json["type"],
    "address": json["address"]
  };
}

// src/openapi/models/EnrichedSuiAddress.ts
function EnrichedSuiAddressFromJSON(json) {
  return EnrichedSuiAddressFromJSONTyped(json, false);
}
function EnrichedSuiAddressFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "vault": json["vault"] == null ? void 0 : VaultRefFromJSON(json["vault"]),
    "explorerUrl": json["explorer_url"] == null ? void 0 : json["explorer_url"],
    "contact": json["contact"] == null ? void 0 : ContactRefFromJSON(json["contact"]),
    "type": json["type"],
    "address": json["address"]
  };
}

// src/openapi/models/EnrichedTonAddress.ts
function EnrichedTonAddressFromJSON(json) {
  return EnrichedTonAddressFromJSONTyped(json, false);
}
function EnrichedTonAddressFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "vault": json["vault"] == null ? void 0 : VaultRefFromJSON(json["vault"]),
    "explorerUrl": json["explorer_url"] == null ? void 0 : json["explorer_url"],
    "contact": json["contact"] == null ? void 0 : ContactRefFromJSON(json["contact"]),
    "type": json["type"],
    "rawAccount": json["raw_account"],
    "base64UrlBounceableAccount": json["base64_url_bounceable_account"],
    "base64UrlNonBounceableAccount": json["base64_url_non_bounceable_account"],
    "originalAccount": json["original_account"]
  };
}

// src/openapi/models/EnrichedTronAddress.ts
function EnrichedTronAddressFromJSON(json) {
  return EnrichedTronAddressFromJSONTyped(json, false);
}
function EnrichedTronAddressFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "vault": json["vault"] == null ? void 0 : VaultRefFromJSON(json["vault"]),
    "explorerUrl": json["explorer_url"] == null ? void 0 : json["explorer_url"],
    "contact": json["contact"] == null ? void 0 : ContactRefFromJSON(json["contact"]),
    "type": json["type"],
    "address": json["address"]
  };
}

// src/openapi/models/UtxoAddressType.ts
function UtxoAddressTypeFromJSON(json) {
  return UtxoAddressTypeFromJSONTyped(json, false);
}
function UtxoAddressTypeFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}
function UtxoAddressTypeToJSON(value) {
  return value;
}

// src/openapi/models/UtxoAddress.ts
function UtxoAddressFromJSON(json) {
  return UtxoAddressFromJSONTyped(json, false);
}
function UtxoAddressFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "address": json["address"],
    "addressType": UtxoAddressTypeFromJSON(json["address_type"]),
    "chain": UtxoChainFromJSON(json["chain"])
  };
}
function UtxoAddressToJSON(json) {
  return UtxoAddressToJSONTyped(json, false);
}
function UtxoAddressToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "address": value["address"],
    "address_type": UtxoAddressTypeToJSON(value["addressType"]),
    "chain": UtxoChainToJSON(value["chain"])
  };
}

// src/openapi/models/VaultAddressRef.ts
function VaultAddressRefFromJSON(json) {
  return VaultAddressRefFromJSONTyped(json, false);
}
function VaultAddressRefFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "id": json["id"],
    "vaultId": json["vault_id"],
    "name": json["name"],
    "address": json["address"]
  };
}

// src/openapi/models/EnrichedUtxoAddress.ts
function EnrichedUtxoAddressFromJSON(json) {
  return EnrichedUtxoAddressFromJSONTyped(json, false);
}
function EnrichedUtxoAddressFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "vault": json["vault"] == null ? void 0 : VaultRefFromJSON(json["vault"]),
    "explorerUrl": json["explorer_url"] == null ? void 0 : json["explorer_url"],
    "contact": json["contact"] == null ? void 0 : ContactRefFromJSON(json["contact"]),
    "type": json["type"],
    "address": UtxoAddressFromJSON(json["address"]),
    "vaultAddress": json["vault_address"] == null ? void 0 : VaultAddressRefFromJSON(json["vault_address"])
  };
}

// src/openapi/models/EnrichedAddress.ts
function EnrichedAddressFromJSON(json) {
  return EnrichedAddressFromJSONTyped(json, false);
}
function EnrichedAddressFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  switch (json["type"]) {
    case "aptos":
      return Object.assign({}, EnrichedAptosAddressFromJSONTyped(json, true), { type: "aptos" });
    case "cosmos":
      return Object.assign({}, EnrichedCosmosBechAddressFromJSONTyped(json, true), { type: "cosmos" });
    case "evm":
      return Object.assign({}, EnrichedEvmAddressFromJSONTyped(json, true), { type: "evm" });
    case "exchange":
      return Object.assign({}, EnrichedExchangeAddressFromJSONTyped(json, true), { type: "exchange" });
    case "solana":
      return Object.assign({}, EnrichedSolanaAddressFromJSONTyped(json, true), { type: "solana" });
    case "stacks":
      return Object.assign({}, EnrichedStacksAddressFromJSONTyped(json, true), { type: "stacks" });
    case "starknet":
      return Object.assign({}, EnrichedStarknetAddressFromJSONTyped(json, true), { type: "starknet" });
    case "sui":
      return Object.assign({}, EnrichedSuiAddressFromJSONTyped(json, true), { type: "sui" });
    case "ton":
      return Object.assign({}, EnrichedTonAddressFromJSONTyped(json, true), { type: "ton" });
    case "tron":
      return Object.assign({}, EnrichedTronAddressFromJSONTyped(json, true), { type: "tron" });
    case "utxo":
      return Object.assign({}, EnrichedUtxoAddressFromJSONTyped(json, true), { type: "utxo" });
    default:
      throw new Error(`No variant of EnrichedAddress exists with 'type=${json["type"]}'`);
  }
}

// src/openapi/models/EnrichedChain.ts
function EnrichedChainFromJSON(json) {
  return EnrichedChainFromJSONTyped(json, false);
}
function EnrichedChainFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  switch (json["chain_type"]) {
    case "aptos":
      return Object.assign({}, EnrichedAptosChainFromJSONTyped(json, true), { chainType: "aptos" });
    case "cosmos":
      return Object.assign({}, EnrichedCosmosChainFromJSONTyped(json, true), { chainType: "cosmos" });
    case "evm":
      return Object.assign({}, EnrichedEvmChainFromJSONTyped(json, true), { chainType: "evm" });
    case "exchange":
      return Object.assign({}, EnrichedExchangeChainFromJSONTyped(json, true), { chainType: "exchange" });
    case "solana":
      return Object.assign({}, EnrichedSolanaChainFromJSONTyped(json, true), { chainType: "solana" });
    case "stacks":
      return Object.assign({}, EnrichedStacksChainFromJSONTyped(json, true), { chainType: "stacks" });
    case "starknet":
      return Object.assign({}, EnrichedStarknetChainFromJSONTyped(json, true), { chainType: "starknet" });
    case "sui":
      return Object.assign({}, EnrichedSuiChainFromJSONTyped(json, true), { chainType: "sui" });
    case "ton":
      return Object.assign({}, EnrichedTonChainFromJSONTyped(json, true), { chainType: "ton" });
    case "tron":
      return Object.assign({}, EnrichedTronChainFromJSONTyped(json, true), { chainType: "tron" });
    case "utxo":
      return Object.assign({}, EnrichedUtxoChainFromJSONTyped(json, true), { chainType: "utxo" });
    default:
      throw new Error(`No variant of EnrichedChain exists with 'chainType=${json["chainType"]}'`);
  }
}

// src/openapi/models/FiatCurrencySymbol.ts
function FiatCurrencySymbolFromJSON(json) {
  return FiatCurrencySymbolFromJSONTyped(json, false);
}
function FiatCurrencySymbolFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// src/openapi/models/FiatCurrency.ts
function FiatCurrencyFromJSON(json) {
  return FiatCurrencyFromJSONTyped(json, false);
}
function FiatCurrencyFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "currencySymbol": FiatCurrencySymbolFromJSON(json["currency_symbol"]),
    "decimals": json["decimals"]
  };
}

// src/openapi/models/Price.ts
function PriceFromJSON(json) {
  return PriceFromJSONTyped(json, false);
}
function PriceFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "price": json["price"],
    "priceFloat": json["price_float"],
    "fiatCurrency": FiatCurrencyFromJSON(json["fiat_currency"])
  };
}

// src/openapi/models/CosmosNativeCoin.ts
function CosmosNativeCoinFromJSON(json) {
  return CosmosNativeCoinFromJSONTyped(json, false);
}
function CosmosNativeCoinFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "name": json["name"],
    "symbol": json["symbol"],
    "display": json["display"] == null ? void 0 : json["display"],
    "description": json["description"] == null ? void 0 : json["description"],
    "baseDenom": json["base_denom"],
    "denom": json["denom"],
    "decimals": json["decimals"],
    "logoUrl": json["logo_url"] == null ? void 0 : json["logo_url"],
    "explorerUrl": json["explorer_url"] == null ? void 0 : json["explorer_url"],
    "type": json["type"]
  };
}

// src/openapi/models/EnrichedCosmosNativeAssetIdentifier.ts
function EnrichedCosmosNativeAssetIdentifierFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "chain": EnrichedCosmosChainFromJSON(json["chain"]),
    "type": json["type"],
    "coin": CosmosNativeCoinFromJSON(json["coin"])
  };
}

// src/openapi/models/CosmosToken.ts
function CosmosTokenFromJSON(json) {
  return CosmosTokenFromJSONTyped(json, false);
}
function CosmosTokenFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "name": json["name"],
    "symbol": json["symbol"],
    "display": json["display"] == null ? void 0 : json["display"],
    "description": json["description"] == null ? void 0 : json["description"],
    "baseDenom": json["base_denom"],
    "denom": json["denom"],
    "decimals": json["decimals"],
    "logoUrl": json["logo_url"] == null ? void 0 : json["logo_url"],
    "explorerUrl": json["explorer_url"] == null ? void 0 : json["explorer_url"],
    "type": json["type"]
  };
}

// src/openapi/models/EnrichedCosmosTokenAssetIdentifier.ts
function EnrichedCosmosTokenAssetIdentifierFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "chain": EnrichedCosmosChainFromJSON(json["chain"]),
    "type": json["type"],
    "coin": CosmosTokenFromJSON(json["coin"])
  };
}

// src/openapi/models/EnrichedCosmosAssetIdentifierDetails.ts
function EnrichedCosmosAssetIdentifierDetailsFromJSON(json) {
  return EnrichedCosmosAssetIdentifierDetailsFromJSONTyped(json, false);
}
function EnrichedCosmosAssetIdentifierDetailsFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  switch (json["type"]) {
    case "native":
      return Object.assign({}, EnrichedCosmosNativeAssetIdentifierFromJSONTyped(json, true), { type: "native" });
    case "token":
      return Object.assign({}, EnrichedCosmosTokenAssetIdentifierFromJSONTyped(json, true), { type: "token" });
    default:
      throw new Error(`No variant of EnrichedCosmosAssetIdentifierDetails exists with 'type=${json["type"]}'`);
  }
}

// src/openapi/models/EnrichedCosmosAssetIdentifier.ts
function EnrichedCosmosAssetIdentifierFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "type": json["type"],
    "details": EnrichedCosmosAssetIdentifierDetailsFromJSON(json["details"])
  };
}

// src/openapi/models/EnrichedEvmErc1155AssetIdentifier.ts
function EnrichedEvmErc1155AssetIdentifierFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "chain": EnrichedEvmChainFromJSON(json["chain"]),
    "type": json["type"],
    "token": EnrichedEvmAddressFromJSON(json["token"]),
    "tokenId": json["token_id"]
  };
}

// src/openapi/models/EnrichedEvmErc20AssetIdentifier.ts
function EnrichedEvmErc20AssetIdentifierFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "chain": EnrichedEvmChainFromJSON(json["chain"]),
    "type": json["type"],
    "token": EnrichedEvmAddressFromJSON(json["token"])
  };
}

// src/openapi/models/EnrichedEvmErc721AssetIdentifier.ts
function EnrichedEvmErc721AssetIdentifierFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "chain": EnrichedEvmChainFromJSON(json["chain"]),
    "type": json["type"],
    "token": EnrichedEvmAddressFromJSON(json["token"]),
    "tokenId": json["token_id"]
  };
}

// src/openapi/models/EnrichedEvmHyperLiquidAssetIdentifier.ts
function EnrichedEvmHyperLiquidAssetIdentifierFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "chain": EnrichedEvmChainFromJSON(json["chain"]),
    "type": json["type"],
    "tokenId": json["token_id"],
    "index": json["index"]
  };
}

// src/openapi/models/EnrichedEvmNativeAssetIdentifier.ts
function EnrichedEvmNativeAssetIdentifierFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "chain": EnrichedEvmChainFromJSON(json["chain"]),
    "type": json["type"]
  };
}

// src/openapi/models/EnrichedEvmAssetIdentifierDetails.ts
function EnrichedEvmAssetIdentifierDetailsFromJSON(json) {
  return EnrichedEvmAssetIdentifierDetailsFromJSONTyped(json, false);
}
function EnrichedEvmAssetIdentifierDetailsFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  switch (json["type"]) {
    case "erc1155":
      return Object.assign({}, EnrichedEvmErc1155AssetIdentifierFromJSONTyped(json, true), { type: "erc1155" });
    case "erc20":
      return Object.assign({}, EnrichedEvmErc20AssetIdentifierFromJSONTyped(json, true), { type: "erc20" });
    case "erc721":
      return Object.assign({}, EnrichedEvmErc721AssetIdentifierFromJSONTyped(json, true), { type: "erc721" });
    case "hyperliquid":
      return Object.assign({}, EnrichedEvmHyperLiquidAssetIdentifierFromJSONTyped(json, true), { type: "hyperliquid" });
    case "native":
      return Object.assign({}, EnrichedEvmNativeAssetIdentifierFromJSONTyped(json, true), { type: "native" });
    default:
      throw new Error(`No variant of EnrichedEvmAssetIdentifierDetails exists with 'type=${json["type"]}'`);
  }
}

// src/openapi/models/EnrichedEvmAssetIdentifier.ts
function EnrichedEvmAssetIdentifierFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "type": json["type"],
    "details": EnrichedEvmAssetIdentifierDetailsFromJSON(json["details"])
  };
}

// src/openapi/models/EnrichedSolanaNativeAssetIdentifier.ts
function EnrichedSolanaNativeAssetIdentifierFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "chain": EnrichedSolanaChainFromJSON(json["chain"]),
    "type": json["type"]
  };
}

// src/openapi/models/EnrichedSolanaSplTokenAssetIdentifier.ts
function EnrichedSolanaSplTokenAssetIdentifierFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "chain": EnrichedSolanaChainFromJSON(json["chain"]),
    "type": json["type"],
    "token": EnrichedSolanaAddressFromJSON(json["token"])
  };
}

// src/openapi/models/EnrichedSolanaAssetIdentifierDetails.ts
function EnrichedSolanaAssetIdentifierDetailsFromJSON(json) {
  return EnrichedSolanaAssetIdentifierDetailsFromJSONTyped(json, false);
}
function EnrichedSolanaAssetIdentifierDetailsFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  switch (json["type"]) {
    case "native":
      return Object.assign({}, EnrichedSolanaNativeAssetIdentifierFromJSONTyped(json, true), { type: "native" });
    case "spl_token":
      return Object.assign({}, EnrichedSolanaSplTokenAssetIdentifierFromJSONTyped(json, true), { type: "spl_token" });
    default:
      throw new Error(`No variant of EnrichedSolanaAssetIdentifierDetails exists with 'type=${json["type"]}'`);
  }
}

// src/openapi/models/EnrichedSolanaAssetIdentifier.ts
function EnrichedSolanaAssetIdentifierFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "type": json["type"],
    "details": EnrichedSolanaAssetIdentifierDetailsFromJSON(json["details"])
  };
}

// src/openapi/models/EnrichedSuiCoin.ts
function EnrichedSuiCoinFromJSON(json) {
  return EnrichedSuiCoinFromJSONTyped(json, false);
}
function EnrichedSuiCoinFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "type": json["type"],
    "coinType": json["coin_type"],
    "name": json["name"],
    "symbol": json["symbol"],
    "decimals": json["decimals"],
    "logoUrl": json["logo_url"] == null ? void 0 : json["logo_url"]
  };
}

// src/openapi/models/EnrichedSuiCoinAssetIdentifier.ts
function EnrichedSuiCoinAssetIdentifierFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "chain": EnrichedSuiChainFromJSON(json["chain"]),
    "type": json["type"],
    "coin": EnrichedSuiCoinFromJSON(json["coin"])
  };
}

// src/openapi/models/EnrichedSuiNativeAssetIdentifier.ts
function EnrichedSuiNativeAssetIdentifierFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "chain": EnrichedSuiChainFromJSON(json["chain"]),
    "type": json["type"]
  };
}

// src/openapi/models/EnrichedSuiAssetIdentifierDetails.ts
function EnrichedSuiAssetIdentifierDetailsFromJSON(json) {
  return EnrichedSuiAssetIdentifierDetailsFromJSONTyped(json, false);
}
function EnrichedSuiAssetIdentifierDetailsFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  switch (json["type"]) {
    case "coin":
      return Object.assign({}, EnrichedSuiCoinAssetIdentifierFromJSONTyped(json, true), { type: "coin" });
    case "native":
      return Object.assign({}, EnrichedSuiNativeAssetIdentifierFromJSONTyped(json, true), { type: "native" });
    default:
      throw new Error(`No variant of EnrichedSuiAssetIdentifierDetails exists with 'type=${json["type"]}'`);
  }
}

// src/openapi/models/EnrichedSuiAssetIdentifier.ts
function EnrichedSuiAssetIdentifierFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "type": json["type"],
    "details": EnrichedSuiAssetIdentifierDetailsFromJSON(json["details"])
  };
}

// src/openapi/models/EnrichedUtxoNativeAssetIdentifier.ts
function EnrichedUtxoNativeAssetIdentifierFromJSON(json) {
  return EnrichedUtxoNativeAssetIdentifierFromJSONTyped(json, false);
}
function EnrichedUtxoNativeAssetIdentifierFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "type": json["type"],
    "chain": EnrichedUtxoChainFromJSON(json["chain"])
  };
}

// src/openapi/models/EnrichedUtxoAssetIdentifier.ts
function EnrichedUtxoAssetIdentifierFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "type": json["type"],
    "details": EnrichedUtxoNativeAssetIdentifierFromJSON(json["details"])
  };
}

// src/openapi/models/EnrichedAssetIdentifier.ts
function EnrichedAssetIdentifierFromJSON(json) {
  return EnrichedAssetIdentifierFromJSONTyped(json, false);
}
function EnrichedAssetIdentifierFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  switch (json["type"]) {
    case "cosmos":
      return Object.assign({}, EnrichedCosmosAssetIdentifierFromJSONTyped(json, true), { type: "cosmos" });
    case "evm":
      return Object.assign({}, EnrichedEvmAssetIdentifierFromJSONTyped(json, true), { type: "evm" });
    case "solana":
      return Object.assign({}, EnrichedSolanaAssetIdentifierFromJSONTyped(json, true), { type: "solana" });
    case "sui":
      return Object.assign({}, EnrichedSuiAssetIdentifierFromJSONTyped(json, true), { type: "sui" });
    case "utxo":
      return Object.assign({}, EnrichedUtxoAssetIdentifierFromJSONTyped(json, true), { type: "utxo" });
    default:
      throw new Error(`No variant of EnrichedAssetIdentifier exists with 'type=${json["type"]}'`);
  }
}

// src/openapi/models/PricedAsset.ts
function PricedAssetFromJSON(json) {
  return PricedAssetFromJSONTyped(json, false);
}
function PricedAssetFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "type": json["type"],
    "assetIdentifier": json["asset_identifier"] == null ? void 0 : EnrichedAssetIdentifierFromJSON(json["asset_identifier"]),
    "assetInfo": AssetInfoFromJSON(json["asset_info"]),
    "price": json["price"] == null ? void 0 : PriceFromJSON(json["price"])
  };
}

// src/openapi/models/Balances.ts
function BalancesFromJSON(json) {
  return BalancesFromJSONTyped(json, false);
}
function BalancesFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "mined": json["mined"],
    "pendingIncoming": json["pending_incoming"]
  };
}

// src/openapi/models/CosmosAssetDetails.ts
function CosmosAssetDetailsFromJSON(json) {
  return CosmosAssetDetailsFromJSONTyped(json, false);
}
function CosmosAssetDetailsFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "chain": EnrichedCosmosChainFromJSON(json["chain"]),
    "type": json["type"]
  };
}

// src/openapi/models/CosmosAsset.ts
function CosmosAssetFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "id": json["id"],
    "decimals": json["decimals"],
    "price": json["price"] == null ? void 0 : PriceFromJSON(json["price"]),
    "name": json["name"],
    "symbol": json["symbol"],
    "hidden": json["hidden"],
    "verified": json["verified"],
    "assetIdentifier": EnrichedAssetIdentifierFromJSON(json["asset_identifier"]),
    "metadataUri": json["metadata_uri"] == null ? void 0 : json["metadata_uri"],
    "type": json["type"],
    "details": CosmosAssetDetailsFromJSON(json["details"])
  };
}

// src/openapi/models/EvmErc1155Asset.ts
function EvmErc1155AssetFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "chain": EnrichedEvmChainFromJSON(json["chain"]),
    "type": json["type"],
    "token": EnrichedEvmAddressFromJSON(json["token"]),
    "tokenId": json["token_id"]
  };
}

// src/openapi/models/EvmErc20Asset.ts
function EvmErc20AssetFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "chain": EnrichedEvmChainFromJSON(json["chain"]),
    "type": json["type"],
    "token": EnrichedEvmAddressFromJSON(json["token"])
  };
}

// src/openapi/models/EvmErc721Asset.ts
function EvmErc721AssetFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "chain": EnrichedEvmChainFromJSON(json["chain"]),
    "type": json["type"],
    "token": EnrichedEvmAddressFromJSON(json["token"]),
    "tokenId": json["token_id"]
  };
}

// src/openapi/models/EvmHyperLiquidAsset.ts
function EvmHyperLiquidAssetFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "type": json["type"],
    "tokenId": json["token_id"],
    "index": json["index"],
    "chain": EnrichedEvmChainFromJSON(json["chain"])
  };
}

// src/openapi/models/EvmNativeAsset.ts
function EvmNativeAssetFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "chain": EnrichedEvmChainFromJSON(json["chain"]),
    "type": json["type"]
  };
}

// src/openapi/models/EvmAssetDetails.ts
function EvmAssetDetailsFromJSON(json) {
  return EvmAssetDetailsFromJSONTyped(json, false);
}
function EvmAssetDetailsFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  switch (json["type"]) {
    case "evm_erc1155_asset":
      return Object.assign({}, EvmErc1155AssetFromJSONTyped(json, true), { type: "evm_erc1155_asset" });
    case "evm_erc20_asset":
      return Object.assign({}, EvmErc20AssetFromJSONTyped(json, true), { type: "evm_erc20_asset" });
    case "evm_erc721_asset":
      return Object.assign({}, EvmErc721AssetFromJSONTyped(json, true), { type: "evm_erc721_asset" });
    case "evm_hyperliquid_asset":
      return Object.assign({}, EvmHyperLiquidAssetFromJSONTyped(json, true), { type: "evm_hyperliquid_asset" });
    case "evm_native_asset":
      return Object.assign({}, EvmNativeAssetFromJSONTyped(json, true), { type: "evm_native_asset" });
    default:
      throw new Error(`No variant of EvmAssetDetails exists with 'type=${json["type"]}'`);
  }
}

// src/openapi/models/EvmAsset.ts
function EvmAssetFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "id": json["id"],
    "decimals": json["decimals"],
    "price": json["price"] == null ? void 0 : PriceFromJSON(json["price"]),
    "name": json["name"],
    "symbol": json["symbol"],
    "hidden": json["hidden"],
    "verified": json["verified"],
    "assetIdentifier": EnrichedAssetIdentifierFromJSON(json["asset_identifier"]),
    "metadataUri": json["metadata_uri"] == null ? void 0 : json["metadata_uri"],
    "type": json["type"],
    "details": EvmAssetDetailsFromJSON(json["details"])
  };
}

// src/openapi/models/SolanaAssetDetails.ts
function SolanaAssetDetailsFromJSON(json) {
  return SolanaAssetDetailsFromJSONTyped(json, false);
}
function SolanaAssetDetailsFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "chain": EnrichedSolanaChainFromJSON(json["chain"]),
    "type": json["type"]
  };
}

// src/openapi/models/SolanaAsset.ts
function SolanaAssetFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "id": json["id"],
    "decimals": json["decimals"],
    "price": json["price"] == null ? void 0 : PriceFromJSON(json["price"]),
    "name": json["name"],
    "symbol": json["symbol"],
    "hidden": json["hidden"],
    "verified": json["verified"],
    "assetIdentifier": EnrichedAssetIdentifierFromJSON(json["asset_identifier"]),
    "metadataUri": json["metadata_uri"] == null ? void 0 : json["metadata_uri"],
    "type": json["type"],
    "details": SolanaAssetDetailsFromJSON(json["details"])
  };
}

// src/openapi/models/SuiAssetDetails.ts
function SuiAssetDetailsFromJSON(json) {
  return SuiAssetDetailsFromJSONTyped(json, false);
}
function SuiAssetDetailsFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "chain": EnrichedSuiChainFromJSON(json["chain"]),
    "type": json["type"]
  };
}

// src/openapi/models/SuiAsset.ts
function SuiAssetFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "id": json["id"],
    "decimals": json["decimals"],
    "price": json["price"] == null ? void 0 : PriceFromJSON(json["price"]),
    "name": json["name"],
    "symbol": json["symbol"],
    "hidden": json["hidden"],
    "verified": json["verified"],
    "assetIdentifier": EnrichedAssetIdentifierFromJSON(json["asset_identifier"]),
    "metadataUri": json["metadata_uri"] == null ? void 0 : json["metadata_uri"],
    "type": json["type"],
    "details": SuiAssetDetailsFromJSON(json["details"])
  };
}

// src/openapi/models/UtxoNativeAsset.ts
function UtxoNativeAssetFromJSON(json) {
  return UtxoNativeAssetFromJSONTyped(json, false);
}
function UtxoNativeAssetFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "chain": EnrichedUtxoChainFromJSON(json["chain"]),
    "type": json["type"]
  };
}

// src/openapi/models/UtxoAsset.ts
function UtxoAssetFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "id": json["id"],
    "decimals": json["decimals"],
    "price": json["price"] == null ? void 0 : PriceFromJSON(json["price"]),
    "name": json["name"],
    "symbol": json["symbol"],
    "hidden": json["hidden"],
    "verified": json["verified"],
    "assetIdentifier": EnrichedAssetIdentifierFromJSON(json["asset_identifier"]),
    "metadataUri": json["metadata_uri"] == null ? void 0 : json["metadata_uri"],
    "type": json["type"],
    "details": UtxoNativeAssetFromJSON(json["details"])
  };
}

// src/openapi/models/Asset.ts
function AssetFromJSON(json) {
  return AssetFromJSONTyped(json, false);
}
function AssetFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  switch (json["type"]) {
    case "cosmos_asset":
      return Object.assign({}, CosmosAssetFromJSONTyped(json, true), { type: "cosmos_asset" });
    case "evm_asset":
      return Object.assign({}, EvmAssetFromJSONTyped(json, true), { type: "evm_asset" });
    case "solana_asset":
      return Object.assign({}, SolanaAssetFromJSONTyped(json, true), { type: "solana_asset" });
    case "sui_asset":
      return Object.assign({}, SuiAssetFromJSONTyped(json, true), { type: "sui_asset" });
    case "utxo_asset":
      return Object.assign({}, UtxoAssetFromJSONTyped(json, true), { type: "utxo_asset" });
    default:
      throw new Error(`No variant of Asset exists with 'type=${json["type"]}'`);
  }
}

// src/openapi/models/OwnedAsset.ts
function OwnedAssetFromJSON(json) {
  return OwnedAssetFromJSONTyped(json, false);
}
function OwnedAssetFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "asset": json["asset"] == null ? void 0 : AssetFromJSON(json["asset"]),
    "pricedAsset": PricedAssetFromJSON(json["priced_asset"]),
    "balance": json["balance"],
    "balances": BalancesFromJSON(json["balances"])
  };
}

// src/openapi/models/AllowanceDetails.ts
function AllowanceDetailsFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "type": json["type"],
    "spender": EnrichedEvmAddressFromJSON(json["spender"])
  };
}

// src/openapi/models/Erc1155Contract.ts
function Erc1155ContractFromJSON(json) {
  return Erc1155ContractFromJSONTyped(json, false);
}
function Erc1155ContractFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "name": json["name"] == null ? void 0 : json["name"],
    "dapp": json["dapp"] == null ? void 0 : DappFromJSON(json["dapp"]),
    "isVerified": json["is_verified"],
    "token": Erc1155FromJSON(json["token"])
  };
}

// src/openapi/models/Erc1155AllowanceForAllChange.ts
function Erc1155AllowanceForAllChangeFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "pricedAsset": PricedAssetFromJSON(json["priced_asset"]),
    "type": json["type"],
    "owner": EnrichedEvmAddressFromJSON(json["owner"]),
    "operator": EnrichedEvmAddressFromJSON(json["operator"]),
    "approved": json["approved"],
    "tokenContract": Erc1155ContractFromJSON(json["token_contract"])
  };
}

// src/openapi/models/Erc20Contract.ts
function Erc20ContractFromJSON(json) {
  return Erc20ContractFromJSONTyped(json, false);
}
function Erc20ContractFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "name": json["name"] == null ? void 0 : json["name"],
    "dapp": json["dapp"] == null ? void 0 : DappFromJSON(json["dapp"]),
    "isVerified": json["is_verified"],
    "token": Erc20FromJSON(json["token"])
  };
}

// src/openapi/models/Erc20AllowanceChange.ts
function Erc20AllowanceChangeFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "pricedAsset": PricedAssetFromJSON(json["priced_asset"]),
    "type": json["type"],
    "owner": EnrichedEvmAddressFromJSON(json["owner"]),
    "spender": EnrichedEvmAddressFromJSON(json["spender"]),
    "amount": json["amount"],
    "tokenContract": Erc20ContractFromJSON(json["token_contract"]),
    "price": json["price"] == null ? void 0 : PriceFromJSON(json["price"])
  };
}

// src/openapi/models/Erc721Contract.ts
function Erc721ContractFromJSON(json) {
  return Erc721ContractFromJSONTyped(json, false);
}
function Erc721ContractFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "name": json["name"] == null ? void 0 : json["name"],
    "dapp": json["dapp"] == null ? void 0 : DappFromJSON(json["dapp"]),
    "isVerified": json["is_verified"],
    "token": Erc721FromJSON(json["token"])
  };
}

// src/openapi/models/Erc721AllowanceChange.ts
function Erc721AllowanceChangeFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "pricedAsset": PricedAssetFromJSON(json["priced_asset"]),
    "type": json["type"],
    "owner": EnrichedEvmAddressFromJSON(json["owner"]),
    "operator": EnrichedEvmAddressFromJSON(json["operator"]),
    "tokenId": json["token_id"],
    "tokenContract": Erc721ContractFromJSON(json["token_contract"]),
    "price": json["price"] == null ? void 0 : PriceFromJSON(json["price"])
  };
}

// src/openapi/models/Erc721AllowanceForAllChange.ts
function Erc721AllowanceForAllChangeFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "pricedAsset": PricedAssetFromJSON(json["priced_asset"]),
    "type": json["type"],
    "owner": EnrichedEvmAddressFromJSON(json["owner"]),
    "operator": EnrichedEvmAddressFromJSON(json["operator"]),
    "approved": json["approved"],
    "tokenContract": Erc721ContractFromJSON(json["token_contract"])
  };
}

// src/openapi/models/AllowanceEffect.ts
function AllowanceEffectFromJSON(json) {
  return AllowanceEffectFromJSONTyped(json, false);
}
function AllowanceEffectFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  switch (json["type"]) {
    case "erc1155_for_all":
      return Object.assign({}, Erc1155AllowanceForAllChangeFromJSONTyped(json, true), { type: "erc1155_for_all" });
    case "erc20":
      return Object.assign({}, Erc20AllowanceChangeFromJSONTyped(json, true), { type: "erc20" });
    case "erc721":
      return Object.assign({}, Erc721AllowanceChangeFromJSONTyped(json, true), { type: "erc721" });
    case "erc721_for_all":
      return Object.assign({}, Erc721AllowanceForAllChangeFromJSONTyped(json, true), { type: "erc721_for_all" });
    default:
      throw new Error(`No variant of AllowanceEffect exists with 'type=${json["type"]}'`);
  }
}

// src/openapi/models/AminoMessage.ts
function AminoMessageFromJSON(json) {
  return AminoMessageFromJSONTyped(json, false);
}
function AminoMessageFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "type": json["type"],
    "value": json["value"]
  };
}
function AminoMessageToJSON(json) {
  return AminoMessageToJSONTyped(json, false);
}
function AminoMessageToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "type": value["type"],
    "value": value["value"]
  };
}

// src/openapi/models/AminoMessagesList.ts
function AminoMessagesListFromJSON(json) {
  return AminoMessagesListFromJSONTyped(json, false);
}
function AminoMessagesListFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "format": json["format"],
    "messages": json["messages"].map(AminoMessageFromJSON)
  };
}

// src/openapi/models/StdCoin.ts
function StdCoinToJSON(json) {
  return StdCoinToJSONTyped(json, false);
}
function StdCoinToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "denom": value["denom"],
    "amount": value["amount"]
  };
}

// src/openapi/models/StdFeeRequest.ts
function StdFeeRequestToJSON(json) {
  return StdFeeRequestToJSONTyped(json, false);
}
function StdFeeRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "amount": value["amount"].map(StdCoinToJSON),
    "gas": value["gas"],
    "payer": value["payer"],
    "granter": value["granter"],
    "fee_payer": value["feePayer"]
  };
}

// src/openapi/models/AminoRequestData.ts
function AminoRequestDataToJSON(json) {
  return AminoRequestDataToJSONTyped(json, false);
}
function AminoRequestDataToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "format": value["format"],
    "messages": value["messages"].map(AminoMessageToJSON),
    "memo": value["memo"],
    "std_fee": StdFeeRequestToJSON(value["stdFee"]),
    "timeout_height": value["timeoutHeight"]
  };
}

// src/openapi/models/CosmosNativeCoinWithAmount.ts
function CosmosNativeCoinWithAmountFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "amount": json["amount"],
    "type": json["type"],
    "coin": CosmosNativeCoinFromJSON(json["coin"])
  };
}

// src/openapi/models/CosmosTokenWithAmount.ts
function CosmosTokenWithAmountFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "amount": json["amount"],
    "type": json["type"],
    "coin": CosmosTokenFromJSON(json["coin"])
  };
}

// src/openapi/models/CosmosCoinWithAmountCoinWithAmount.ts
function CosmosCoinWithAmountCoinWithAmountFromJSON(json) {
  return CosmosCoinWithAmountCoinWithAmountFromJSONTyped(json, false);
}
function CosmosCoinWithAmountCoinWithAmountFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  switch (json["type"]) {
    case "native":
      return Object.assign({}, CosmosNativeCoinWithAmountFromJSONTyped(json, true), { type: "native" });
    case "token":
      return Object.assign({}, CosmosTokenWithAmountFromJSONTyped(json, true), { type: "token" });
    default:
      throw new Error(`No variant of CosmosCoinWithAmountCoinWithAmount exists with 'type=${json["type"]}'`);
  }
}

// src/openapi/models/CosmosCoinWithAmount.ts
function CosmosCoinWithAmountFromJSON(json) {
  return CosmosCoinWithAmountFromJSONTyped(json, false);
}
function CosmosCoinWithAmountFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "coinWithAmount": CosmosCoinWithAmountCoinWithAmountFromJSON(json["coin_with_amount"])
  };
}

// src/openapi/models/StdFee.ts
function StdFeeFromJSON(json) {
  return StdFeeFromJSONTyped(json, false);
}
function StdFeeFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "coins": json["coins"].map(CosmosCoinWithAmountFromJSON),
    "gas": json["gas"],
    "payer": json["payer"] == null ? void 0 : EnrichedCosmosBechAddressFromJSON(json["payer"]),
    "granter": json["granter"] == null ? void 0 : EnrichedCosmosBechAddressFromJSON(json["granter"]),
    "feePayer": json["fee_payer"] == null ? void 0 : EnrichedCosmosBechAddressFromJSON(json["fee_payer"])
  };
}

// src/openapi/models/StdSignDoc.ts
function StdSignDocFromJSON(json) {
  return StdSignDocFromJSONTyped(json, false);
}
function StdSignDocFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "chain": EnrichedCosmosChainFromJSON(json["chain"]),
    "accountNumber": json["account_number"],
    "sequence": json["sequence"],
    "timeoutHeight": json["timeout_height"] == null ? void 0 : json["timeout_height"],
    "fee": StdFeeFromJSON(json["fee"]),
    "messages": AminoMessagesListFromJSON(json["messages"]),
    "memo": json["memo"]
  };
}

// src/openapi/models/AminoSignDoc.ts
function AminoSignDocFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "format": json["format"],
    "signDoc": StdSignDocFromJSON(json["sign_doc"])
  };
}

// src/openapi/models/VaultGroupRef.ts
function VaultGroupRefFromJSON(json) {
  return VaultGroupRefFromJSONTyped(json, false);
}
function VaultGroupRefFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "id": json["id"],
    "name": json["name"],
    "vaultCount": json["vault_count"],
    "canCurrentUserCreateOrEditVaults": json["can_current_user_create_or_edit_vaults"]
  };
}

// src/openapi/models/AmlPolicyMatchIncomingActionType.ts
function AmlPolicyMatchIncomingActionTypeFromJSON(json) {
  return AmlPolicyMatchIncomingActionTypeFromJSONTyped(json, false);
}
function AmlPolicyMatchIncomingActionTypeFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// src/openapi/models/UnfreezeApprovalState.ts
function UnfreezeApprovalStateFromJSON(json) {
  return UnfreezeApprovalStateFromJSONTyped(json, false);
}
function UnfreezeApprovalStateFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// src/openapi/models/AmlUnfreezeApprovalRequest.ts
function AmlUnfreezeApprovalRequestFromJSON(json) {
  return AmlUnfreezeApprovalRequestFromJSONTyped(json, false);
}
function AmlUnfreezeApprovalRequestFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "state": UnfreezeApprovalStateFromJSON(json["state"]),
    "approvers": json["approvers"].map(RequestApproverFromJSON)
  };
}

// src/openapi/models/AmlPolicyMatchIncoming.ts
function AmlPolicyMatchIncomingFromJSON(json) {
  return AmlPolicyMatchIncomingFromJSONTyped(json, false);
}
function AmlPolicyMatchIncomingFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "isDefault": json["is_default"],
    "ruleId": json["rule_id"],
    "ruleName": json["rule_name"],
    "actionType": AmlPolicyMatchIncomingActionTypeFromJSON(json["action_type"]),
    "amlUnfreezeApprovalRequest": json["aml_unfreeze_approval_request"] == null ? void 0 : AmlUnfreezeApprovalRequestFromJSON(json["aml_unfreeze_approval_request"])
  };
}

// src/openapi/models/AmlPolicyMatchOutgoingActionType.ts
function AmlPolicyMatchOutgoingActionTypeFromJSON(json) {
  return AmlPolicyMatchOutgoingActionTypeFromJSONTyped(json, false);
}
function AmlPolicyMatchOutgoingActionTypeFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// src/openapi/models/AmlPolicyMatchOutgoing.ts
function AmlPolicyMatchOutgoingFromJSON(json) {
  return AmlPolicyMatchOutgoingFromJSONTyped(json, false);
}
function AmlPolicyMatchOutgoingFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "isDefault": json["is_default"],
    "ruleId": json["rule_id"],
    "ruleName": json["rule_name"],
    "actionType": AmlPolicyMatchOutgoingActionTypeFromJSON(json["action_type"])
  };
}

// src/openapi/models/AmlScanStatus.ts
function AmlScanStatusFromJSON(json) {
  return AmlScanStatusFromJSONTyped(json, false);
}
function AmlScanStatusFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// src/openapi/models/Category.ts
function CategoryFromJSON(json) {
  return CategoryFromJSONTyped(json, false);
}
function CategoryFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "id": json["id"],
    "name": json["name"]
  };
}

// src/openapi/models/ExposureType.ts
function ExposureTypeFromJSON(json) {
  return ExposureTypeFromJSONTyped(json, false);
}
function ExposureTypeFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// src/openapi/models/RiskRating.ts
function RiskRatingFromJSON(json) {
  return RiskRatingFromJSONTyped(json, false);
}
function RiskRatingFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// src/openapi/models/ChainalysisAlert.ts
function ChainalysisAlertFromJSON(json) {
  return ChainalysisAlertFromJSONTyped(json, false);
}
function ChainalysisAlertFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "category": CategoryFromJSON(json["category"]),
    "riskRating": RiskRatingFromJSON(json["risk_rating"]),
    "exposureType": ExposureTypeFromJSON(json["exposure_type"]),
    "service": json["service"] == null ? void 0 : json["service"]
  };
}

// src/openapi/models/ChainalysisScanResult.ts
function ChainalysisScanResultFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "type": json["type"],
    "alerts": json["alerts"].map(ChainalysisAlertFromJSON),
    "externalId": json["external_id"]
  };
}

// src/openapi/models/AmlResultsScanResults.ts
function AmlResultsScanResultsFromJSON(json) {
  return AmlResultsScanResultsFromJSONTyped(json, false);
}
function AmlResultsScanResultsFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  switch (json["type"]) {
    case "chainalysis":
      return Object.assign({}, ChainalysisScanResultFromJSONTyped(json, true), { type: "chainalysis" });
    default:
      throw new Error(`No variant of AmlResultsScanResults exists with 'type=${json["type"]}'`);
  }
}

// src/openapi/models/AmlResults.ts
function AmlResultsFromJSON(json) {
  return AmlResultsFromJSONTyped(json, false);
}
function AmlResultsFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "scanStatus": AmlScanStatusFromJSON(json["scan_status"]),
    "errorMessage": json["error_message"] == null ? void 0 : json["error_message"],
    "scanResults": json["scan_results"] == null ? void 0 : AmlResultsScanResultsFromJSON(json["scan_results"])
  };
}

// src/openapi/models/AptosAccountRepr.ts
function AptosAccountReprToJSON(json) {
  return AptosAccountReprToJSONTyped(json, false);
}
function AptosAccountReprToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "chain_type": value["chainType"],
    "hex_repr": value["hexRepr"]
  };
}

// src/openapi/models/AptosAssetIdentifierRequest.ts
function AptosAssetIdentifierRequestToJSON(json) {
  return AptosAssetIdentifierRequestToJSONTyped(json, false);
}
function AptosAssetIdentifierRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "type": value["type"],
    "details": AptosAssetIdentifierDetailsToJSON(value["details"])
  };
}

// src/openapi/models/AptosBalanceChangeEffectType.ts
function AptosBalanceChangeEffectTypeFromJSON(json) {
  return AptosBalanceChangeEffectTypeFromJSONTyped(json, false);
}
function AptosBalanceChangeEffectTypeFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// src/openapi/models/AptosBalanceChangeEffect.ts
function AptosBalanceChangeEffectFromJSON(json) {
  return AptosBalanceChangeEffectFromJSONTyped(json, false);
}
function AptosBalanceChangeEffectFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "pricedAsset": PricedAssetFromJSON(json["priced_asset"]),
    "diff": json["diff"],
    "type": AptosBalanceChangeEffectTypeFromJSON(json["type"]),
    "address": EnrichedAptosAddressFromJSON(json["address"]),
    "owner": json["owner"] == null ? void 0 : EnrichedAptosAddressFromJSON(json["owner"])
  };
}

// src/openapi/models/AptosBlock.ts
function AptosBlockFromJSON(json) {
  return AptosBlockFromJSONTyped(json, false);
}
function AptosBlockFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "height": json["height"],
    "hash": json["hash"],
    "minedAt": new Date(json["mined_at"])
  };
}

// src/openapi/models/AptosCoinTransferDetails.ts
function AptosCoinTransferDetailsFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "type": json["type"],
    "sender": EnrichedAptosAddressFromJSON(json["sender"]),
    "recipient": EnrichedAptosAddressFromJSON(json["recipient"]),
    "isInternal": json["is_internal"] == null ? void 0 : json["is_internal"]
  };
}

// src/openapi/models/AptosCustomGasPriceRequest.ts
function AptosCustomGasPriceRequestToJSON(json) {
  return AptosCustomGasPriceRequestToJSONTyped(json, false);
}
function AptosCustomGasPriceRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "type": value["type"],
    "price": value["price"]
  };
}

// src/openapi/models/AptosTransferEffectType.ts
function AptosTransferEffectTypeFromJSON(json) {
  return AptosTransferEffectTypeFromJSONTyped(json, false);
}
function AptosTransferEffectTypeFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// src/openapi/models/AptosTransferEffect.ts
function AptosTransferEffectFromJSON(json) {
  return AptosTransferEffectFromJSONTyped(json, false);
}
function AptosTransferEffectFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "pricedAsset": PricedAssetFromJSON(json["priced_asset"]),
    "amount": json["amount"],
    "type": AptosTransferEffectTypeFromJSON(json["type"]),
    "from": EnrichedAptosAddressFromJSON(json["from"]),
    "to": EnrichedAptosAddressFromJSON(json["to"])
  };
}

// src/openapi/models/AptosEffects.ts
function AptosEffectsFromJSON(json) {
  return AptosEffectsFromJSONTyped(json, false);
}
function AptosEffectsFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "balanceChanges": json["balance_changes"].map(AptosBalanceChangeEffectFromJSON),
    "transfers": json["transfers"].map(AptosTransferEffectFromJSON)
  };
}

// src/openapi/models/AptosEntryFunctionPayload.ts
function AptosEntryFunctionPayloadFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "typedArguments": json["typed_arguments"],
    "arguments": json["arguments"],
    "type": json["type"],
    "functionId": json["function_id"],
    "address": EnrichedAptosAddressFromJSON(json["address"]),
    "module": json["module"],
    "functionName": json["function_name"]
  };
}

// src/openapi/models/AptosEntryPointDetails.ts
function AptosEntryPointDetailsFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "type": json["type"],
    "recipient": EnrichedAptosAddressFromJSON(json["recipient"])
  };
}

// src/openapi/models/AptosFeeStatement.ts
function AptosFeeStatementFromJSON(json) {
  return AptosFeeStatementFromJSONTyped(json, false);
}
function AptosFeeStatementFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "executionGasUnits": json["execution_gas_units"],
    "ioGasUnits": json["io_gas_units"],
    "storageFeeOctas": json["storage_fee_octas"],
    "storageFeeRefundOctas": json["storage_fee_refund_octas"],
    "totalChargeGasUnits": json["total_charge_gas_units"],
    "totalGas": json["total_gas"],
    "fiatPrice": json["fiat_price"] == null ? void 0 : PriceFromJSON(json["fiat_price"]),
    "pricedAsset": PricedAssetFromJSON(json["priced_asset"])
  };
}

// src/openapi/models/FeePriorityLevelRequest.ts
function FeePriorityLevelRequestToJSON(value) {
  return value;
}

// src/openapi/models/AptosPriorityGasPriceRequest.ts
function AptosPriorityGasPriceRequestToJSON(json) {
  return AptosPriorityGasPriceRequestToJSONTyped(json, false);
}
function AptosPriorityGasPriceRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "type": value["type"],
    "priority": FeePriorityLevelRequestToJSON(value["priority"])
  };
}

// src/openapi/models/AptosGasConfigRequestPrice.ts
function AptosGasConfigRequestPriceToJSON(json) {
  return AptosGasConfigRequestPriceToJSONTyped(json, false);
}
function AptosGasConfigRequestPriceToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  switch (value["type"]) {
    case "custom":
      return Object.assign({}, AptosCustomGasPriceRequestToJSON(value), { type: "custom" });
    case "priority":
      return Object.assign({}, AptosPriorityGasPriceRequestToJSON(value), { type: "priority" });
    default:
      throw new Error(`No variant of AptosGasConfigRequestPrice exists with 'type=${value["type"]}'`);
  }
}

// src/openapi/models/AptosGasConfigRequest.ts
function AptosGasConfigRequestToJSON(json) {
  return AptosGasConfigRequestToJSONTyped(json, false);
}
function AptosGasConfigRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "max_gas": value["maxGas"],
    "price": AptosGasConfigRequestPriceToJSON(value["price"])
  };
}

// src/openapi/models/FeePriorityLevel.ts
function FeePriorityLevelFromJSON(json) {
  return FeePriorityLevelFromJSONTyped(json, false);
}
function FeePriorityLevelFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// src/openapi/models/AptosGasPrice.ts
function AptosGasPriceFromJSON(json) {
  return AptosGasPriceFromJSONTyped(json, false);
}
function AptosGasPriceFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "priorityLevel": FeePriorityLevelFromJSON(json["priority_level"]),
    "price": json["price"],
    "fiatPrice": json["fiat_price"] == null ? void 0 : PriceFromJSON(json["fiat_price"])
  };
}

// src/openapi/models/AptosGasData.ts
function AptosGasDataFromJSON(json) {
  return AptosGasDataFromJSONTyped(json, false);
}
function AptosGasDataFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "gasLimit": json["gas_limit"],
    "price": AptosGasPriceFromJSON(json["price"])
  };
}

// src/openapi/models/TransactionRiskType.ts
function TransactionRiskTypeFromJSON(json) {
  return TransactionRiskTypeFromJSONTyped(json, false);
}
function TransactionRiskTypeFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// src/openapi/models/TransactionRiskSeverity.ts
function TransactionRiskSeverityFromJSON(json) {
  return TransactionRiskSeverityFromJSONTyped(json, false);
}
function TransactionRiskSeverityFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// src/openapi/models/TransactionRisk.ts
function TransactionRiskFromJSON(json) {
  return TransactionRiskFromJSONTyped(json, false);
}
function TransactionRiskFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "type": TransactionRiskTypeFromJSON(json["type"]),
    "severity": TransactionRiskSeverityFromJSON(json["severity"]),
    "title": json["title"],
    "description": json["description"]
  };
}

// src/openapi/models/SignMode.ts
function SignModeFromJSON(json) {
  return SignModeFromJSONTyped(json, false);
}
function SignModeFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}
function SignModeToJSON(value) {
  return value;
}

// src/openapi/models/BatchData.ts
function BatchDataFromJSON(json) {
  return BatchDataFromJSONTyped(json, false);
}
function BatchDataFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "batchId": json["batch_id"],
    "indexInBatch": json["index_in_batch"],
    "batchSize": json["batch_size"]
  };
}

// src/openapi/models/TransactionPolicyMatchActionType.ts
function TransactionPolicyMatchActionTypeFromJSON(json) {
  return TransactionPolicyMatchActionTypeFromJSONTyped(json, false);
}
function TransactionPolicyMatchActionTypeFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// src/openapi/models/PolicyMatch.ts
function PolicyMatchFromJSON(json) {
  return PolicyMatchFromJSONTyped(json, false);
}
function PolicyMatchFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "isDefault": json["is_default"],
    "ruleId": json["rule_id"],
    "ruleName": json["rule_name"],
    "actionType": TransactionPolicyMatchActionTypeFromJSON(json["action_type"])
  };
}

// src/openapi/models/SignerType.ts
var SignerType = {
  initiator: "initiator",
  apiSigner: "api_signer",
  endUser: "end_user",
  multipleSigners: "multiple_signers"
};
function SignerTypeFromJSON(json) {
  return SignerTypeFromJSONTyped(json, false);
}
function SignerTypeFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}
function SignerTypeToJSON(value) {
  return value;
}

// src/openapi/models/PushMode.ts
var PushMode = {
  auto: "auto",
  manual: "manual",
  deferred: "deferred"
};
function PushModeFromJSON(json) {
  return PushModeFromJSONTyped(json, false);
}
function PushModeFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}
function PushModeToJSON(value) {
  return value;
}

// src/openapi/models/ManagedTransactionData.ts
function ManagedTransactionDataFromJSON(json) {
  return ManagedTransactionDataFromJSONTyped(json, false);
}
function ManagedTransactionDataFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "createdBy": UserRefFromJSON(json["created_by"]),
    "abortedBy": json["aborted_by"] == null ? void 0 : UserRefFromJSON(json["aborted_by"]),
    "deviceSigningRequest": json["device_signing_request"] == null ? void 0 : ActionSigningRequestFromJSON(json["device_signing_request"]),
    "approvalRequest": json["approval_request"] == null ? void 0 : ApprovalRequestFromJSON(json["approval_request"]),
    "amlPolicyMatch": json["aml_policy_match"] == null ? void 0 : AmlPolicyMatchOutgoingFromJSON(json["aml_policy_match"]),
    "policyMatch": json["policy_match"] == null ? void 0 : PolicyMatchFromJSON(json["policy_match"]),
    "signerType": SignerTypeFromJSON(json["signer_type"]),
    "risks": json["risks"].map(TransactionRiskFromJSON),
    "errorPushingToBlockchainMessage": json["error_pushing_to_blockchain_message"] == null ? void 0 : json["error_pushing_to_blockchain_message"],
    "originalErrorPushingToBlockchainMessage": json["original_error_pushing_to_blockchain_message"] == null ? void 0 : json["original_error_pushing_to_blockchain_message"],
    "vault": VaultRefFromJSON(json["vault"]),
    "idempotenceId": json["idempotence_id"] == null ? void 0 : json["idempotence_id"],
    "hasCurrentUserVaultPermissions": json["has_current_user_vault_permissions"],
    "batchData": json["batch_data"] == null ? void 0 : BatchDataFromJSON(json["batch_data"]),
    "pushMode": json["push_mode"] == null ? void 0 : PushModeFromJSON(json["push_mode"]),
    "lastPushedAt": json["last_pushed_at"] == null ? void 0 : new Date(json["last_pushed_at"]),
    "signMode": json["sign_mode"] == null ? void 0 : SignModeFromJSON(json["sign_mode"])
  };
}

// src/openapi/models/TransactionSpamState.ts
function TransactionSpamStateFromJSON(json) {
  return TransactionSpamStateFromJSONTyped(json, false);
}
function TransactionSpamStateFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// src/openapi/models/TransactionDirection.ts
function TransactionDirectionFromJSON(json) {
  return TransactionDirectionFromJSONTyped(json, false);
}
function TransactionDirectionFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// src/openapi/models/SignatureSignedBy.ts
function SignatureSignedByFromJSON(json) {
  return SignatureSignedByFromJSONTyped(json, false);
}
function SignatureSignedByFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  switch (json["user_type"]) {
    case "api_signer":
      return Object.assign({}, ApiSignerRefFromJSONTyped(json, true), { userType: "api_signer" });
    case "end_user":
      return Object.assign({}, EndUserRefFromJSONTyped(json, true), { userType: "end_user" });
    case "person":
      return Object.assign({}, PersonRefFromJSONTyped(json, true), { userType: "person" });
    default:
      throw new Error(`No variant of SignatureSignedBy exists with 'userType=${json["userType"]}'`);
  }
}

// src/openapi/models/Signature.ts
function SignatureFromJSON(json) {
  return SignatureFromJSONTyped(json, false);
}
function SignatureFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "data": json["data"],
    "signedBy": json["signed_by"] == null ? void 0 : SignatureSignedByFromJSON(json["signed_by"])
  };
}

// src/openapi/models/PricedErc20.ts
function PricedErc20FromJSON(json) {
  return PricedErc20FromJSONTyped(json, false);
}
function PricedErc20FromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "price": json["price"],
    "priceFloat": json["price_float"],
    "fiatCurrency": FiatCurrencyFromJSON(json["fiat_currency"]),
    "token": Erc20FromJSON(json["token"])
  };
}

// src/openapi/models/EvmPrices.ts
function EvmPricesFromJSON(json) {
  return EvmPricesFromJSONTyped(json, false);
}
function EvmPricesFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "nativeCurrencyPrice": json["native_currency_price"] == null ? void 0 : PriceFromJSON(json["native_currency_price"]),
    "tokenPrices": json["token_prices"] == null ? void 0 : json["token_prices"].map(PricedErc20FromJSON)
  };
}

// src/openapi/models/StateChangeReason.ts
function StateChangeReasonFromJSON(json) {
  return StateChangeReasonFromJSONTyped(json, false);
}
function StateChangeReasonFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// src/openapi/models/NonPushableTransactionState.ts
function NonPushableTransactionStateFromJSON(json) {
  return NonPushableTransactionStateFromJSONTyped(json, false);
}
function NonPushableTransactionStateFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}
function NonPushableTransactionStateToJSON(value) {
  return value;
}

// src/openapi/models/NonPushableTransactionStateChange.ts
function NonPushableTransactionStateChangeFromJSON(json) {
  return NonPushableTransactionStateChangeFromJSONTyped(json, false);
}
function NonPushableTransactionStateChangeFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "changedAt": new Date(json["changed_at"]),
    "reason": json["reason"] == null ? void 0 : StateChangeReasonFromJSON(json["reason"]),
    "assetPrices": json["asset_prices"] == null ? void 0 : json["asset_prices"].map(PricedAssetFromJSON),
    "prices": json["prices"] == null ? void 0 : EvmPricesFromJSON(json["prices"]),
    "previousState": json["previous_state"] == null ? void 0 : NonPushableTransactionStateFromJSON(json["previous_state"]),
    "newState": NonPushableTransactionStateFromJSON(json["new_state"])
  };
}

// src/openapi/models/AptosMessageType.ts
function AptosMessageTypeFromJSON(json) {
  return AptosMessageTypeFromJSONTyped(json, false);
}
function AptosMessageTypeFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// src/openapi/models/AptosMessage.ts
function AptosMessageFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "id": json["id"],
    "createdAt": new Date(json["created_at"]),
    "modifiedAt": new Date(json["modified_at"]),
    "managedTransactionData": json["managed_transaction_data"] == null ? void 0 : ManagedTransactionDataFromJSON(json["managed_transaction_data"]),
    "signatures": json["signatures"].map(SignatureFromJSON),
    "note": json["note"] == null ? void 0 : json["note"],
    "spamState": json["spam_state"] == null ? void 0 : TransactionSpamStateFromJSON(json["spam_state"]),
    "direction": TransactionDirectionFromJSON(json["direction"]),
    "signedExternally": json["signed_externally"] == null ? void 0 : json["signed_externally"],
    "state": NonPushableTransactionStateFromJSON(json["state"]),
    "stateChanges": json["state_changes"].map(NonPushableTransactionStateChangeFromJSON),
    "type": json["type"],
    "aptosMessageType": AptosMessageTypeFromJSON(json["aptos_message_type"]),
    "rawOriginalMessageToSign": json["raw_original_message_to_sign"],
    "stringOriginalMessageToSign": json["string_original_message_to_sign"],
    "rawFullMessageToSign": json["raw_full_message_to_sign"],
    "stringFullMessageToSign": json["string_full_message_to_sign"],
    "chain": EnrichedAptosChainFromJSON(json["chain"]),
    "sender": EnrichedAptosAddressFromJSON(json["sender"])
  };
}

// src/openapi/models/AptosNativeTransferDetails.ts
function AptosNativeTransferDetailsFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "type": json["type"],
    "sender": EnrichedAptosAddressFromJSON(json["sender"]),
    "recipient": EnrichedAptosAddressFromJSON(json["recipient"]),
    "isInternal": json["is_internal"] == null ? void 0 : json["is_internal"]
  };
}

// src/openapi/models/AptosPersonalMessageRequest.ts
function AptosPersonalMessageRequestToJSON(json) {
  return AptosPersonalMessageRequestToJSONTyped(json, false);
}
function AptosPersonalMessageRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "type": value["type"],
    "should_include_address": value["shouldIncludeAddress"],
    "application": value["application"],
    "should_include_application": value["shouldIncludeApplication"],
    "chain": AptosChainUniqueIdToJSON(value["chain"]),
    "should_include_chain": value["shouldIncludeChain"],
    "message_to_sign": value["messageToSign"],
    "nonce": value["nonce"]
  };
}

// src/openapi/models/AptosRecipientHex.ts
function AptosRecipientHexToJSON(json) {
  return AptosRecipientHexToJSONTyped(json, false);
}
function AptosRecipientHexToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "type": value["type"],
    "address": value["address"]
  };
}

// src/openapi/models/AptosReversionState.ts
function AptosReversionStateFromJSON(json) {
  return AptosReversionStateFromJSONTyped(json, false);
}
function AptosReversionStateFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// src/openapi/models/AptosReversion.ts
function AptosReversionFromJSON(json) {
  return AptosReversionFromJSONTyped(json, false);
}
function AptosReversionFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "state": AptosReversionStateFromJSON(json["state"]),
    "reason": json["reason"] == null ? void 0 : json["reason"]
  };
}

// src/openapi/models/AptosScriptDetails.ts
function AptosScriptDetailsFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "type": json["type"]
  };
}

// src/openapi/models/AptosSuggestedFees.ts
function AptosSuggestedFeesFromJSON(json) {
  return AptosSuggestedFeesFromJSONTyped(json, false);
}
function AptosSuggestedFeesFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "type": json["type"],
    "low": json["low"],
    "medium": json["medium"],
    "high": json["high"],
    "chainUniqueId": AptosChainUniqueIdFromJSON(json["chain_unique_id"])
  };
}

// src/openapi/models/AptosTransactionResult.ts
function AptosTransactionResultFromJSON(json) {
  return AptosTransactionResultFromJSONTyped(json, false);
}
function AptosTransactionResultFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "reversion": AptosReversionFromJSON(json["reversion"]),
    "feeStatement": AptosFeeStatementFromJSON(json["fee_statement"]),
    "effects": AptosEffectsFromJSON(json["effects"]),
    "rawResult": json["raw_result"] == null ? void 0 : json["raw_result"]
  };
}

// src/openapi/models/AptosTransactionAptosTransactionTypeDetails.ts
function AptosTransactionAptosTransactionTypeDetailsFromJSON(json) {
  return AptosTransactionAptosTransactionTypeDetailsFromJSONTyped(json, false);
}
function AptosTransactionAptosTransactionTypeDetailsFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  switch (json["type"]) {
    case "coin_transfer":
      return Object.assign({}, AptosCoinTransferDetailsFromJSONTyped(json, true), { type: "coin_transfer" });
    case "entry_point":
      return Object.assign({}, AptosEntryPointDetailsFromJSONTyped(json, true), { type: "entry_point" });
    case "native_transfer":
      return Object.assign({}, AptosNativeTransferDetailsFromJSONTyped(json, true), { type: "native_transfer" });
    case "script":
      return Object.assign({}, AptosScriptDetailsFromJSONTyped(json, true), { type: "script" });
    default:
      throw new Error(`No variant of AptosTransactionAptosTransactionTypeDetails exists with 'type=${json["type"]}'`);
  }
}

// src/openapi/models/PushableTransactionState.ts
var PushableTransactionState = {
  waitingForApproval: "waiting_for_approval",
  waitingForSigningTrigger: "waiting_for_signing_trigger",
  approved: "approved",
  signed: "signed",
  pushedToBlockchain: "pushed_to_blockchain",
  mined: "mined",
  completed: "completed",
  aborted: "aborted",
  errorPushingToBlockchain: "error_pushing_to_blockchain",
  minedReverted: "mined_reverted",
  completedReverted: "completed_reverted",
  errorSigning: "error_signing",
  stuck: "stuck",
  dropped: "dropped",
  queued: "queued",
  aborting: "aborting",
  accelerating: "accelerating",
  canceling: "canceling",
  accelerated: "accelerated",
  cancelled: "cancelled",
  insufficientFunds: "insufficient_funds"
};
function PushableTransactionStateFromJSON(json) {
  return PushableTransactionStateFromJSONTyped(json, false);
}
function PushableTransactionStateFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}
function PushableTransactionStateToJSON(value) {
  return value;
}

// src/openapi/models/PushableTransactionStateChange.ts
function PushableTransactionStateChangeFromJSON(json) {
  return PushableTransactionStateChangeFromJSONTyped(json, false);
}
function PushableTransactionStateChangeFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "changedAt": new Date(json["changed_at"]),
    "reason": json["reason"] == null ? void 0 : StateChangeReasonFromJSON(json["reason"]),
    "assetPrices": json["asset_prices"] == null ? void 0 : json["asset_prices"].map(PricedAssetFromJSON),
    "prices": json["prices"] == null ? void 0 : EvmPricesFromJSON(json["prices"]),
    "previousState": json["previous_state"] == null ? void 0 : PushableTransactionStateFromJSON(json["previous_state"]),
    "newState": PushableTransactionStateFromJSON(json["new_state"])
  };
}

// src/openapi/models/ScriptPayload.ts
function ScriptPayloadFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "typedArguments": json["typed_arguments"],
    "arguments": json["arguments"],
    "type": json["type"],
    "code": json["code"]
  };
}

// src/openapi/models/AptosTransactionPayload.ts
function AptosTransactionPayloadFromJSON(json) {
  return AptosTransactionPayloadFromJSONTyped(json, false);
}
function AptosTransactionPayloadFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  switch (json["type"]) {
    case "entry_point":
      return Object.assign({}, AptosEntryFunctionPayloadFromJSONTyped(json, true), { type: "entry_point" });
    case "script":
      return Object.assign({}, ScriptPayloadFromJSONTyped(json, true), { type: "script" });
    default:
      throw new Error(`No variant of AptosTransactionPayload exists with 'type=${json["type"]}'`);
  }
}

// src/openapi/models/SimulationStatus.ts
function SimulationStatusFromJSON(json) {
  return SimulationStatusFromJSONTyped(json, false);
}
function SimulationStatusFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// src/openapi/models/SimulationStatusResult.ts
function SimulationStatusResultFromJSON(json) {
  return SimulationStatusResultFromJSONTyped(json, false);
}
function SimulationStatusResultFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "simulationStatus": json["simulation_status"] == null ? void 0 : SimulationStatusFromJSON(json["simulation_status"]),
    "details": json["details"]
  };
}

// src/openapi/models/AptosTransaction.ts
function AptosTransactionFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "id": json["id"],
    "createdAt": new Date(json["created_at"]),
    "modifiedAt": new Date(json["modified_at"]),
    "managedTransactionData": json["managed_transaction_data"] == null ? void 0 : ManagedTransactionDataFromJSON(json["managed_transaction_data"]),
    "signatures": json["signatures"].map(SignatureFromJSON),
    "note": json["note"] == null ? void 0 : json["note"],
    "spamState": json["spam_state"] == null ? void 0 : TransactionSpamStateFromJSON(json["spam_state"]),
    "direction": TransactionDirectionFromJSON(json["direction"]),
    "signedExternally": json["signed_externally"] == null ? void 0 : json["signed_externally"],
    "state": PushableTransactionStateFromJSON(json["state"]),
    "stateChanges": json["state_changes"].map(PushableTransactionStateChangeFromJSON),
    "amlResults": json["aml_results"] == null ? void 0 : AmlResultsFromJSON(json["aml_results"]),
    "incomingAmlPolicyMatch": json["incoming_aml_policy_match"] == null ? void 0 : AmlPolicyMatchIncomingFromJSON(json["incoming_aml_policy_match"]),
    "type": json["type"],
    "aptosTransactionTypeDetails": AptosTransactionAptosTransactionTypeDetailsFromJSON(json["aptos_transaction_type_details"]),
    "chain": EnrichedAptosChainFromJSON(json["chain"]),
    "version": json["version"] == null ? void 0 : json["version"],
    "nonce": json["nonce"] == null ? void 0 : json["nonce"],
    "sender": EnrichedAptosAddressFromJSON(json["sender"]),
    "payload": AptosTransactionPayloadFromJSON(json["payload"]),
    "hash": json["hash"] == null ? void 0 : json["hash"],
    "block": json["block"] == null ? void 0 : AptosBlockFromJSON(json["block"]),
    "gasSubmitted": AptosGasDataFromJSON(json["gas_submitted"]),
    "serializedSignedTransaction": json["serialized_signed_transaction"] == null ? void 0 : json["serialized_signed_transaction"],
    "expectedResult": json["expected_result"] == null ? void 0 : AptosTransactionResultFromJSON(json["expected_result"]),
    "simulationStatusResult": json["simulation_status_result"] == null ? void 0 : SimulationStatusResultFromJSON(json["simulation_status_result"]),
    "minedResult": json["mined_result"] == null ? void 0 : AptosTransactionResultFromJSON(json["mined_result"]),
    "explorerUrl": json["explorer_url"] == null ? void 0 : json["explorer_url"]
  };
}

// src/openapi/models/PendingVaultGroupActionAdd.ts
function PendingVaultGroupActionAddFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "type": json["type"],
    "vaultGroupId": json["vault_group_id"],
    "vaultGroupName": json["vault_group_name"]
  };
}

// src/openapi/models/PendingVaultGroupActionRemove.ts
function PendingVaultGroupActionRemoveFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "type": json["type"]
  };
}

// src/openapi/models/AptosVaultPendingVaultGroupAction.ts
function AptosVaultPendingVaultGroupActionFromJSON(json) {
  return AptosVaultPendingVaultGroupActionFromJSONTyped(json, false);
}
function AptosVaultPendingVaultGroupActionFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  switch (json["type"]) {
    case "add":
      return Object.assign({}, PendingVaultGroupActionAddFromJSONTyped(json, true), { type: "add" });
    case "remove":
      return Object.assign({}, PendingVaultGroupActionRemoveFromJSONTyped(json, true), { type: "remove" });
    default:
      throw new Error(`No variant of AptosVaultPendingVaultGroupAction exists with 'type=${json["type"]}'`);
  }
}

// src/openapi/models/AptosVaultMetadataValue.ts
function AptosVaultMetadataValueFromJSON(json) {
  return AptosVaultMetadataValueFromJSONTyped(json, false);
}
function AptosVaultMetadataValueFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}
function AptosVaultMetadataValueToJSON(json) {
  return AptosVaultMetadataValueToJSONTyped(json, false);
}
function AptosVaultMetadataValueToJSONTyped(value, ignoreDiscriminator = false) {
  return value;
}

// src/openapi/models/VaultOriginType.ts
function VaultOriginTypeFromJSON(json) {
  return VaultOriginTypeFromJSONTyped(json, false);
}
function VaultOriginTypeFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// src/openapi/models/KeysetScope.ts
function KeysetScopeFromJSON(json) {
  return KeysetScopeFromJSONTyped(json, false);
}
function KeysetScopeFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// src/openapi/models/KeysetRef.ts
function KeysetRefFromJSON(json) {
  return KeysetRefFromJSONTyped(json, false);
}
function KeysetRefFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "id": json["id"],
    "name": json["name"],
    "scope": KeysetScopeFromJSON(json["scope"])
  };
}

// src/openapi/models/MasterPublicKey.ts
function MasterPublicKeyFromJSON(json) {
  return MasterPublicKeyFromJSONTyped(json, false);
}
function MasterPublicKeyFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "id": json["id"],
    "xpub": json["xpub"]
  };
}

// src/openapi/models/VaultDerivationInfo.ts
function VaultDerivationInfoFromJSON(json) {
  return VaultDerivationInfoFromJSONTyped(json, false);
}
function VaultDerivationInfoFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "derivationPath": json["derivation_path"],
    "masterPublicKey": MasterPublicKeyFromJSON(json["master_public_key"])
  };
}

// src/openapi/models/AptosVault.ts
function AptosVaultFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "id": json["id"],
    "createdAt": new Date(json["created_at"]),
    "modifiedAt": new Date(json["modified_at"]),
    "metadata": json["metadata"] == null ? void 0 : mapValues(json["metadata"], AptosVaultMetadataValueFromJSON),
    "name": json["name"],
    "createdBy": UserRefFromJSON(json["created_by"]),
    "vaultGroup": VaultGroupRefFromJSON(json["vault_group"]),
    "pendingVaultGroupAction": json["pending_vault_group_action"] == null ? void 0 : AptosVaultPendingVaultGroupActionFromJSON(json["pending_vault_group_action"]),
    "state": VaultStateFromJSON(json["state"]),
    "areAllChainsDisabled": json["are_all_chains_disabled"],
    "derivationPath": json["derivation_path"],
    "publicKeyCompressed": json["public_key_compressed"],
    "derivationInfo": VaultDerivationInfoFromJSON(json["derivation_info"]),
    "keyset": KeysetRefFromJSON(json["keyset"]),
    "keyHolder": json["key_holder"] == null ? void 0 : EndUserRefFromJSON(json["key_holder"]),
    "originType": VaultOriginTypeFromJSON(json["origin_type"]),
    "type": json["type"],
    "address": json["address"]
  };
}

// src/openapi/models/CosmosAssetIdentifierRequest.ts
function CosmosAssetIdentifierRequestToJSON(json) {
  return CosmosAssetIdentifierRequestToJSONTyped(json, false);
}
function CosmosAssetIdentifierRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "type": value["type"],
    "details": CosmosAssetIdentifierDetailsToJSON(value["details"])
  };
}

// src/openapi/models/EvmAssetIdentifierRequest.ts
function EvmAssetIdentifierRequestToJSON(json) {
  return EvmAssetIdentifierRequestToJSONTyped(json, false);
}
function EvmAssetIdentifierRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "type": value["type"],
    "details": EvmAssetIdentifierDetailsToJSON(value["details"])
  };
}

// src/openapi/models/ExchangeAssetIdentifierRequest.ts
function ExchangeAssetIdentifierRequestToJSON(json) {
  return ExchangeAssetIdentifierRequestToJSONTyped(json, false);
}
function ExchangeAssetIdentifierRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "type": value["type"],
    "exchange_type": ExchangeTypeToJSON(value["exchangeType"]),
    "asset_symbol": value["assetSymbol"]
  };
}

// src/openapi/models/SolanaAssetIdentifierRequest.ts
function SolanaAssetIdentifierRequestToJSON(json) {
  return SolanaAssetIdentifierRequestToJSONTyped(json, false);
}
function SolanaAssetIdentifierRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "type": value["type"],
    "details": SolanaAssetIdentifierDetailsToJSON(value["details"])
  };
}

// src/openapi/models/StacksAssetIdentifierRequest.ts
function StacksAssetIdentifierRequestToJSON(json) {
  return StacksAssetIdentifierRequestToJSONTyped(json, false);
}
function StacksAssetIdentifierRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "type": value["type"],
    "details": StacksAssetIdentifierDetailsToJSON(value["details"])
  };
}

// src/openapi/models/StarknetAssetIdentifierRequest.ts
function StarknetAssetIdentifierRequestToJSON(json) {
  return StarknetAssetIdentifierRequestToJSONTyped(json, false);
}
function StarknetAssetIdentifierRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "type": value["type"],
    "details": StarknetAssetIdentifierDetailsToJSON(value["details"])
  };
}

// src/openapi/models/SuiAssetIdentifierRequest.ts
function SuiAssetIdentifierRequestToJSON(json) {
  return SuiAssetIdentifierRequestToJSONTyped(json, false);
}
function SuiAssetIdentifierRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "type": value["type"],
    "details": SuiAssetIdentifierDetailsToJSON(value["details"])
  };
}

// src/openapi/models/TonAssetIdentifierRequest.ts
function TonAssetIdentifierRequestToJSON(json) {
  return TonAssetIdentifierRequestToJSONTyped(json, false);
}
function TonAssetIdentifierRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "type": value["type"],
    "details": TonAssetIdentifierDetailsToJSON(value["details"])
  };
}

// src/openapi/models/TronAssetIdentifierRequest.ts
function TronAssetIdentifierRequestToJSON(json) {
  return TronAssetIdentifierRequestToJSONTyped(json, false);
}
function TronAssetIdentifierRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "type": value["type"],
    "details": TronAssetIdentifierDetailsToJSON(value["details"])
  };
}

// src/openapi/models/SuiPureBoolInput.ts
function SuiPureBoolInputFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "type": json["type"],
    "value": json["value"]
  };
}
function SuiPureBoolInputToJSON(json) {
  return SuiPureBoolInputToJSONTyped(json, false);
}
function SuiPureBoolInputToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "type": value["type"],
    "value": value["value"]
  };
}

// src/openapi/models/SuiPureByteArrayInput.ts
function SuiPureByteArrayInputFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "type": json["type"],
    "value": json["value"]
  };
}
function SuiPureByteArrayInputToJSON(json) {
  return SuiPureByteArrayInputToJSONTyped(json, false);
}
function SuiPureByteArrayInputToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "type": value["type"],
    "value": value["value"]
  };
}

// src/openapi/models/SuiPureNumberInput.ts
function SuiPureNumberInputFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "type": json["type"],
    "value": json["value"]
  };
}
function SuiPureNumberInputToJSON(json) {
  return SuiPureNumberInputToJSONTyped(json, false);
}
function SuiPureNumberInputToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "type": value["type"],
    "value": value["value"]
  };
}

// src/openapi/models/SuiPureStringInput.ts
function SuiPureStringInputFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "type": json["type"],
    "value": json["value"]
  };
}
function SuiPureStringInputToJSON(json) {
  return SuiPureStringInputToJSONTyped(json, false);
}
function SuiPureStringInputToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "type": value["type"],
    "value": value["value"]
  };
}

// src/openapi/models/BaseSuiPureInputValue.ts
function BaseSuiPureInputValueFromJSON(json) {
  return BaseSuiPureInputValueFromJSONTyped(json, false);
}
function BaseSuiPureInputValueFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  switch (json["type"]) {
    case "bool_pure_input":
      return Object.assign({}, SuiPureBoolInputFromJSONTyped(json, true), { type: "bool_pure_input" });
    case "byte_array_pure_input":
      return Object.assign({}, SuiPureByteArrayInputFromJSONTyped(json, true), { type: "byte_array_pure_input" });
    case "number_pure_input":
      return Object.assign({}, SuiPureNumberInputFromJSONTyped(json, true), { type: "number_pure_input" });
    case "string_pure_input":
      return Object.assign({}, SuiPureStringInputFromJSONTyped(json, true), { type: "string_pure_input" });
    default:
      throw new Error(`No variant of BaseSuiPureInputValue exists with 'type=${json["type"]}'`);
  }
}
function BaseSuiPureInputValueToJSON(json) {
  return BaseSuiPureInputValueToJSONTyped(json, false);
}
function BaseSuiPureInputValueToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  switch (value["type"]) {
    case "bool_pure_input":
      return Object.assign({}, SuiPureBoolInputToJSON(value), { type: "bool_pure_input" });
    case "byte_array_pure_input":
      return Object.assign({}, SuiPureByteArrayInputToJSON(value), { type: "byte_array_pure_input" });
    case "number_pure_input":
      return Object.assign({}, SuiPureNumberInputToJSON(value), { type: "number_pure_input" });
    case "string_pure_input":
      return Object.assign({}, SuiPureStringInputToJSON(value), { type: "string_pure_input" });
    default:
      throw new Error(`No variant of BaseSuiPureInputValue exists with 'type=${value["type"]}'`);
  }
}

// src/openapi/models/BaseSuiPureInput.ts
function BaseSuiPureInputFromJSON(json) {
  return BaseSuiPureInputFromJSONTyped(json, false);
}
function BaseSuiPureInputFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "value": BaseSuiPureInputValueFromJSON(json["value"])
  };
}
function BaseSuiPureInputToJSON(json) {
  return BaseSuiPureInputToJSONTyped(json, false);
}
function BaseSuiPureInputToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "value": BaseSuiPureInputValueToJSON(value["value"])
  };
}

// src/openapi/models/SolanaMessageAddressTableLookupRequest.ts
function SolanaMessageAddressTableLookupRequestToJSON(json) {
  return SolanaMessageAddressTableLookupRequestToJSONTyped(json, false);
}
function SolanaMessageAddressTableLookupRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "account_key": value["accountKey"],
    "writable_indexes": value["writableIndexes"],
    "readonly_indexes": value["readonlyIndexes"]
  };
}

// src/openapi/models/SolanaMessageVersion.ts
function SolanaMessageVersionFromJSON(json) {
  return SolanaMessageVersionFromJSONTyped(json, false);
}
function SolanaMessageVersionFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}
function SolanaMessageVersionToJSON(value) {
  return value;
}

// src/openapi/models/SolanaTransactionSignaturesRequest.ts
function SolanaTransactionSignaturesRequestToJSON(json) {
  return SolanaTransactionSignaturesRequestToJSONTyped(json, false);
}
function SolanaTransactionSignaturesRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "data": value["data"]
  };
}

// src/openapi/models/SolanaCompiledInstructionRequest.ts
function SolanaCompiledInstructionRequestToJSON(json) {
  return SolanaCompiledInstructionRequestToJSONTyped(json, false);
}
function SolanaCompiledInstructionRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "program_index": value["programIndex"],
    "data": value["data"],
    "account_indexes": value["accountIndexes"]
  };
}

// src/openapi/models/SolanaTransactionAccountRequest.ts
function SolanaTransactionAccountRequestToJSON(json) {
  return SolanaTransactionAccountRequestToJSONTyped(json, false);
}
function SolanaTransactionAccountRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "address": value["address"],
    "writable": value["writable"],
    "signer": value["signer"],
    "ephemeral_key": value["ephemeralKey"]
  };
}

// src/openapi/models/SolanaCustomFeeRequest.ts
function SolanaCustomFeeRequestToJSON(json) {
  return SolanaCustomFeeRequestToJSONTyped(json, false);
}
function SolanaCustomFeeRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "type": value["type"],
    "priority_fee": value["priorityFee"]
  };
}

// src/openapi/models/SolanaPriorityFeeRequest.ts
function SolanaPriorityFeeRequestToJSON(json) {
  return SolanaPriorityFeeRequestToJSONTyped(json, false);
}
function SolanaPriorityFeeRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "type": value["type"],
    "priority_level": FeePriorityLevelRequestToJSON(value["priorityLevel"])
  };
}

// src/openapi/models/BatchSolanaTransactionRequestDetailsFee.ts
function BatchSolanaTransactionRequestDetailsFeeToJSON(json) {
  return BatchSolanaTransactionRequestDetailsFeeToJSONTyped(json, false);
}
function BatchSolanaTransactionRequestDetailsFeeToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  switch (value["type"]) {
    case "custom":
      return Object.assign({}, SolanaCustomFeeRequestToJSON(value), { type: "custom" });
    case "priority":
      return Object.assign({}, SolanaPriorityFeeRequestToJSON(value), { type: "priority" });
    default:
      throw new Error(`No variant of BatchSolanaTransactionRequestDetailsFee exists with 'type=${value["type"]}'`);
  }
}

// src/openapi/models/BinaryHashPayload.ts
function BinaryHashPayloadToJSON(json) {
  return BinaryHashPayloadToJSONTyped(json, false);
}
function BinaryHashPayloadToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "format": value["format"],
    "hash_binary": value["hashBinary"]
  };
}

// src/openapi/models/EcdsaSignature.ts
function EcdsaSignatureFromJSON(json) {
  return EcdsaSignatureFromJSONTyped(json, false);
}
function EcdsaSignatureFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "r": json["r"],
    "s": json["s"],
    "v": json["v"]
  };
}

// src/openapi/models/BlackBoxSignatureEcdsaSecp256k1Details.ts
function BlackBoxSignatureEcdsaSecp256k1DetailsFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "type": json["type"],
    "signature": json["signature"] == null ? void 0 : EcdsaSignatureFromJSON(json["signature"]),
    "hashBinary": json["hash_binary"]
  };
}

// src/openapi/models/BlackBoxSignatureEcdsaStarkDetails.ts
function BlackBoxSignatureEcdsaStarkDetailsFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "type": json["type"],
    "signature": json["signature"] == null ? void 0 : EcdsaSignatureFromJSON(json["signature"]),
    "hashBinary": json["hash_binary"],
    "hashInteger": json["hash_integer"]
  };
}

// src/openapi/models/BlackBoxSignatureEddsaEd25519Details.ts
function BlackBoxSignatureEddsaEd25519DetailsFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "type": json["type"],
    "signature": json["signature"] == null ? void 0 : json["signature"],
    "hashBinary": json["hash_binary"]
  };
}

// src/openapi/models/BlackBoxSignatureSchnorrSecp256k1Details.ts
function BlackBoxSignatureSchnorrSecp256k1DetailsFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "type": json["type"],
    "signature": json["signature"] == null ? void 0 : json["signature"],
    "hashBinary": json["hash_binary"]
  };
}

// src/openapi/models/BlackBoxSignatureDetails.ts
function BlackBoxSignatureDetailsFromJSON(json) {
  return BlackBoxSignatureDetailsFromJSONTyped(json, false);
}
function BlackBoxSignatureDetailsFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  switch (json["type"]) {
    case "ecdsa_secp256k1":
      return Object.assign({}, BlackBoxSignatureEcdsaSecp256k1DetailsFromJSONTyped(json, true), { type: "ecdsa_secp256k1" });
    case "ecdsa_stark":
      return Object.assign({}, BlackBoxSignatureEcdsaStarkDetailsFromJSONTyped(json, true), { type: "ecdsa_stark" });
    case "eddsa_ed25519":
      return Object.assign({}, BlackBoxSignatureEddsaEd25519DetailsFromJSONTyped(json, true), { type: "eddsa_ed25519" });
    case "schnorr_secp256k1":
      return Object.assign({}, BlackBoxSignatureSchnorrSecp256k1DetailsFromJSONTyped(json, true), { type: "schnorr_secp256k1" });
    default:
      throw new Error(`No variant of BlackBoxSignatureDetails exists with 'type=${json["type"]}'`);
  }
}

// src/openapi/models/BlackBoxSignature.ts
function BlackBoxSignatureFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "id": json["id"],
    "createdAt": new Date(json["created_at"]),
    "modifiedAt": new Date(json["modified_at"]),
    "managedTransactionData": ManagedTransactionDataFromJSON(json["managed_transaction_data"]),
    "signatures": json["signatures"].map(SignatureFromJSON),
    "note": json["note"] == null ? void 0 : json["note"],
    "spamState": json["spam_state"] == null ? void 0 : TransactionSpamStateFromJSON(json["spam_state"]),
    "direction": TransactionDirectionFromJSON(json["direction"]),
    "signedExternally": json["signed_externally"] == null ? void 0 : json["signed_externally"],
    "state": NonPushableTransactionStateFromJSON(json["state"]),
    "stateChanges": json["state_changes"].map(NonPushableTransactionStateChangeFromJSON),
    "type": json["type"],
    "payload": json["payload"],
    "vault": VaultRefFromJSON(json["vault"]),
    "details": BlackBoxSignatureDetailsFromJSON(json["details"])
  };
}

// src/openapi/models/EcdsaSecp256k1BlackBoxVault.ts
function EcdsaSecp256k1BlackBoxVaultFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "type": json["type"]
  };
}

// src/openapi/models/EcdsaStarkBlackBoxVault.ts
function EcdsaStarkBlackBoxVaultFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "type": json["type"],
    "publicKey": json["public_key"],
    "starkKey": json["stark_key"]
  };
}

// src/openapi/models/EddsaED25519BlackBoxVault.ts
function EddsaED25519BlackBoxVaultFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "type": json["type"]
  };
}

// src/openapi/models/SchnorrSecp256k1BlackBoxValue.ts
function SchnorrSecp256k1BlackBoxValueFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "type": json["type"]
  };
}

// src/openapi/models/BlackBoxVaultDetails.ts
function BlackBoxVaultDetailsFromJSON(json) {
  return BlackBoxVaultDetailsFromJSONTyped(json, false);
}
function BlackBoxVaultDetailsFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  switch (json["type"]) {
    case "ecdsa_secp256k1":
      return Object.assign({}, EcdsaSecp256k1BlackBoxVaultFromJSONTyped(json, true), { type: "ecdsa_secp256k1" });
    case "ecdsa_stark":
      return Object.assign({}, EcdsaStarkBlackBoxVaultFromJSONTyped(json, true), { type: "ecdsa_stark" });
    case "eddsa_ed25519":
      return Object.assign({}, EddsaED25519BlackBoxVaultFromJSONTyped(json, true), { type: "eddsa_ed25519" });
    case "schnorr_secp256k1":
      return Object.assign({}, SchnorrSecp256k1BlackBoxValueFromJSONTyped(json, true), { type: "schnorr_secp256k1" });
    default:
      throw new Error(`No variant of BlackBoxVaultDetails exists with 'type=${json["type"]}'`);
  }
}

// src/openapi/models/BlackBoxVault.ts
function BlackBoxVaultFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "id": json["id"],
    "createdAt": new Date(json["created_at"]),
    "modifiedAt": new Date(json["modified_at"]),
    "metadata": json["metadata"] == null ? void 0 : mapValues(json["metadata"], AptosVaultMetadataValueFromJSON),
    "name": json["name"],
    "createdBy": UserRefFromJSON(json["created_by"]),
    "vaultGroup": VaultGroupRefFromJSON(json["vault_group"]),
    "pendingVaultGroupAction": json["pending_vault_group_action"] == null ? void 0 : AptosVaultPendingVaultGroupActionFromJSON(json["pending_vault_group_action"]),
    "state": VaultStateFromJSON(json["state"]),
    "areAllChainsDisabled": json["are_all_chains_disabled"],
    "derivationPath": json["derivation_path"],
    "publicKeyCompressed": json["public_key_compressed"],
    "derivationInfo": VaultDerivationInfoFromJSON(json["derivation_info"]),
    "keyset": KeysetRefFromJSON(json["keyset"]),
    "keyHolder": json["key_holder"] == null ? void 0 : EndUserRefFromJSON(json["key_holder"]),
    "originType": VaultOriginTypeFromJSON(json["origin_type"]),
    "type": json["type"],
    "details": BlackBoxVaultDetailsFromJSON(json["details"])
  };
}

// src/openapi/models/EvmBridgeEffectSourceErc20.ts
function EvmBridgeEffectSourceErc20FromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "pricedAsset": PricedAssetFromJSON(json["priced_asset"]),
    "type": json["type"],
    "sourceAddress": EnrichedEvmAddressFromJSON(json["source_address"]),
    "token": Erc20FromJSON(json["token"]),
    "price": json["price"] == null ? void 0 : PriceFromJSON(json["price"])
  };
}

// src/openapi/models/EvmBridgeEffectSourceNative.ts
function EvmBridgeEffectSourceNativeFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "pricedAsset": PricedAssetFromJSON(json["priced_asset"]),
    "type": json["type"],
    "sourceAddress": EnrichedEvmAddressFromJSON(json["source_address"]),
    "price": json["price"] == null ? void 0 : PriceFromJSON(json["price"])
  };
}

// src/openapi/models/EvmBridgeEffectSource.ts
function EvmBridgeEffectSourceFromJSON(json) {
  return EvmBridgeEffectSourceFromJSONTyped(json, false);
}
function EvmBridgeEffectSourceFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  switch (json["type"]) {
    case "erc20":
      return Object.assign({}, EvmBridgeEffectSourceErc20FromJSONTyped(json, true), { type: "erc20" });
    case "native":
      return Object.assign({}, EvmBridgeEffectSourceNativeFromJSONTyped(json, true), { type: "native" });
    default:
      throw new Error(`No variant of EvmBridgeEffectSource exists with 'type=${json["type"]}'`);
  }
}

// src/openapi/models/EvmBridgeEffectKnownDestination.ts
function EvmBridgeEffectKnownDestinationFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "type": json["type"],
    "destAddress": EnrichedEvmAddressFromJSON(json["dest_address"]),
    "destChain": EnrichedEvmChainFromJSON(json["dest_chain"])
  };
}

// src/openapi/models/EvmBridgeEffectUnknownDestination.ts
function EvmBridgeEffectUnknownDestinationFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "type": json["type"],
    "destAddress": json["dest_address"] == null ? void 0 : json["dest_address"],
    "destChain": json["dest_chain"]
  };
}

// src/openapi/models/EvmBridgeEffectDestination.ts
function EvmBridgeEffectDestinationFromJSON(json) {
  return EvmBridgeEffectDestinationFromJSONTyped(json, false);
}
function EvmBridgeEffectDestinationFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  switch (json["type"]) {
    case "known_target_chain":
      return Object.assign({}, EvmBridgeEffectKnownDestinationFromJSONTyped(json, true), { type: "known_target_chain" });
    case "unknown_target_chain":
      return Object.assign({}, EvmBridgeEffectUnknownDestinationFromJSONTyped(json, true), { type: "unknown_target_chain" });
    default:
      throw new Error(`No variant of EvmBridgeEffectDestination exists with 'type=${json["type"]}'`);
  }
}

// src/openapi/models/EvmBridgeEffect.ts
function EvmBridgeEffectFromJSON(json) {
  return EvmBridgeEffectFromJSONTyped(json, false);
}
function EvmBridgeEffectFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "bridgeName": json["bridge_name"],
    "source": json["source"] == null ? void 0 : EvmBridgeEffectSourceFromJSON(json["source"]),
    "destination": EvmBridgeEffectDestinationFromJSON(json["destination"]),
    "amount": json["amount"]
  };
}

// src/openapi/models/BridgeDetails.ts
function BridgeDetailsFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "type": json["type"],
    "bridgeEffect": EvmBridgeEffectFromJSON(json["bridge_effect"])
  };
}

// src/openapi/models/ChainType.ts
var ChainType = {
  aptos: "aptos",
  cosmos: "cosmos",
  evm: "evm",
  exchange: "exchange",
  solana: "solana",
  stacks: "stacks",
  starknet: "starknet",
  sui: "sui",
  ton: "ton",
  tron: "tron",
  utxo: "utxo"
};

// src/openapi/models/FiatValue.ts
function FiatValueFromJSON(json) {
  return FiatValueFromJSONTyped(json, false);
}
function FiatValueFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "value": json["value"],
    "currency": FiatCurrencyFromJSON(json["currency"])
  };
}

// src/openapi/models/ChainWithAssets.ts
function ChainWithAssetsFromJSON(json) {
  return ChainWithAssetsFromJSONTyped(json, false);
}
function ChainWithAssetsFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "chain": EnrichedChainFromJSON(json["chain"]),
    "nativeAsset": OwnedAssetFromJSON(json["native_asset"]),
    "totalValue": FiatValueFromJSON(json["total_value"])
  };
}

// src/openapi/models/EnrichedDapp.ts
function EnrichedDappFromJSON(json) {
  return EnrichedDappFromJSONTyped(json, false);
}
function EnrichedDappFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "id": json["id"],
    "name": json["name"],
    "url": json["url"] == null ? void 0 : json["url"],
    "logoUrl": json["logo_url"] == null ? void 0 : json["logo_url"],
    "chain": EnrichedChainFromJSON(json["chain"])
  };
}

// src/openapi/models/CosmosAccountRepr.ts
function CosmosAccountReprToJSON(json) {
  return CosmosAccountReprToJSONTyped(json, false);
}
function CosmosAccountReprToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "chain_type": value["chainType"],
    "bech32_repr": value["bech32Repr"]
  };
}

// src/openapi/models/EvmAccountRepr.ts
function EvmAccountReprToJSON(json) {
  return EvmAccountReprToJSONTyped(json, false);
}
function EvmAccountReprToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "chain_type": value["chainType"],
    "hex_repr": value["hexRepr"]
  };
}

// src/openapi/models/SolanaAccountRepr.ts
function SolanaAccountReprToJSON(json) {
  return SolanaAccountReprToJSONTyped(json, false);
}
function SolanaAccountReprToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "chain_type": value["chainType"],
    "base58_repr": value["base58Repr"]
  };
}

// src/openapi/models/StacksAccountRepr.ts
function StacksAccountReprToJSON(json) {
  return StacksAccountReprToJSONTyped(json, false);
}
function StacksAccountReprToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "chain_type": value["chainType"],
    "hex_repr": value["hexRepr"]
  };
}

// src/openapi/models/StarknetAccountRepr.ts
function StarknetAccountReprToJSON(json) {
  return StarknetAccountReprToJSONTyped(json, false);
}
function StarknetAccountReprToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "chain_type": value["chainType"],
    "hex_repr": value["hexRepr"]
  };
}

// src/openapi/models/SuiAccountRepr.ts
function SuiAccountReprToJSON(json) {
  return SuiAccountReprToJSONTyped(json, false);
}
function SuiAccountReprToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "chain_type": value["chainType"],
    "hex_repr": value["hexRepr"]
  };
}

// src/openapi/models/TonAccountRepr.ts
function TonAccountReprFromJSON(json) {
  return TonAccountReprFromJSONTyped(json, false);
}
function TonAccountReprFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "chainType": json["chain_type"],
    "address": json["address"]
  };
}
function TonAccountReprToJSON(json) {
  return TonAccountReprToJSONTyped(json, false);
}
function TonAccountReprToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "chain_type": value["chainType"],
    "address": value["address"]
  };
}

// src/openapi/models/TronAccountRepr.ts
function TronAccountReprToJSON(json) {
  return TronAccountReprToJSONTyped(json, false);
}
function TronAccountReprToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "chain_type": value["chainType"],
    "hex_repr": value["hexRepr"]
  };
}

// src/openapi/models/UtxoAccountRepr.ts
function UtxoAccountReprToJSON(json) {
  return UtxoAccountReprToJSONTyped(json, false);
}
function UtxoAccountReprToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "chain_type": value["chainType"],
    "hex_repr": value["hexRepr"]
  };
}

// src/openapi/models/MultiChainAccount.ts
function MultiChainAccountToJSON(json) {
  return MultiChainAccountToJSONTyped(json, false);
}
function MultiChainAccountToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  switch (value["chainType"]) {
    case "aptos":
      return Object.assign({}, AptosAccountReprToJSON(value), { chainType: "aptos" });
    case "cosmos":
      return Object.assign({}, CosmosAccountReprToJSON(value), { chainType: "cosmos" });
    case "evm":
      return Object.assign({}, EvmAccountReprToJSON(value), { chainType: "evm" });
    case "solana":
      return Object.assign({}, SolanaAccountReprToJSON(value), { chainType: "solana" });
    case "stacks":
      return Object.assign({}, StacksAccountReprToJSON(value), { chainType: "stacks" });
    case "starknet":
      return Object.assign({}, StarknetAccountReprToJSON(value), { chainType: "starknet" });
    case "sui":
      return Object.assign({}, SuiAccountReprToJSON(value), { chainType: "sui" });
    case "ton":
      return Object.assign({}, TonAccountReprToJSON(value), { chainType: "ton" });
    case "tron":
      return Object.assign({}, TronAccountReprToJSON(value), { chainType: "tron" });
    case "utxo":
      return Object.assign({}, UtxoAccountReprToJSON(value), { chainType: "utxo" });
    default:
      throw new Error(`No variant of MultiChainAccount exists with 'chainType=${value["chainType"]}'`);
  }
}

// src/openapi/models/TimestampedSignature.ts
function TimestampedSignatureFromJSON(json) {
  return TimestampedSignatureFromJSONTyped(json, false);
}
function TimestampedSignatureFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "signature": json["signature"],
    "timestamp": json["timestamp"]
  };
}

// src/openapi/models/ContractCallDetails.ts
function ContractCallDetailsFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "type": json["type"]
  };
}

// src/openapi/models/ContractDeploymentDetails.ts
function ContractDeploymentDetailsFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "type": json["type"],
    "contractAddress": EnrichedEvmAddressFromJSON(json["contract_address"])
  };
}

// src/openapi/models/CosmosMessageBase64Data.ts
function CosmosMessageBase64DataFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "type": json["type"],
    "data": json["data"]
  };
}
function CosmosMessageBase64DataToJSON(json) {
  return CosmosMessageBase64DataToJSONTyped(json, false);
}
function CosmosMessageBase64DataToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "type": value["type"],
    "data": value["data"]
  };
}

// src/openapi/models/CosmosMessageStrData.ts
function CosmosMessageStrDataFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "type": json["type"],
    "data": json["data"]
  };
}
function CosmosMessageStrDataToJSON(json) {
  return CosmosMessageStrDataToJSONTyped(json, false);
}
function CosmosMessageStrDataToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "type": value["type"],
    "data": value["data"]
  };
}

// src/openapi/models/CosmosMessageData.ts
function CosmosMessageDataFromJSON(json) {
  return CosmosMessageDataFromJSONTyped(json, false);
}
function CosmosMessageDataFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  switch (json["type"]) {
    case "base64":
      return Object.assign({}, CosmosMessageBase64DataFromJSONTyped(json, true), { type: "base64" });
    case "string":
      return Object.assign({}, CosmosMessageStrDataFromJSONTyped(json, true), { type: "string" });
    default:
      throw new Error(`No variant of CosmosMessageData exists with 'type=${json["type"]}'`);
  }
}
function CosmosMessageDataToJSON(json) {
  return CosmosMessageDataToJSONTyped(json, false);
}
function CosmosMessageDataToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  switch (value["type"]) {
    case "base64":
      return Object.assign({}, CosmosMessageBase64DataToJSON(value), { type: "base64" });
    case "string":
      return Object.assign({}, CosmosMessageStrDataToJSON(value), { type: "string" });
    default:
      throw new Error(`No variant of CosmosMessageData exists with 'type=${value["type"]}'`);
  }
}

// src/openapi/models/CosmosArbitraryMessageRequest.ts
function CosmosArbitraryMessageRequestToJSON(json) {
  return CosmosArbitraryMessageRequestToJSONTyped(json, false);
}
function CosmosArbitraryMessageRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "type": value["type"],
    "chain": CosmosChainUniqueIdToJSON(value["chain"]),
    "data": CosmosMessageDataToJSON(value["data"])
  };
}

// src/openapi/models/CosmosBalanceChangeEffectType.ts
function CosmosBalanceChangeEffectTypeFromJSON(json) {
  return CosmosBalanceChangeEffectTypeFromJSONTyped(json, false);
}
function CosmosBalanceChangeEffectTypeFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// src/openapi/models/CosmosBalanceChangeEffectCoinInfo.ts
function CosmosBalanceChangeEffectCoinInfoFromJSON(json) {
  return CosmosBalanceChangeEffectCoinInfoFromJSONTyped(json, false);
}
function CosmosBalanceChangeEffectCoinInfoFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "isVerified": json["is_verified"],
    "coin": CosmosTokenFromJSON(json["coin"])
  };
}

// src/openapi/models/CosmosBalanceChangeEffect.ts
function CosmosBalanceChangeEffectFromJSON(json) {
  return CosmosBalanceChangeEffectFromJSONTyped(json, false);
}
function CosmosBalanceChangeEffectFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "pricedAsset": PricedAssetFromJSON(json["priced_asset"]),
    "diff": json["diff"],
    "type": CosmosBalanceChangeEffectTypeFromJSON(json["type"]),
    "coinInfo": CosmosBalanceChangeEffectCoinInfoFromJSON(json["coin_info"]),
    "address": EnrichedCosmosBechAddressFromJSON(json["address"]),
    "owner": json["owner"] == null ? void 0 : EnrichedCosmosBechAddressFromJSON(json["owner"]),
    "price": json["price"] == null ? void 0 : PriceFromJSON(json["price"])
  };
}

// src/openapi/models/CosmosBechAddressEnrichedChain.ts
function CosmosBechAddressEnrichedChainFromJSON(json) {
  return CosmosBechAddressEnrichedChainFromJSONTyped(json, false);
}
function CosmosBechAddressEnrichedChainFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "chain": CosmosChainUniqueIdFromJSON(json["chain"]),
    "address": json["address"],
    "hexRepr": json["hex_repr"] == null ? void 0 : json["hex_repr"],
    "keyType": json["key_type"] == null ? void 0 : CosmosKeyTypeFromJSON(json["key_type"]),
    "enrichedChain": EnrichedCosmosChainFromJSON(json["enriched_chain"])
  };
}

// src/openapi/models/CosmosTransferEffectType.ts
function CosmosTransferEffectTypeFromJSON(json) {
  return CosmosTransferEffectTypeFromJSONTyped(json, false);
}
function CosmosTransferEffectTypeFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// src/openapi/models/CosmosTransferEffect.ts
function CosmosTransferEffectFromJSON(json) {
  return CosmosTransferEffectFromJSONTyped(json, false);
}
function CosmosTransferEffectFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "pricedAsset": PricedAssetFromJSON(json["priced_asset"]),
    "amount": json["amount"],
    "type": CosmosTransferEffectTypeFromJSON(json["type"]),
    "coinInfo": CosmosBalanceChangeEffectCoinInfoFromJSON(json["coin_info"]),
    "from": EnrichedCosmosBechAddressFromJSON(json["from"]),
    "to": EnrichedCosmosBechAddressFromJSON(json["to"]),
    "price": json["price"] == null ? void 0 : PriceFromJSON(json["price"])
  };
}

// src/openapi/models/CosmosEffects.ts
function CosmosEffectsFromJSON(json) {
  return CosmosEffectsFromJSONTyped(json, false);
}
function CosmosEffectsFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "balanceChanges": json["balance_changes"].map(CosmosBalanceChangeEffectFromJSON),
    "transfers": json["transfers"].map(CosmosTransferEffectFromJSON)
  };
}

// src/openapi/models/CosmosGasDebit.ts
function CosmosGasDebitFromJSON(json) {
  return CosmosGasDebitFromJSONTyped(json, false);
}
function CosmosGasDebitFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "gasUsed": json["gas_used"],
    "totalFee": json["total_fee"].map(CosmosCoinWithAmountFromJSON),
    "fiatPrices": json["fiat_prices"].map(PriceFromJSON)
  };
}

// src/openapi/models/CosmosMessageType.ts
function CosmosMessageTypeFromJSON(json) {
  return CosmosMessageTypeFromJSONTyped(json, false);
}
function CosmosMessageTypeFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// src/openapi/models/CosmosMessage.ts
function CosmosMessageFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "id": json["id"],
    "createdAt": new Date(json["created_at"]),
    "modifiedAt": new Date(json["modified_at"]),
    "managedTransactionData": json["managed_transaction_data"] == null ? void 0 : ManagedTransactionDataFromJSON(json["managed_transaction_data"]),
    "signatures": json["signatures"].map(SignatureFromJSON),
    "note": json["note"] == null ? void 0 : json["note"],
    "spamState": json["spam_state"] == null ? void 0 : TransactionSpamStateFromJSON(json["spam_state"]),
    "direction": TransactionDirectionFromJSON(json["direction"]),
    "signedExternally": json["signed_externally"] == null ? void 0 : json["signed_externally"],
    "state": NonPushableTransactionStateFromJSON(json["state"]),
    "stateChanges": json["state_changes"].map(NonPushableTransactionStateChangeFromJSON),
    "type": json["type"],
    "cosmosMessageType": CosmosMessageTypeFromJSON(json["cosmos_message_type"]),
    "data": CosmosMessageDataFromJSON(json["data"]),
    "chain": EnrichedCosmosChainFromJSON(json["chain"]),
    "sender": EnrichedCosmosBechAddressFromJSON(json["sender"])
  };
}

// src/openapi/models/DirectMessage.ts
function DirectMessageFromJSON(json) {
  return DirectMessageFromJSONTyped(json, false);
}
function DirectMessageFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "type": json["type"],
    "value": json["value"]
  };
}

// src/openapi/models/DirectMessagesList.ts
function DirectMessagesListFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "format": json["format"],
    "messages": json["messages"].map(DirectMessageFromJSON)
  };
}

// src/openapi/models/MinedMessagesList.ts
function MinedMessagesListFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "format": json["format"],
    "messages": json["messages"]
  };
}

// src/openapi/models/MessagesList.ts
function MessagesListFromJSON(json) {
  return MessagesListFromJSONTyped(json, false);
}
function MessagesListFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  switch (json["format"]) {
    case "amino":
      return Object.assign({}, AminoMessagesListFromJSONTyped(json, true), { format: "amino" });
    case "direct":
      return Object.assign({}, DirectMessagesListFromJSONTyped(json, true), { format: "direct" });
    case "mined":
      return Object.assign({}, MinedMessagesListFromJSONTyped(json, true), { format: "mined" });
    default:
      throw new Error(`No variant of MessagesList exists with 'format=${json["format"]}'`);
  }
}

// src/openapi/models/CosmosMultipleMessagesTransactionDetails.ts
function CosmosMultipleMessagesTransactionDetailsFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "transactionData": MessagesListFromJSON(json["transaction_data"]),
    "type": json["type"]
  };
}

// src/openapi/models/TransferDirection.ts
function TransferDirectionFromJSON(json) {
  return TransferDirectionFromJSONTyped(json, false);
}
function TransferDirectionFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// src/openapi/models/CosmosNativeTransferDetails.ts
function CosmosNativeTransferDetailsFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "transactionData": MessagesListFromJSON(json["transaction_data"]),
    "direction": TransferDirectionFromJSON(json["direction"]),
    "sender": EnrichedCosmosBechAddressFromJSON(json["sender"]),
    "recipient": EnrichedCosmosBechAddressFromJSON(json["recipient"]),
    "isInternal": json["is_internal"] == null ? void 0 : json["is_internal"],
    "type": json["type"]
  };
}

// src/openapi/models/CosmosPushData.ts
function CosmosPushDataToJSON(json) {
  return CosmosPushDataToJSONTyped(json, false);
}
function CosmosPushDataToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "type": value["type"],
    "transaction_body": value["transactionBody"]
  };
}

// src/openapi/models/CosmosSuggestedFees.ts
function CosmosSuggestedFeesFromJSON(json) {
  return CosmosSuggestedFeesFromJSONTyped(json, false);
}
function CosmosSuggestedFeesFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "type": json["type"],
    "chainUniqueId": CosmosChainUniqueIdFromJSON(json["chain_unique_id"]),
    "feePerSignature": json["fee_per_signature"] == null ? void 0 : json["fee_per_signature"]
  };
}

// src/openapi/models/CosmosTokenTransferDetails.ts
function CosmosTokenTransferDetailsFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "transactionData": MessagesListFromJSON(json["transaction_data"]),
    "direction": TransferDirectionFromJSON(json["direction"]),
    "sender": EnrichedCosmosBechAddressFromJSON(json["sender"]),
    "recipient": EnrichedCosmosBechAddressFromJSON(json["recipient"]),
    "isInternal": json["is_internal"] == null ? void 0 : json["is_internal"],
    "type": json["type"]
  };
}

// src/openapi/models/CosmosTransactionResult.ts
function CosmosTransactionResultFromJSON(json) {
  return CosmosTransactionResultFromJSONTyped(json, false);
}
function CosmosTransactionResultFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "message": json["message"] == null ? void 0 : json["message"],
    "gasDebit": CosmosGasDebitFromJSON(json["gas_debit"]),
    "effects": CosmosEffectsFromJSON(json["effects"])
  };
}

// src/openapi/models/DirectSignDoc.ts
function DirectSignDocFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "format": json["format"],
    "body": json["body"],
    "authInfo": json["auth_info"],
    "chain": EnrichedCosmosChainFromJSON(json["chain"]),
    "accountNumber": json["account_number"],
    "signedBody": json["signed_body"],
    "signedAuthInfo": json["signed_auth_info"]
  };
}

// src/openapi/models/MinedSignDoc.ts
function MinedSignDocFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "format": json["format"],
    "messages": json["messages"],
    "chain": EnrichedCosmosChainFromJSON(json["chain"])
  };
}

// src/openapi/models/SignDoc.ts
function SignDocFromJSON(json) {
  return SignDocFromJSONTyped(json, false);
}
function SignDocFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  switch (json["format"]) {
    case "amino":
      return Object.assign({}, AminoSignDocFromJSONTyped(json, true), { format: "amino" });
    case "direct":
      return Object.assign({}, DirectSignDocFromJSONTyped(json, true), { format: "direct" });
    case "mined":
      return Object.assign({}, MinedSignDocFromJSONTyped(json, true), { format: "mined" });
    default:
      throw new Error(`No variant of SignDoc exists with 'format=${json["format"]}'`);
  }
}

// src/openapi/models/CosmosTransactionTypeDetails.ts
function CosmosTransactionTypeDetailsFromJSON(json) {
  return CosmosTransactionTypeDetailsFromJSONTyped(json, false);
}
function CosmosTransactionTypeDetailsFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  switch (json["type"]) {
    case "messages":
      return Object.assign({}, CosmosMultipleMessagesTransactionDetailsFromJSONTyped(json, true), { type: "messages" });
    case "native_transfer":
      return Object.assign({}, CosmosNativeTransferDetailsFromJSONTyped(json, true), { type: "native_transfer" });
    case "token_transfer":
      return Object.assign({}, CosmosTokenTransferDetailsFromJSONTyped(json, true), { type: "token_transfer" });
    default:
      throw new Error(`No variant of CosmosTransactionTypeDetails exists with 'type=${json["type"]}'`);
  }
}

// src/openapi/models/SignerInfo.ts
function SignerInfoFromJSON(json) {
  return SignerInfoFromJSONTyped(json, false);
}
function SignerInfoFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "signerAddress": EnrichedCosmosBechAddressFromJSON(json["signer_address"]),
    "publicKey": json["public_key"],
    "account": json["account"],
    "sequence": json["sequence"]
  };
}

// src/openapi/models/CosmosTransaction.ts
function CosmosTransactionFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "id": json["id"],
    "createdAt": new Date(json["created_at"]),
    "modifiedAt": new Date(json["modified_at"]),
    "managedTransactionData": json["managed_transaction_data"] == null ? void 0 : ManagedTransactionDataFromJSON(json["managed_transaction_data"]),
    "signatures": json["signatures"].map(SignatureFromJSON),
    "note": json["note"] == null ? void 0 : json["note"],
    "spamState": json["spam_state"] == null ? void 0 : TransactionSpamStateFromJSON(json["spam_state"]),
    "direction": TransactionDirectionFromJSON(json["direction"]),
    "signedExternally": json["signed_externally"] == null ? void 0 : json["signed_externally"],
    "state": PushableTransactionStateFromJSON(json["state"]),
    "stateChanges": json["state_changes"].map(PushableTransactionStateChangeFromJSON),
    "amlResults": json["aml_results"] == null ? void 0 : AmlResultsFromJSON(json["aml_results"]),
    "incomingAmlPolicyMatch": json["incoming_aml_policy_match"] == null ? void 0 : AmlPolicyMatchIncomingFromJSON(json["incoming_aml_policy_match"]),
    "cosmosTransactionTypeDetails": CosmosTransactionTypeDetailsFromJSON(json["cosmos_transaction_type_details"]),
    "memo": json["memo"] == null ? void 0 : json["memo"],
    "chain": EnrichedCosmosChainFromJSON(json["chain"]),
    "from": EnrichedCosmosBechAddressFromJSON(json["from"]),
    "sender": EnrichedCosmosBechAddressFromJSON(json["sender"]),
    "type": json["type"],
    "hash": json["hash"] == null ? void 0 : json["hash"],
    "explorerUrl": json["explorer_url"] == null ? void 0 : json["explorer_url"],
    "signersInfo": json["signers_info"].map(SignerInfoFromJSON),
    "expectedResult": json["expected_result"] == null ? void 0 : CosmosTransactionResultFromJSON(json["expected_result"]),
    "minedResult": json["mined_result"] == null ? void 0 : CosmosTransactionResultFromJSON(json["mined_result"]),
    "signDoc": json["sign_doc"] == null ? void 0 : SignDocFromJSON(json["sign_doc"])
  };
}

// src/openapi/models/CosmosTransferToAddressRequest.ts
function CosmosTransferToAddressRequestToJSON(json) {
  return CosmosTransferToAddressRequestToJSONTyped(json, false);
}
function CosmosTransferToAddressRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "type": value["type"],
    "address": CosmosBechAddressToJSON(value["address"])
  };
}

// src/openapi/models/CosmosVault.ts
function CosmosVaultFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "id": json["id"],
    "createdAt": new Date(json["created_at"]),
    "modifiedAt": new Date(json["modified_at"]),
    "metadata": json["metadata"] == null ? void 0 : mapValues(json["metadata"], AptosVaultMetadataValueFromJSON),
    "name": json["name"],
    "createdBy": UserRefFromJSON(json["created_by"]),
    "vaultGroup": VaultGroupRefFromJSON(json["vault_group"]),
    "pendingVaultGroupAction": json["pending_vault_group_action"] == null ? void 0 : AptosVaultPendingVaultGroupActionFromJSON(json["pending_vault_group_action"]),
    "state": VaultStateFromJSON(json["state"]),
    "areAllChainsDisabled": json["are_all_chains_disabled"],
    "derivationPath": json["derivation_path"],
    "publicKeyCompressed": json["public_key_compressed"],
    "derivationInfo": VaultDerivationInfoFromJSON(json["derivation_info"]),
    "keyset": KeysetRefFromJSON(json["keyset"]),
    "keyHolder": json["key_holder"] == null ? void 0 : EndUserRefFromJSON(json["key_holder"]),
    "originType": VaultOriginTypeFromJSON(json["origin_type"]),
    "type": json["type"],
    "mainAddress": json["main_address"],
    "evmAddress": json["evm_address"],
    "chainsAddresses": json["chains_addresses"].map(CosmosBechAddressEnrichedChainFromJSON)
  };
}

// src/openapi/models/DappInfo.ts
function DappInfoToJSON(json) {
  return DappInfoToJSONTyped(json, false);
}
function DappInfoToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "url": value["url"],
    "name": value["name"]
  };
}

// src/openapi/models/CreateAptosMessageRequest.ts
function CreateAptosMessageRequestToJSON(json) {
  return CreateAptosMessageRequestToJSONTyped(json, false);
}
function CreateAptosMessageRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "vault_id": value["vaultId"],
    "note": value["note"],
    "signer_type": SignerTypeToJSON(value["signerType"]),
    "sign_mode": SignModeToJSON(value["signMode"]),
    "dapp_info": DappInfoToJSON(value["dappInfo"]),
    "type": value["type"],
    "details": AptosPersonalMessageRequestToJSON(value["details"])
  };
}

// src/openapi/models/CreateAptosMessageWithWaitRequest.ts
function CreateAptosMessageWithWaitRequestToJSON(json) {
  return CreateAptosMessageWithWaitRequestToJSONTyped(json, false);
}
function CreateAptosMessageWithWaitRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "vault_id": value["vaultId"],
    "note": value["note"],
    "signer_type": SignerTypeToJSON(value["signerType"]),
    "sign_mode": SignModeToJSON(value["signMode"]),
    "dapp_info": DappInfoToJSON(value["dappInfo"]),
    "type": value["type"],
    "details": AptosPersonalMessageRequestToJSON(value["details"]),
    "timeout": value["timeout"],
    "wait_for_state": NonPushableTransactionStateToJSON(value["waitForState"])
  };
}

// src/openapi/models/CreateAptosSerializedRawTransactionRequest.ts
function CreateAptosSerializedRawTransactionRequestToJSON(json) {
  return CreateAptosSerializedRawTransactionRequestToJSONTyped(json, false);
}
function CreateAptosSerializedRawTransactionRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "type": value["type"],
    "fail_on_prediction_failure": value["failOnPredictionFailure"],
    "gas_config": AptosGasConfigRequestToJSON(value["gasConfig"]),
    "chain": AptosChainUniqueIdToJSON(value["chain"]),
    "serialized_transaction_payload": value["serializedTransactionPayload"],
    "skip_prediction": value["skipPrediction"],
    "push_mode": PushModeToJSON(value["pushMode"])
  };
}

// src/openapi/models/RecipientVaultId.ts
function RecipientVaultIdToJSON(json) {
  return RecipientVaultIdToJSONTyped(json, false);
}
function RecipientVaultIdToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "type": value["type"],
    "vault_id": value["vaultId"]
  };
}

// src/openapi/models/CreateAptosTransferRequestTo.ts
function CreateAptosTransferRequestToToJSON(json) {
  return CreateAptosTransferRequestToToJSONTyped(json, false);
}
function CreateAptosTransferRequestToToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  switch (value["type"]) {
    case "hex":
      return Object.assign({}, AptosRecipientHexToJSON(value), { type: "hex" });
    case "vault_id":
      return Object.assign({}, RecipientVaultIdToJSON(value), { type: "vault_id" });
    default:
      throw new Error(`No variant of CreateAptosTransferRequestTo exists with 'type=${value["type"]}'`);
  }
}

// src/openapi/models/CreateTransferRequestExplicitAmount.ts
function CreateTransferRequestExplicitAmountToJSON(json) {
  return CreateTransferRequestExplicitAmountToJSONTyped(json, false);
}
function CreateTransferRequestExplicitAmountToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "type": value["type"],
    "value": value["value"]
  };
}

// src/openapi/models/CreateTransferRequestMaxAmount.ts
function CreateTransferRequestMaxAmountToJSON(json) {
  return CreateTransferRequestMaxAmountToJSONTyped(json, false);
}
function CreateTransferRequestMaxAmountToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "type": value["type"]
  };
}

// src/openapi/models/CreateAptosTransferRequestValue.ts
function CreateAptosTransferRequestValueToJSON(json) {
  return CreateAptosTransferRequestValueToJSONTyped(json, false);
}
function CreateAptosTransferRequestValueToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  switch (value["type"]) {
    case "max":
      return Object.assign({}, CreateTransferRequestMaxAmountToJSON(value), { type: "max" });
    case "value":
      return Object.assign({}, CreateTransferRequestExplicitAmountToJSON(value), { type: "value" });
    default:
      throw new Error(`No variant of CreateAptosTransferRequestValue exists with 'type=${value["type"]}'`);
  }
}

// src/openapi/models/CreateAptosTransferRequest.ts
function CreateAptosTransferRequestToJSON(json) {
  return CreateAptosTransferRequestToJSONTyped(json, false);
}
function CreateAptosTransferRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "type": value["type"],
    "fail_on_prediction_failure": value["failOnPredictionFailure"],
    "gas_config": AptosGasConfigRequestToJSON(value["gasConfig"]),
    "to": CreateAptosTransferRequestToToJSON(value["to"]),
    "value": CreateAptosTransferRequestValueToJSON(value["value"]),
    "asset_identifier": AptosAssetIdentifierRequestToJSON(value["assetIdentifier"]),
    "skip_prediction": value["skipPrediction"],
    "push_mode": PushModeToJSON(value["pushMode"])
  };
}

// src/openapi/models/CreateAptosTransactionRequestDetails.ts
function CreateAptosTransactionRequestDetailsToJSON(json) {
  return CreateAptosTransactionRequestDetailsToJSONTyped(json, false);
}
function CreateAptosTransactionRequestDetailsToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  switch (value["type"]) {
    case "aptos_serialized_entry_point_payload":
      return Object.assign({}, CreateAptosSerializedRawTransactionRequestToJSON(value), { type: "aptos_serialized_entry_point_payload" });
    case "aptos_transfer":
      return Object.assign({}, CreateAptosTransferRequestToJSON(value), { type: "aptos_transfer" });
    default:
      throw new Error(`No variant of CreateAptosTransactionRequestDetails exists with 'type=${value["type"]}'`);
  }
}

// src/openapi/models/CreateAptosTransactionRequest.ts
function CreateAptosTransactionRequestToJSON(json) {
  return CreateAptosTransactionRequestToJSONTyped(json, false);
}
function CreateAptosTransactionRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "vault_id": value["vaultId"],
    "note": value["note"],
    "signer_type": SignerTypeToJSON(value["signerType"]),
    "sign_mode": SignModeToJSON(value["signMode"]),
    "dapp_info": DappInfoToJSON(value["dappInfo"]),
    "type": value["type"],
    "details": CreateAptosTransactionRequestDetailsToJSON(value["details"])
  };
}

// src/openapi/models/CreateAptosTransactionWithWaitRequest.ts
function CreateAptosTransactionWithWaitRequestToJSON(json) {
  return CreateAptosTransactionWithWaitRequestToJSONTyped(json, false);
}
function CreateAptosTransactionWithWaitRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "vault_id": value["vaultId"],
    "note": value["note"],
    "signer_type": SignerTypeToJSON(value["signerType"]),
    "sign_mode": SignModeToJSON(value["signMode"]),
    "dapp_info": DappInfoToJSON(value["dappInfo"]),
    "type": value["type"],
    "details": CreateAptosTransactionRequestDetailsToJSON(value["details"]),
    "timeout": value["timeout"],
    "wait_for_state": PushableTransactionStateToJSON(value["waitForState"])
  };
}

// src/openapi/models/ImportVaultDefaultOptions.ts
function ImportVaultDefaultOptionsToJSON(json) {
  return ImportVaultDefaultOptionsToJSONTyped(json, false);
}
function ImportVaultDefaultOptionsToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "derivation_path": value["derivationPath"],
    "key_id": value["keyId"]
  };
}

// src/openapi/models/CreateAptosVaultRequest.ts
function CreateAptosVaultRequestToJSON(json) {
  return CreateAptosVaultRequestToJSONTyped(json, false);
}
function CreateAptosVaultRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "name": value["name"],
    "keyset_id": value["keysetId"],
    "end_user_id": value["endUserId"],
    "vault_group_id": value["vaultGroupId"],
    "import_vault": ImportVaultDefaultOptionsToJSON(value["importVault"]),
    "type": value["type"]
  };
}

// src/openapi/models/SolanaCompiledInstruction.ts
function SolanaCompiledInstructionFromJSON(json) {
  return SolanaCompiledInstructionFromJSONTyped(json, false);
}
function SolanaCompiledInstructionFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "programIndex": json["program_index"],
    "data": json["data"],
    "accountIndexes": json["account_indexes"],
    "program": EnrichedSolanaAddressFromJSON(json["program"]),
    "base58Data": json["base58_data"] == null ? void 0 : json["base58_data"]
  };
}

// src/openapi/models/SolanaTransactionAccount.ts
function SolanaTransactionAccountFromJSON(json) {
  return SolanaTransactionAccountFromJSONTyped(json, false);
}
function SolanaTransactionAccountFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "address": EnrichedSolanaAddressFromJSON(json["address"]),
    "writable": json["writable"],
    "signer": json["signer"]
  };
}

// src/openapi/models/SolanaReversionState.ts
function SolanaReversionStateFromJSON(json) {
  return SolanaReversionStateFromJSONTyped(json, false);
}
function SolanaReversionStateFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// src/openapi/models/SolanaReversion.ts
function SolanaReversionFromJSON(json) {
  return SolanaReversionFromJSONTyped(json, false);
}
function SolanaReversionFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "state": SolanaReversionStateFromJSON(json["state"]),
    "reason": json["reason"] == null ? void 0 : json["reason"]
  };
}

// src/openapi/models/SolanaFeeType.ts
function SolanaFeeTypeFromJSON(json) {
  return SolanaFeeTypeFromJSONTyped(json, false);
}
function SolanaFeeTypeFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// src/openapi/models/SolanaFee.ts
function SolanaFeeFromJSON(json) {
  return SolanaFeeFromJSONTyped(json, false);
}
function SolanaFeeFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "priorityLevel": FeePriorityLevelFromJSON(json["priority_level"]),
    "baseFee": json["base_fee"],
    "priorityFee": json["priority_fee"],
    "fee": json["fee"],
    "feeType": SolanaFeeTypeFromJSON(json["fee_type"]),
    "fiatPrice": json["fiat_price"] == null ? void 0 : PriceFromJSON(json["fiat_price"]),
    "pricedAsset": PricedAssetFromJSON(json["priced_asset"])
  };
}

// src/openapi/models/InstructionError.ts
function InstructionErrorFromJSON(json) {
  return InstructionErrorFromJSONTyped(json, false);
}
function InstructionErrorFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "errorType": json["error_type"],
    "instructionIndex": json["instruction_index"],
    "errorDescription": json["error_description"] == null ? void 0 : json["error_description"]
  };
}

// src/openapi/models/SplTokenContract.ts
function SplTokenContractFromJSON(json) {
  return SplTokenContractFromJSONTyped(json, false);
}
function SplTokenContractFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "name": json["name"] == null ? void 0 : json["name"],
    "dapp": json["dapp"] == null ? void 0 : DappFromJSON(json["dapp"]),
    "isVerified": json["is_verified"],
    "token": SplTokenFromJSON(json["token"])
  };
}

// src/openapi/models/SolanaTransferEffectType.ts
function SolanaTransferEffectTypeFromJSON(json) {
  return SolanaTransferEffectTypeFromJSONTyped(json, false);
}
function SolanaTransferEffectTypeFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// src/openapi/models/SolanaTransferEffect.ts
function SolanaTransferEffectFromJSON(json) {
  return SolanaTransferEffectFromJSONTyped(json, false);
}
function SolanaTransferEffectFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "pricedAsset": PricedAssetFromJSON(json["priced_asset"]),
    "amount": json["amount"],
    "type": SolanaTransferEffectTypeFromJSON(json["type"]),
    "from": EnrichedSolanaAddressFromJSON(json["from"]),
    "to": EnrichedSolanaAddressFromJSON(json["to"]),
    "price": json["price"] == null ? void 0 : PriceFromJSON(json["price"]),
    "tokenContract": json["token_contract"] == null ? void 0 : SplTokenContractFromJSON(json["token_contract"])
  };
}

// src/openapi/models/SolanaBalanceChangeEffectType.ts
function SolanaBalanceChangeEffectTypeFromJSON(json) {
  return SolanaBalanceChangeEffectTypeFromJSONTyped(json, false);
}
function SolanaBalanceChangeEffectTypeFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// src/openapi/models/SolanaBalanceChangeEffect.ts
function SolanaBalanceChangeEffectFromJSON(json) {
  return SolanaBalanceChangeEffectFromJSONTyped(json, false);
}
function SolanaBalanceChangeEffectFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "pricedAsset": PricedAssetFromJSON(json["priced_asset"]),
    "diff": json["diff"],
    "type": SolanaBalanceChangeEffectTypeFromJSON(json["type"]),
    "address": EnrichedSolanaAddressFromJSON(json["address"]),
    "owner": json["owner"] == null ? void 0 : EnrichedSolanaAddressFromJSON(json["owner"]),
    "price": json["price"] == null ? void 0 : PriceFromJSON(json["price"]),
    "tokenContract": json["token_contract"] == null ? void 0 : SplTokenContractFromJSON(json["token_contract"])
  };
}

// src/openapi/models/SolanaEffects.ts
function SolanaEffectsFromJSON(json) {
  return SolanaEffectsFromJSONTyped(json, false);
}
function SolanaEffectsFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "balanceChanges": json["balance_changes"].map(SolanaBalanceChangeEffectFromJSON),
    "transfers": json["transfers"].map(SolanaTransferEffectFromJSON)
  };
}

// src/openapi/models/SolanaTransactionResult.ts
function SolanaTransactionResultFromJSON(json) {
  return SolanaTransactionResultFromJSONTyped(json, false);
}
function SolanaTransactionResultFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "reversion": SolanaReversionFromJSON(json["reversion"]),
    "transactionError": json["transaction_error"] == null ? void 0 : json["transaction_error"],
    "fee": json["fee"],
    "enrichedFee": SolanaFeeFromJSON(json["enriched_fee"]),
    "effects": SolanaEffectsFromJSON(json["effects"]),
    "instructionError": json["instruction_error"] == null ? void 0 : InstructionErrorFromJSON(json["instruction_error"])
  };
}

// src/openapi/models/SolanaEnrichedMessageAddressTableLookup.ts
function SolanaEnrichedMessageAddressTableLookupFromJSON(json) {
  return SolanaEnrichedMessageAddressTableLookupFromJSONTyped(json, false);
}
function SolanaEnrichedMessageAddressTableLookupFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "accountKey": SolanaAddressFromJSON(json["account_key"]),
    "writableIndexes": json["writable_indexes"],
    "readonlyIndexes": json["readonly_indexes"],
    "state": AddressLookupTableStateFromJSON(json["state"])
  };
}

// src/openapi/models/SolanaSpotSwapBroadcastMode.ts
function SolanaSpotSwapBroadcastModeFromJSON(json) {
  return SolanaSpotSwapBroadcastModeFromJSONTyped(json, false);
}
function SolanaSpotSwapBroadcastModeFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// src/openapi/models/GetSolanaSpotSwapDetails.ts
function GetSolanaSpotSwapDetailsFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "type": json["type"],
    "slippageBps": json["slippage_bps"],
    "priceImpactPct": json["price_impact_pct"],
    "rate": json["rate"],
    "broadcastMode": SolanaSpotSwapBroadcastModeFromJSON(json["broadcast_mode"]),
    "inputAsset": AssetInfoFromJSON(json["input_asset"]),
    "outputAsset": AssetInfoFromJSON(json["output_asset"]),
    "recipients": json["recipients"].map(EnrichedSolanaAddressFromJSON)
  };
}

// src/openapi/models/SolanaNativeTransferDetails.ts
function SolanaNativeTransferDetailsFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "type": json["type"],
    "direction": TransferDirectionFromJSON(json["direction"]),
    "sender": EnrichedSolanaAddressFromJSON(json["sender"]),
    "recipient": EnrichedSolanaAddressFromJSON(json["recipient"]),
    "isInternal": json["is_internal"] == null ? void 0 : json["is_internal"]
  };
}

// src/openapi/models/SolanaRawTransactionDetails.ts
function SolanaRawTransactionDetailsFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "type": json["type"],
    "recipients": json["recipients"].map(EnrichedSolanaAddressFromJSON)
  };
}

// src/openapi/models/SolanaTokenTransferDetails.ts
function SolanaTokenTransferDetailsFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "type": json["type"],
    "direction": TransferDirectionFromJSON(json["direction"]),
    "sender": EnrichedSolanaAddressFromJSON(json["sender"]),
    "recipient": EnrichedSolanaAddressFromJSON(json["recipient"]),
    "isInternal": json["is_internal"] == null ? void 0 : json["is_internal"]
  };
}

// src/openapi/models/SolanaTransactionSolanaTransactionTypeDetails.ts
function SolanaTransactionSolanaTransactionTypeDetailsFromJSON(json) {
  return SolanaTransactionSolanaTransactionTypeDetailsFromJSONTyped(json, false);
}
function SolanaTransactionSolanaTransactionTypeDetailsFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  switch (json["type"]) {
    case "native_transfer":
      return Object.assign({}, SolanaNativeTransferDetailsFromJSONTyped(json, true), { type: "native_transfer" });
    case "raw_transaction":
      return Object.assign({}, SolanaRawTransactionDetailsFromJSONTyped(json, true), { type: "raw_transaction" });
    case "spot_swap":
      return Object.assign({}, GetSolanaSpotSwapDetailsFromJSONTyped(json, true), { type: "spot_swap" });
    case "token_transfer":
      return Object.assign({}, SolanaTokenTransferDetailsFromJSONTyped(json, true), { type: "token_transfer" });
    default:
      throw new Error(`No variant of SolanaTransactionSolanaTransactionTypeDetails exists with 'type=${json["type"]}'`);
  }
}

// src/openapi/models/SolanaBlockData.ts
function SolanaBlockDataFromJSON(json) {
  return SolanaBlockDataFromJSONTyped(json, false);
}
function SolanaBlockDataFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "slot": json["slot"],
    "hash": json["hash"],
    "minedAt": new Date(json["mined_at"])
  };
}

// src/openapi/models/SolanaTransaction.ts
function SolanaTransactionFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "id": json["id"],
    "createdAt": new Date(json["created_at"]),
    "modifiedAt": new Date(json["modified_at"]),
    "managedTransactionData": json["managed_transaction_data"] == null ? void 0 : ManagedTransactionDataFromJSON(json["managed_transaction_data"]),
    "signatures": json["signatures"].map(SignatureFromJSON),
    "note": json["note"] == null ? void 0 : json["note"],
    "spamState": json["spam_state"] == null ? void 0 : TransactionSpamStateFromJSON(json["spam_state"]),
    "direction": TransactionDirectionFromJSON(json["direction"]),
    "signedExternally": json["signed_externally"] == null ? void 0 : json["signed_externally"],
    "state": PushableTransactionStateFromJSON(json["state"]),
    "stateChanges": json["state_changes"].map(PushableTransactionStateChangeFromJSON),
    "amlResults": json["aml_results"] == null ? void 0 : AmlResultsFromJSON(json["aml_results"]),
    "incomingAmlPolicyMatch": json["incoming_aml_policy_match"] == null ? void 0 : AmlPolicyMatchIncomingFromJSON(json["incoming_aml_policy_match"]),
    "type": json["type"],
    "solanaTransactionTypeDetails": SolanaTransactionSolanaTransactionTypeDetailsFromJSON(json["solana_transaction_type_details"]),
    "chain": EnrichedSolanaChainFromJSON(json["chain"]),
    "version": SolanaMessageVersionFromJSON(json["version"]),
    "instructions": json["instructions"].map(SolanaCompiledInstructionFromJSON),
    "accounts": json["accounts"].map(SolanaTransactionAccountFromJSON),
    "addressTableLookups": json["address_table_lookups"].map(SolanaEnrichedMessageAddressTableLookupFromJSON),
    "sender": EnrichedSolanaAddressFromJSON(json["sender"]),
    "rawTransaction": json["raw_transaction"] == null ? void 0 : json["raw_transaction"],
    "hash": json["hash"] == null ? void 0 : json["hash"],
    "recentBlockhash": json["recent_blockhash"] == null ? void 0 : json["recent_blockhash"],
    "block": json["block"] == null ? void 0 : SolanaBlockDataFromJSON(json["block"]),
    "expectedResult": json["expected_result"] == null ? void 0 : SolanaTransactionResultFromJSON(json["expected_result"]),
    "simulationStatusResult": SimulationStatusResultFromJSON(json["simulation_status_result"]),
    "minedResult": json["mined_result"] == null ? void 0 : SolanaTransactionResultFromJSON(json["mined_result"]),
    "explorerUrl": json["explorer_url"] == null ? void 0 : json["explorer_url"],
    "wasFeeSetInRequest": json["was_fee_set_in_request"]
  };
}

// src/openapi/models/IntegerHashPayload.ts
function IntegerHashPayloadToJSON(json) {
  return IntegerHashPayloadToJSONTyped(json, false);
}
function IntegerHashPayloadToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "format": value["format"],
    "hash_integer": value["hashInteger"]
  };
}

// src/openapi/models/CreateBlackBoxSignatureRequestDetails.ts
function CreateBlackBoxSignatureRequestDetailsToJSON(json) {
  return CreateBlackBoxSignatureRequestDetailsToJSONTyped(json, false);
}
function CreateBlackBoxSignatureRequestDetailsToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  switch (value["format"]) {
    case "hash_binary":
      return Object.assign({}, BinaryHashPayloadToJSON(value), { format: "hash_binary" });
    case "hash_integer":
      return Object.assign({}, IntegerHashPayloadToJSON(value), { format: "hash_integer" });
    default:
      throw new Error(`No variant of CreateBlackBoxSignatureRequestDetails exists with 'format=${value["format"]}'`);
  }
}

// src/openapi/models/CreateBlackBoxSignatureRequest.ts
function CreateBlackBoxSignatureRequestToJSON(json) {
  return CreateBlackBoxSignatureRequestToJSONTyped(json, false);
}
function CreateBlackBoxSignatureRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "vault_id": value["vaultId"],
    "note": value["note"],
    "signer_type": SignerTypeToJSON(value["signerType"]),
    "sign_mode": SignModeToJSON(value["signMode"]),
    "dapp_info": DappInfoToJSON(value["dappInfo"]),
    "type": value["type"],
    "details": CreateBlackBoxSignatureRequestDetailsToJSON(value["details"])
  };
}

// src/openapi/models/CreateBlackBoxSignatureWithWaitRequest.ts
function CreateBlackBoxSignatureWithWaitRequestToJSON(json) {
  return CreateBlackBoxSignatureWithWaitRequestToJSONTyped(json, false);
}
function CreateBlackBoxSignatureWithWaitRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "vault_id": value["vaultId"],
    "note": value["note"],
    "signer_type": SignerTypeToJSON(value["signerType"]),
    "sign_mode": SignModeToJSON(value["signMode"]),
    "dapp_info": DappInfoToJSON(value["dappInfo"]),
    "type": value["type"],
    "details": CreateBlackBoxSignatureRequestDetailsToJSON(value["details"]),
    "timeout": value["timeout"],
    "wait_for_state": NonPushableTransactionStateToJSON(value["waitForState"])
  };
}

// src/openapi/models/CreateBlackBoxVaultRequest.ts
function CreateBlackBoxVaultRequestToJSON(json) {
  return CreateBlackBoxVaultRequestToJSONTyped(json, false);
}
function CreateBlackBoxVaultRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "name": value["name"],
    "keyset_id": value["keysetId"],
    "end_user_id": value["endUserId"],
    "vault_group_id": value["vaultGroupId"],
    "import_vault": ImportVaultDefaultOptionsToJSON(value["importVault"]),
    "type": value["type"],
    "key_type": value["keyType"]
  };
}

// src/openapi/models/CreateCosmosMessageRequest.ts
function CreateCosmosMessageRequestToJSON(json) {
  return CreateCosmosMessageRequestToJSONTyped(json, false);
}
function CreateCosmosMessageRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "vault_id": value["vaultId"],
    "note": value["note"],
    "signer_type": SignerTypeToJSON(value["signerType"]),
    "sign_mode": SignModeToJSON(value["signMode"]),
    "dapp_info": DappInfoToJSON(value["dappInfo"]),
    "type": value["type"],
    "details": CosmosArbitraryMessageRequestToJSON(value["details"])
  };
}

// src/openapi/models/CreateCosmosMessageWithWaitRequest.ts
function CreateCosmosMessageWithWaitRequestToJSON(json) {
  return CreateCosmosMessageWithWaitRequestToJSONTyped(json, false);
}
function CreateCosmosMessageWithWaitRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "vault_id": value["vaultId"],
    "note": value["note"],
    "signer_type": SignerTypeToJSON(value["signerType"]),
    "sign_mode": SignModeToJSON(value["signMode"]),
    "dapp_info": DappInfoToJSON(value["dappInfo"]),
    "type": value["type"],
    "details": CosmosArbitraryMessageRequestToJSON(value["details"]),
    "timeout": value["timeout"],
    "wait_for_state": NonPushableTransactionStateToJSON(value["waitForState"])
  };
}

// src/openapi/models/DirectRequestData.ts
function DirectRequestDataToJSON(json) {
  return DirectRequestDataToJSONTyped(json, false);
}
function DirectRequestDataToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "format": value["format"],
    "body": value["body"],
    "auth_info": value["authInfo"],
    "account_number": value["accountNumber"]
  };
}

// src/openapi/models/TypedCosmosRawTransactionRequestRequestData.ts
function TypedCosmosRawTransactionRequestRequestDataToJSON(json) {
  return TypedCosmosRawTransactionRequestRequestDataToJSONTyped(json, false);
}
function TypedCosmosRawTransactionRequestRequestDataToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  switch (value["format"]) {
    case "amino":
      return Object.assign({}, AminoRequestDataToJSON(value), { format: "amino" });
    case "direct":
      return Object.assign({}, DirectRequestDataToJSON(value), { format: "direct" });
    default:
      throw new Error(`No variant of TypedCosmosRawTransactionRequestRequestData exists with 'format=${value["format"]}'`);
  }
}

// src/openapi/models/TypedCosmosRawTransactionRequest.ts
function TypedCosmosRawTransactionRequestToJSON(json) {
  return TypedCosmosRawTransactionRequestToJSONTyped(json, false);
}
function TypedCosmosRawTransactionRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "type": value["type"],
    "push_mode": PushModeToJSON(value["pushMode"]),
    "chain": CosmosChainUniqueIdToJSON(value["chain"]),
    "request_data": TypedCosmosRawTransactionRequestRequestDataToJSON(value["requestData"])
  };
}

// src/openapi/models/TypedCosmosTransferRequestTo.ts
function TypedCosmosTransferRequestToToJSON(json) {
  return TypedCosmosTransferRequestToToJSONTyped(json, false);
}
function TypedCosmosTransferRequestToToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  switch (value["type"]) {
    case "address":
      return Object.assign({}, CosmosTransferToAddressRequestToJSON(value), { type: "address" });
    case "vault_id":
      return Object.assign({}, RecipientVaultIdToJSON(value), { type: "vault_id" });
    default:
      throw new Error(`No variant of TypedCosmosTransferRequestTo exists with 'type=${value["type"]}'`);
  }
}

// src/openapi/models/TypedCosmosTransferRequest.ts
function TypedCosmosTransferRequestToJSON(json) {
  return TypedCosmosTransferRequestToJSONTyped(json, false);
}
function TypedCosmosTransferRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "type": value["type"],
    "push_mode": PushModeToJSON(value["pushMode"]),
    "to": TypedCosmosTransferRequestToToJSON(value["to"]),
    "asset_identifier": CosmosAssetIdentifierRequestToJSON(value["assetIdentifier"]),
    "value": CreateAptosTransferRequestValueToJSON(value["value"]),
    "memo": value["memo"]
  };
}

// src/openapi/models/CreateCosmosTransactionRequestDetails.ts
function CreateCosmosTransactionRequestDetailsToJSON(json) {
  return CreateCosmosTransactionRequestDetailsToJSONTyped(json, false);
}
function CreateCosmosTransactionRequestDetailsToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  switch (value["type"]) {
    case "cosmos_raw_transaction":
      return Object.assign({}, TypedCosmosRawTransactionRequestToJSON(value), { type: "cosmos_raw_transaction" });
    case "cosmos_transfer":
      return Object.assign({}, TypedCosmosTransferRequestToJSON(value), { type: "cosmos_transfer" });
    default:
      throw new Error(`No variant of CreateCosmosTransactionRequestDetails exists with 'type=${value["type"]}'`);
  }
}

// src/openapi/models/CreateCosmosTransactionRequest.ts
function CreateCosmosTransactionRequestToJSON(json) {
  return CreateCosmosTransactionRequestToJSONTyped(json, false);
}
function CreateCosmosTransactionRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "vault_id": value["vaultId"],
    "note": value["note"],
    "signer_type": SignerTypeToJSON(value["signerType"]),
    "sign_mode": SignModeToJSON(value["signMode"]),
    "dapp_info": DappInfoToJSON(value["dappInfo"]),
    "type": value["type"],
    "details": CreateCosmosTransactionRequestDetailsToJSON(value["details"])
  };
}

// src/openapi/models/CreateCosmosTransactionWithWaitRequest.ts
function CreateCosmosTransactionWithWaitRequestToJSON(json) {
  return CreateCosmosTransactionWithWaitRequestToJSONTyped(json, false);
}
function CreateCosmosTransactionWithWaitRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "vault_id": value["vaultId"],
    "note": value["note"],
    "signer_type": SignerTypeToJSON(value["signerType"]),
    "sign_mode": SignModeToJSON(value["signMode"]),
    "dapp_info": DappInfoToJSON(value["dappInfo"]),
    "type": value["type"],
    "details": CreateCosmosTransactionRequestDetailsToJSON(value["details"]),
    "timeout": value["timeout"],
    "wait_for_state": PushableTransactionStateToJSON(value["waitForState"])
  };
}

// src/openapi/models/CreateCosmosVaultRequest.ts
function CreateCosmosVaultRequestToJSON(json) {
  return CreateCosmosVaultRequestToJSONTyped(json, false);
}
function CreateCosmosVaultRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "name": value["name"],
    "keyset_id": value["keysetId"],
    "end_user_id": value["endUserId"],
    "vault_group_id": value["vaultGroupId"],
    "import_vault": ImportVaultDefaultOptionsToJSON(value["importVault"]),
    "type": value["type"]
  };
}

// src/openapi/models/KeyType.ts
function KeyTypeFromJSON(json) {
  return KeyTypeFromJSONTyped(json, false);
}
function KeyTypeFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// src/openapi/models/EvmChainRequest.ts
function EvmChainRequestToJSON(json) {
  return EvmChainRequestToJSONTyped(json, false);
}
function EvmChainRequestToJSONTyped(value, ignoreDiscriminator = false) {
  return value;
}

// src/openapi/models/CreateEvmPersonalMessageRequest.ts
var CreateEvmPersonalMessageRequestTypeEnum = {
  personalMessageType: "personal_message_type"
};
function CreateEvmPersonalMessageRequestToJSON(json) {
  return CreateEvmPersonalMessageRequestToJSONTyped(json, false);
}
function CreateEvmPersonalMessageRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "type": value["type"],
    "chain": EvmChainRequestToJSON(value["chain"]),
    "raw_data": value["rawData"]
  };
}

// src/openapi/models/CreateEvmTypedMessageRequest.ts
var CreateEvmTypedMessageRequestTypeEnum = {
  typedMessageType: "typed_message_type"
};
function CreateEvmTypedMessageRequestToJSON(json) {
  return CreateEvmTypedMessageRequestToJSONTyped(json, false);
}
function CreateEvmTypedMessageRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "type": value["type"],
    "chain": EvmChainRequestToJSON(value["chain"]),
    "raw_data": value["rawData"]
  };
}

// src/openapi/models/CreateEvmTypedV1MessageRequest.ts
function CreateEvmTypedV1MessageRequestToJSON(json) {
  return CreateEvmTypedV1MessageRequestToJSONTyped(json, false);
}
function CreateEvmTypedV1MessageRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "type": value["type"],
    "chain": EvmChainRequestToJSON(value["chain"]),
    "raw_data": value["rawData"]
  };
}

// src/openapi/models/CreateEvmMessageRequestDetails.ts
function CreateEvmMessageRequestDetailsToJSON(json) {
  return CreateEvmMessageRequestDetailsToJSONTyped(json, false);
}
function CreateEvmMessageRequestDetailsToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  switch (value["type"]) {
    case "personal_message_type":
      return Object.assign({}, CreateEvmPersonalMessageRequestToJSON(value), { type: "personal_message_type" });
    case "typed_message_type":
      return Object.assign({}, CreateEvmTypedMessageRequestToJSON(value), { type: "typed_message_type" });
    case "typed_message_type_v1":
      return Object.assign({}, CreateEvmTypedV1MessageRequestToJSON(value), { type: "typed_message_type_v1" });
    default:
      throw new Error(`No variant of CreateEvmMessageRequestDetails exists with 'type=${value["type"]}'`);
  }
}

// src/openapi/models/CreateEvmMessageRequest.ts
var CreateEvmMessageRequestTypeEnum = {
  evmMessage: "evm_message"
};
function CreateEvmMessageRequestToJSON(json) {
  return CreateEvmMessageRequestToJSONTyped(json, false);
}
function CreateEvmMessageRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "vault_id": value["vaultId"],
    "note": value["note"],
    "signer_type": SignerTypeToJSON(value["signerType"]),
    "sign_mode": SignModeToJSON(value["signMode"]),
    "dapp_info": DappInfoToJSON(value["dappInfo"]),
    "type": value["type"],
    "details": CreateEvmMessageRequestDetailsToJSON(value["details"])
  };
}

// src/openapi/models/CreateEvmMessageWithWaitRequest.ts
function CreateEvmMessageWithWaitRequestToJSON(json) {
  return CreateEvmMessageWithWaitRequestToJSONTyped(json, false);
}
function CreateEvmMessageWithWaitRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "vault_id": value["vaultId"],
    "note": value["note"],
    "signer_type": SignerTypeToJSON(value["signerType"]),
    "sign_mode": SignModeToJSON(value["signMode"]),
    "dapp_info": DappInfoToJSON(value["dappInfo"]),
    "type": value["type"],
    "details": CreateEvmMessageRequestDetailsToJSON(value["details"]),
    "timeout": value["timeout"],
    "wait_for_state": NonPushableTransactionStateToJSON(value["waitForState"])
  };
}

// src/openapi/models/EvmDataRequestBase64.ts
function EvmDataRequestBase64ToJSON(json) {
  return EvmDataRequestBase64ToJSONTyped(json, false);
}
function EvmDataRequestBase64ToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "type": value["type"],
    "raw_data": value["rawData"]
  };
}

// src/openapi/models/EvmDataRequestFullDetails.ts
function EvmDataRequestFullDetailsToJSON(json) {
  return EvmDataRequestFullDetailsToJSONTyped(json, false);
}
function EvmDataRequestFullDetailsToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "type": value["type"],
    "method_name": value["methodName"],
    "method_arguments": value["methodArguments"]
  };
}

// src/openapi/models/EvmDataRequestHex.ts
var EvmDataRequestHexTypeEnum = {
  hex: "hex"
};
function EvmDataRequestHexToJSON(json) {
  return EvmDataRequestHexToJSONTyped(json, false);
}
function EvmDataRequestHexToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "type": value["type"],
    "hex_data": value["hexData"]
  };
}

// src/openapi/models/EvmDataRequest.ts
function EvmDataRequestToJSON(json) {
  return EvmDataRequestToJSONTyped(json, false);
}
function EvmDataRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  switch (value["type"]) {
    case "base64":
      return Object.assign({}, EvmDataRequestBase64ToJSON(value), { type: "base64" });
    case "full_details":
      return Object.assign({}, EvmDataRequestFullDetailsToJSON(value), { type: "full_details" });
    case "hex":
      return Object.assign({}, EvmDataRequestHexToJSON(value), { type: "hex" });
    default:
      throw new Error(`No variant of EvmDataRequest exists with 'type=${value["type"]}'`);
  }
}

// src/openapi/models/DynamicGasRequest.ts
var DynamicGasRequestTypeEnum = {
  dynamic: "dynamic"
};
function DynamicGasRequestToJSON(json) {
  return DynamicGasRequestToJSONTyped(json, false);
}
function DynamicGasRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "type": value["type"],
    "max_priority_fee_per_gas": value["maxPriorityFeePerGas"],
    "max_fee_per_gas": value["maxFeePerGas"]
  };
}

// src/openapi/models/LegacyGasRequest.ts
function LegacyGasRequestToJSON(json) {
  return LegacyGasRequestToJSONTyped(json, false);
}
function LegacyGasRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "type": value["type"],
    "price": value["price"]
  };
}

// src/openapi/models/CustomGasRequestDetails.ts
function CustomGasRequestDetailsToJSON(json) {
  return CustomGasRequestDetailsToJSONTyped(json, false);
}
function CustomGasRequestDetailsToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  switch (value["type"]) {
    case "dynamic":
      return Object.assign({}, DynamicGasRequestToJSON(value), { type: "dynamic" });
    case "legacy":
      return Object.assign({}, LegacyGasRequestToJSON(value), { type: "legacy" });
    default:
      throw new Error(`No variant of CustomGasRequestDetails exists with 'type=${value["type"]}'`);
  }
}

// src/openapi/models/CustomGasRequest.ts
var CustomGasRequestTypeEnum = {
  custom: "custom"
};
function CustomGasRequestToJSON(json) {
  return CustomGasRequestToJSONTyped(json, false);
}
function CustomGasRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "gas_limit": value["gasLimit"],
    "type": value["type"],
    "details": CustomGasRequestDetailsToJSON(value["details"])
  };
}

// src/openapi/models/GasPriorityLevelRequest.ts
var GasPriorityLevelRequest = {
  low: "low",
  medium: "medium",
  high: "high"
};
function GasPriorityLevelRequestToJSON(value) {
  return value;
}

// src/openapi/models/GasPriorityRequest.ts
var GasPriorityRequestTypeEnum = {
  priority: "priority"
};
function GasPriorityRequestToJSON(json) {
  return GasPriorityRequestToJSONTyped(json, false);
}
function GasPriorityRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "gas_limit": value["gasLimit"],
    "type": value["type"],
    "priority_level": GasPriorityLevelRequestToJSON(value["priorityLevel"])
  };
}

// src/openapi/models/CreateEvmRawTransactionRequestGas.ts
function CreateEvmRawTransactionRequestGasToJSON(json) {
  return CreateEvmRawTransactionRequestGasToJSONTyped(json, false);
}
function CreateEvmRawTransactionRequestGasToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  switch (value["type"]) {
    case "custom":
      return Object.assign({}, CustomGasRequestToJSON(value), { type: "custom" });
    case "priority":
      return Object.assign({}, GasPriorityRequestToJSON(value), { type: "priority" });
    default:
      throw new Error(`No variant of CreateEvmRawTransactionRequestGas exists with 'type=${value["type"]}'`);
  }
}

// src/openapi/models/CreateEvmRawTransactionRequest.ts
var CreateEvmRawTransactionRequestTypeEnum = {
  evmRawTransaction: "evm_raw_transaction"
};
function CreateEvmRawTransactionRequestToJSON(json) {
  return CreateEvmRawTransactionRequestToJSONTyped(json, false);
}
function CreateEvmRawTransactionRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "type": value["type"],
    "use_secure_node": value["useSecureNode"],
    "gas": CreateEvmRawTransactionRequestGasToJSON(value["gas"]),
    "fail_on_prediction_failure": value["failOnPredictionFailure"],
    "skip_prediction": value["skipPrediction"],
    "push_mode": PushModeToJSON(value["pushMode"]),
    "funder": value["funder"],
    "chain": EvmChainRequestToJSON(value["chain"]),
    "to": value["to"],
    "value": value["value"],
    "data": EvmDataRequestToJSON(value["data"])
  };
}

// src/openapi/models/CreateEvmRevokeAllowanceRequest.ts
function CreateEvmRevokeAllowanceRequestToJSON(json) {
  return CreateEvmRevokeAllowanceRequestToJSONTyped(json, false);
}
function CreateEvmRevokeAllowanceRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "type": value["type"],
    "use_secure_node": value["useSecureNode"],
    "gas": CreateEvmRawTransactionRequestGasToJSON(value["gas"]),
    "fail_on_prediction_failure": value["failOnPredictionFailure"],
    "skip_prediction": value["skipPrediction"],
    "push_mode": PushModeToJSON(value["pushMode"]),
    "funder": value["funder"],
    "chain": EvmChainRequestToJSON(value["chain"]),
    "token": value["token"],
    "spender": value["spender"]
  };
}

// src/openapi/models/CreateEvmTransferRequestTo.ts
function CreateEvmTransferRequestToToJSON(json) {
  return CreateEvmTransferRequestToToJSONTyped(json, false);
}
function CreateEvmTransferRequestToToJSONTyped(value, ignoreDiscriminator = false) {
  return value;
}

// src/openapi/models/CreateEvmTransferRequest.ts
function CreateEvmTransferRequestToJSON(json) {
  return CreateEvmTransferRequestToJSONTyped(json, false);
}
function CreateEvmTransferRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "type": value["type"],
    "use_secure_node": value["useSecureNode"],
    "gas": CreateEvmRawTransactionRequestGasToJSON(value["gas"]),
    "fail_on_prediction_failure": value["failOnPredictionFailure"],
    "skip_prediction": value["skipPrediction"],
    "push_mode": PushModeToJSON(value["pushMode"]),
    "funder": value["funder"],
    "to": CreateEvmTransferRequestToToJSON(value["to"]),
    "asset_identifier": EvmAssetIdentifierRequestToJSON(value["assetIdentifier"]),
    "value": CreateAptosTransferRequestValueToJSON(value["value"])
  };
}

// src/openapi/models/CreateEvmTransactionRequestDetails.ts
function CreateEvmTransactionRequestDetailsToJSON(json) {
  return CreateEvmTransactionRequestDetailsToJSONTyped(json, false);
}
function CreateEvmTransactionRequestDetailsToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  switch (value["type"]) {
    case "evm_raw_transaction":
      return Object.assign({}, CreateEvmRawTransactionRequestToJSON(value), { type: "evm_raw_transaction" });
    case "evm_revoke_allowance":
      return Object.assign({}, CreateEvmRevokeAllowanceRequestToJSON(value), { type: "evm_revoke_allowance" });
    case "evm_transfer":
      return Object.assign({}, CreateEvmTransferRequestToJSON(value), { type: "evm_transfer" });
    default:
      throw new Error(`No variant of CreateEvmTransactionRequestDetails exists with 'type=${value["type"]}'`);
  }
}

// src/openapi/models/CreateEvmTransactionRequest.ts
var CreateEvmTransactionRequestTypeEnum = {
  evmTransaction: "evm_transaction"
};
function CreateEvmTransactionRequestToJSON(json) {
  return CreateEvmTransactionRequestToJSONTyped(json, false);
}
function CreateEvmTransactionRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "vault_id": value["vaultId"],
    "note": value["note"],
    "signer_type": SignerTypeToJSON(value["signerType"]),
    "sign_mode": SignModeToJSON(value["signMode"]),
    "dapp_info": DappInfoToJSON(value["dappInfo"]),
    "type": value["type"],
    "details": CreateEvmTransactionRequestDetailsToJSON(value["details"])
  };
}

// src/openapi/models/CreateEvmTransactionWithWaitRequest.ts
function CreateEvmTransactionWithWaitRequestToJSON(json) {
  return CreateEvmTransactionWithWaitRequestToJSONTyped(json, false);
}
function CreateEvmTransactionWithWaitRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "vault_id": value["vaultId"],
    "note": value["note"],
    "signer_type": SignerTypeToJSON(value["signerType"]),
    "sign_mode": SignModeToJSON(value["signMode"]),
    "dapp_info": DappInfoToJSON(value["dappInfo"]),
    "type": value["type"],
    "details": CreateEvmTransactionRequestDetailsToJSON(value["details"]),
    "timeout": value["timeout"],
    "wait_for_state": PushableTransactionStateToJSON(value["waitForState"])
  };
}

// src/openapi/models/CreateEvmVaultRequest.ts
function CreateEvmVaultRequestToJSON(json) {
  return CreateEvmVaultRequestToJSONTyped(json, false);
}
function CreateEvmVaultRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "name": value["name"],
    "keyset_id": value["keysetId"],
    "end_user_id": value["endUserId"],
    "vault_group_id": value["vaultGroupId"],
    "import_vault": ImportVaultDefaultOptionsToJSON(value["importVault"]),
    "type": value["type"]
  };
}

// src/openapi/models/CreateExchangeExternalWithdrawRequestExplicitAmount.ts
function CreateExchangeExternalWithdrawRequestExplicitAmountToJSON(json) {
  return CreateExchangeExternalWithdrawRequestExplicitAmountToJSONTyped(json, false);
}
function CreateExchangeExternalWithdrawRequestExplicitAmountToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "type": value["type"],
    "value": value["value"],
    "is_net_amount": value["isNetAmount"]
  };
}

// src/openapi/models/CreateExchangeTransferRequestMaxAmount.ts
function CreateExchangeTransferRequestMaxAmountToJSON(json) {
  return CreateExchangeTransferRequestMaxAmountToJSONTyped(json, false);
}
function CreateExchangeTransferRequestMaxAmountToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "type": value["type"]
  };
}

// src/openapi/models/CreateExchangeExternalWithdrawRequestValue.ts
function CreateExchangeExternalWithdrawRequestValueToJSON(json) {
  return CreateExchangeExternalWithdrawRequestValueToJSONTyped(json, false);
}
function CreateExchangeExternalWithdrawRequestValueToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  switch (value["type"]) {
    case "max":
      return Object.assign({}, CreateExchangeTransferRequestMaxAmountToJSON(value), { type: "max" });
    case "value":
      return Object.assign({}, CreateExchangeExternalWithdrawRequestExplicitAmountToJSON(value), { type: "value" });
    default:
      throw new Error(`No variant of CreateExchangeExternalWithdrawRequestValue exists with 'type=${value["type"]}'`);
  }
}

// src/openapi/models/ExchangeTransferExternalRecipientTypeAddress.ts
function ExchangeTransferExternalRecipientTypeAddressToJSON(json) {
  return ExchangeTransferExternalRecipientTypeAddressToJSONTyped(json, false);
}
function ExchangeTransferExternalRecipientTypeAddressToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "type": value["type"],
    "address": value["address"]
  };
}

// src/openapi/models/ExchangeTransferExternalRecipientTypeVault.ts
function ExchangeTransferExternalRecipientTypeVaultToJSON(json) {
  return ExchangeTransferExternalRecipientTypeVaultToJSONTyped(json, false);
}
function ExchangeTransferExternalRecipientTypeVaultToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "type": value["type"],
    "vault_id": value["vaultId"]
  };
}

// src/openapi/models/CreateExchangeExternalWithdrawRequestTo.ts
function CreateExchangeExternalWithdrawRequestToToJSON(json) {
  return CreateExchangeExternalWithdrawRequestToToJSONTyped(json, false);
}
function CreateExchangeExternalWithdrawRequestToToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  switch (value["type"]) {
    case "address":
      return Object.assign({}, ExchangeTransferExternalRecipientTypeAddressToJSON(value), { type: "address" });
    case "vault":
      return Object.assign({}, ExchangeTransferExternalRecipientTypeVaultToJSON(value), { type: "vault" });
    default:
      throw new Error(`No variant of CreateExchangeExternalWithdrawRequestTo exists with 'type=${value["type"]}'`);
  }
}

// src/openapi/models/CreateExchangeExternalWithdrawRequest.ts
function CreateExchangeExternalWithdrawRequestToJSON(json) {
  return CreateExchangeExternalWithdrawRequestToJSONTyped(json, false);
}
function CreateExchangeExternalWithdrawRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "type": value["type"],
    "fail_on_prediction_failure": value["failOnPredictionFailure"],
    "skip_prediction": value["skipPrediction"],
    "asset_identifier": ExchangeAssetIdentifierRequestToJSON(value["assetIdentifier"]),
    "chain": value["chain"],
    "to": CreateExchangeExternalWithdrawRequestToToJSON(value["to"]),
    "value": CreateExchangeExternalWithdrawRequestValueToJSON(value["value"]),
    "memo": value["memo"]
  };
}

// src/openapi/models/CreateExchangeTransactionRequestDetails.ts
function CreateExchangeTransactionRequestDetailsToJSON(json) {
  return CreateExchangeTransactionRequestDetailsToJSONTyped(json, false);
}
function CreateExchangeTransactionRequestDetailsToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  switch (value["type"]) {
    case "external_withdraw":
      return Object.assign({}, CreateExchangeExternalWithdrawRequestToJSON(value), { type: "external_withdraw" });
    default:
      throw new Error(`No variant of CreateExchangeTransactionRequestDetails exists with 'type=${value["type"]}'`);
  }
}

// src/openapi/models/CreateExchangeTransactionRequest.ts
function CreateExchangeTransactionRequestToJSON(json) {
  return CreateExchangeTransactionRequestToJSONTyped(json, false);
}
function CreateExchangeTransactionRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "vault_id": value["vaultId"],
    "note": value["note"],
    "signer_type": value["signerType"],
    "dapp_info": DappInfoToJSON(value["dappInfo"]),
    "type": value["type"],
    "details": CreateExchangeTransactionRequestDetailsToJSON(value["details"])
  };
}

// src/openapi/models/EvmVault.ts
function EvmVaultFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "id": json["id"],
    "createdAt": new Date(json["created_at"]),
    "modifiedAt": new Date(json["modified_at"]),
    "metadata": json["metadata"] == null ? void 0 : mapValues(json["metadata"], AptosVaultMetadataValueFromJSON),
    "name": json["name"],
    "createdBy": UserRefFromJSON(json["created_by"]),
    "vaultGroup": VaultGroupRefFromJSON(json["vault_group"]),
    "pendingVaultGroupAction": json["pending_vault_group_action"] == null ? void 0 : AptosVaultPendingVaultGroupActionFromJSON(json["pending_vault_group_action"]),
    "state": VaultStateFromJSON(json["state"]),
    "areAllChainsDisabled": json["are_all_chains_disabled"],
    "derivationPath": json["derivation_path"],
    "publicKeyCompressed": json["public_key_compressed"],
    "derivationInfo": VaultDerivationInfoFromJSON(json["derivation_info"]),
    "keyset": KeysetRefFromJSON(json["keyset"]),
    "keyHolder": json["key_holder"] == null ? void 0 : EndUserRefFromJSON(json["key_holder"]),
    "originType": VaultOriginTypeFromJSON(json["origin_type"]),
    "type": json["type"],
    "address": json["address"]
  };
}

// src/openapi/models/ExchangeAccount.ts
function ExchangeAccountFromJSON(json) {
  return ExchangeAccountFromJSONTyped(json, false);
}
function ExchangeAccountFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "accountId": json["account_id"],
    "accountName": json["account_name"]
  };
}

// src/openapi/models/ExchangeVault.ts
function ExchangeVaultFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "id": json["id"],
    "createdAt": new Date(json["created_at"]),
    "modifiedAt": new Date(json["modified_at"]),
    "metadata": json["metadata"] == null ? void 0 : mapValues(json["metadata"], AptosVaultMetadataValueFromJSON),
    "name": json["name"],
    "createdBy": UserRefFromJSON(json["created_by"]),
    "vaultGroup": VaultGroupRefFromJSON(json["vault_group"]),
    "pendingVaultGroupAction": json["pending_vault_group_action"] == null ? void 0 : AptosVaultPendingVaultGroupActionFromJSON(json["pending_vault_group_action"]),
    "state": VaultStateFromJSON(json["state"]),
    "areAllChainsDisabled": json["are_all_chains_disabled"],
    "type": json["type"],
    "exchangeType": ExchangeTypeFromJSON(json["exchange_type"]),
    "apiKey": json["api_key"],
    "activeAccount": json["active_account"] == null ? void 0 : ExchangeAccountFromJSON(json["active_account"]),
    "logoUrl": json["logo_url"],
    "isBalanceDataOutdated": json["is_balance_data_outdated"]
  };
}

// src/openapi/models/SolanaVault.ts
function SolanaVaultFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "id": json["id"],
    "createdAt": new Date(json["created_at"]),
    "modifiedAt": new Date(json["modified_at"]),
    "metadata": json["metadata"] == null ? void 0 : mapValues(json["metadata"], AptosVaultMetadataValueFromJSON),
    "name": json["name"],
    "createdBy": UserRefFromJSON(json["created_by"]),
    "vaultGroup": VaultGroupRefFromJSON(json["vault_group"]),
    "pendingVaultGroupAction": json["pending_vault_group_action"] == null ? void 0 : AptosVaultPendingVaultGroupActionFromJSON(json["pending_vault_group_action"]),
    "state": VaultStateFromJSON(json["state"]),
    "areAllChainsDisabled": json["are_all_chains_disabled"],
    "derivationPath": json["derivation_path"],
    "publicKeyCompressed": json["public_key_compressed"],
    "derivationInfo": VaultDerivationInfoFromJSON(json["derivation_info"]),
    "keyset": KeysetRefFromJSON(json["keyset"]),
    "keyHolder": json["key_holder"] == null ? void 0 : EndUserRefFromJSON(json["key_holder"]),
    "originType": VaultOriginTypeFromJSON(json["origin_type"]),
    "type": json["type"],
    "address": json["address"]
  };
}

// src/openapi/models/StacksVault.ts
function StacksVaultFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "id": json["id"],
    "createdAt": new Date(json["created_at"]),
    "modifiedAt": new Date(json["modified_at"]),
    "metadata": json["metadata"] == null ? void 0 : mapValues(json["metadata"], AptosVaultMetadataValueFromJSON),
    "name": json["name"],
    "createdBy": UserRefFromJSON(json["created_by"]),
    "vaultGroup": VaultGroupRefFromJSON(json["vault_group"]),
    "pendingVaultGroupAction": json["pending_vault_group_action"] == null ? void 0 : AptosVaultPendingVaultGroupActionFromJSON(json["pending_vault_group_action"]),
    "state": VaultStateFromJSON(json["state"]),
    "areAllChainsDisabled": json["are_all_chains_disabled"],
    "derivationPath": json["derivation_path"],
    "publicKeyCompressed": json["public_key_compressed"],
    "derivationInfo": VaultDerivationInfoFromJSON(json["derivation_info"]),
    "keyset": KeysetRefFromJSON(json["keyset"]),
    "keyHolder": json["key_holder"] == null ? void 0 : EndUserRefFromJSON(json["key_holder"]),
    "originType": VaultOriginTypeFromJSON(json["origin_type"]),
    "type": json["type"],
    "address": json["address"]
  };
}

// src/openapi/models/StarknetVaultState.ts
function StarknetVaultStateFromJSON(json) {
  return StarknetVaultStateFromJSONTyped(json, false);
}
function StarknetVaultStateFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// src/openapi/models/StarknetVault.ts
function StarknetVaultFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "id": json["id"],
    "createdAt": new Date(json["created_at"]),
    "modifiedAt": new Date(json["modified_at"]),
    "metadata": json["metadata"] == null ? void 0 : mapValues(json["metadata"], AptosVaultMetadataValueFromJSON),
    "name": json["name"],
    "createdBy": UserRefFromJSON(json["created_by"]),
    "vaultGroup": VaultGroupRefFromJSON(json["vault_group"]),
    "pendingVaultGroupAction": json["pending_vault_group_action"] == null ? void 0 : AptosVaultPendingVaultGroupActionFromJSON(json["pending_vault_group_action"]),
    "state": VaultStateFromJSON(json["state"]),
    "areAllChainsDisabled": json["are_all_chains_disabled"],
    "derivationPath": json["derivation_path"],
    "publicKeyCompressed": json["public_key_compressed"],
    "derivationInfo": VaultDerivationInfoFromJSON(json["derivation_info"]),
    "keyset": KeysetRefFromJSON(json["keyset"]),
    "keyHolder": json["key_holder"] == null ? void 0 : EndUserRefFromJSON(json["key_holder"]),
    "originType": VaultOriginTypeFromJSON(json["origin_type"]),
    "type": json["type"],
    "address": json["address"],
    "activationState": StarknetVaultStateFromJSON(json["activation_state"]),
    "activatingTransactionId": json["activating_transaction_id"] == null ? void 0 : json["activating_transaction_id"]
  };
}

// src/openapi/models/SuiVault.ts
function SuiVaultFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "id": json["id"],
    "createdAt": new Date(json["created_at"]),
    "modifiedAt": new Date(json["modified_at"]),
    "metadata": json["metadata"] == null ? void 0 : mapValues(json["metadata"], AptosVaultMetadataValueFromJSON),
    "name": json["name"],
    "createdBy": UserRefFromJSON(json["created_by"]),
    "vaultGroup": VaultGroupRefFromJSON(json["vault_group"]),
    "pendingVaultGroupAction": json["pending_vault_group_action"] == null ? void 0 : AptosVaultPendingVaultGroupActionFromJSON(json["pending_vault_group_action"]),
    "state": VaultStateFromJSON(json["state"]),
    "areAllChainsDisabled": json["are_all_chains_disabled"],
    "derivationPath": json["derivation_path"],
    "publicKeyCompressed": json["public_key_compressed"],
    "derivationInfo": VaultDerivationInfoFromJSON(json["derivation_info"]),
    "keyset": KeysetRefFromJSON(json["keyset"]),
    "keyHolder": json["key_holder"] == null ? void 0 : EndUserRefFromJSON(json["key_holder"]),
    "originType": VaultOriginTypeFromJSON(json["origin_type"]),
    "type": json["type"],
    "address": json["address"]
  };
}

// src/openapi/models/TonVault.ts
function TonVaultFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "id": json["id"],
    "createdAt": new Date(json["created_at"]),
    "modifiedAt": new Date(json["modified_at"]),
    "metadata": json["metadata"] == null ? void 0 : mapValues(json["metadata"], AptosVaultMetadataValueFromJSON),
    "name": json["name"],
    "createdBy": UserRefFromJSON(json["created_by"]),
    "vaultGroup": VaultGroupRefFromJSON(json["vault_group"]),
    "pendingVaultGroupAction": json["pending_vault_group_action"] == null ? void 0 : AptosVaultPendingVaultGroupActionFromJSON(json["pending_vault_group_action"]),
    "state": VaultStateFromJSON(json["state"]),
    "areAllChainsDisabled": json["are_all_chains_disabled"],
    "derivationPath": json["derivation_path"],
    "publicKeyCompressed": json["public_key_compressed"],
    "derivationInfo": VaultDerivationInfoFromJSON(json["derivation_info"]),
    "keyset": KeysetRefFromJSON(json["keyset"]),
    "keyHolder": json["key_holder"] == null ? void 0 : EndUserRefFromJSON(json["key_holder"]),
    "originType": VaultOriginTypeFromJSON(json["origin_type"]),
    "type": json["type"],
    "rawAccount": json["raw_account"],
    "base64UrlBounceableAccount": json["base64_url_bounceable_account"],
    "base64UrlNonBounceableAccount": json["base64_url_non_bounceable_account"],
    "stateInit": json["state_init"]
  };
}

// src/openapi/models/TronVaultEnergyAndBandwidthData.ts
function TronVaultEnergyAndBandwidthDataFromJSON(json) {
  return TronVaultEnergyAndBandwidthDataFromJSONTyped(json, false);
}
function TronVaultEnergyAndBandwidthDataFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "energyUsed": json["energy_used"],
    "energyLimit": json["energy_limit"],
    "bandwidthUsed": json["bandwidth_used"],
    "bandwidthLimit": json["bandwidth_limit"]
  };
}

// src/openapi/models/TronVault.ts
function TronVaultFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "id": json["id"],
    "createdAt": new Date(json["created_at"]),
    "modifiedAt": new Date(json["modified_at"]),
    "metadata": json["metadata"] == null ? void 0 : mapValues(json["metadata"], AptosVaultMetadataValueFromJSON),
    "name": json["name"],
    "createdBy": UserRefFromJSON(json["created_by"]),
    "vaultGroup": VaultGroupRefFromJSON(json["vault_group"]),
    "pendingVaultGroupAction": json["pending_vault_group_action"] == null ? void 0 : AptosVaultPendingVaultGroupActionFromJSON(json["pending_vault_group_action"]),
    "state": VaultStateFromJSON(json["state"]),
    "areAllChainsDisabled": json["are_all_chains_disabled"],
    "derivationPath": json["derivation_path"],
    "publicKeyCompressed": json["public_key_compressed"],
    "derivationInfo": VaultDerivationInfoFromJSON(json["derivation_info"]),
    "keyset": KeysetRefFromJSON(json["keyset"]),
    "keyHolder": json["key_holder"] == null ? void 0 : EndUserRefFromJSON(json["key_holder"]),
    "originType": VaultOriginTypeFromJSON(json["origin_type"]),
    "type": json["type"],
    "address": json["address"],
    "energyAndBandwidthDataMap": mapValues(json["energy_and_bandwidth_data_map"], TronVaultEnergyAndBandwidthDataFromJSON)
  };
}

// src/openapi/models/UtxoVaultAddress.ts
function UtxoVaultAddressFromJSON(json) {
  return UtxoVaultAddressFromJSONTyped(json, false);
}
function UtxoVaultAddressFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "id": json["id"],
    "createdAt": new Date(json["created_at"]),
    "modifiedAt": new Date(json["modified_at"]),
    "vault": VaultRefFromJSON(json["vault"]),
    "name": json["name"],
    "balance": json["balance"] == null ? void 0 : json["balance"],
    "balances": json["balances"] == null ? void 0 : BalancesFromJSON(json["balances"]),
    "publicKeyCompressed": json["public_key_compressed"],
    "derivationPath": json["derivation_path"],
    "type": json["type"],
    "address": UtxoAddressFromJSON(json["address"])
  };
}

// src/openapi/models/UtxoVault.ts
function UtxoVaultFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "id": json["id"],
    "createdAt": new Date(json["created_at"]),
    "modifiedAt": new Date(json["modified_at"]),
    "metadata": json["metadata"] == null ? void 0 : mapValues(json["metadata"], AptosVaultMetadataValueFromJSON),
    "name": json["name"],
    "createdBy": UserRefFromJSON(json["created_by"]),
    "vaultGroup": VaultGroupRefFromJSON(json["vault_group"]),
    "pendingVaultGroupAction": json["pending_vault_group_action"] == null ? void 0 : AptosVaultPendingVaultGroupActionFromJSON(json["pending_vault_group_action"]),
    "state": VaultStateFromJSON(json["state"]),
    "areAllChainsDisabled": json["are_all_chains_disabled"],
    "derivationPath": json["derivation_path"],
    "publicKeyCompressed": json["public_key_compressed"],
    "derivationInfo": VaultDerivationInfoFromJSON(json["derivation_info"]),
    "keyset": KeysetRefFromJSON(json["keyset"]),
    "keyHolder": json["key_holder"] == null ? void 0 : EndUserRefFromJSON(json["key_holder"]),
    "originType": VaultOriginTypeFromJSON(json["origin_type"]),
    "type": json["type"],
    "chain": EnrichedUtxoChainFromJSON(json["chain"]),
    "defaultAddress": UtxoVaultAddressFromJSON(json["default_address"]),
    "defaultNextAddressName": json["default_next_address_name"],
    "taprootKeyPublicCompressed": json["taproot_key_public_compressed"] == null ? void 0 : json["taproot_key_public_compressed"],
    "taprootKeyDerivationInfo": json["taproot_key_derivation_info"] == null ? void 0 : VaultDerivationInfoFromJSON(json["taproot_key_derivation_info"])
  };
}

// src/openapi/models/SolanaPersonalMessageRequest.ts
function SolanaPersonalMessageRequestToJSON(json) {
  return SolanaPersonalMessageRequestToJSONTyped(json, false);
}
function SolanaPersonalMessageRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "type": value["type"],
    "chain": SolanaChainUniqueIdToJSON(value["chain"]),
    "raw_data": value["rawData"]
  };
}

// src/openapi/models/CreateSolanaMessageRequest.ts
function CreateSolanaMessageRequestToJSON(json) {
  return CreateSolanaMessageRequestToJSONTyped(json, false);
}
function CreateSolanaMessageRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "vault_id": value["vaultId"],
    "note": value["note"],
    "signer_type": SignerTypeToJSON(value["signerType"]),
    "sign_mode": SignModeToJSON(value["signMode"]),
    "dapp_info": DappInfoToJSON(value["dappInfo"]),
    "type": value["type"],
    "details": SolanaPersonalMessageRequestToJSON(value["details"])
  };
}

// src/openapi/models/CreateSolanaMessageWithWaitRequest.ts
function CreateSolanaMessageWithWaitRequestToJSON(json) {
  return CreateSolanaMessageWithWaitRequestToJSONTyped(json, false);
}
function CreateSolanaMessageWithWaitRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "vault_id": value["vaultId"],
    "note": value["note"],
    "signer_type": SignerTypeToJSON(value["signerType"]),
    "sign_mode": SignModeToJSON(value["signMode"]),
    "dapp_info": DappInfoToJSON(value["dappInfo"]),
    "type": value["type"],
    "details": SolanaPersonalMessageRequestToJSON(value["details"]),
    "timeout": value["timeout"],
    "wait_for_state": NonPushableTransactionStateToJSON(value["waitForState"])
  };
}

// src/openapi/models/CreateSolanaRawTransactionRequest.ts
function CreateSolanaRawTransactionRequestToJSON(json) {
  return CreateSolanaRawTransactionRequestToJSONTyped(json, false);
}
function CreateSolanaRawTransactionRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "version": SolanaMessageVersionToJSON(value["version"]),
    "instructions": value["instructions"].map(SolanaCompiledInstructionRequestToJSON),
    "accounts": value["accounts"].map(SolanaTransactionAccountRequestToJSON),
    "address_table_lookups": value["addressTableLookups"].map(SolanaMessageAddressTableLookupRequestToJSON),
    "signatures": value["signatures"] == null ? void 0 : value["signatures"].map(SolanaTransactionSignaturesRequestToJSON),
    "recent_blockhash": value["recentBlockhash"],
    "fee": BatchSolanaTransactionRequestDetailsFeeToJSON(value["fee"]),
    "type": value["type"],
    "fail_on_prediction_failure": value["failOnPredictionFailure"],
    "push_mode": PushModeToJSON(value["pushMode"]),
    "skip_prediction": value["skipPrediction"],
    "chain": SolanaChainUniqueIdToJSON(value["chain"])
  };
}

// src/openapi/models/SolanaSecretKeyRequest.ts
function SolanaSecretKeyRequestToJSON(json) {
  return SolanaSecretKeyRequestToJSONTyped(json, false);
}
function SolanaSecretKeyRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "data": value["data"]
  };
}

// src/openapi/models/CreateSolanaSerializedTransactionMessageRequest.ts
function CreateSolanaSerializedTransactionMessageRequestToJSON(json) {
  return CreateSolanaSerializedTransactionMessageRequestToJSONTyped(json, false);
}
function CreateSolanaSerializedTransactionMessageRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "fee": BatchSolanaTransactionRequestDetailsFeeToJSON(value["fee"]),
    "type": value["type"],
    "fail_on_prediction_failure": value["failOnPredictionFailure"],
    "push_mode": PushModeToJSON(value["pushMode"]),
    "skip_prediction": value["skipPrediction"],
    "chain": SolanaChainUniqueIdToJSON(value["chain"]),
    "data": value["data"],
    "signatures": value["signatures"] == null ? void 0 : value["signatures"].map(SolanaTransactionSignaturesRequestToJSON),
    "ephemeral_keys": value["ephemeralKeys"] == null ? void 0 : value["ephemeralKeys"].map(SolanaSecretKeyRequestToJSON)
  };
}

// src/openapi/models/JitoCustomFeeRequest.ts
function JitoCustomFeeRequestToJSON(json) {
  return JitoCustomFeeRequestToJSONTyped(json, false);
}
function JitoCustomFeeRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "type": value["type"],
    "jito_tip": value["jitoTip"]
  };
}

// src/openapi/models/JitoPriorityFeeRequest.ts
function JitoPriorityFeeRequestToJSON(json) {
  return JitoPriorityFeeRequestToJSONTyped(json, false);
}
function JitoPriorityFeeRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "type": value["type"],
    "priority_level": FeePriorityLevelRequestToJSON(value["priorityLevel"])
  };
}

// src/openapi/models/SolanaJitoFeeTypeRequestDetails.ts
function SolanaJitoFeeTypeRequestDetailsToJSON(json) {
  return SolanaJitoFeeTypeRequestDetailsToJSONTyped(json, false);
}
function SolanaJitoFeeTypeRequestDetailsToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  switch (value["type"]) {
    case "custom":
      return Object.assign({}, JitoCustomFeeRequestToJSON(value), { type: "custom" });
    case "priority":
      return Object.assign({}, JitoPriorityFeeRequestToJSON(value), { type: "priority" });
    default:
      throw new Error(`No variant of SolanaJitoFeeTypeRequestDetails exists with 'type=${value["type"]}'`);
  }
}

// src/openapi/models/SolanaJitoFeeTypeRequest.ts
function SolanaJitoFeeTypeRequestToJSON(json) {
  return SolanaJitoFeeTypeRequestToJSONTyped(json, false);
}
function SolanaJitoFeeTypeRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "type": value["type"],
    "details": SolanaJitoFeeTypeRequestDetailsToJSON(value["details"])
  };
}

// src/openapi/models/SolanaPriorityFeeTypeRequest.ts
function SolanaPriorityFeeTypeRequestToJSON(json) {
  return SolanaPriorityFeeTypeRequestToJSONTyped(json, false);
}
function SolanaPriorityFeeTypeRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "type": value["type"],
    "details": BatchSolanaTransactionRequestDetailsFeeToJSON(value["details"])
  };
}

// src/openapi/models/CreateSolanaSpotSwapRequestFee.ts
function CreateSolanaSpotSwapRequestFeeToJSON(json) {
  return CreateSolanaSpotSwapRequestFeeToJSONTyped(json, false);
}
function CreateSolanaSpotSwapRequestFeeToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  switch (value["type"]) {
    case "jito":
      return Object.assign({}, SolanaJitoFeeTypeRequestToJSON(value), { type: "jito" });
    case "priority_fee":
      return Object.assign({}, SolanaPriorityFeeTypeRequestToJSON(value), { type: "priority_fee" });
    default:
      throw new Error(`No variant of CreateSolanaSpotSwapRequestFee exists with 'type=${value["type"]}'`);
  }
}

// src/openapi/models/CreateSolanaSpotSwapRequest.ts
function CreateSolanaSpotSwapRequestToJSON(json) {
  return CreateSolanaSpotSwapRequestToJSONTyped(json, false);
}
function CreateSolanaSpotSwapRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "quote_id": value["quoteId"],
    "input_asset_identifier": SolanaAssetIdentifierRequestToJSON(value["inputAssetIdentifier"]),
    "output_asset_identifier": SolanaAssetIdentifierRequestToJSON(value["outputAssetIdentifier"]),
    "amount": value["amount"],
    "fee": CreateSolanaSpotSwapRequestFeeToJSON(value["fee"]),
    "slippage_bps": value["slippageBps"],
    "type": value["type"],
    "fail_on_prediction_failure": value["failOnPredictionFailure"],
    "push_mode": PushModeToJSON(value["pushMode"]),
    "skip_prediction": value["skipPrediction"]
  };
}

// src/openapi/models/CreateSolanaTransferRequestTo.ts
function CreateSolanaTransferRequestToToJSON(json) {
  return CreateSolanaTransferRequestToToJSONTyped(json, false);
}
function CreateSolanaTransferRequestToToJSONTyped(value, ignoreDiscriminator = false) {
  return value;
}

// src/openapi/models/CreateSolanaTransferRequest.ts
function CreateSolanaTransferRequestToJSON(json) {
  return CreateSolanaTransferRequestToJSONTyped(json, false);
}
function CreateSolanaTransferRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "fee": BatchSolanaTransactionRequestDetailsFeeToJSON(value["fee"]),
    "type": value["type"],
    "fail_on_prediction_failure": value["failOnPredictionFailure"],
    "push_mode": PushModeToJSON(value["pushMode"]),
    "skip_prediction": value["skipPrediction"],
    "to": CreateSolanaTransferRequestToToJSON(value["to"]),
    "value": CreateAptosTransferRequestValueToJSON(value["value"]),
    "asset_identifier": SolanaAssetIdentifierRequestToJSON(value["assetIdentifier"])
  };
}

// src/openapi/models/CreateSolanaTransactionRequestDetails.ts
function CreateSolanaTransactionRequestDetailsToJSON(json) {
  return CreateSolanaTransactionRequestDetailsToJSONTyped(json, false);
}
function CreateSolanaTransactionRequestDetailsToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  switch (value["type"]) {
    case "solana_raw_transaction":
      return Object.assign({}, CreateSolanaRawTransactionRequestToJSON(value), { type: "solana_raw_transaction" });
    case "solana_serialized_transaction_message":
      return Object.assign({}, CreateSolanaSerializedTransactionMessageRequestToJSON(value), { type: "solana_serialized_transaction_message" });
    case "solana_spot_swap":
      return Object.assign({}, CreateSolanaSpotSwapRequestToJSON(value), { type: "solana_spot_swap" });
    case "solana_transfer":
      return Object.assign({}, CreateSolanaTransferRequestToJSON(value), { type: "solana_transfer" });
    default:
      throw new Error(`No variant of CreateSolanaTransactionRequestDetails exists with 'type=${value["type"]}'`);
  }
}

// src/openapi/models/CreateSolanaTransactionRequest.ts
function CreateSolanaTransactionRequestToJSON(json) {
  return CreateSolanaTransactionRequestToJSONTyped(json, false);
}
function CreateSolanaTransactionRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "vault_id": value["vaultId"],
    "note": value["note"],
    "signer_type": SignerTypeToJSON(value["signerType"]),
    "sign_mode": SignModeToJSON(value["signMode"]),
    "dapp_info": DappInfoToJSON(value["dappInfo"]),
    "type": value["type"],
    "details": CreateSolanaTransactionRequestDetailsToJSON(value["details"])
  };
}

// src/openapi/models/CreateSolanaTransactionWithWaitRequest.ts
function CreateSolanaTransactionWithWaitRequestToJSON(json) {
  return CreateSolanaTransactionWithWaitRequestToJSONTyped(json, false);
}
function CreateSolanaTransactionWithWaitRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "vault_id": value["vaultId"],
    "note": value["note"],
    "signer_type": SignerTypeToJSON(value["signerType"]),
    "sign_mode": SignModeToJSON(value["signMode"]),
    "dapp_info": DappInfoToJSON(value["dappInfo"]),
    "type": value["type"],
    "details": CreateSolanaTransactionRequestDetailsToJSON(value["details"]),
    "timeout": value["timeout"],
    "wait_for_state": PushableTransactionStateToJSON(value["waitForState"])
  };
}

// src/openapi/models/CreateSolanaVaultRequest.ts
function CreateSolanaVaultRequestToJSON(json) {
  return CreateSolanaVaultRequestToJSONTyped(json, false);
}
function CreateSolanaVaultRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "name": value["name"],
    "keyset_id": value["keysetId"],
    "end_user_id": value["endUserId"],
    "vault_group_id": value["vaultGroupId"],
    "import_vault": ImportVaultDefaultOptionsToJSON(value["importVault"]),
    "type": value["type"]
  };
}

// src/openapi/models/StacksCustomFeeRequest.ts
function StacksCustomFeeRequestToJSON(json) {
  return StacksCustomFeeRequestToJSONTyped(json, false);
}
function StacksCustomFeeRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "type": value["type"],
    "total_fee": value["totalFee"]
  };
}

// src/openapi/models/StacksPriorityFeeRequest.ts
function StacksPriorityFeeRequestToJSON(json) {
  return StacksPriorityFeeRequestToJSONTyped(json, false);
}
function StacksPriorityFeeRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "type": value["type"],
    "priority_level": FeePriorityLevelRequestToJSON(value["priorityLevel"])
  };
}

// src/openapi/models/CreateStacksTransactionSerializedRequestFee.ts
function CreateStacksTransactionSerializedRequestFeeToJSON(json) {
  return CreateStacksTransactionSerializedRequestFeeToJSONTyped(json, false);
}
function CreateStacksTransactionSerializedRequestFeeToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  switch (value["type"]) {
    case "custom":
      return Object.assign({}, StacksCustomFeeRequestToJSON(value), { type: "custom" });
    case "priority":
      return Object.assign({}, StacksPriorityFeeRequestToJSON(value), { type: "priority" });
    default:
      throw new Error(`No variant of CreateStacksTransactionSerializedRequestFee exists with 'type=${value["type"]}'`);
  }
}

// src/openapi/models/CreateStacksTransactionSerializedRequest.ts
function CreateStacksTransactionSerializedRequestToJSON(json) {
  return CreateStacksTransactionSerializedRequestToJSONTyped(json, false);
}
function CreateStacksTransactionSerializedRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "type": value["type"],
    "fail_on_prediction_failure": value["failOnPredictionFailure"],
    "skip_prediction": value["skipPrediction"],
    "push_mode": PushModeToJSON(value["pushMode"]),
    "fee": CreateStacksTransactionSerializedRequestFeeToJSON(value["fee"]),
    "serialized_transaction": value["serializedTransaction"],
    "chain": StacksChainUniqueIdToJSON(value["chain"])
  };
}

// src/openapi/models/StacksRecipientHex.ts
function StacksRecipientHexToJSON(json) {
  return StacksRecipientHexToJSONTyped(json, false);
}
function StacksRecipientHexToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "type": value["type"],
    "address": value["address"]
  };
}

// src/openapi/models/CreateStacksTransferRequestTo.ts
function CreateStacksTransferRequestToToJSON(json) {
  return CreateStacksTransferRequestToToJSONTyped(json, false);
}
function CreateStacksTransferRequestToToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  switch (value["type"]) {
    case "hex":
      return Object.assign({}, StacksRecipientHexToJSON(value), { type: "hex" });
    case "vault_id":
      return Object.assign({}, RecipientVaultIdToJSON(value), { type: "vault_id" });
    default:
      throw new Error(`No variant of CreateStacksTransferRequestTo exists with 'type=${value["type"]}'`);
  }
}

// src/openapi/models/CreateStacksTransferRequest.ts
function CreateStacksTransferRequestToJSON(json) {
  return CreateStacksTransferRequestToJSONTyped(json, false);
}
function CreateStacksTransferRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "type": value["type"],
    "fail_on_prediction_failure": value["failOnPredictionFailure"],
    "skip_prediction": value["skipPrediction"],
    "push_mode": PushModeToJSON(value["pushMode"]),
    "fee": CreateStacksTransactionSerializedRequestFeeToJSON(value["fee"]),
    "to": CreateStacksTransferRequestToToJSON(value["to"]),
    "value": CreateAptosTransferRequestValueToJSON(value["value"]),
    "asset_identifier": StacksAssetIdentifierRequestToJSON(value["assetIdentifier"]),
    "memo": value["memo"]
  };
}

// src/openapi/models/CreateStacksTransactionRequestDetails.ts
function CreateStacksTransactionRequestDetailsToJSON(json) {
  return CreateStacksTransactionRequestDetailsToJSONTyped(json, false);
}
function CreateStacksTransactionRequestDetailsToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  switch (value["type"]) {
    case "stacks_serialized_transaction":
      return Object.assign({}, CreateStacksTransactionSerializedRequestToJSON(value), { type: "stacks_serialized_transaction" });
    case "stacks_transfer":
      return Object.assign({}, CreateStacksTransferRequestToJSON(value), { type: "stacks_transfer" });
    default:
      throw new Error(`No variant of CreateStacksTransactionRequestDetails exists with 'type=${value["type"]}'`);
  }
}

// src/openapi/models/CreateStacksTransactionRequest.ts
function CreateStacksTransactionRequestToJSON(json) {
  return CreateStacksTransactionRequestToJSONTyped(json, false);
}
function CreateStacksTransactionRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "vault_id": value["vaultId"],
    "note": value["note"],
    "signer_type": SignerTypeToJSON(value["signerType"]),
    "sign_mode": SignModeToJSON(value["signMode"]),
    "dapp_info": DappInfoToJSON(value["dappInfo"]),
    "type": value["type"],
    "details": CreateStacksTransactionRequestDetailsToJSON(value["details"])
  };
}

// src/openapi/models/CreateStacksTransactionWithWaitRequest.ts
function CreateStacksTransactionWithWaitRequestToJSON(json) {
  return CreateStacksTransactionWithWaitRequestToJSONTyped(json, false);
}
function CreateStacksTransactionWithWaitRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "vault_id": value["vaultId"],
    "note": value["note"],
    "signer_type": SignerTypeToJSON(value["signerType"]),
    "sign_mode": SignModeToJSON(value["signMode"]),
    "dapp_info": DappInfoToJSON(value["dappInfo"]),
    "type": value["type"],
    "details": CreateStacksTransactionRequestDetailsToJSON(value["details"]),
    "timeout": value["timeout"],
    "wait_for_state": PushableTransactionStateToJSON(value["waitForState"])
  };
}

// src/openapi/models/CreateStacksVaultRequest.ts
function CreateStacksVaultRequestToJSON(json) {
  return CreateStacksVaultRequestToJSONTyped(json, false);
}
function CreateStacksVaultRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "name": value["name"],
    "keyset_id": value["keysetId"],
    "end_user_id": value["endUserId"],
    "vault_group_id": value["vaultGroupId"],
    "type": value["type"]
  };
}

// src/openapi/models/CreateStarknetContractDeploymentRequest.ts
function CreateStarknetContractDeploymentRequestToJSON(json) {
  return CreateStarknetContractDeploymentRequestToJSONTyped(json, false);
}
function CreateStarknetContractDeploymentRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "type": value["type"],
    "fail_on_prediction_failure": value["failOnPredictionFailure"],
    "skip_prediction": value["skipPrediction"],
    "push_mode": PushModeToJSON(value["pushMode"]),
    "chain": StarknetChainUniqueIdToJSON(value["chain"])
  };
}

// src/openapi/models/StarknetTypedMessageRequest.ts
function StarknetTypedMessageRequestToJSON(json) {
  return StarknetTypedMessageRequestToJSONTyped(json, false);
}
function StarknetTypedMessageRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "type": value["type"],
    "chain": StarknetChainUniqueIdToJSON(value["chain"]),
    "raw_data": value["rawData"]
  };
}

// src/openapi/models/CreateStarknetMessageRequest.ts
function CreateStarknetMessageRequestToJSON(json) {
  return CreateStarknetMessageRequestToJSONTyped(json, false);
}
function CreateStarknetMessageRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "vault_id": value["vaultId"],
    "note": value["note"],
    "signer_type": SignerTypeToJSON(value["signerType"]),
    "sign_mode": SignModeToJSON(value["signMode"]),
    "dapp_info": DappInfoToJSON(value["dappInfo"]),
    "type": value["type"],
    "details": StarknetTypedMessageRequestToJSON(value["details"])
  };
}

// src/openapi/models/CreateStarknetMessageWithWaitRequest.ts
function CreateStarknetMessageWithWaitRequestToJSON(json) {
  return CreateStarknetMessageWithWaitRequestToJSONTyped(json, false);
}
function CreateStarknetMessageWithWaitRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "vault_id": value["vaultId"],
    "note": value["note"],
    "signer_type": SignerTypeToJSON(value["signerType"]),
    "sign_mode": SignModeToJSON(value["signMode"]),
    "dapp_info": DappInfoToJSON(value["dappInfo"]),
    "type": value["type"],
    "details": StarknetTypedMessageRequestToJSON(value["details"]),
    "timeout": value["timeout"],
    "wait_for_state": NonPushableTransactionStateToJSON(value["waitForState"])
  };
}

// src/openapi/models/StarknetCallDataRequest.ts
function StarknetCallDataRequestToJSON(json) {
  return StarknetCallDataRequestToJSONTyped(json, false);
}
function StarknetCallDataRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "to": value["to"],
    "method_name": value["methodName"],
    "method_arguments": value["methodArguments"]
  };
}

// src/openapi/models/CreateStarknetTransactionInvokeRequest.ts
function CreateStarknetTransactionInvokeRequestToJSON(json) {
  return CreateStarknetTransactionInvokeRequestToJSONTyped(json, false);
}
function CreateStarknetTransactionInvokeRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "type": value["type"],
    "fail_on_prediction_failure": value["failOnPredictionFailure"],
    "skip_prediction": value["skipPrediction"],
    "push_mode": PushModeToJSON(value["pushMode"]),
    "chain": StarknetChainUniqueIdToJSON(value["chain"]),
    "call_data": value["callData"].map(StarknetCallDataRequestToJSON)
  };
}

// src/openapi/models/StarknetRecipientHex.ts
function StarknetRecipientHexToJSON(json) {
  return StarknetRecipientHexToJSONTyped(json, false);
}
function StarknetRecipientHexToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "type": value["type"],
    "address": value["address"]
  };
}

// src/openapi/models/CreateStarknetTransferRequestTo.ts
function CreateStarknetTransferRequestToToJSON(json) {
  return CreateStarknetTransferRequestToToJSONTyped(json, false);
}
function CreateStarknetTransferRequestToToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  switch (value["type"]) {
    case "hex":
      return Object.assign({}, StarknetRecipientHexToJSON(value), { type: "hex" });
    case "vault_id":
      return Object.assign({}, RecipientVaultIdToJSON(value), { type: "vault_id" });
    default:
      throw new Error(`No variant of CreateStarknetTransferRequestTo exists with 'type=${value["type"]}'`);
  }
}

// src/openapi/models/CreateStarknetTransferRequest.ts
function CreateStarknetTransferRequestToJSON(json) {
  return CreateStarknetTransferRequestToJSONTyped(json, false);
}
function CreateStarknetTransferRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "type": value["type"],
    "fail_on_prediction_failure": value["failOnPredictionFailure"],
    "skip_prediction": value["skipPrediction"],
    "push_mode": PushModeToJSON(value["pushMode"]),
    "to": CreateStarknetTransferRequestToToJSON(value["to"]),
    "value": CreateAptosTransferRequestValueToJSON(value["value"]),
    "asset_identifier": StarknetAssetIdentifierRequestToJSON(value["assetIdentifier"])
  };
}

// src/openapi/models/CreateStarknetTransactionRequestDetails.ts
function CreateStarknetTransactionRequestDetailsToJSON(json) {
  return CreateStarknetTransactionRequestDetailsToJSONTyped(json, false);
}
function CreateStarknetTransactionRequestDetailsToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  switch (value["type"]) {
    case "starknet_contract_call":
      return Object.assign({}, CreateStarknetTransactionInvokeRequestToJSON(value), { type: "starknet_contract_call" });
    case "starknet_contract_deployment":
      return Object.assign({}, CreateStarknetContractDeploymentRequestToJSON(value), { type: "starknet_contract_deployment" });
    case "starknet_transfer":
      return Object.assign({}, CreateStarknetTransferRequestToJSON(value), { type: "starknet_transfer" });
    default:
      throw new Error(`No variant of CreateStarknetTransactionRequestDetails exists with 'type=${value["type"]}'`);
  }
}

// src/openapi/models/CreateStarknetTransactionRequest.ts
function CreateStarknetTransactionRequestToJSON(json) {
  return CreateStarknetTransactionRequestToJSONTyped(json, false);
}
function CreateStarknetTransactionRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "vault_id": value["vaultId"],
    "note": value["note"],
    "signer_type": SignerTypeToJSON(value["signerType"]),
    "sign_mode": SignModeToJSON(value["signMode"]),
    "dapp_info": DappInfoToJSON(value["dappInfo"]),
    "type": value["type"],
    "details": CreateStarknetTransactionRequestDetailsToJSON(value["details"])
  };
}

// src/openapi/models/CreateStarknetTransactionWithWaitRequest.ts
function CreateStarknetTransactionWithWaitRequestToJSON(json) {
  return CreateStarknetTransactionWithWaitRequestToJSONTyped(json, false);
}
function CreateStarknetTransactionWithWaitRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "vault_id": value["vaultId"],
    "note": value["note"],
    "signer_type": SignerTypeToJSON(value["signerType"]),
    "sign_mode": SignModeToJSON(value["signMode"]),
    "dapp_info": DappInfoToJSON(value["dappInfo"]),
    "type": value["type"],
    "details": CreateStarknetTransactionRequestDetailsToJSON(value["details"]),
    "timeout": value["timeout"],
    "wait_for_state": PushableTransactionStateToJSON(value["waitForState"])
  };
}

// src/openapi/models/CreateStarknetVaultRequest.ts
function CreateStarknetVaultRequestToJSON(json) {
  return CreateStarknetVaultRequestToJSONTyped(json, false);
}
function CreateStarknetVaultRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "name": value["name"],
    "keyset_id": value["keysetId"],
    "end_user_id": value["endUserId"],
    "vault_group_id": value["vaultGroupId"],
    "import_vault": ImportVaultDefaultOptionsToJSON(value["importVault"]),
    "type": value["type"]
  };
}

// src/openapi/models/SuiPersonalMessageRequest.ts
function SuiPersonalMessageRequestToJSON(json) {
  return SuiPersonalMessageRequestToJSONTyped(json, false);
}
function SuiPersonalMessageRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "type": value["type"],
    "chain": SuiChainUniqueIdToJSON(value["chain"]),
    "raw_data": value["rawData"]
  };
}

// src/openapi/models/CreateSuiMessageRequest.ts
function CreateSuiMessageRequestToJSON(json) {
  return CreateSuiMessageRequestToJSONTyped(json, false);
}
function CreateSuiMessageRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "vault_id": value["vaultId"],
    "note": value["note"],
    "signer_type": SignerTypeToJSON(value["signerType"]),
    "sign_mode": SignModeToJSON(value["signMode"]),
    "dapp_info": DappInfoToJSON(value["dappInfo"]),
    "type": value["type"],
    "details": SuiPersonalMessageRequestToJSON(value["details"])
  };
}

// src/openapi/models/CreateSuiMessageWithWaitRequest.ts
function CreateSuiMessageWithWaitRequestToJSON(json) {
  return CreateSuiMessageWithWaitRequestToJSONTyped(json, false);
}
function CreateSuiMessageWithWaitRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "vault_id": value["vaultId"],
    "note": value["note"],
    "signer_type": SignerTypeToJSON(value["signerType"]),
    "sign_mode": SignModeToJSON(value["signMode"]),
    "dapp_info": DappInfoToJSON(value["dappInfo"]),
    "type": value["type"],
    "details": SuiPersonalMessageRequestToJSON(value["details"]),
    "timeout": value["timeout"],
    "wait_for_state": NonPushableTransactionStateToJSON(value["waitForState"])
  };
}

// src/openapi/models/SuiCommandGasCoinArgument.ts
function SuiCommandGasCoinArgumentFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "type": json["type"]
  };
}
function SuiCommandGasCoinArgumentToJSON(json) {
  return SuiCommandGasCoinArgumentToJSONTyped(json, false);
}
function SuiCommandGasCoinArgumentToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "type": value["type"]
  };
}

// src/openapi/models/SuiCommandInputArgument.ts
function SuiCommandInputArgumentFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "type": json["type"],
    "index": json["index"]
  };
}
function SuiCommandInputArgumentToJSON(json) {
  return SuiCommandInputArgumentToJSONTyped(json, false);
}
function SuiCommandInputArgumentToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "type": value["type"],
    "index": value["index"]
  };
}

// src/openapi/models/SuiCommandNestedResultArgument.ts
function SuiCommandNestedResultArgumentFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "type": json["type"],
    "index": json["index"],
    "resultIndex": json["result_index"]
  };
}
function SuiCommandNestedResultArgumentToJSON(json) {
  return SuiCommandNestedResultArgumentToJSONTyped(json, false);
}
function SuiCommandNestedResultArgumentToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "type": value["type"],
    "index": value["index"],
    "result_index": value["resultIndex"]
  };
}

// src/openapi/models/SuiCommandResultArgument.ts
function SuiCommandResultArgumentFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "type": json["type"],
    "index": json["index"]
  };
}
function SuiCommandResultArgumentToJSON(json) {
  return SuiCommandResultArgumentToJSONTyped(json, false);
}
function SuiCommandResultArgumentToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "type": value["type"],
    "index": value["index"]
  };
}

// src/openapi/models/SuiCommandArgument.ts
function SuiCommandArgumentFromJSON(json) {
  return SuiCommandArgumentFromJSONTyped(json, false);
}
function SuiCommandArgumentFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  switch (json["type"]) {
    case "gas_coin":
      return Object.assign({}, SuiCommandGasCoinArgumentFromJSONTyped(json, true), { type: "gas_coin" });
    case "input":
      return Object.assign({}, SuiCommandInputArgumentFromJSONTyped(json, true), { type: "input" });
    case "nested_result":
      return Object.assign({}, SuiCommandNestedResultArgumentFromJSONTyped(json, true), { type: "nested_result" });
    case "result":
      return Object.assign({}, SuiCommandResultArgumentFromJSONTyped(json, true), { type: "result" });
    default:
      throw new Error(`No variant of SuiCommandArgument exists with 'type=${json["type"]}'`);
  }
}
function SuiCommandArgumentToJSON(json) {
  return SuiCommandArgumentToJSONTyped(json, false);
}
function SuiCommandArgumentToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  switch (value["type"]) {
    case "gas_coin":
      return Object.assign({}, SuiCommandGasCoinArgumentToJSON(value), { type: "gas_coin" });
    case "input":
      return Object.assign({}, SuiCommandInputArgumentToJSON(value), { type: "input" });
    case "nested_result":
      return Object.assign({}, SuiCommandNestedResultArgumentToJSON(value), { type: "nested_result" });
    case "result":
      return Object.assign({}, SuiCommandResultArgumentToJSON(value), { type: "result" });
    default:
      throw new Error(`No variant of SuiCommandArgument exists with 'type=${value["type"]}'`);
  }
}

// src/openapi/models/SuiMakeMoveVecCommand.ts
function SuiMakeMoveVecCommandFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "type": json["type"],
    "typeTag": json["type_tag"] == null ? void 0 : json["type_tag"],
    "objects": json["objects"].map(SuiCommandArgumentFromJSON)
  };
}
function SuiMakeMoveVecCommandToJSON(json) {
  return SuiMakeMoveVecCommandToJSONTyped(json, false);
}
function SuiMakeMoveVecCommandToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "type": value["type"],
    "type_tag": value["typeTag"],
    "objects": value["objects"].map(SuiCommandArgumentToJSON)
  };
}

// src/openapi/models/SuiMergeCoinsCommand.ts
function SuiMergeCoinsCommandFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "type": json["type"],
    "sourceCoinObjects": json["source_coin_objects"].map(SuiCommandArgumentFromJSON),
    "destinationCoinObject": SuiCommandArgumentFromJSON(json["destination_coin_object"])
  };
}
function SuiMergeCoinsCommandToJSON(json) {
  return SuiMergeCoinsCommandToJSONTyped(json, false);
}
function SuiMergeCoinsCommandToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "type": value["type"],
    "source_coin_objects": value["sourceCoinObjects"].map(SuiCommandArgumentToJSON),
    "destination_coin_object": SuiCommandArgumentToJSON(value["destinationCoinObject"])
  };
}

// src/openapi/models/SuiMoveCallCommand.ts
function SuiMoveCallCommandFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "type": json["type"],
    "arguments": json["arguments"].map(SuiCommandArgumentFromJSON),
    "target": json["target"],
    "typeArguments": json["type_arguments"]
  };
}
function SuiMoveCallCommandToJSON(json) {
  return SuiMoveCallCommandToJSONTyped(json, false);
}
function SuiMoveCallCommandToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "type": value["type"],
    "arguments": value["arguments"].map(SuiCommandArgumentToJSON),
    "target": value["target"],
    "type_arguments": value["typeArguments"]
  };
}

// src/openapi/models/SuiSplitCoinsCommand.ts
function SuiSplitCoinsCommandFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "type": json["type"],
    "coinObject": SuiCommandArgumentFromJSON(json["coin_object"]),
    "amounts": json["amounts"].map(SuiCommandArgumentFromJSON)
  };
}
function SuiSplitCoinsCommandToJSON(json) {
  return SuiSplitCoinsCommandToJSONTyped(json, false);
}
function SuiSplitCoinsCommandToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "type": value["type"],
    "coin_object": SuiCommandArgumentToJSON(value["coinObject"]),
    "amounts": value["amounts"].map(SuiCommandArgumentToJSON)
  };
}

// src/openapi/models/SuiTransferObjectsCommand.ts
function SuiTransferObjectsCommandFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "type": json["type"],
    "objects": json["objects"].map(SuiCommandArgumentFromJSON),
    "address": SuiCommandArgumentFromJSON(json["address"])
  };
}
function SuiTransferObjectsCommandToJSON(json) {
  return SuiTransferObjectsCommandToJSONTyped(json, false);
}
function SuiTransferObjectsCommandToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "type": value["type"],
    "objects": value["objects"].map(SuiCommandArgumentToJSON),
    "address": SuiCommandArgumentToJSON(value["address"])
  };
}

// src/openapi/models/SuiCommand.ts
function SuiCommandFromJSON(json) {
  return SuiCommandFromJSONTyped(json, false);
}
function SuiCommandFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  switch (json["type"]) {
    case "make_move_vec":
      return Object.assign({}, SuiMakeMoveVecCommandFromJSONTyped(json, true), { type: "make_move_vec" });
    case "merge_coins":
      return Object.assign({}, SuiMergeCoinsCommandFromJSONTyped(json, true), { type: "merge_coins" });
    case "move_call":
      return Object.assign({}, SuiMoveCallCommandFromJSONTyped(json, true), { type: "move_call" });
    case "split_coins":
      return Object.assign({}, SuiSplitCoinsCommandFromJSONTyped(json, true), { type: "split_coins" });
    case "transfer_objects":
      return Object.assign({}, SuiTransferObjectsCommandFromJSONTyped(json, true), { type: "transfer_objects" });
    default:
      throw new Error(`No variant of SuiCommand exists with 'type=${json["type"]}'`);
  }
}
function SuiCommandToJSON(json) {
  return SuiCommandToJSONTyped(json, false);
}
function SuiCommandToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  switch (value["type"]) {
    case "make_move_vec":
      return Object.assign({}, SuiMakeMoveVecCommandToJSON(value), { type: "make_move_vec" });
    case "merge_coins":
      return Object.assign({}, SuiMergeCoinsCommandToJSON(value), { type: "merge_coins" });
    case "move_call":
      return Object.assign({}, SuiMoveCallCommandToJSON(value), { type: "move_call" });
    case "split_coins":
      return Object.assign({}, SuiSplitCoinsCommandToJSON(value), { type: "split_coins" });
    case "transfer_objects":
      return Object.assign({}, SuiTransferObjectsCommandToJSON(value), { type: "transfer_objects" });
    default:
      throw new Error(`No variant of SuiCommand exists with 'type=${value["type"]}'`);
  }
}

// src/openapi/models/SuiImmOrOwnedObjectRefInputArgument.ts
function SuiImmOrOwnedObjectRefInputArgumentFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "digest": json["digest"],
    "objectId": json["object_id"],
    "version": json["version"],
    "type": json["type"]
  };
}
function SuiImmOrOwnedObjectRefInputArgumentToJSON(json) {
  return SuiImmOrOwnedObjectRefInputArgumentToJSONTyped(json, false);
}
function SuiImmOrOwnedObjectRefInputArgumentToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "digest": value["digest"],
    "object_id": value["objectId"],
    "version": value["version"],
    "type": value["type"]
  };
}

// src/openapi/models/SuiPartialObjectRefInputArgument.ts
function SuiPartialObjectRefInputArgumentFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "type": json["type"],
    "objectId": json["object_id"]
  };
}
function SuiPartialObjectRefInputArgumentToJSON(json) {
  return SuiPartialObjectRefInputArgumentToJSONTyped(json, false);
}
function SuiPartialObjectRefInputArgumentToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "type": value["type"],
    "object_id": value["objectId"]
  };
}

// src/openapi/models/SuiReceivingObjectRefInputArgument.ts
function SuiReceivingObjectRefInputArgumentFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "digest": json["digest"],
    "objectId": json["object_id"],
    "version": json["version"],
    "type": json["type"]
  };
}
function SuiReceivingObjectRefInputArgumentToJSON(json) {
  return SuiReceivingObjectRefInputArgumentToJSONTyped(json, false);
}
function SuiReceivingObjectRefInputArgumentToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "digest": value["digest"],
    "object_id": value["objectId"],
    "version": value["version"],
    "type": value["type"]
  };
}

// src/openapi/models/SuiSharedObjectRefInputArgument.ts
function SuiSharedObjectRefInputArgumentFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "type": json["type"],
    "objectId": json["object_id"],
    "initialSharedVersion": json["initial_shared_version"],
    "mutable": json["mutable"]
  };
}
function SuiSharedObjectRefInputArgumentToJSON(json) {
  return SuiSharedObjectRefInputArgumentToJSONTyped(json, false);
}
function SuiSharedObjectRefInputArgumentToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "type": value["type"],
    "object_id": value["objectId"],
    "initial_shared_version": value["initialSharedVersion"],
    "mutable": value["mutable"]
  };
}

// src/openapi/models/SuiObjectInputArgumentDetails.ts
function SuiObjectInputArgumentDetailsFromJSON(json) {
  return SuiObjectInputArgumentDetailsFromJSONTyped(json, false);
}
function SuiObjectInputArgumentDetailsFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  switch (json["type"]) {
    case "imm_or_owned":
      return Object.assign({}, SuiImmOrOwnedObjectRefInputArgumentFromJSONTyped(json, true), { type: "imm_or_owned" });
    case "partial":
      return Object.assign({}, SuiPartialObjectRefInputArgumentFromJSONTyped(json, true), { type: "partial" });
    case "receiving":
      return Object.assign({}, SuiReceivingObjectRefInputArgumentFromJSONTyped(json, true), { type: "receiving" });
    case "shared":
      return Object.assign({}, SuiSharedObjectRefInputArgumentFromJSONTyped(json, true), { type: "shared" });
    default:
      throw new Error(`No variant of SuiObjectInputArgumentDetails exists with 'type=${json["type"]}'`);
  }
}
function SuiObjectInputArgumentDetailsToJSON(json) {
  return SuiObjectInputArgumentDetailsToJSONTyped(json, false);
}
function SuiObjectInputArgumentDetailsToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  switch (value["type"]) {
    case "imm_or_owned":
      return Object.assign({}, SuiImmOrOwnedObjectRefInputArgumentToJSON(value), { type: "imm_or_owned" });
    case "partial":
      return Object.assign({}, SuiPartialObjectRefInputArgumentToJSON(value), { type: "partial" });
    case "receiving":
      return Object.assign({}, SuiReceivingObjectRefInputArgumentToJSON(value), { type: "receiving" });
    case "shared":
      return Object.assign({}, SuiSharedObjectRefInputArgumentToJSON(value), { type: "shared" });
    default:
      throw new Error(`No variant of SuiObjectInputArgumentDetails exists with 'type=${value["type"]}'`);
  }
}

// src/openapi/models/SuiObjectInputArgument.ts
function SuiObjectInputArgumentFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "type": json["type"],
    "details": SuiObjectInputArgumentDetailsFromJSON(json["details"])
  };
}
function SuiObjectInputArgumentToJSON(json) {
  return SuiObjectInputArgumentToJSONTyped(json, false);
}
function SuiObjectInputArgumentToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "type": value["type"],
    "details": SuiObjectInputArgumentDetailsToJSON(value["details"])
  };
}

// src/openapi/models/SuiPureInputArgument.ts
function SuiPureInputArgumentFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "type": json["type"],
    "details": BaseSuiPureInputFromJSON(json["details"])
  };
}
function SuiPureInputArgumentToJSON(json) {
  return SuiPureInputArgumentToJSONTyped(json, false);
}
function SuiPureInputArgumentToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "type": value["type"],
    "details": BaseSuiPureInputToJSON(value["details"])
  };
}

// src/openapi/models/SuiInput.ts
function SuiInputFromJSON(json) {
  return SuiInputFromJSONTyped(json, false);
}
function SuiInputFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  switch (json["type"]) {
    case "object":
      return Object.assign({}, SuiObjectInputArgumentFromJSONTyped(json, true), { type: "object" });
    case "pure":
      return Object.assign({}, SuiPureInputArgumentFromJSONTyped(json, true), { type: "pure" });
    default:
      throw new Error(`No variant of SuiInput exists with 'type=${json["type"]}'`);
  }
}
function SuiInputToJSON(json) {
  return SuiInputToJSONTyped(json, false);
}
function SuiInputToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  switch (value["type"]) {
    case "object":
      return Object.assign({}, SuiObjectInputArgumentToJSON(value), { type: "object" });
    case "pure":
      return Object.assign({}, SuiPureInputArgumentToJSON(value), { type: "pure" });
    default:
      throw new Error(`No variant of SuiInput exists with 'type=${value["type"]}'`);
  }
}

// src/openapi/models/SuiObjectRef.ts
function SuiObjectRefFromJSON(json) {
  return SuiObjectRefFromJSONTyped(json, false);
}
function SuiObjectRefFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "digest": json["digest"],
    "objectId": json["object_id"],
    "version": json["version"]
  };
}
function SuiObjectRefToJSON(json) {
  return SuiObjectRefToJSONTyped(json, false);
}
function SuiObjectRefToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "digest": value["digest"],
    "object_id": value["objectId"],
    "version": value["version"]
  };
}

// src/openapi/models/SuiGasConfig.ts
function SuiGasConfigFromJSON(json) {
  return SuiGasConfigFromJSONTyped(json, false);
}
function SuiGasConfigFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "budget": json["budget"] == null ? void 0 : json["budget"],
    "price": json["price"] == null ? void 0 : json["price"],
    "payment": json["payment"].map(SuiObjectRefFromJSON)
  };
}
function SuiGasConfigToJSON(json) {
  return SuiGasConfigToJSONTyped(json, false);
}
function SuiGasConfigToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "budget": value["budget"],
    "price": value["price"],
    "payment": value["payment"].map(SuiObjectRefToJSON)
  };
}

// src/openapi/models/CreateSuiProgrammableTransactionBlockRequest.ts
function CreateSuiProgrammableTransactionBlockRequestToJSON(json) {
  return CreateSuiProgrammableTransactionBlockRequestToJSONTyped(json, false);
}
function CreateSuiProgrammableTransactionBlockRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "type": value["type"],
    "fail_on_prediction_failure": value["failOnPredictionFailure"],
    "push_mode": PushModeToJSON(value["pushMode"]),
    "skip_prediction": value["skipPrediction"],
    "chain": SuiChainUniqueIdToJSON(value["chain"]),
    "gas_config": SuiGasConfigToJSON(value["gasConfig"]),
    "inputs": value["inputs"].map(SuiInputToJSON),
    "commands": value["commands"].map(SuiCommandToJSON)
  };
}

// src/openapi/models/CreateSuiSerializedTransactionDataRequest.ts
function CreateSuiSerializedTransactionDataRequestToJSON(json) {
  return CreateSuiSerializedTransactionDataRequestToJSONTyped(json, false);
}
function CreateSuiSerializedTransactionDataRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "type": value["type"],
    "fail_on_prediction_failure": value["failOnPredictionFailure"],
    "push_mode": PushModeToJSON(value["pushMode"]),
    "skip_prediction": value["skipPrediction"],
    "chain": SuiChainUniqueIdToJSON(value["chain"]),
    "data": value["data"]
  };
}

// src/openapi/models/SuiRecipientHex.ts
function SuiRecipientHexToJSON(json) {
  return SuiRecipientHexToJSONTyped(json, false);
}
function SuiRecipientHexToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "type": value["type"],
    "address": value["address"]
  };
}

// src/openapi/models/CreateSuiTransferRequestTo.ts
function CreateSuiTransferRequestToToJSON(json) {
  return CreateSuiTransferRequestToToJSONTyped(json, false);
}
function CreateSuiTransferRequestToToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  switch (value["type"]) {
    case "hex":
      return Object.assign({}, SuiRecipientHexToJSON(value), { type: "hex" });
    case "vault_id":
      return Object.assign({}, RecipientVaultIdToJSON(value), { type: "vault_id" });
    default:
      throw new Error(`No variant of CreateSuiTransferRequestTo exists with 'type=${value["type"]}'`);
  }
}

// src/openapi/models/CreateSuiTransferRequest.ts
function CreateSuiTransferRequestToJSON(json) {
  return CreateSuiTransferRequestToJSONTyped(json, false);
}
function CreateSuiTransferRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "type": value["type"],
    "fail_on_prediction_failure": value["failOnPredictionFailure"],
    "push_mode": PushModeToJSON(value["pushMode"]),
    "skip_prediction": value["skipPrediction"],
    "to": CreateSuiTransferRequestToToJSON(value["to"]),
    "gas_config": SuiGasConfigToJSON(value["gasConfig"]),
    "value": CreateAptosTransferRequestValueToJSON(value["value"]),
    "asset_identifier": SuiAssetIdentifierRequestToJSON(value["assetIdentifier"])
  };
}

// src/openapi/models/CreateSuiTransactionRequestDetails.ts
function CreateSuiTransactionRequestDetailsToJSON(json) {
  return CreateSuiTransactionRequestDetailsToJSONTyped(json, false);
}
function CreateSuiTransactionRequestDetailsToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  switch (value["type"]) {
    case "sui_binary_canonical_serialization":
      return Object.assign({}, CreateSuiSerializedTransactionDataRequestToJSON(value), { type: "sui_binary_canonical_serialization" });
    case "sui_programmable_transaction_block":
      return Object.assign({}, CreateSuiProgrammableTransactionBlockRequestToJSON(value), { type: "sui_programmable_transaction_block" });
    case "sui_transfer":
      return Object.assign({}, CreateSuiTransferRequestToJSON(value), { type: "sui_transfer" });
    default:
      throw new Error(`No variant of CreateSuiTransactionRequestDetails exists with 'type=${value["type"]}'`);
  }
}

// src/openapi/models/CreateSuiTransactionRequest.ts
function CreateSuiTransactionRequestToJSON(json) {
  return CreateSuiTransactionRequestToJSONTyped(json, false);
}
function CreateSuiTransactionRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "vault_id": value["vaultId"],
    "note": value["note"],
    "signer_type": SignerTypeToJSON(value["signerType"]),
    "sign_mode": SignModeToJSON(value["signMode"]),
    "dapp_info": DappInfoToJSON(value["dappInfo"]),
    "type": value["type"],
    "details": CreateSuiTransactionRequestDetailsToJSON(value["details"])
  };
}

// src/openapi/models/CreateSuiTransactionWithWaitRequest.ts
function CreateSuiTransactionWithWaitRequestToJSON(json) {
  return CreateSuiTransactionWithWaitRequestToJSONTyped(json, false);
}
function CreateSuiTransactionWithWaitRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "vault_id": value["vaultId"],
    "note": value["note"],
    "signer_type": SignerTypeToJSON(value["signerType"]),
    "sign_mode": SignModeToJSON(value["signMode"]),
    "dapp_info": DappInfoToJSON(value["dappInfo"]),
    "type": value["type"],
    "details": CreateSuiTransactionRequestDetailsToJSON(value["details"]),
    "timeout": value["timeout"],
    "wait_for_state": PushableTransactionStateToJSON(value["waitForState"])
  };
}

// src/openapi/models/CreateSuiVaultRequest.ts
function CreateSuiVaultRequestToJSON(json) {
  return CreateSuiVaultRequestToJSONTyped(json, false);
}
function CreateSuiVaultRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "name": value["name"],
    "keyset_id": value["keysetId"],
    "end_user_id": value["endUserId"],
    "vault_group_id": value["vaultGroupId"],
    "import_vault": ImportVaultDefaultOptionsToJSON(value["importVault"]),
    "type": value["type"]
  };
}

// src/openapi/models/TonProofMessageRequest.ts
function TonProofMessageRequestToJSON(json) {
  return TonProofMessageRequestToJSONTyped(json, false);
}
function TonProofMessageRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "type": value["type"],
    "manifest_url": value["manifestUrl"],
    "chain": TonChainUniqueIdToJSON(value["chain"]),
    "message_to_sign": value["messageToSign"]
  };
}

// src/openapi/models/CreateTonMessageRequest.ts
function CreateTonMessageRequestToJSON(json) {
  return CreateTonMessageRequestToJSONTyped(json, false);
}
function CreateTonMessageRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "vault_id": value["vaultId"],
    "note": value["note"],
    "signer_type": SignerTypeToJSON(value["signerType"]),
    "sign_mode": SignModeToJSON(value["signMode"]),
    "dapp_info": DappInfoToJSON(value["dappInfo"]),
    "type": value["type"],
    "details": TonProofMessageRequestToJSON(value["details"])
  };
}

// src/openapi/models/CreateTonMessageWithWaitRequest.ts
function CreateTonMessageWithWaitRequestToJSON(json) {
  return CreateTonMessageWithWaitRequestToJSONTyped(json, false);
}
function CreateTonMessageWithWaitRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "vault_id": value["vaultId"],
    "note": value["note"],
    "signer_type": SignerTypeToJSON(value["signerType"]),
    "sign_mode": SignModeToJSON(value["signMode"]),
    "dapp_info": DappInfoToJSON(value["dappInfo"]),
    "type": value["type"],
    "details": TonProofMessageRequestToJSON(value["details"]),
    "timeout": value["timeout"],
    "wait_for_state": NonPushableTransactionStateToJSON(value["waitForState"])
  };
}

// src/openapi/models/TonTransactionMessage.ts
function TonTransactionMessageFromJSON(json) {
  return TonTransactionMessageFromJSONTyped(json, false);
}
function TonTransactionMessageFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "address": TonAccountReprFromJSON(json["address"]),
    "amount": json["amount"],
    "payload": json["payload"] == null ? void 0 : json["payload"],
    "stateInit": json["state_init"] == null ? void 0 : json["state_init"],
    "comment": json["comment"] == null ? void 0 : json["comment"]
  };
}
function TonTransactionMessageToJSON(json) {
  return TonTransactionMessageToJSONTyped(json, false);
}
function TonTransactionMessageToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "address": TonAccountReprToJSON(value["address"]),
    "amount": value["amount"],
    "payload": value["payload"],
    "state_init": value["stateInit"],
    "comment": value["comment"]
  };
}

// src/openapi/models/TonNetwork.ts
function TonNetworkFromJSON(json) {
  return TonNetworkFromJSONTyped(json, false);
}
function TonNetworkFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}
function TonNetworkToJSON(value) {
  return value;
}

// src/openapi/models/TonTransactionPayload.ts
function TonTransactionPayloadFromJSON(json) {
  return TonTransactionPayloadFromJSONTyped(json, false);
}
function TonTransactionPayloadFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "validUntil": json["valid_until"] == null ? void 0 : json["valid_until"],
    "network": json["network"] == null ? void 0 : TonNetworkFromJSON(json["network"]),
    "messages": json["messages"].map(TonTransactionMessageFromJSON)
  };
}
function TonTransactionPayloadToJSON(json) {
  return TonTransactionPayloadToJSONTyped(json, false);
}
function TonTransactionPayloadToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "valid_until": value["validUntil"],
    "network": TonNetworkToJSON(value["network"]),
    "messages": value["messages"].map(TonTransactionMessageToJSON)
  };
}

// src/openapi/models/CreateTonSerializedRawTransactionRequest.ts
function CreateTonSerializedRawTransactionRequestToJSON(json) {
  return CreateTonSerializedRawTransactionRequestToJSONTyped(json, false);
}
function CreateTonSerializedRawTransactionRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "type": value["type"],
    "fail_on_prediction_failure": value["failOnPredictionFailure"],
    "push_mode": PushModeToJSON(value["pushMode"]),
    "chain": TonChainUniqueIdToJSON(value["chain"]),
    "transaction_payload": TonTransactionPayloadToJSON(value["transactionPayload"]),
    "skip_prediction": value["skipPrediction"]
  };
}

// src/openapi/models/TonRecipientHex.ts
function TonRecipientHexToJSON(json) {
  return TonRecipientHexToJSONTyped(json, false);
}
function TonRecipientHexToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "type": value["type"],
    "address": value["address"]
  };
}

// src/openapi/models/CreateTonTransferRequestTo.ts
function CreateTonTransferRequestToToJSON(json) {
  return CreateTonTransferRequestToToJSONTyped(json, false);
}
function CreateTonTransferRequestToToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  switch (value["type"]) {
    case "hex":
      return Object.assign({}, TonRecipientHexToJSON(value), { type: "hex" });
    case "vault_id":
      return Object.assign({}, RecipientVaultIdToJSON(value), { type: "vault_id" });
    default:
      throw new Error(`No variant of CreateTonTransferRequestTo exists with 'type=${value["type"]}'`);
  }
}

// src/openapi/models/CreateTonTransferRequest.ts
function CreateTonTransferRequestToJSON(json) {
  return CreateTonTransferRequestToJSONTyped(json, false);
}
function CreateTonTransferRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "type": value["type"],
    "fail_on_prediction_failure": value["failOnPredictionFailure"],
    "push_mode": PushModeToJSON(value["pushMode"]),
    "to": CreateTonTransferRequestToToJSON(value["to"]),
    "value": CreateAptosTransferRequestValueToJSON(value["value"]),
    "asset_identifier": TonAssetIdentifierRequestToJSON(value["assetIdentifier"]),
    "comment": value["comment"],
    "skip_prediction": value["skipPrediction"]
  };
}

// src/openapi/models/CreateTonTransactionRequestDetails.ts
function CreateTonTransactionRequestDetailsToJSON(json) {
  return CreateTonTransactionRequestDetailsToJSONTyped(json, false);
}
function CreateTonTransactionRequestDetailsToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  switch (value["type"]) {
    case "ton_raw_transaction":
      return Object.assign({}, CreateTonSerializedRawTransactionRequestToJSON(value), { type: "ton_raw_transaction" });
    case "ton_transfer":
      return Object.assign({}, CreateTonTransferRequestToJSON(value), { type: "ton_transfer" });
    default:
      throw new Error(`No variant of CreateTonTransactionRequestDetails exists with 'type=${value["type"]}'`);
  }
}

// src/openapi/models/CreateTonTransactionRequest.ts
function CreateTonTransactionRequestToJSON(json) {
  return CreateTonTransactionRequestToJSONTyped(json, false);
}
function CreateTonTransactionRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "vault_id": value["vaultId"],
    "note": value["note"],
    "signer_type": SignerTypeToJSON(value["signerType"]),
    "sign_mode": SignModeToJSON(value["signMode"]),
    "dapp_info": DappInfoToJSON(value["dappInfo"]),
    "type": value["type"],
    "details": CreateTonTransactionRequestDetailsToJSON(value["details"])
  };
}

// src/openapi/models/CreateTonTransactionWithWaitRequest.ts
function CreateTonTransactionWithWaitRequestToJSON(json) {
  return CreateTonTransactionWithWaitRequestToJSONTyped(json, false);
}
function CreateTonTransactionWithWaitRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "vault_id": value["vaultId"],
    "note": value["note"],
    "signer_type": SignerTypeToJSON(value["signerType"]),
    "sign_mode": SignModeToJSON(value["signMode"]),
    "dapp_info": DappInfoToJSON(value["dappInfo"]),
    "type": value["type"],
    "details": CreateTonTransactionRequestDetailsToJSON(value["details"]),
    "timeout": value["timeout"],
    "wait_for_state": PushableTransactionStateToJSON(value["waitForState"])
  };
}

// src/openapi/models/CreateTonVaultRequest.ts
function CreateTonVaultRequestToJSON(json) {
  return CreateTonVaultRequestToJSONTyped(json, false);
}
function CreateTonVaultRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "name": value["name"],
    "keyset_id": value["keysetId"],
    "end_user_id": value["endUserId"],
    "vault_group_id": value["vaultGroupId"],
    "import_vault": ImportVaultDefaultOptionsToJSON(value["importVault"]),
    "type": value["type"]
  };
}

// src/openapi/models/TronRecipientHex.ts
function TronRecipientHexToJSON(json) {
  return TronRecipientHexToJSONTyped(json, false);
}
function TronRecipientHexToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "type": value["type"],
    "address": value["address"]
  };
}

// src/openapi/models/CreateTronTransferRequestTo.ts
function CreateTronTransferRequestToToJSON(json) {
  return CreateTronTransferRequestToToJSONTyped(json, false);
}
function CreateTronTransferRequestToToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  switch (value["type"]) {
    case "hex":
      return Object.assign({}, TronRecipientHexToJSON(value), { type: "hex" });
    case "vault_id":
      return Object.assign({}, RecipientVaultIdToJSON(value), { type: "vault_id" });
    default:
      throw new Error(`No variant of CreateTronTransferRequestTo exists with 'type=${value["type"]}'`);
  }
}

// src/openapi/models/CreateTronTransferRequest.ts
function CreateTronTransferRequestToJSON(json) {
  return CreateTronTransferRequestToJSONTyped(json, false);
}
function CreateTronTransferRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "type": value["type"],
    "fail_on_prediction_failure": value["failOnPredictionFailure"],
    "skip_prediction": value["skipPrediction"],
    "push_mode": PushModeToJSON(value["pushMode"]),
    "to": CreateTronTransferRequestToToJSON(value["to"]),
    "value": CreateAptosTransferRequestValueToJSON(value["value"]),
    "asset_identifier": TronAssetIdentifierRequestToJSON(value["assetIdentifier"]),
    "memo": value["memo"]
  };
}

// src/openapi/models/CreateTronTransactionRequestDetails.ts
function CreateTronTransactionRequestDetailsToJSON(json) {
  return CreateTronTransactionRequestDetailsToJSONTyped(json, false);
}
function CreateTronTransactionRequestDetailsToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  switch (value["type"]) {
    case "tron_transfer":
      return Object.assign({}, CreateTronTransferRequestToJSON(value), { type: "tron_transfer" });
    default:
      throw new Error(`No variant of CreateTronTransactionRequestDetails exists with 'type=${value["type"]}'`);
  }
}

// src/openapi/models/CreateTronTransactionRequest.ts
function CreateTronTransactionRequestToJSON(json) {
  return CreateTronTransactionRequestToJSONTyped(json, false);
}
function CreateTronTransactionRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "vault_id": value["vaultId"],
    "note": value["note"],
    "signer_type": SignerTypeToJSON(value["signerType"]),
    "sign_mode": SignModeToJSON(value["signMode"]),
    "dapp_info": DappInfoToJSON(value["dappInfo"]),
    "type": value["type"],
    "details": CreateTronTransactionRequestDetailsToJSON(value["details"])
  };
}

// src/openapi/models/UtxoMessageType.ts
function UtxoMessageTypeFromJSON(json) {
  return UtxoMessageTypeFromJSONTyped(json, false);
}
function UtxoMessageTypeFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}
function UtxoMessageTypeToJSON(value) {
  return value;
}

// src/openapi/models/UtxoMessageDetails.ts
function UtxoMessageDetailsToJSON(json) {
  return UtxoMessageDetailsToJSONTyped(json, false);
}
function UtxoMessageDetailsToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "type": UtxoMessageTypeToJSON(value["type"]),
    "sender": UtxoAddressToJSON(value["sender"]),
    "raw_data": value["rawData"]
  };
}

// src/openapi/models/CreateUtxoMessageRequest.ts
function CreateUtxoMessageRequestToJSON(json) {
  return CreateUtxoMessageRequestToJSONTyped(json, false);
}
function CreateUtxoMessageRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "vault_id": value["vaultId"],
    "note": value["note"],
    "signer_type": SignerTypeToJSON(value["signerType"]),
    "sign_mode": SignModeToJSON(value["signMode"]),
    "dapp_info": DappInfoToJSON(value["dappInfo"]),
    "type": value["type"],
    "details": UtxoMessageDetailsToJSON(value["details"])
  };
}

// src/openapi/models/PsbtSignerIdentityAddress.ts
function PsbtSignerIdentityAddressToJSON(json) {
  return PsbtSignerIdentityAddressToJSONTyped(json, false);
}
function PsbtSignerIdentityAddressToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "type": value["type"],
    "address": value["address"]
  };
}

// src/openapi/models/PsbtSignerIdentityPublicKey.ts
function PsbtSignerIdentityPublicKeyToJSON(json) {
  return PsbtSignerIdentityPublicKeyToJSONTyped(json, false);
}
function PsbtSignerIdentityPublicKeyToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "type": value["type"],
    "public_key": value["publicKey"]
  };
}

// src/openapi/models/PsbtInputSignerIdentity.ts
function PsbtInputSignerIdentityToJSON(json) {
  return PsbtInputSignerIdentityToJSONTyped(json, false);
}
function PsbtInputSignerIdentityToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  switch (value["type"]) {
    case "address":
      return Object.assign({}, PsbtSignerIdentityAddressToJSON(value), { type: "address" });
    case "public_key":
      return Object.assign({}, PsbtSignerIdentityPublicKeyToJSON(value), { type: "public_key" });
    default:
      throw new Error(`No variant of PsbtInputSignerIdentity exists with 'type=${value["type"]}'`);
  }
}

// src/openapi/models/PsbtInput.ts
function PsbtInputToJSON(json) {
  return PsbtInputToJSONTyped(json, false);
}
function PsbtInputToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "index": value["index"],
    "signer_identity": PsbtInputSignerIdentityToJSON(value["signerIdentity"]),
    "sighash_types": value["sighashTypes"],
    "disable_tweak_signer": value["disableTweakSigner"]
  };
}

// src/openapi/models/TransactionDetailsUtxoPsbtRequest.ts
function TransactionDetailsUtxoPsbtRequestToJSON(json) {
  return TransactionDetailsUtxoPsbtRequestToJSONTyped(json, false);
}
function TransactionDetailsUtxoPsbtRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "type": value["type"],
    "psbt_raw_data": value["psbtRawData"],
    "auto_finalize": value["autoFinalize"],
    "sender": UtxoAddressToJSON(value["sender"]),
    "inputs": value["inputs"] == null ? void 0 : value["inputs"].map(PsbtInputToJSON),
    "push_mode": PushModeToJSON(value["pushMode"])
  };
}

// src/openapi/models/UtxoOutputToAddressRequest.ts
function UtxoOutputToAddressRequestToJSON(json) {
  return UtxoOutputToAddressRequestToJSONTyped(json, false);
}
function UtxoOutputToAddressRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "type": value["type"],
    "address": value["address"]
  };
}

// src/openapi/models/UtxoOutputToVaultAddressIdRequest.ts
function UtxoOutputToVaultAddressIdRequestToJSON(json) {
  return UtxoOutputToVaultAddressIdRequestToJSONTyped(json, false);
}
function UtxoOutputToVaultAddressIdRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "type": value["type"],
    "vault_address_id": value["vaultAddressId"]
  };
}

// src/openapi/models/UtxoOutputToVaultIdRequest.ts
function UtxoOutputToVaultIdRequestToJSON(json) {
  return UtxoOutputToVaultIdRequestToJSONTyped(json, false);
}
function UtxoOutputToVaultIdRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "type": value["type"],
    "vault_id": value["vaultId"]
  };
}

// src/openapi/models/UtxoOutputRequestTo.ts
function UtxoOutputRequestToToJSON(json) {
  return UtxoOutputRequestToToJSONTyped(json, false);
}
function UtxoOutputRequestToToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  switch (value["type"]) {
    case "address":
      return Object.assign({}, UtxoOutputToAddressRequestToJSON(value), { type: "address" });
    case "vault_address_id":
      return Object.assign({}, UtxoOutputToVaultAddressIdRequestToJSON(value), { type: "vault_address_id" });
    case "vault_id":
      return Object.assign({}, UtxoOutputToVaultIdRequestToJSON(value), { type: "vault_id" });
    default:
      throw new Error(`No variant of UtxoOutputRequestTo exists with 'type=${value["type"]}'`);
  }
}

// src/openapi/models/UtxoOutputRequest.ts
function UtxoOutputRequestToJSON(json) {
  return UtxoOutputRequestToJSONTyped(json, false);
}
function UtxoOutputRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "to": UtxoOutputRequestToToJSON(value["to"]),
    "value": value["value"]
  };
}

// src/openapi/models/CustomFeeRequest.ts
function CustomFeeRequestToJSON(json) {
  return CustomFeeRequestToJSONTyped(json, false);
}
function CustomFeeRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "type": value["type"],
    "fee_per_byte": value["feePerByte"]
  };
}

// src/openapi/models/FeePriorityRequest.ts
function FeePriorityRequestToJSON(json) {
  return FeePriorityRequestToJSONTyped(json, false);
}
function FeePriorityRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "type": value["type"],
    "priority_level": FeePriorityLevelRequestToJSON(value["priorityLevel"])
  };
}

// src/openapi/models/TransactionDetailsUtxoTransferRequestFeePerByte.ts
function TransactionDetailsUtxoTransferRequestFeePerByteToJSON(json) {
  return TransactionDetailsUtxoTransferRequestFeePerByteToJSONTyped(json, false);
}
function TransactionDetailsUtxoTransferRequestFeePerByteToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  switch (value["type"]) {
    case "custom":
      return Object.assign({}, CustomFeeRequestToJSON(value), { type: "custom" });
    case "priority":
      return Object.assign({}, FeePriorityRequestToJSON(value), { type: "priority" });
    default:
      throw new Error(`No variant of TransactionDetailsUtxoTransferRequestFeePerByte exists with 'type=${value["type"]}'`);
  }
}

// src/openapi/models/TransactionDetailsUtxoTransferRequest.ts
function TransactionDetailsUtxoTransferRequestToJSON(json) {
  return TransactionDetailsUtxoTransferRequestToJSONTyped(json, false);
}
function TransactionDetailsUtxoTransferRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "type": value["type"],
    "outputs": value["outputs"].map(UtxoOutputRequestToJSON),
    "fee_per_byte": TransactionDetailsUtxoTransferRequestFeePerByteToJSON(value["feePerByte"]),
    "push_mode": PushModeToJSON(value["pushMode"]),
    "memos": value["memos"]
  };
}

// src/openapi/models/CreateUtxoTransactionRequestDetails.ts
function CreateUtxoTransactionRequestDetailsToJSON(json) {
  return CreateUtxoTransactionRequestDetailsToJSONTyped(json, false);
}
function CreateUtxoTransactionRequestDetailsToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  switch (value["type"]) {
    case "utxo_partially_signed_bitcoin_transaction":
      return Object.assign({}, TransactionDetailsUtxoPsbtRequestToJSON(value), { type: "utxo_partially_signed_bitcoin_transaction" });
    case "utxo_transfer":
      return Object.assign({}, TransactionDetailsUtxoTransferRequestToJSON(value), { type: "utxo_transfer" });
    default:
      throw new Error(`No variant of CreateUtxoTransactionRequestDetails exists with 'type=${value["type"]}'`);
  }
}

// src/openapi/models/CreateUtxoTransactionRequest.ts
function CreateUtxoTransactionRequestToJSON(json) {
  return CreateUtxoTransactionRequestToJSONTyped(json, false);
}
function CreateUtxoTransactionRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "vault_id": value["vaultId"],
    "note": value["note"],
    "signer_type": SignerTypeToJSON(value["signerType"]),
    "sign_mode": SignModeToJSON(value["signMode"]),
    "dapp_info": DappInfoToJSON(value["dappInfo"]),
    "type": value["type"],
    "details": CreateUtxoTransactionRequestDetailsToJSON(value["details"])
  };
}

// src/openapi/models/CreateTransactionRequest.ts
function CreateTransactionRequestToJSON(json) {
  return CreateTransactionRequestToJSONTyped(json, false);
}
function CreateTransactionRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  switch (value["type"]) {
    case "aptos_message":
      return Object.assign({}, CreateAptosMessageRequestToJSON(value), { type: "aptos_message" });
    case "aptos_transaction":
      return Object.assign({}, CreateAptosTransactionRequestToJSON(value), { type: "aptos_transaction" });
    case "black_box_signature":
      return Object.assign({}, CreateBlackBoxSignatureRequestToJSON(value), { type: "black_box_signature" });
    case "cosmos_message":
      return Object.assign({}, CreateCosmosMessageRequestToJSON(value), { type: "cosmos_message" });
    case "cosmos_transaction":
      return Object.assign({}, CreateCosmosTransactionRequestToJSON(value), { type: "cosmos_transaction" });
    case "evm_message":
      return Object.assign({}, CreateEvmMessageRequestToJSON(value), { type: "evm_message" });
    case "evm_transaction":
      return Object.assign({}, CreateEvmTransactionRequestToJSON(value), { type: "evm_transaction" });
    case "exchange_transaction":
      return Object.assign({}, CreateExchangeTransactionRequestToJSON(value), { type: "exchange_transaction" });
    case "solana_message":
      return Object.assign({}, CreateSolanaMessageRequestToJSON(value), { type: "solana_message" });
    case "solana_transaction":
      return Object.assign({}, CreateSolanaTransactionRequestToJSON(value), { type: "solana_transaction" });
    case "stacks_transaction":
      return Object.assign({}, CreateStacksTransactionRequestToJSON(value), { type: "stacks_transaction" });
    case "starknet_message":
      return Object.assign({}, CreateStarknetMessageRequestToJSON(value), { type: "starknet_message" });
    case "starknet_transaction":
      return Object.assign({}, CreateStarknetTransactionRequestToJSON(value), { type: "starknet_transaction" });
    case "sui_message":
      return Object.assign({}, CreateSuiMessageRequestToJSON(value), { type: "sui_message" });
    case "sui_transaction":
      return Object.assign({}, CreateSuiTransactionRequestToJSON(value), { type: "sui_transaction" });
    case "ton_message":
      return Object.assign({}, CreateTonMessageRequestToJSON(value), { type: "ton_message" });
    case "ton_transaction":
      return Object.assign({}, CreateTonTransactionRequestToJSON(value), { type: "ton_transaction" });
    case "tron_transaction":
      return Object.assign({}, CreateTronTransactionRequestToJSON(value), { type: "tron_transaction" });
    case "utxo_message":
      return Object.assign({}, CreateUtxoMessageRequestToJSON(value), { type: "utxo_message" });
    case "utxo_transaction":
      return Object.assign({}, CreateUtxoTransactionRequestToJSON(value), { type: "utxo_transaction" });
    default:
      throw new Error(`No variant of CreateTransactionRequest exists with 'type=${value["type"]}'`);
  }
}

// src/openapi/models/EvmMessageDomainData.ts
function EvmMessageDomainDataFromJSON(json) {
  return EvmMessageDomainDataFromJSONTyped(json, false);
}
function EvmMessageDomainDataFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "name": json["name"] == null ? void 0 : json["name"],
    "version": json["version"] == null ? void 0 : json["version"],
    "chainId": json["chain_id"] == null ? void 0 : json["chain_id"],
    "verifyingContract": json["verifying_contract"] == null ? void 0 : EnrichedEvmAddressFromJSON(json["verifying_contract"]),
    "salt": json["salt"] == null ? void 0 : json["salt"]
  };
}

// src/openapi/models/Permit2TypedMessageEvmMessage.ts
function Permit2TypedMessageEvmMessageFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "domain": EvmMessageDomainDataFromJSON(json["domain"]),
    "primaryType": json["primary_type"],
    "type": json["type"],
    "spender": EnrichedEvmAddressFromJSON(json["spender"]),
    "deadline": new Date(json["deadline"]),
    "token": EnrichedEvmAddressFromJSON(json["token"]),
    "value": json["value"],
    "expiration": new Date(json["expiration"]),
    "nonce": json["nonce"],
    "price": json["price"] == null ? void 0 : PriceFromJSON(json["price"]),
    "pricedAsset": PricedAssetFromJSON(json["priced_asset"])
  };
}

// src/openapi/models/PermitTypedMessageEvmMessage.ts
function PermitTypedMessageEvmMessageFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "domain": EvmMessageDomainDataFromJSON(json["domain"]),
    "primaryType": json["primary_type"],
    "type": json["type"],
    "owner": EnrichedEvmAddressFromJSON(json["owner"]),
    "spender": EnrichedEvmAddressFromJSON(json["spender"]),
    "value": json["value"],
    "deadline": new Date(json["deadline"]),
    "nonce": json["nonce"],
    "price": json["price"] == null ? void 0 : PriceFromJSON(json["price"]),
    "pricedAsset": PricedAssetFromJSON(json["priced_asset"])
  };
}

// src/openapi/models/UnknownTypedMessageEvmMessage.ts
function UnknownTypedMessageEvmMessageFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "domain": EvmMessageDomainDataFromJSON(json["domain"]),
    "primaryType": json["primary_type"],
    "type": json["type"]
  };
}

// src/openapi/models/EvmMessageTypedData.ts
function EvmMessageTypedDataFromJSON(json) {
  return EvmMessageTypedDataFromJSONTyped(json, false);
}
function EvmMessageTypedDataFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  switch (json["type"]) {
    case "permit":
      return Object.assign({}, PermitTypedMessageEvmMessageFromJSONTyped(json, true), { type: "permit" });
    case "permit2":
      return Object.assign({}, Permit2TypedMessageEvmMessageFromJSONTyped(json, true), { type: "permit2" });
    case "unknown":
      return Object.assign({}, UnknownTypedMessageEvmMessageFromJSONTyped(json, true), { type: "unknown" });
    default:
      throw new Error(`No variant of EvmMessageTypedData exists with 'type=${json["type"]}'`);
  }
}

// src/openapi/models/EvmMessageType.ts
function EvmMessageTypeFromJSON(json) {
  return EvmMessageTypeFromJSONTyped(json, false);
}
function EvmMessageTypeFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// src/openapi/models/EvmMessage.ts
function EvmMessageFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "id": json["id"],
    "createdAt": new Date(json["created_at"]),
    "modifiedAt": new Date(json["modified_at"]),
    "managedTransactionData": json["managed_transaction_data"] == null ? void 0 : ManagedTransactionDataFromJSON(json["managed_transaction_data"]),
    "signatures": json["signatures"].map(SignatureFromJSON),
    "note": json["note"] == null ? void 0 : json["note"],
    "spamState": json["spam_state"] == null ? void 0 : TransactionSpamStateFromJSON(json["spam_state"]),
    "direction": TransactionDirectionFromJSON(json["direction"]),
    "signedExternally": json["signed_externally"] == null ? void 0 : json["signed_externally"],
    "state": NonPushableTransactionStateFromJSON(json["state"]),
    "stateChanges": json["state_changes"].map(NonPushableTransactionStateChangeFromJSON),
    "type": json["type"],
    "evmMessageType": EvmMessageTypeFromJSON(json["evm_message_type"]),
    "rawData": json["raw_data"],
    "typedData": json["typed_data"] == null ? void 0 : EvmMessageTypedDataFromJSON(json["typed_data"]),
    "vault": VaultRefFromJSON(json["vault"]),
    "chain": EnrichedEvmChainFromJSON(json["chain"]),
    "sender": EnrichedEvmAddressFromJSON(json["sender"])
  };
}

// src/openapi/models/EvmReversionState.ts
function EvmReversionStateFromJSON(json) {
  return EvmReversionStateFromJSONTyped(json, false);
}
function EvmReversionStateFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// src/openapi/models/EvmReversion.ts
function EvmReversionFromJSON(json) {
  return EvmReversionFromJSONTyped(json, false);
}
function EvmReversionFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "state": EvmReversionStateFromJSON(json["state"]),
    "reason": json["reason"] == null ? void 0 : json["reason"]
  };
}

// src/openapi/models/EvmBalanceChangeEffectTokenContract.ts
function EvmBalanceChangeEffectTokenContractFromJSON(json) {
  return EvmBalanceChangeEffectTokenContractFromJSONTyped(json, false);
}
function EvmBalanceChangeEffectTokenContractFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "name": json["name"] == null ? void 0 : json["name"],
    "dapp": json["dapp"] == null ? void 0 : DappFromJSON(json["dapp"]),
    "isVerified": json["is_verified"],
    "token": Erc1155FromJSON(json["token"])
  };
}

// src/openapi/models/EvmBalanceChangeEffectType.ts
function EvmBalanceChangeEffectTypeFromJSON(json) {
  return EvmBalanceChangeEffectTypeFromJSONTyped(json, false);
}
function EvmBalanceChangeEffectTypeFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// src/openapi/models/EvmBalanceChangeEffect.ts
function EvmBalanceChangeEffectFromJSON(json) {
  return EvmBalanceChangeEffectFromJSONTyped(json, false);
}
function EvmBalanceChangeEffectFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "pricedAsset": PricedAssetFromJSON(json["priced_asset"]),
    "diff": json["diff"],
    "type": EvmBalanceChangeEffectTypeFromJSON(json["type"]),
    "address": EnrichedEvmAddressFromJSON(json["address"]),
    "owner": EnrichedEvmAddressFromJSON(json["owner"]),
    "price": json["price"] == null ? void 0 : PriceFromJSON(json["price"]),
    "tokenContract": json["token_contract"] == null ? void 0 : EvmBalanceChangeEffectTokenContractFromJSON(json["token_contract"]),
    "tokenId": json["token_id"] == null ? void 0 : json["token_id"],
    "owned": json["owned"] == null ? void 0 : json["owned"]
  };
}

// src/openapi/models/EvmTransferEffectType.ts
function EvmTransferEffectTypeFromJSON(json) {
  return EvmTransferEffectTypeFromJSONTyped(json, false);
}
function EvmTransferEffectTypeFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// src/openapi/models/EvmTransferEffect.ts
function EvmTransferEffectFromJSON(json) {
  return EvmTransferEffectFromJSONTyped(json, false);
}
function EvmTransferEffectFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "pricedAsset": PricedAssetFromJSON(json["priced_asset"]),
    "amount": json["amount"],
    "type": EvmTransferEffectTypeFromJSON(json["type"]),
    "from": EnrichedEvmAddressFromJSON(json["from"]),
    "to": EnrichedEvmAddressFromJSON(json["to"]),
    "price": json["price"] == null ? void 0 : PriceFromJSON(json["price"]),
    "tokenContract": json["token_contract"] == null ? void 0 : EvmBalanceChangeEffectTokenContractFromJSON(json["token_contract"]),
    "tokenId": json["token_id"] == null ? void 0 : json["token_id"]
  };
}

// src/openapi/models/EvmContractDeploymentEffect.ts
function EvmContractDeploymentEffectFromJSON(json) {
  return EvmContractDeploymentEffectFromJSONTyped(json, false);
}
function EvmContractDeploymentEffectFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "address": EnrichedEvmAddressFromJSON(json["address"])
  };
}

// src/openapi/models/EvmEffects.ts
function EvmEffectsFromJSON(json) {
  return EvmEffectsFromJSONTyped(json, false);
}
function EvmEffectsFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "balanceChanges": json["balance_changes"].map(EvmBalanceChangeEffectFromJSON),
    "transfers": json["transfers"].map(EvmTransferEffectFromJSON),
    "allowances": json["allowances"].map(AllowanceEffectFromJSON),
    "bridge": json["bridge"].map(EvmBridgeEffectFromJSON),
    "contractDeployments": json["contract_deployments"].map(EvmContractDeploymentEffectFromJSON)
  };
}

// src/openapi/models/GasDebit.ts
function GasDebitFromJSON(json) {
  return GasDebitFromJSONTyped(json, false);
}
function GasDebitFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "gasUsed": json["gas_used"],
    "gasPrice": json["gas_price"],
    "totalFee": json["total_fee"],
    "fiatPrice": json["fiat_price"] == null ? void 0 : PriceFromJSON(json["fiat_price"]),
    "pricedAsset": PricedAssetFromJSON(json["priced_asset"])
  };
}

// src/openapi/models/EvmTransactionResult.ts
function EvmTransactionResultFromJSON(json) {
  return EvmTransactionResultFromJSONTyped(json, false);
}
function EvmTransactionResultFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "reversion": EvmReversionFromJSON(json["reversion"]),
    "gasDebit": GasDebitFromJSON(json["gas_debit"]),
    "effects": EvmEffectsFromJSON(json["effects"])
  };
}

// src/openapi/models/GasPriorityLevel.ts
function GasPriorityLevelFromJSON(json) {
  return GasPriorityLevelFromJSONTyped(json, false);
}
function GasPriorityLevelFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// src/openapi/models/DynamicGas.ts
function DynamicGasFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "maxPriorityFeePerGas": json["max_priority_fee_per_gas"],
    "maxFeePerGas": json["max_fee_per_gas"],
    "priority": GasPriorityLevelFromJSON(json["priority"]),
    "limit": json["limit"],
    "type": json["type"]
  };
}

// src/openapi/models/LegacyGas.ts
var LegacyGasTypeEnum = {
  legacy: "legacy"
};
function LegacyGasFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "price": json["price"],
    "priority": GasPriorityLevelFromJSON(json["priority"]),
    "limit": json["limit"],
    "type": json["type"]
  };
}

// src/openapi/models/EvmTransactionGasSubmitted.ts
function EvmTransactionGasSubmittedFromJSON(json) {
  return EvmTransactionGasSubmittedFromJSONTyped(json, false);
}
function EvmTransactionGasSubmittedFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  switch (json["type"]) {
    case "dynamic":
      return Object.assign({}, DynamicGasFromJSONTyped(json, true), { type: "dynamic" });
    case "legacy":
      return Object.assign({}, LegacyGasFromJSONTyped(json, true), { type: "legacy" });
    default:
      throw new Error(`No variant of EvmTransactionGasSubmitted exists with 'type=${json["type"]}'`);
  }
}

// src/openapi/models/EvmTransactionMethodArgument.ts
function EvmTransactionMethodArgumentFromJSON(json) {
  return EvmTransactionMethodArgumentFromJSONTyped(json, false);
}
function EvmTransactionMethodArgumentFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "name": json["name"],
    "type": json["type"],
    "value": json["value"],
    "enrichedAddress": json["enriched_address"] == null ? void 0 : EnrichedEvmAddressFromJSON(json["enriched_address"])
  };
}

// src/openapi/models/EvmTransactionParsedData.ts
function EvmTransactionParsedDataFromJSON(json) {
  return EvmTransactionParsedDataFromJSONTyped(json, false);
}
function EvmTransactionParsedDataFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "method": json["method"],
    "methodArguments": json["method_arguments"].map(EvmTransactionMethodArgumentFromJSON)
  };
}

// src/openapi/models/EvmBlockData.ts
function EvmBlockDataFromJSON(json) {
  return EvmBlockDataFromJSONTyped(json, false);
}
function EvmBlockDataFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "number": json["number"],
    "hash": json["hash"],
    "minedAt": new Date(json["mined_at"])
  };
}

// src/openapi/models/EvmNativeTransferDetails.ts
function EvmNativeTransferDetailsFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "type": json["type"],
    "direction": TransferDirectionFromJSON(json["direction"]),
    "isInternal": json["is_internal"] == null ? void 0 : json["is_internal"]
  };
}

// src/openapi/models/TokenTransferDetails.ts
function TokenTransferDetailsFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "type": json["type"],
    "direction": TransferDirectionFromJSON(json["direction"]),
    "recipient": EnrichedEvmAddressFromJSON(json["recipient"]),
    "isInternal": json["is_internal"] == null ? void 0 : json["is_internal"]
  };
}

// src/openapi/models/EvmTransactionEvmTransactionTypeDetails.ts
function EvmTransactionEvmTransactionTypeDetailsFromJSON(json) {
  return EvmTransactionEvmTransactionTypeDetailsFromJSONTyped(json, false);
}
function EvmTransactionEvmTransactionTypeDetailsFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  switch (json["type"]) {
    case "allowance":
      return Object.assign({}, AllowanceDetailsFromJSONTyped(json, true), { type: "allowance" });
    case "contract_call":
      return Object.assign({}, ContractCallDetailsFromJSONTyped(json, true), { type: "contract_call" });
    case "contract_deployment":
      return Object.assign({}, ContractDeploymentDetailsFromJSONTyped(json, true), { type: "contract_deployment" });
    case "cross_chain_bridge":
      return Object.assign({}, BridgeDetailsFromJSONTyped(json, true), { type: "cross_chain_bridge" });
    case "native_transfer":
      return Object.assign({}, EvmNativeTransferDetailsFromJSONTyped(json, true), { type: "native_transfer" });
    case "token_transfer":
      return Object.assign({}, TokenTransferDetailsFromJSONTyped(json, true), { type: "token_transfer" });
    default:
      throw new Error(`No variant of EvmTransactionEvmTransactionTypeDetails exists with 'type=${json["type"]}'`);
  }
}

// src/openapi/models/EvmTransaction.ts
function EvmTransactionFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "id": json["id"],
    "createdAt": new Date(json["created_at"]),
    "modifiedAt": new Date(json["modified_at"]),
    "managedTransactionData": json["managed_transaction_data"] == null ? void 0 : ManagedTransactionDataFromJSON(json["managed_transaction_data"]),
    "signatures": json["signatures"].map(SignatureFromJSON),
    "note": json["note"] == null ? void 0 : json["note"],
    "spamState": json["spam_state"] == null ? void 0 : TransactionSpamStateFromJSON(json["spam_state"]),
    "direction": TransactionDirectionFromJSON(json["direction"]),
    "signedExternally": json["signed_externally"] == null ? void 0 : json["signed_externally"],
    "state": PushableTransactionStateFromJSON(json["state"]),
    "stateChanges": json["state_changes"].map(PushableTransactionStateChangeFromJSON),
    "amlResults": json["aml_results"] == null ? void 0 : AmlResultsFromJSON(json["aml_results"]),
    "incomingAmlPolicyMatch": json["incoming_aml_policy_match"] == null ? void 0 : AmlPolicyMatchIncomingFromJSON(json["incoming_aml_policy_match"]),
    "type": json["type"],
    "evmTransactionTypeDetails": EvmTransactionEvmTransactionTypeDetailsFromJSON(json["evm_transaction_type_details"]),
    "chain": EnrichedEvmChainFromJSON(json["chain"]),
    "from": EnrichedEvmAddressFromJSON(json["from"]),
    "to": EnrichedEvmAddressFromJSON(json["to"]),
    "value": json["value"],
    "data": json["data"],
    "hexData": json["hex_data"] == null ? void 0 : json["hex_data"],
    "parsedData": EvmTransactionParsedDataFromJSON(json["parsed_data"]),
    "hash": json["hash"] == null ? void 0 : json["hash"],
    "nonce": json["nonce"] == null ? void 0 : json["nonce"],
    "block": json["block"] == null ? void 0 : EvmBlockDataFromJSON(json["block"]),
    "expectedResult": json["expected_result"] == null ? void 0 : EvmTransactionResultFromJSON(json["expected_result"]),
    "simulationStatusResult": json["simulation_status_result"] == null ? void 0 : SimulationStatusResultFromJSON(json["simulation_status_result"]),
    "minedResult": json["mined_result"] == null ? void 0 : EvmTransactionResultFromJSON(json["mined_result"]),
    "gasSubmitted": EvmTransactionGasSubmittedFromJSON(json["gas_submitted"]),
    "parentTransactionId": json["parent_transaction_id"] == null ? void 0 : json["parent_transaction_id"],
    "childTransactionId": json["child_transaction_id"] == null ? void 0 : json["child_transaction_id"],
    "fundingForTransactionId": json["funding_for_transaction_id"] == null ? void 0 : json["funding_for_transaction_id"],
    "fundedByTransactionId": json["funded_by_transaction_id"] == null ? void 0 : json["funded_by_transaction_id"],
    "fundedByVault": json["funded_by_vault"] == null ? void 0 : VaultRefFromJSON(json["funded_by_vault"]),
    "currentPrecedingPushedToBlockchainTransactionId": json["current_preceding_pushed_to_blockchain_transaction_id"] == null ? void 0 : json["current_preceding_pushed_to_blockchain_transaction_id"],
    "isCancelation": json["is_cancelation"],
    "isAcceleration": json["is_acceleration"],
    "useSecureNode": json["use_secure_node"],
    "explorerUrl": json["explorer_url"] == null ? void 0 : json["explorer_url"],
    "rawTransaction": json["raw_transaction"] == null ? void 0 : json["raw_transaction"]
  };
}

// src/openapi/models/ExchangeTransactionState.ts
function ExchangeTransactionStateFromJSON(json) {
  return ExchangeTransactionStateFromJSONTyped(json, false);
}
function ExchangeTransactionStateFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// src/openapi/models/ExchangeTransactionStateChange.ts
function ExchangeTransactionStateChangeFromJSON(json) {
  return ExchangeTransactionStateChangeFromJSONTyped(json, false);
}
function ExchangeTransactionStateChangeFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "changedAt": new Date(json["changed_at"]),
    "reason": json["reason"] == null ? void 0 : StateChangeReasonFromJSON(json["reason"]),
    "assetPrices": json["asset_prices"] == null ? void 0 : json["asset_prices"].map(PricedAssetFromJSON),
    "prices": json["prices"] == null ? void 0 : EvmPricesFromJSON(json["prices"]),
    "previousState": json["previous_state"] == null ? void 0 : ExchangeTransactionStateFromJSON(json["previous_state"]),
    "newState": ExchangeTransactionStateFromJSON(json["new_state"])
  };
}

// src/openapi/models/ExchangeExternalWithdrawDetails.ts
function ExchangeExternalWithdrawDetailsFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "isInternal": json["is_internal"],
    "sender": EnrichedExchangeAddressFromJSON(json["sender"]),
    "type": json["type"],
    "recipient": EnrichedAddressFromJSON(json["recipient"]),
    "chain": EnrichedChainFromJSON(json["chain"]),
    "memo": json["memo"] == null ? void 0 : json["memo"],
    "hash": json["hash"] == null ? void 0 : json["hash"],
    "explorerUrl": json["explorer_url"] == null ? void 0 : json["explorer_url"]
  };
}

// src/openapi/models/ExchangeInternalTransferDetails.ts
function ExchangeInternalTransferDetailsFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "isInternal": json["is_internal"],
    "sender": EnrichedExchangeAddressFromJSON(json["sender"]),
    "type": json["type"],
    "recipient": EnrichedExchangeAddressFromJSON(json["recipient"])
  };
}

// src/openapi/models/ExchangeTransactionExchangeTransactionTypeDetails.ts
function ExchangeTransactionExchangeTransactionTypeDetailsFromJSON(json) {
  return ExchangeTransactionExchangeTransactionTypeDetailsFromJSONTyped(json, false);
}
function ExchangeTransactionExchangeTransactionTypeDetailsFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  switch (json["type"]) {
    case "external_withdraw":
      return Object.assign({}, ExchangeExternalWithdrawDetailsFromJSONTyped(json, true), { type: "external_withdraw" });
    case "internal_transfer":
      return Object.assign({}, ExchangeInternalTransferDetailsFromJSONTyped(json, true), { type: "internal_transfer" });
    default:
      throw new Error(`No variant of ExchangeTransactionExchangeTransactionTypeDetails exists with 'type=${json["type"]}'`);
  }
}

// src/openapi/models/ExchangeTransferEffect.ts
function ExchangeTransferEffectFromJSON(json) {
  return ExchangeTransferEffectFromJSONTyped(json, false);
}
function ExchangeTransferEffectFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "pricedAsset": PricedAssetFromJSON(json["priced_asset"]),
    "amount": json["amount"],
    "from": EnrichedExchangeAddressFromJSON(json["from"]),
    "to": EnrichedAddressFromJSON(json["to"])
  };
}

// src/openapi/models/ExchangeBalanceChangeEffect.ts
function ExchangeBalanceChangeEffectFromJSON(json) {
  return ExchangeBalanceChangeEffectFromJSONTyped(json, false);
}
function ExchangeBalanceChangeEffectFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "pricedAsset": PricedAssetFromJSON(json["priced_asset"]),
    "diff": json["diff"],
    "address": EnrichedAddressFromJSON(json["address"])
  };
}

// src/openapi/models/ExchangeEffects.ts
function ExchangeEffectsFromJSON(json) {
  return ExchangeEffectsFromJSONTyped(json, false);
}
function ExchangeEffectsFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "balanceChanges": json["balance_changes"].map(ExchangeBalanceChangeEffectFromJSON),
    "transfers": json["transfers"].map(ExchangeTransferEffectFromJSON)
  };
}

// src/openapi/models/ExchangeFee.ts
function ExchangeFeeFromJSON(json) {
  return ExchangeFeeFromJSONTyped(json, false);
}
function ExchangeFeeFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "pricedAsset": PricedAssetFromJSON(json["priced_asset"]),
    "fee": json["fee"]
  };
}

// src/openapi/models/ExchangeReversionState.ts
function ExchangeReversionStateFromJSON(json) {
  return ExchangeReversionStateFromJSONTyped(json, false);
}
function ExchangeReversionStateFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// src/openapi/models/ExchangeReversion.ts
function ExchangeReversionFromJSON(json) {
  return ExchangeReversionFromJSONTyped(json, false);
}
function ExchangeReversionFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "state": ExchangeReversionStateFromJSON(json["state"]),
    "reason": json["reason"] == null ? void 0 : json["reason"]
  };
}

// src/openapi/models/ExchangeTransactionResult.ts
function ExchangeTransactionResultFromJSON(json) {
  return ExchangeTransactionResultFromJSONTyped(json, false);
}
function ExchangeTransactionResultFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "reversion": ExchangeReversionFromJSON(json["reversion"]),
    "effects": ExchangeEffectsFromJSON(json["effects"]),
    "exchangeFee": json["exchange_fee"] == null ? void 0 : ExchangeFeeFromJSON(json["exchange_fee"])
  };
}

// src/openapi/models/ExchangeTransaction.ts
function ExchangeTransactionFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "id": json["id"],
    "createdAt": new Date(json["created_at"]),
    "modifiedAt": new Date(json["modified_at"]),
    "managedTransactionData": json["managed_transaction_data"] == null ? void 0 : ManagedTransactionDataFromJSON(json["managed_transaction_data"]),
    "signatures": json["signatures"].map(SignatureFromJSON),
    "note": json["note"] == null ? void 0 : json["note"],
    "spamState": json["spam_state"] == null ? void 0 : TransactionSpamStateFromJSON(json["spam_state"]),
    "direction": TransactionDirectionFromJSON(json["direction"]),
    "signedExternally": json["signed_externally"] == null ? void 0 : json["signed_externally"],
    "state": ExchangeTransactionStateFromJSON(json["state"]),
    "stateChanges": json["state_changes"].map(ExchangeTransactionStateChangeFromJSON),
    "type": json["type"],
    "exchangeTransactionTypeDetails": ExchangeTransactionExchangeTransactionTypeDetailsFromJSON(json["exchange_transaction_type_details"]),
    "exchangeNonce": json["exchange_nonce"] == null ? void 0 : json["exchange_nonce"],
    "exchangeTransactionId": json["exchange_transaction_id"] == null ? void 0 : json["exchange_transaction_id"],
    "hash": json["hash"] == null ? void 0 : json["hash"],
    "expectedResult": json["expected_result"] == null ? void 0 : ExchangeTransactionResultFromJSON(json["expected_result"]),
    "simulationStatusResult": SimulationStatusResultFromJSON(json["simulation_status_result"]),
    "minedResult": json["mined_result"] == null ? void 0 : ExchangeTransactionResultFromJSON(json["mined_result"]),
    "explorerUrl": json["explorer_url"] == null ? void 0 : json["explorer_url"]
  };
}

// src/openapi/models/SolanaMessageType.ts
function SolanaMessageTypeFromJSON(json) {
  return SolanaMessageTypeFromJSONTyped(json, false);
}
function SolanaMessageTypeFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// src/openapi/models/SolanaMessage.ts
function SolanaMessageFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "id": json["id"],
    "createdAt": new Date(json["created_at"]),
    "modifiedAt": new Date(json["modified_at"]),
    "managedTransactionData": json["managed_transaction_data"] == null ? void 0 : ManagedTransactionDataFromJSON(json["managed_transaction_data"]),
    "signatures": json["signatures"].map(SignatureFromJSON),
    "note": json["note"] == null ? void 0 : json["note"],
    "spamState": json["spam_state"] == null ? void 0 : TransactionSpamStateFromJSON(json["spam_state"]),
    "direction": TransactionDirectionFromJSON(json["direction"]),
    "signedExternally": json["signed_externally"] == null ? void 0 : json["signed_externally"],
    "state": NonPushableTransactionStateFromJSON(json["state"]),
    "stateChanges": json["state_changes"].map(NonPushableTransactionStateChangeFromJSON),
    "type": json["type"],
    "solanaMessageType": SolanaMessageTypeFromJSON(json["solana_message_type"]),
    "stringData": json["string_data"],
    "rawData": json["raw_data"],
    "chain": EnrichedSolanaChainFromJSON(json["chain"]),
    "sender": EnrichedSolanaAddressFromJSON(json["sender"])
  };
}

// src/openapi/models/StacksTransferEffect.ts
function StacksTransferEffectFromJSON(json) {
  return StacksTransferEffectFromJSONTyped(json, false);
}
function StacksTransferEffectFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "pricedAsset": PricedAssetFromJSON(json["priced_asset"]),
    "amount": json["amount"],
    "from": EnrichedStacksAddressFromJSON(json["from"]),
    "to": EnrichedStacksAddressFromJSON(json["to"])
  };
}

// src/openapi/models/StacksBalanceChangeEffect.ts
function StacksBalanceChangeEffectFromJSON(json) {
  return StacksBalanceChangeEffectFromJSONTyped(json, false);
}
function StacksBalanceChangeEffectFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "pricedAsset": PricedAssetFromJSON(json["priced_asset"]),
    "diff": json["diff"],
    "address": EnrichedStacksAddressFromJSON(json["address"])
  };
}

// src/openapi/models/StacksEffects.ts
function StacksEffectsFromJSON(json) {
  return StacksEffectsFromJSONTyped(json, false);
}
function StacksEffectsFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "balanceChanges": json["balance_changes"].map(StacksBalanceChangeEffectFromJSON),
    "transfers": json["transfers"].map(StacksTransferEffectFromJSON)
  };
}

// src/openapi/models/StacksFee.ts
function StacksFeeFromJSON(json) {
  return StacksFeeFromJSONTyped(json, false);
}
function StacksFeeFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "priority": FeePriorityLevelFromJSON(json["priority"]),
    "totalFee": json["total_fee"],
    "pricedAsset": PricedAssetFromJSON(json["priced_asset"])
  };
}

// src/openapi/models/StacksReversionState.ts
function StacksReversionStateFromJSON(json) {
  return StacksReversionStateFromJSONTyped(json, false);
}
function StacksReversionStateFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// src/openapi/models/StacksReversion.ts
function StacksReversionFromJSON(json) {
  return StacksReversionFromJSONTyped(json, false);
}
function StacksReversionFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "state": StacksReversionStateFromJSON(json["state"]),
    "reason": json["reason"] == null ? void 0 : json["reason"]
  };
}

// src/openapi/models/StacksTransactionResult.ts
function StacksTransactionResultFromJSON(json) {
  return StacksTransactionResultFromJSONTyped(json, false);
}
function StacksTransactionResultFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "reversion": StacksReversionFromJSON(json["reversion"]),
    "fee": StacksFeeFromJSON(json["fee"]),
    "effects": StacksEffectsFromJSON(json["effects"])
  };
}

// src/openapi/models/StacksPostConditionMode.ts
function StacksPostConditionModeFromJSON(json) {
  return StacksPostConditionModeFromJSONTyped(json, false);
}
function StacksPostConditionModeFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// src/openapi/models/StacksPostConditionComparator.ts
function StacksPostConditionComparatorFromJSON(json) {
  return StacksPostConditionComparatorFromJSONTyped(json, false);
}
function StacksPostConditionComparatorFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// src/openapi/models/KnownAssetStacksPostCondition.ts
function KnownAssetStacksPostConditionFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "address": EnrichedStacksAddressFromJSON(json["address"]),
    "conditionCode": StacksPostConditionComparatorFromJSON(json["condition_code"]),
    "amount": json["amount"],
    "type": json["type"],
    "pricedAsset": PricedAssetFromJSON(json["priced_asset"])
  };
}

// src/openapi/models/UnknownAssetStacksPostCondition.ts
function UnknownAssetStacksPostConditionFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "address": EnrichedStacksAddressFromJSON(json["address"]),
    "conditionCode": StacksPostConditionComparatorFromJSON(json["condition_code"]),
    "amount": json["amount"],
    "type": json["type"],
    "assetName": json["asset_name"]
  };
}

// src/openapi/models/StacksPostCondition.ts
function StacksPostConditionFromJSON(json) {
  return StacksPostConditionFromJSONTyped(json, false);
}
function StacksPostConditionFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  switch (json["type"]) {
    case "known_asset":
      return Object.assign({}, KnownAssetStacksPostConditionFromJSONTyped(json, true), { type: "known_asset" });
    case "unknown_asset":
      return Object.assign({}, UnknownAssetStacksPostConditionFromJSONTyped(json, true), { type: "unknown_asset" });
    default:
      throw new Error(`No variant of StacksPostCondition exists with 'type=${json["type"]}'`);
  }
}

// src/openapi/models/StacksPostConditions.ts
function StacksPostConditionsFromJSON(json) {
  return StacksPostConditionsFromJSONTyped(json, false);
}
function StacksPostConditionsFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "postConditionMode": StacksPostConditionModeFromJSON(json["post_condition_mode"]),
    "postConditions": json["post_conditions"].map(StacksPostConditionFromJSON)
  };
}

// src/openapi/models/StacksNativeTransferDetails.ts
function StacksNativeTransferDetailsFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "type": json["type"],
    "sender": EnrichedStacksAddressFromJSON(json["sender"]),
    "recipient": EnrichedStacksAddressFromJSON(json["recipient"]),
    "isInternal": json["is_internal"] == null ? void 0 : json["is_internal"]
  };
}

// src/openapi/models/StacksContractCallPayload.ts
function StacksContractCallPayloadFromJSON(json) {
  return StacksContractCallPayloadFromJSONTyped(json, false);
}
function StacksContractCallPayloadFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "contractAddress": EnrichedStacksAddressFromJSON(json["contract_address"]),
    "contractName": json["contract_name"],
    "functionName": json["function_name"],
    "functionArguments": json["function_arguments"]
  };
}

// src/openapi/models/StacksRawTransactionDetails.ts
function StacksRawTransactionDetailsFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "type": json["type"],
    "contractCallPayload": StacksContractCallPayloadFromJSON(json["contract_call_payload"])
  };
}

// src/openapi/models/StacksTokenTransferDetails.ts
function StacksTokenTransferDetailsFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "type": json["type"],
    "sender": EnrichedStacksAddressFromJSON(json["sender"]),
    "recipient": EnrichedStacksAddressFromJSON(json["recipient"]),
    "isInternal": json["is_internal"] == null ? void 0 : json["is_internal"]
  };
}

// src/openapi/models/PredictedStacksTransactionStacksTransactionTypeDetails.ts
function PredictedStacksTransactionStacksTransactionTypeDetailsFromJSON(json) {
  return PredictedStacksTransactionStacksTransactionTypeDetailsFromJSONTyped(json, false);
}
function PredictedStacksTransactionStacksTransactionTypeDetailsFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  switch (json["type"]) {
    case "native_transfer":
      return Object.assign({}, StacksNativeTransferDetailsFromJSONTyped(json, true), { type: "native_transfer" });
    case "raw_transaction":
      return Object.assign({}, StacksRawTransactionDetailsFromJSONTyped(json, true), { type: "raw_transaction" });
    case "token_transfer":
      return Object.assign({}, StacksTokenTransferDetailsFromJSONTyped(json, true), { type: "token_transfer" });
    default:
      throw new Error(`No variant of PredictedStacksTransactionStacksTransactionTypeDetails exists with 'type=${json["type"]}'`);
  }
}

// src/openapi/models/StacksBlock.ts
function StacksBlockFromJSON(json) {
  return StacksBlockFromJSONTyped(json, false);
}
function StacksBlockFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "number": json["number"],
    "hash": json["hash"],
    "minedAt": new Date(json["mined_at"])
  };
}

// src/openapi/models/StacksTransaction.ts
function StacksTransactionFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "id": json["id"],
    "createdAt": new Date(json["created_at"]),
    "modifiedAt": new Date(json["modified_at"]),
    "managedTransactionData": json["managed_transaction_data"] == null ? void 0 : ManagedTransactionDataFromJSON(json["managed_transaction_data"]),
    "signatures": json["signatures"].map(SignatureFromJSON),
    "note": json["note"] == null ? void 0 : json["note"],
    "spamState": json["spam_state"] == null ? void 0 : TransactionSpamStateFromJSON(json["spam_state"]),
    "direction": TransactionDirectionFromJSON(json["direction"]),
    "signedExternally": json["signed_externally"] == null ? void 0 : json["signed_externally"],
    "state": PushableTransactionStateFromJSON(json["state"]),
    "stateChanges": json["state_changes"].map(PushableTransactionStateChangeFromJSON),
    "amlResults": json["aml_results"] == null ? void 0 : AmlResultsFromJSON(json["aml_results"]),
    "incomingAmlPolicyMatch": json["incoming_aml_policy_match"] == null ? void 0 : AmlPolicyMatchIncomingFromJSON(json["incoming_aml_policy_match"]),
    "type": json["type"],
    "stacksTransactionTypeDetails": PredictedStacksTransactionStacksTransactionTypeDetailsFromJSON(json["stacks_transaction_type_details"]),
    "chain": EnrichedStacksChainFromJSON(json["chain"]),
    "nonce": json["nonce"] == null ? void 0 : json["nonce"],
    "sender": EnrichedStacksAddressFromJSON(json["sender"]),
    "hash": json["hash"] == null ? void 0 : json["hash"],
    "block": json["block"] == null ? void 0 : StacksBlockFromJSON(json["block"]),
    "postConditions": json["post_conditions"] == null ? void 0 : StacksPostConditionsFromJSON(json["post_conditions"]),
    "serializedPayload": json["serialized_payload"] == null ? void 0 : json["serialized_payload"],
    "serializedSignedTransaction": json["serialized_signed_transaction"] == null ? void 0 : json["serialized_signed_transaction"],
    "expectedResult": json["expected_result"] == null ? void 0 : StacksTransactionResultFromJSON(json["expected_result"]),
    "simulationStatusResult": json["simulation_status_result"] == null ? void 0 : SimulationStatusResultFromJSON(json["simulation_status_result"]),
    "minedResult": json["mined_result"] == null ? void 0 : StacksTransactionResultFromJSON(json["mined_result"]),
    "explorerUrl": json["explorer_url"] == null ? void 0 : json["explorer_url"],
    "memo": json["memo"] == null ? void 0 : json["memo"]
  };
}

// src/openapi/models/StarknetMessageType.ts
function StarknetMessageTypeFromJSON(json) {
  return StarknetMessageTypeFromJSONTyped(json, false);
}
function StarknetMessageTypeFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// src/openapi/models/StarknetMessage.ts
function StarknetMessageFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "id": json["id"],
    "createdAt": new Date(json["created_at"]),
    "modifiedAt": new Date(json["modified_at"]),
    "managedTransactionData": json["managed_transaction_data"] == null ? void 0 : ManagedTransactionDataFromJSON(json["managed_transaction_data"]),
    "signatures": json["signatures"].map(SignatureFromJSON),
    "note": json["note"] == null ? void 0 : json["note"],
    "spamState": json["spam_state"] == null ? void 0 : TransactionSpamStateFromJSON(json["spam_state"]),
    "direction": TransactionDirectionFromJSON(json["direction"]),
    "signedExternally": json["signed_externally"] == null ? void 0 : json["signed_externally"],
    "state": NonPushableTransactionStateFromJSON(json["state"]),
    "stateChanges": json["state_changes"].map(NonPushableTransactionStateChangeFromJSON),
    "type": json["type"],
    "starknetMessageType": StarknetMessageTypeFromJSON(json["starknet_message_type"]),
    "rawData": json["raw_data"],
    "chain": EnrichedStarknetChainFromJSON(json["chain"]),
    "sender": EnrichedStarknetAddressFromJSON(json["sender"]),
    "messageHash": json["message_hash"],
    "starknetSignatures": json["starknet_signatures"]
  };
}

// src/openapi/models/StarknetContractCreationDetails.ts
function StarknetContractCreationDetailsFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "type": json["type"]
  };
}

// src/openapi/models/StarknetErc20TransferDetails.ts
function StarknetErc20TransferDetailsFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "type": json["type"],
    "sender": EnrichedStarknetAddressFromJSON(json["sender"]),
    "recipient": EnrichedStarknetAddressFromJSON(json["recipient"]),
    "isInternal": json["is_internal"] == null ? void 0 : json["is_internal"]
  };
}

// src/openapi/models/StarknetNativeTransferDetails.ts
function StarknetNativeTransferDetailsFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "type": json["type"],
    "sender": EnrichedStarknetAddressFromJSON(json["sender"]),
    "recipient": EnrichedStarknetAddressFromJSON(json["recipient"]),
    "isInternal": json["is_internal"] == null ? void 0 : json["is_internal"]
  };
}

// src/openapi/models/StarknetRawTransactionDetails.ts
function StarknetRawTransactionDetailsFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "type": json["type"],
    "recipients": json["recipients"].map(EnrichedStarknetAddressFromJSON)
  };
}

// src/openapi/models/PredictedStarknetTransactionStarknetTransactionTypeDetails.ts
function PredictedStarknetTransactionStarknetTransactionTypeDetailsFromJSON(json) {
  return PredictedStarknetTransactionStarknetTransactionTypeDetailsFromJSONTyped(json, false);
}
function PredictedStarknetTransactionStarknetTransactionTypeDetailsFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  switch (json["type"]) {
    case "contract_deployment":
      return Object.assign({}, StarknetContractCreationDetailsFromJSONTyped(json, true), { type: "contract_deployment" });
    case "erc20_transfer":
      return Object.assign({}, StarknetErc20TransferDetailsFromJSONTyped(json, true), { type: "erc20_transfer" });
    case "native_transfer":
      return Object.assign({}, StarknetNativeTransferDetailsFromJSONTyped(json, true), { type: "native_transfer" });
    case "raw_transaction":
      return Object.assign({}, StarknetRawTransactionDetailsFromJSONTyped(json, true), { type: "raw_transaction" });
    default:
      throw new Error(`No variant of PredictedStarknetTransactionStarknetTransactionTypeDetails exists with 'type=${json["type"]}'`);
  }
}

// src/openapi/models/StarknetBlock.ts
function StarknetBlockFromJSON(json) {
  return StarknetBlockFromJSONTyped(json, false);
}
function StarknetBlockFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "number": json["number"],
    "hash": json["hash"],
    "minedAt": new Date(json["mined_at"])
  };
}

// src/openapi/models/StarknetBalanceChangeEffect.ts
function StarknetBalanceChangeEffectFromJSON(json) {
  return StarknetBalanceChangeEffectFromJSONTyped(json, false);
}
function StarknetBalanceChangeEffectFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "pricedAsset": PricedAssetFromJSON(json["priced_asset"]),
    "diff": json["diff"],
    "address": EnrichedStarknetAddressFromJSON(json["address"])
  };
}

// src/openapi/models/StarknetTransferEffect.ts
function StarknetTransferEffectFromJSON(json) {
  return StarknetTransferEffectFromJSONTyped(json, false);
}
function StarknetTransferEffectFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "pricedAsset": PricedAssetFromJSON(json["priced_asset"]),
    "amount": json["amount"],
    "from": EnrichedStarknetAddressFromJSON(json["from"]),
    "to": EnrichedStarknetAddressFromJSON(json["to"])
  };
}

// src/openapi/models/StarknetEffects.ts
function StarknetEffectsFromJSON(json) {
  return StarknetEffectsFromJSONTyped(json, false);
}
function StarknetEffectsFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "balanceChanges": json["balance_changes"].map(StarknetBalanceChangeEffectFromJSON),
    "transfers": json["transfers"].map(StarknetTransferEffectFromJSON)
  };
}

// src/openapi/models/StarknetReversionState.ts
function StarknetReversionStateFromJSON(json) {
  return StarknetReversionStateFromJSONTyped(json, false);
}
function StarknetReversionStateFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// src/openapi/models/StarknetReversion.ts
function StarknetReversionFromJSON(json) {
  return StarknetReversionFromJSONTyped(json, false);
}
function StarknetReversionFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "state": StarknetReversionStateFromJSON(json["state"]),
    "reason": json["reason"] == null ? void 0 : json["reason"]
  };
}

// src/openapi/models/StarknetFees.ts
function StarknetFeesFromJSON(json) {
  return StarknetFeesFromJSONTyped(json, false);
}
function StarknetFeesFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "feePayed": json["fee_payed"],
    "fiatPrice": json["fiat_price"] == null ? void 0 : PriceFromJSON(json["fiat_price"]),
    "pricedAsset": PricedAssetFromJSON(json["priced_asset"])
  };
}

// src/openapi/models/StarknetTransactionResult.ts
function StarknetTransactionResultFromJSON(json) {
  return StarknetTransactionResultFromJSONTyped(json, false);
}
function StarknetTransactionResultFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "reversion": StarknetReversionFromJSON(json["reversion"]),
    "fees": StarknetFeesFromJSON(json["fees"]),
    "effects": StarknetEffectsFromJSON(json["effects"])
  };
}

// src/openapi/models/StarknetCallData.ts
function StarknetCallDataFromJSON(json) {
  return StarknetCallDataFromJSONTyped(json, false);
}
function StarknetCallDataFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "to": EnrichedStarknetAddressFromJSON(json["to"]),
    "methodName": json["method_name"],
    "methodArguments": json["method_arguments"]
  };
}

// src/openapi/models/StarknetTransaction.ts
function StarknetTransactionFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "id": json["id"],
    "createdAt": new Date(json["created_at"]),
    "modifiedAt": new Date(json["modified_at"]),
    "managedTransactionData": json["managed_transaction_data"] == null ? void 0 : ManagedTransactionDataFromJSON(json["managed_transaction_data"]),
    "signatures": json["signatures"].map(SignatureFromJSON),
    "note": json["note"] == null ? void 0 : json["note"],
    "spamState": json["spam_state"] == null ? void 0 : TransactionSpamStateFromJSON(json["spam_state"]),
    "direction": TransactionDirectionFromJSON(json["direction"]),
    "signedExternally": json["signed_externally"] == null ? void 0 : json["signed_externally"],
    "state": PushableTransactionStateFromJSON(json["state"]),
    "stateChanges": json["state_changes"].map(PushableTransactionStateChangeFromJSON),
    "amlResults": json["aml_results"] == null ? void 0 : AmlResultsFromJSON(json["aml_results"]),
    "incomingAmlPolicyMatch": json["incoming_aml_policy_match"] == null ? void 0 : AmlPolicyMatchIncomingFromJSON(json["incoming_aml_policy_match"]),
    "type": json["type"],
    "starknetTransactionTypeDetails": PredictedStarknetTransactionStarknetTransactionTypeDetailsFromJSON(json["starknet_transaction_type_details"]),
    "callData": json["call_data"].map(StarknetCallDataFromJSON),
    "chain": EnrichedStarknetChainFromJSON(json["chain"]),
    "nonce": json["nonce"] == null ? void 0 : json["nonce"],
    "sender": EnrichedStarknetAddressFromJSON(json["sender"]),
    "hash": json["hash"] == null ? void 0 : json["hash"],
    "block": json["block"] == null ? void 0 : StarknetBlockFromJSON(json["block"]),
    "expectedResult": json["expected_result"] == null ? void 0 : StarknetTransactionResultFromJSON(json["expected_result"]),
    "simulationStatusResult": json["simulation_status_result"] == null ? void 0 : SimulationStatusResultFromJSON(json["simulation_status_result"]),
    "minedResult": json["mined_result"] == null ? void 0 : StarknetTransactionResultFromJSON(json["mined_result"]),
    "explorerUrl": json["explorer_url"] == null ? void 0 : json["explorer_url"],
    "l1GasMaxAmount": json["l1_gas_max_amount"] == null ? void 0 : json["l1_gas_max_amount"],
    "l1GasMaxPricePerUnit": json["l1_gas_max_price_per_unit"] == null ? void 0 : json["l1_gas_max_price_per_unit"]
  };
}

// src/openapi/models/SuiMessageType.ts
function SuiMessageTypeFromJSON(json) {
  return SuiMessageTypeFromJSONTyped(json, false);
}
function SuiMessageTypeFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// src/openapi/models/SuiMessage.ts
function SuiMessageFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "id": json["id"],
    "createdAt": new Date(json["created_at"]),
    "modifiedAt": new Date(json["modified_at"]),
    "managedTransactionData": json["managed_transaction_data"] == null ? void 0 : ManagedTransactionDataFromJSON(json["managed_transaction_data"]),
    "signatures": json["signatures"].map(SignatureFromJSON),
    "note": json["note"] == null ? void 0 : json["note"],
    "spamState": json["spam_state"] == null ? void 0 : TransactionSpamStateFromJSON(json["spam_state"]),
    "direction": TransactionDirectionFromJSON(json["direction"]),
    "signedExternally": json["signed_externally"] == null ? void 0 : json["signed_externally"],
    "state": NonPushableTransactionStateFromJSON(json["state"]),
    "stateChanges": json["state_changes"].map(NonPushableTransactionStateChangeFromJSON),
    "type": json["type"],
    "suiMessageType": SuiMessageTypeFromJSON(json["sui_message_type"]),
    "stringData": json["string_data"],
    "rawData": json["raw_data"],
    "chain": EnrichedSuiChainFromJSON(json["chain"]),
    "sender": EnrichedSuiAddressFromJSON(json["sender"])
  };
}

// src/openapi/models/SuiCoinTransferDetails.ts
function SuiCoinTransferDetailsFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "type": json["type"],
    "sender": EnrichedSuiAddressFromJSON(json["sender"]),
    "recipient": EnrichedSuiAddressFromJSON(json["recipient"]),
    "isInternal": json["is_internal"] == null ? void 0 : json["is_internal"]
  };
}

// src/openapi/models/SuiNativeTransferDetails.ts
function SuiNativeTransferDetailsFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "type": json["type"],
    "sender": EnrichedSuiAddressFromJSON(json["sender"]),
    "recipient": EnrichedSuiAddressFromJSON(json["recipient"]),
    "isInternal": json["is_internal"] == null ? void 0 : json["is_internal"]
  };
}

// src/openapi/models/SuiProgrammableTransactionBlockDetails.ts
function SuiProgrammableTransactionBlockDetailsFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "type": json["type"],
    "sender": EnrichedSuiAddressFromJSON(json["sender"]),
    "recipients": json["recipients"].map(EnrichedSuiAddressFromJSON)
  };
}

// src/openapi/models/PredictedSuiTransactionSuiTransactionTypeDetails.ts
function PredictedSuiTransactionSuiTransactionTypeDetailsFromJSON(json) {
  return PredictedSuiTransactionSuiTransactionTypeDetailsFromJSONTyped(json, false);
}
function PredictedSuiTransactionSuiTransactionTypeDetailsFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  switch (json["type"]) {
    case "coin_transfer":
      return Object.assign({}, SuiCoinTransferDetailsFromJSONTyped(json, true), { type: "coin_transfer" });
    case "native_transfer":
      return Object.assign({}, SuiNativeTransferDetailsFromJSONTyped(json, true), { type: "native_transfer" });
    case "programmable_transaction_block":
      return Object.assign({}, SuiProgrammableTransactionBlockDetailsFromJSONTyped(json, true), { type: "programmable_transaction_block" });
    default:
      throw new Error(`No variant of PredictedSuiTransactionSuiTransactionTypeDetails exists with 'type=${json["type"]}'`);
  }
}

// src/openapi/models/SuiCheckpointData.ts
function SuiCheckpointDataFromJSON(json) {
  return SuiCheckpointDataFromJSONTyped(json, false);
}
function SuiCheckpointDataFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "sequenceNumber": json["sequence_number"],
    "digest": json["digest"],
    "minedAt": new Date(json["mined_at"])
  };
}

// src/openapi/models/SuiBalanceChangeEffectType.ts
function SuiBalanceChangeEffectTypeFromJSON(json) {
  return SuiBalanceChangeEffectTypeFromJSONTyped(json, false);
}
function SuiBalanceChangeEffectTypeFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// src/openapi/models/SuiBalanceChangeEffect.ts
function SuiBalanceChangeEffectFromJSON(json) {
  return SuiBalanceChangeEffectFromJSONTyped(json, false);
}
function SuiBalanceChangeEffectFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "pricedAsset": PricedAssetFromJSON(json["priced_asset"]),
    "diff": json["diff"],
    "type": SuiBalanceChangeEffectTypeFromJSON(json["type"]),
    "owner": json["owner"] == null ? void 0 : EnrichedSuiAddressFromJSON(json["owner"]),
    "address": EnrichedSuiAddressFromJSON(json["address"])
  };
}

// src/openapi/models/SuiTransferEffectType.ts
function SuiTransferEffectTypeFromJSON(json) {
  return SuiTransferEffectTypeFromJSONTyped(json, false);
}
function SuiTransferEffectTypeFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// src/openapi/models/SuiTransferEffect.ts
function SuiTransferEffectFromJSON(json) {
  return SuiTransferEffectFromJSONTyped(json, false);
}
function SuiTransferEffectFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "pricedAsset": PricedAssetFromJSON(json["priced_asset"]),
    "amount": json["amount"],
    "type": SuiTransferEffectTypeFromJSON(json["type"]),
    "from": EnrichedSuiAddressFromJSON(json["from"]),
    "to": EnrichedSuiAddressFromJSON(json["to"])
  };
}

// src/openapi/models/SuiEffects.ts
function SuiEffectsFromJSON(json) {
  return SuiEffectsFromJSONTyped(json, false);
}
function SuiEffectsFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "balanceChanges": json["balance_changes"].map(SuiBalanceChangeEffectFromJSON),
    "transfers": json["transfers"].map(SuiTransferEffectFromJSON)
  };
}

// src/openapi/models/SuiGas.ts
function SuiGasFromJSON(json) {
  return SuiGasFromJSONTyped(json, false);
}
function SuiGasFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "totalGas": json["total_gas"],
    "fiatPrice": json["fiat_price"] == null ? void 0 : PriceFromJSON(json["fiat_price"]),
    "pricedAsset": PricedAssetFromJSON(json["priced_asset"])
  };
}

// src/openapi/models/SuiReversionState.ts
function SuiReversionStateFromJSON(json) {
  return SuiReversionStateFromJSONTyped(json, false);
}
function SuiReversionStateFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// src/openapi/models/SuiReversion.ts
function SuiReversionFromJSON(json) {
  return SuiReversionFromJSONTyped(json, false);
}
function SuiReversionFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "state": SuiReversionStateFromJSON(json["state"]),
    "reason": json["reason"] == null ? void 0 : json["reason"]
  };
}

// src/openapi/models/SuiTransactionResult.ts
function SuiTransactionResultFromJSON(json) {
  return SuiTransactionResultFromJSONTyped(json, false);
}
function SuiTransactionResultFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "reversion": SuiReversionFromJSON(json["reversion"]),
    "transactionError": json["transaction_error"] == null ? void 0 : json["transaction_error"],
    "enrichedGas": SuiGasFromJSON(json["enriched_gas"]),
    "effects": SuiEffectsFromJSON(json["effects"])
  };
}

// src/openapi/models/SuiMessageVersion.ts
function SuiMessageVersionFromJSON(json) {
  return SuiMessageVersionFromJSONTyped(json, false);
}
function SuiMessageVersionFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// src/openapi/models/SuiTransaction.ts
function SuiTransactionFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "id": json["id"],
    "createdAt": new Date(json["created_at"]),
    "modifiedAt": new Date(json["modified_at"]),
    "managedTransactionData": json["managed_transaction_data"] == null ? void 0 : ManagedTransactionDataFromJSON(json["managed_transaction_data"]),
    "signatures": json["signatures"].map(SignatureFromJSON),
    "note": json["note"] == null ? void 0 : json["note"],
    "spamState": json["spam_state"] == null ? void 0 : TransactionSpamStateFromJSON(json["spam_state"]),
    "direction": TransactionDirectionFromJSON(json["direction"]),
    "signedExternally": json["signed_externally"] == null ? void 0 : json["signed_externally"],
    "state": PushableTransactionStateFromJSON(json["state"]),
    "stateChanges": json["state_changes"].map(PushableTransactionStateChangeFromJSON),
    "amlResults": json["aml_results"] == null ? void 0 : AmlResultsFromJSON(json["aml_results"]),
    "incomingAmlPolicyMatch": json["incoming_aml_policy_match"] == null ? void 0 : AmlPolicyMatchIncomingFromJSON(json["incoming_aml_policy_match"]),
    "type": json["type"],
    "suiTransactionTypeDetails": PredictedSuiTransactionSuiTransactionTypeDetailsFromJSON(json["sui_transaction_type_details"]),
    "chain": EnrichedSuiChainFromJSON(json["chain"]),
    "version": SuiMessageVersionFromJSON(json["version"]),
    "inputs": json["inputs"].map(SuiInputFromJSON),
    "commands": json["commands"].map(SuiCommandFromJSON),
    "sender": EnrichedSuiAddressFromJSON(json["sender"]),
    "recipient": json["recipient"] == null ? void 0 : EnrichedSuiAddressFromJSON(json["recipient"]),
    "digest": json["digest"] == null ? void 0 : json["digest"],
    "txBytes": json["tx_bytes"] == null ? void 0 : json["tx_bytes"],
    "decodedTxBytes": json["decoded_tx_bytes"] == null ? void 0 : json["decoded_tx_bytes"],
    "checkpoint": json["checkpoint"] == null ? void 0 : SuiCheckpointDataFromJSON(json["checkpoint"]),
    "epoch": json["epoch"] == null ? void 0 : json["epoch"],
    "gasSubmitted": SuiGasConfigFromJSON(json["gas_submitted"]),
    "expectedResult": json["expected_result"] == null ? void 0 : SuiTransactionResultFromJSON(json["expected_result"]),
    "simulationStatusResult": SimulationStatusResultFromJSON(json["simulation_status_result"]),
    "minedResult": json["mined_result"] == null ? void 0 : SuiTransactionResultFromJSON(json["mined_result"]),
    "transactionBlockData": json["transaction_block_data"] == null ? void 0 : json["transaction_block_data"],
    "explorerUrl": json["explorer_url"] == null ? void 0 : json["explorer_url"]
  };
}

// src/openapi/models/TonMessageType.ts
function TonMessageTypeFromJSON(json) {
  return TonMessageTypeFromJSONTyped(json, false);
}
function TonMessageTypeFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// src/openapi/models/TonMessage.ts
function TonMessageFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "id": json["id"],
    "createdAt": new Date(json["created_at"]),
    "modifiedAt": new Date(json["modified_at"]),
    "managedTransactionData": json["managed_transaction_data"] == null ? void 0 : ManagedTransactionDataFromJSON(json["managed_transaction_data"]),
    "signatures": json["signatures"].map(SignatureFromJSON),
    "note": json["note"] == null ? void 0 : json["note"],
    "spamState": json["spam_state"] == null ? void 0 : TransactionSpamStateFromJSON(json["spam_state"]),
    "direction": TransactionDirectionFromJSON(json["direction"]),
    "signedExternally": json["signed_externally"] == null ? void 0 : json["signed_externally"],
    "state": NonPushableTransactionStateFromJSON(json["state"]),
    "stateChanges": json["state_changes"].map(NonPushableTransactionStateChangeFromJSON),
    "type": json["type"],
    "tonMessageType": TonMessageTypeFromJSON(json["ton_message_type"]),
    "rawPayloadToSign": json["raw_payload_to_sign"],
    "stringPayloadToSign": json["string_payload_to_sign"],
    "chain": EnrichedTonChainFromJSON(json["chain"]),
    "sender": EnrichedTonAddressFromJSON(json["sender"]),
    "domain": json["domain"],
    "domainBytesLength": json["domain_bytes_length"],
    "timestamp": json["timestamp"]
  };
}

// src/openapi/models/TonJettonTransferDetails.ts
function TonJettonTransferDetailsFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "type": json["type"],
    "sender": EnrichedTonAddressFromJSON(json["sender"]),
    "recipient": EnrichedTonAddressFromJSON(json["recipient"]),
    "isInternal": json["is_internal"] == null ? void 0 : json["is_internal"]
  };
}

// src/openapi/models/TonNativeTransferDetails.ts
function TonNativeTransferDetailsFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "type": json["type"],
    "sender": EnrichedTonAddressFromJSON(json["sender"]),
    "recipient": EnrichedTonAddressFromJSON(json["recipient"]),
    "isInternal": json["is_internal"] == null ? void 0 : json["is_internal"]
  };
}

// src/openapi/models/TonRawTransactionDetails.ts
function TonRawTransactionDetailsFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "type": json["type"],
    "recipients": json["recipients"].map(EnrichedTonAddressFromJSON)
  };
}

// src/openapi/models/PredictedTonTransactionTonTransactionTypeDetails.ts
function PredictedTonTransactionTonTransactionTypeDetailsFromJSON(json) {
  return PredictedTonTransactionTonTransactionTypeDetailsFromJSONTyped(json, false);
}
function PredictedTonTransactionTonTransactionTypeDetailsFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  switch (json["type"]) {
    case "jetton_transfer":
      return Object.assign({}, TonJettonTransferDetailsFromJSONTyped(json, true), { type: "jetton_transfer" });
    case "native_transfer":
      return Object.assign({}, TonNativeTransferDetailsFromJSONTyped(json, true), { type: "native_transfer" });
    case "raw_transaction":
      return Object.assign({}, TonRawTransactionDetailsFromJSONTyped(json, true), { type: "raw_transaction" });
    default:
      throw new Error(`No variant of PredictedTonTransactionTonTransactionTypeDetails exists with 'type=${json["type"]}'`);
  }
}

// src/openapi/models/TonBalanceChangeEffect.ts
function TonBalanceChangeEffectFromJSON(json) {
  return TonBalanceChangeEffectFromJSONTyped(json, false);
}
function TonBalanceChangeEffectFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "pricedAsset": PricedAssetFromJSON(json["priced_asset"]),
    "diff": json["diff"],
    "address": EnrichedTonAddressFromJSON(json["address"])
  };
}

// src/openapi/models/TonTransferEffect.ts
function TonTransferEffectFromJSON(json) {
  return TonTransferEffectFromJSONTyped(json, false);
}
function TonTransferEffectFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "pricedAsset": PricedAssetFromJSON(json["priced_asset"]),
    "amount": json["amount"],
    "from": EnrichedTonAddressFromJSON(json["from"]),
    "to": EnrichedTonAddressFromJSON(json["to"])
  };
}

// src/openapi/models/TonEffects.ts
function TonEffectsFromJSON(json) {
  return TonEffectsFromJSONTyped(json, false);
}
function TonEffectsFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "balanceChanges": json["balance_changes"].map(TonBalanceChangeEffectFromJSON),
    "transfers": json["transfers"].map(TonTransferEffectFromJSON)
  };
}

// src/openapi/models/TonReversionState.ts
function TonReversionStateFromJSON(json) {
  return TonReversionStateFromJSONTyped(json, false);
}
function TonReversionStateFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// src/openapi/models/TonReversion.ts
function TonReversionFromJSON(json) {
  return TonReversionFromJSONTyped(json, false);
}
function TonReversionFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "state": TonReversionStateFromJSON(json["state"]),
    "reason": json["reason"] == null ? void 0 : json["reason"]
  };
}

// src/openapi/models/TonAddressFee.ts
function TonAddressFeeFromJSON(json) {
  return TonAddressFeeFromJSONTyped(json, false);
}
function TonAddressFeeFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "address": EnrichedTonAddressFromJSON(json["address"]),
    "totalFee": json["total_fee"],
    "fiatPrice": json["fiat_price"] == null ? void 0 : PriceFromJSON(json["fiat_price"]),
    "pricedAsset": PricedAssetFromJSON(json["priced_asset"])
  };
}

// src/openapi/models/TonTransactionResult.ts
function TonTransactionResultFromJSON(json) {
  return TonTransactionResultFromJSONTyped(json, false);
}
function TonTransactionResultFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "reversion": TonReversionFromJSON(json["reversion"]),
    "addressFees": json["address_fees"].map(TonAddressFeeFromJSON),
    "effects": TonEffectsFromJSON(json["effects"])
  };
}

// src/openapi/models/TonBlock.ts
function TonBlockFromJSON(json) {
  return TonBlockFromJSONTyped(json, false);
}
function TonBlockFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "sequence": json["sequence"],
    "hash": json["hash"] == null ? void 0 : json["hash"],
    "minedAt": new Date(json["mined_at"])
  };
}

// src/openapi/models/TonTransaction.ts
function TonTransactionFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "id": json["id"],
    "createdAt": new Date(json["created_at"]),
    "modifiedAt": new Date(json["modified_at"]),
    "managedTransactionData": json["managed_transaction_data"] == null ? void 0 : ManagedTransactionDataFromJSON(json["managed_transaction_data"]),
    "signatures": json["signatures"].map(SignatureFromJSON),
    "note": json["note"] == null ? void 0 : json["note"],
    "spamState": json["spam_state"] == null ? void 0 : TransactionSpamStateFromJSON(json["spam_state"]),
    "direction": TransactionDirectionFromJSON(json["direction"]),
    "signedExternally": json["signed_externally"] == null ? void 0 : json["signed_externally"],
    "state": PushableTransactionStateFromJSON(json["state"]),
    "stateChanges": json["state_changes"].map(PushableTransactionStateChangeFromJSON),
    "amlResults": json["aml_results"] == null ? void 0 : AmlResultsFromJSON(json["aml_results"]),
    "incomingAmlPolicyMatch": json["incoming_aml_policy_match"] == null ? void 0 : AmlPolicyMatchIncomingFromJSON(json["incoming_aml_policy_match"]),
    "type": json["type"],
    "tonTransactionTypeDetails": PredictedTonTransactionTonTransactionTypeDetailsFromJSON(json["ton_transaction_type_details"]),
    "chain": EnrichedTonChainFromJSON(json["chain"]),
    "nonce": json["nonce"] == null ? void 0 : json["nonce"],
    "sender": EnrichedTonAddressFromJSON(json["sender"]),
    "payload": TonTransactionPayloadFromJSON(json["payload"]),
    "hash": json["hash"] == null ? void 0 : json["hash"],
    "block": json["block"] == null ? void 0 : TonBlockFromJSON(json["block"]),
    "serializedSignedTransaction": json["serialized_signed_transaction"] == null ? void 0 : json["serialized_signed_transaction"],
    "expectedResult": json["expected_result"] == null ? void 0 : TonTransactionResultFromJSON(json["expected_result"]),
    "simulationStatusResult": json["simulation_status_result"] == null ? void 0 : SimulationStatusResultFromJSON(json["simulation_status_result"]),
    "minedResult": json["mined_result"] == null ? void 0 : TonTransactionResultFromJSON(json["mined_result"]),
    "explorerUrl": json["explorer_url"] == null ? void 0 : json["explorer_url"]
  };
}

// src/openapi/models/TronBlock.ts
function TronBlockFromJSON(json) {
  return TronBlockFromJSONTyped(json, false);
}
function TronBlockFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "number": json["number"],
    "hash": json["hash"],
    "minedAt": new Date(json["mined_at"])
  };
}

// src/openapi/models/TronNativeTransferDetails.ts
function TronNativeTransferDetailsFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "type": json["type"],
    "sender": EnrichedTronAddressFromJSON(json["sender"]),
    "recipient": EnrichedTronAddressFromJSON(json["recipient"]),
    "isInternal": json["is_internal"] == null ? void 0 : json["is_internal"]
  };
}

// src/openapi/models/TronTokenTransferDetails.ts
function TronTokenTransferDetailsFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "type": json["type"],
    "sender": EnrichedTronAddressFromJSON(json["sender"]),
    "recipient": EnrichedTronAddressFromJSON(json["recipient"]),
    "isInternal": json["is_internal"] == null ? void 0 : json["is_internal"]
  };
}

// src/openapi/models/PredictedTronTransactionTronTransactionTypeDetails.ts
function PredictedTronTransactionTronTransactionTypeDetailsFromJSON(json) {
  return PredictedTronTransactionTronTransactionTypeDetailsFromJSONTyped(json, false);
}
function PredictedTronTransactionTronTransactionTypeDetailsFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  switch (json["type"]) {
    case "native_transfer":
      return Object.assign({}, TronNativeTransferDetailsFromJSONTyped(json, true), { type: "native_transfer" });
    case "token_transfer":
      return Object.assign({}, TronTokenTransferDetailsFromJSONTyped(json, true), { type: "token_transfer" });
    default:
      throw new Error(`No variant of PredictedTronTransactionTronTransactionTypeDetails exists with 'type=${json["type"]}'`);
  }
}

// src/openapi/models/TronTransferEffect.ts
function TronTransferEffectFromJSON(json) {
  return TronTransferEffectFromJSONTyped(json, false);
}
function TronTransferEffectFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "pricedAsset": PricedAssetFromJSON(json["priced_asset"]),
    "amount": json["amount"],
    "from": EnrichedTronAddressFromJSON(json["from"]),
    "to": EnrichedTronAddressFromJSON(json["to"])
  };
}

// src/openapi/models/TronBalanceChangeEffect.ts
function TronBalanceChangeEffectFromJSON(json) {
  return TronBalanceChangeEffectFromJSONTyped(json, false);
}
function TronBalanceChangeEffectFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "pricedAsset": PricedAssetFromJSON(json["priced_asset"]),
    "diff": json["diff"],
    "address": EnrichedTronAddressFromJSON(json["address"])
  };
}

// src/openapi/models/TronEffects.ts
function TronEffectsFromJSON(json) {
  return TronEffectsFromJSONTyped(json, false);
}
function TronEffectsFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "balanceChanges": json["balance_changes"].map(TronBalanceChangeEffectFromJSON),
    "transfers": json["transfers"].map(TronTransferEffectFromJSON)
  };
}

// src/openapi/models/TronReversionState.ts
function TronReversionStateFromJSON(json) {
  return TronReversionStateFromJSONTyped(json, false);
}
function TronReversionStateFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// src/openapi/models/TronReversion.ts
function TronReversionFromJSON(json) {
  return TronReversionFromJSONTyped(json, false);
}
function TronReversionFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "state": TronReversionStateFromJSON(json["state"]),
    "reason": json["reason"] == null ? void 0 : json["reason"]
  };
}

// src/openapi/models/TronFee.ts
function TronFeeFromJSON(json) {
  return TronFeeFromJSONTyped(json, false);
}
function TronFeeFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "trxFee": json["trx_fee"],
    "energyFee": json["energy_fee"],
    "bandwidthFee": json["bandwidth_fee"],
    "pricedAsset": PricedAssetFromJSON(json["priced_asset"])
  };
}

// src/openapi/models/TronTransactionResult.ts
function TronTransactionResultFromJSON(json) {
  return TronTransactionResultFromJSONTyped(json, false);
}
function TronTransactionResultFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "reversion": TronReversionFromJSON(json["reversion"]),
    "fee": TronFeeFromJSON(json["fee"]),
    "effects": TronEffectsFromJSON(json["effects"])
  };
}

// src/openapi/models/TronTransaction.ts
function TronTransactionFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "id": json["id"],
    "createdAt": new Date(json["created_at"]),
    "modifiedAt": new Date(json["modified_at"]),
    "managedTransactionData": json["managed_transaction_data"] == null ? void 0 : ManagedTransactionDataFromJSON(json["managed_transaction_data"]),
    "signatures": json["signatures"].map(SignatureFromJSON),
    "note": json["note"] == null ? void 0 : json["note"],
    "spamState": json["spam_state"] == null ? void 0 : TransactionSpamStateFromJSON(json["spam_state"]),
    "direction": TransactionDirectionFromJSON(json["direction"]),
    "signedExternally": json["signed_externally"] == null ? void 0 : json["signed_externally"],
    "state": PushableTransactionStateFromJSON(json["state"]),
    "stateChanges": json["state_changes"].map(PushableTransactionStateChangeFromJSON),
    "amlResults": json["aml_results"] == null ? void 0 : AmlResultsFromJSON(json["aml_results"]),
    "incomingAmlPolicyMatch": json["incoming_aml_policy_match"] == null ? void 0 : AmlPolicyMatchIncomingFromJSON(json["incoming_aml_policy_match"]),
    "type": json["type"],
    "tronTransactionTypeDetails": PredictedTronTransactionTronTransactionTypeDetailsFromJSON(json["tron_transaction_type_details"]),
    "chain": EnrichedTronChainFromJSON(json["chain"]),
    "sender": EnrichedTronAddressFromJSON(json["sender"]),
    "hash": json["hash"] == null ? void 0 : json["hash"],
    "serializedSignedTransaction": json["serialized_signed_transaction"] == null ? void 0 : json["serialized_signed_transaction"],
    "block": json["block"] == null ? void 0 : TronBlockFromJSON(json["block"]),
    "expectedResult": json["expected_result"] == null ? void 0 : TronTransactionResultFromJSON(json["expected_result"]),
    "simulationStatusResult": json["simulation_status_result"] == null ? void 0 : SimulationStatusResultFromJSON(json["simulation_status_result"]),
    "minedResult": json["mined_result"] == null ? void 0 : TronTransactionResultFromJSON(json["mined_result"]),
    "explorerUrl": json["explorer_url"] == null ? void 0 : json["explorer_url"],
    "memo": json["memo"] == null ? void 0 : json["memo"]
  };
}

// src/openapi/models/UtxoMessage.ts
function UtxoMessageFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "id": json["id"],
    "createdAt": new Date(json["created_at"]),
    "modifiedAt": new Date(json["modified_at"]),
    "managedTransactionData": json["managed_transaction_data"] == null ? void 0 : ManagedTransactionDataFromJSON(json["managed_transaction_data"]),
    "signatures": json["signatures"].map(SignatureFromJSON),
    "note": json["note"] == null ? void 0 : json["note"],
    "spamState": json["spam_state"] == null ? void 0 : TransactionSpamStateFromJSON(json["spam_state"]),
    "direction": TransactionDirectionFromJSON(json["direction"]),
    "signedExternally": json["signed_externally"] == null ? void 0 : json["signed_externally"],
    "state": NonPushableTransactionStateFromJSON(json["state"]),
    "stateChanges": json["state_changes"].map(NonPushableTransactionStateChangeFromJSON),
    "type": json["type"],
    "utxoMessageType": UtxoMessageTypeFromJSON(json["utxo_message_type"]),
    "rawData": json["raw_data"],
    "chain": EnrichedUtxoChainFromJSON(json["chain"]),
    "stringData": json["string_data"],
    "sender": EnrichedUtxoAddressFromJSON(json["sender"])
  };
}

// src/openapi/models/UtxoBalanceChangeEffect.ts
function UtxoBalanceChangeEffectFromJSON(json) {
  return UtxoBalanceChangeEffectFromJSONTyped(json, false);
}
function UtxoBalanceChangeEffectFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "type": json["type"],
    "vault": VaultRefFromJSON(json["vault"]),
    "diff": json["diff"],
    "pricedAsset": PricedAssetFromJSON(json["priced_asset"])
  };
}

// src/openapi/models/UtxoInput.ts
function UtxoInputFromJSON(json) {
  return UtxoInputFromJSONTyped(json, false);
}
function UtxoInputFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "address": EnrichedUtxoAddressFromJSON(json["address"]),
    "value": json["value"],
    "shouldSign": json["should_sign"] == null ? void 0 : json["should_sign"]
  };
}

// src/openapi/models/UtxoOutput.ts
function UtxoOutputFromJSON(json) {
  return UtxoOutputFromJSONTyped(json, false);
}
function UtxoOutputFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "address": EnrichedUtxoAddressFromJSON(json["address"]),
    "value": json["value"],
    "isChangeAddress": json["is_change_address"] == null ? void 0 : json["is_change_address"]
  };
}

// src/openapi/models/UtxoEffects.ts
function UtxoEffectsFromJSON(json) {
  return UtxoEffectsFromJSONTyped(json, false);
}
function UtxoEffectsFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "inputs": json["inputs"].map(UtxoInputFromJSON),
    "outputs": json["outputs"].map(UtxoOutputFromJSON),
    "balanceChanges": json["balance_changes"].map(UtxoBalanceChangeEffectFromJSON),
    "totalValue": json["total_value"],
    "price": json["price"] == null ? void 0 : PriceFromJSON(json["price"]),
    "pricedAsset": PricedAssetFromJSON(json["priced_asset"])
  };
}

// src/openapi/models/UtxoFees.ts
function UtxoFeesFromJSON(json) {
  return UtxoFeesFromJSONTyped(json, false);
}
function UtxoFeesFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "priority": FeePriorityLevelFromJSON(json["priority"]),
    "feePerByte": json["fee_per_byte"],
    "transactionByteSize": json["transaction_byte_size"],
    "totalFee": json["total_fee"],
    "fiatPrice": json["fiat_price"] == null ? void 0 : PriceFromJSON(json["fiat_price"]),
    "pricedAsset": PricedAssetFromJSON(json["priced_asset"])
  };
}

// src/openapi/models/UtxoTransactionResult.ts
function UtxoTransactionResultFromJSON(json) {
  return UtxoTransactionResultFromJSONTyped(json, false);
}
function UtxoTransactionResultFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "fees": json["fees"] == null ? void 0 : UtxoFeesFromJSON(json["fees"]),
    "effects": UtxoEffectsFromJSON(json["effects"])
  };
}

// src/openapi/models/UtxoNativeTransferDetails.ts
function UtxoNativeTransferDetailsFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "type": json["type"],
    "direction": TransferDirectionFromJSON(json["direction"]),
    "isInternal": json["is_internal"] == null ? void 0 : json["is_internal"],
    "vault": json["vault"] == null ? void 0 : VaultRefFromJSON(json["vault"]),
    "memos": json["memos"]
  };
}

// src/openapi/models/UtxoPsbtDetails.ts
function UtxoPsbtDetailsFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "type": json["type"],
    "psbtRawData": json["psbt_raw_data"],
    "signedPsbtRawData": json["signed_psbt_raw_data"] == null ? void 0 : json["signed_psbt_raw_data"],
    "sender": EnrichedUtxoAddressFromJSON(json["sender"]),
    "jsonRepresentation": json["json_representation"] == null ? void 0 : json["json_representation"]
  };
}

// src/openapi/models/PredictedUtxoTransactionUtxoTransactionTypeDetails.ts
function PredictedUtxoTransactionUtxoTransactionTypeDetailsFromJSON(json) {
  return PredictedUtxoTransactionUtxoTransactionTypeDetailsFromJSONTyped(json, false);
}
function PredictedUtxoTransactionUtxoTransactionTypeDetailsFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  switch (json["type"]) {
    case "native_transfer":
      return Object.assign({}, UtxoNativeTransferDetailsFromJSONTyped(json, true), { type: "native_transfer" });
    case "partially_signed_bitcoin_transaction":
      return Object.assign({}, UtxoPsbtDetailsFromJSONTyped(json, true), { type: "partially_signed_bitcoin_transaction" });
    default:
      throw new Error(`No variant of PredictedUtxoTransactionUtxoTransactionTypeDetails exists with 'type=${json["type"]}'`);
  }
}

// src/openapi/models/UtxoBlockData.ts
function UtxoBlockDataFromJSON(json) {
  return UtxoBlockDataFromJSONTyped(json, false);
}
function UtxoBlockDataFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "number": json["number"],
    "hash": json["hash"],
    "minedAt": new Date(json["mined_at"])
  };
}

// src/openapi/models/UtxoTransaction.ts
function UtxoTransactionFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "id": json["id"],
    "createdAt": new Date(json["created_at"]),
    "modifiedAt": new Date(json["modified_at"]),
    "managedTransactionData": json["managed_transaction_data"] == null ? void 0 : ManagedTransactionDataFromJSON(json["managed_transaction_data"]),
    "signatures": json["signatures"].map(SignatureFromJSON),
    "note": json["note"] == null ? void 0 : json["note"],
    "spamState": json["spam_state"] == null ? void 0 : TransactionSpamStateFromJSON(json["spam_state"]),
    "direction": TransactionDirectionFromJSON(json["direction"]),
    "signedExternally": json["signed_externally"] == null ? void 0 : json["signed_externally"],
    "state": PushableTransactionStateFromJSON(json["state"]),
    "stateChanges": json["state_changes"].map(PushableTransactionStateChangeFromJSON),
    "amlResults": json["aml_results"] == null ? void 0 : AmlResultsFromJSON(json["aml_results"]),
    "incomingAmlPolicyMatch": json["incoming_aml_policy_match"] == null ? void 0 : AmlPolicyMatchIncomingFromJSON(json["incoming_aml_policy_match"]),
    "type": json["type"],
    "utxoTransactionTypeDetails": PredictedUtxoTransactionUtxoTransactionTypeDetailsFromJSON(json["utxo_transaction_type_details"]),
    "chain": EnrichedUtxoChainFromJSON(json["chain"]),
    "hash": json["hash"] == null ? void 0 : json["hash"],
    "explorerUrl": json["explorer_url"] == null ? void 0 : json["explorer_url"],
    "block": json["block"] == null ? void 0 : UtxoBlockDataFromJSON(json["block"]),
    "expectedResult": json["expected_result"] == null ? void 0 : UtxoTransactionResultFromJSON(json["expected_result"]),
    "minedResult": json["mined_result"] == null ? void 0 : UtxoTransactionResultFromJSON(json["mined_result"])
  };
}

// src/openapi/models/CreateTransactionResponse.ts
function CreateTransactionResponseFromJSON(json) {
  return CreateTransactionResponseFromJSONTyped(json, false);
}
function CreateTransactionResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  switch (json["type"]) {
    case "aptos_message":
      return Object.assign({}, AptosMessageFromJSONTyped(json, true), { type: "aptos_message" });
    case "aptos_transaction":
      return Object.assign({}, AptosTransactionFromJSONTyped(json, true), { type: "aptos_transaction" });
    case "black_box_signature":
      return Object.assign({}, BlackBoxSignatureFromJSONTyped(json, true), { type: "black_box_signature" });
    case "cosmos_message":
      return Object.assign({}, CosmosMessageFromJSONTyped(json, true), { type: "cosmos_message" });
    case "cosmos_transaction":
      return Object.assign({}, CosmosTransactionFromJSONTyped(json, true), { type: "cosmos_transaction" });
    case "evm_message":
      return Object.assign({}, EvmMessageFromJSONTyped(json, true), { type: "evm_message" });
    case "evm_transaction":
      return Object.assign({}, EvmTransactionFromJSONTyped(json, true), { type: "evm_transaction" });
    case "exchange_transaction":
      return Object.assign({}, ExchangeTransactionFromJSONTyped(json, true), { type: "exchange_transaction" });
    case "solana_message":
      return Object.assign({}, SolanaMessageFromJSONTyped(json, true), { type: "solana_message" });
    case "solana_transaction":
      return Object.assign({}, SolanaTransactionFromJSONTyped(json, true), { type: "solana_transaction" });
    case "stacks_transaction":
      return Object.assign({}, StacksTransactionFromJSONTyped(json, true), { type: "stacks_transaction" });
    case "starknet_message":
      return Object.assign({}, StarknetMessageFromJSONTyped(json, true), { type: "starknet_message" });
    case "starknet_transaction":
      return Object.assign({}, StarknetTransactionFromJSONTyped(json, true), { type: "starknet_transaction" });
    case "sui_message":
      return Object.assign({}, SuiMessageFromJSONTyped(json, true), { type: "sui_message" });
    case "sui_transaction":
      return Object.assign({}, SuiTransactionFromJSONTyped(json, true), { type: "sui_transaction" });
    case "ton_message":
      return Object.assign({}, TonMessageFromJSONTyped(json, true), { type: "ton_message" });
    case "ton_transaction":
      return Object.assign({}, TonTransactionFromJSONTyped(json, true), { type: "ton_transaction" });
    case "tron_transaction":
      return Object.assign({}, TronTransactionFromJSONTyped(json, true), { type: "tron_transaction" });
    case "utxo_message":
      return Object.assign({}, UtxoMessageFromJSONTyped(json, true), { type: "utxo_message" });
    case "utxo_transaction":
      return Object.assign({}, UtxoTransactionFromJSONTyped(json, true), { type: "utxo_transaction" });
    default:
      throw new Error(`No variant of CreateTransactionResponse exists with 'type=${json["type"]}'`);
  }
}

// src/openapi/models/CreateTronTransactionWithWaitRequest.ts
function CreateTronTransactionWithWaitRequestToJSON(json) {
  return CreateTronTransactionWithWaitRequestToJSONTyped(json, false);
}
function CreateTronTransactionWithWaitRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "vault_id": value["vaultId"],
    "note": value["note"],
    "signer_type": SignerTypeToJSON(value["signerType"]),
    "sign_mode": SignModeToJSON(value["signMode"]),
    "dapp_info": DappInfoToJSON(value["dappInfo"]),
    "type": value["type"],
    "details": CreateTronTransactionRequestDetailsToJSON(value["details"]),
    "timeout": value["timeout"],
    "wait_for_state": PushableTransactionStateToJSON(value["waitForState"])
  };
}

// src/openapi/models/CreateUtxoMessageWithWaitRequest.ts
function CreateUtxoMessageWithWaitRequestToJSON(json) {
  return CreateUtxoMessageWithWaitRequestToJSONTyped(json, false);
}
function CreateUtxoMessageWithWaitRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "vault_id": value["vaultId"],
    "note": value["note"],
    "signer_type": SignerTypeToJSON(value["signerType"]),
    "sign_mode": SignModeToJSON(value["signMode"]),
    "dapp_info": DappInfoToJSON(value["dappInfo"]),
    "type": value["type"],
    "details": UtxoMessageDetailsToJSON(value["details"]),
    "timeout": value["timeout"],
    "wait_for_state": NonPushableTransactionStateToJSON(value["waitForState"])
  };
}

// src/openapi/models/CreateUtxoTransactionWithWaitRequest.ts
function CreateUtxoTransactionWithWaitRequestToJSON(json) {
  return CreateUtxoTransactionWithWaitRequestToJSONTyped(json, false);
}
function CreateUtxoTransactionWithWaitRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "vault_id": value["vaultId"],
    "note": value["note"],
    "signer_type": SignerTypeToJSON(value["signerType"]),
    "sign_mode": SignModeToJSON(value["signMode"]),
    "dapp_info": DappInfoToJSON(value["dappInfo"]),
    "type": value["type"],
    "details": CreateUtxoTransactionRequestDetailsToJSON(value["details"]),
    "timeout": value["timeout"],
    "wait_for_state": PushableTransactionStateToJSON(value["waitForState"])
  };
}

// src/openapi/models/CreateTransactionWithWaitRequest.ts
function CreateTransactionWithWaitRequestToJSON(json) {
  return CreateTransactionWithWaitRequestToJSONTyped(json, false);
}
function CreateTransactionWithWaitRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  switch (value["type"]) {
    case "aptos_message":
      return Object.assign({}, CreateAptosMessageWithWaitRequestToJSON(value), { type: "aptos_message" });
    case "aptos_transaction":
      return Object.assign({}, CreateAptosTransactionWithWaitRequestToJSON(value), { type: "aptos_transaction" });
    case "black_box_signature":
      return Object.assign({}, CreateBlackBoxSignatureWithWaitRequestToJSON(value), { type: "black_box_signature" });
    case "cosmos_message":
      return Object.assign({}, CreateCosmosMessageWithWaitRequestToJSON(value), { type: "cosmos_message" });
    case "cosmos_transaction":
      return Object.assign({}, CreateCosmosTransactionWithWaitRequestToJSON(value), { type: "cosmos_transaction" });
    case "evm_message":
      return Object.assign({}, CreateEvmMessageWithWaitRequestToJSON(value), { type: "evm_message" });
    case "evm_transaction":
      return Object.assign({}, CreateEvmTransactionWithWaitRequestToJSON(value), { type: "evm_transaction" });
    case "solana_message":
      return Object.assign({}, CreateSolanaMessageWithWaitRequestToJSON(value), { type: "solana_message" });
    case "solana_transaction":
      return Object.assign({}, CreateSolanaTransactionWithWaitRequestToJSON(value), { type: "solana_transaction" });
    case "stacks_transaction":
      return Object.assign({}, CreateStacksTransactionWithWaitRequestToJSON(value), { type: "stacks_transaction" });
    case "starknet_message":
      return Object.assign({}, CreateStarknetMessageWithWaitRequestToJSON(value), { type: "starknet_message" });
    case "starknet_transaction":
      return Object.assign({}, CreateStarknetTransactionWithWaitRequestToJSON(value), { type: "starknet_transaction" });
    case "sui_message":
      return Object.assign({}, CreateSuiMessageWithWaitRequestToJSON(value), { type: "sui_message" });
    case "sui_transaction":
      return Object.assign({}, CreateSuiTransactionWithWaitRequestToJSON(value), { type: "sui_transaction" });
    case "ton_message":
      return Object.assign({}, CreateTonMessageWithWaitRequestToJSON(value), { type: "ton_message" });
    case "ton_transaction":
      return Object.assign({}, CreateTonTransactionWithWaitRequestToJSON(value), { type: "ton_transaction" });
    case "tron_transaction":
      return Object.assign({}, CreateTronTransactionWithWaitRequestToJSON(value), { type: "tron_transaction" });
    case "utxo_message":
      return Object.assign({}, CreateUtxoMessageWithWaitRequestToJSON(value), { type: "utxo_message" });
    case "utxo_transaction":
      return Object.assign({}, CreateUtxoTransactionWithWaitRequestToJSON(value), { type: "utxo_transaction" });
    default:
      throw new Error(`No variant of CreateTransactionWithWaitRequest exists with 'type=${value["type"]}'`);
  }
}

// src/openapi/models/CreateTransactionWithWaitResponseState.ts
function CreateTransactionWithWaitResponseStateFromJSON(json) {
  return CreateTransactionWithWaitResponseStateFromJSONTyped(json, false);
}
function CreateTransactionWithWaitResponseStateFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// src/openapi/models/CreateTransactionWithWaitResponse.ts
function CreateTransactionWithWaitResponseFromJSON(json) {
  return CreateTransactionWithWaitResponseFromJSONTyped(json, false);
}
function CreateTransactionWithWaitResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "id": json["id"],
    "createdAt": new Date(json["created_at"]),
    "modifiedAt": new Date(json["modified_at"]),
    "signatures": json["signatures"],
    "state": CreateTransactionWithWaitResponseStateFromJSON(json["state"]),
    "hasTimedOut": json["has_timed_out"]
  };
}

// src/openapi/models/CreateTronVaultRequest.ts
function CreateTronVaultRequestToJSON(json) {
  return CreateTronVaultRequestToJSONTyped(json, false);
}
function CreateTronVaultRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "name": value["name"],
    "keyset_id": value["keysetId"],
    "end_user_id": value["endUserId"],
    "vault_group_id": value["vaultGroupId"],
    "type": value["type"]
  };
}

// src/openapi/models/ImportVaultUtxoOptions.ts
function ImportVaultUtxoOptionsToJSON(json) {
  return ImportVaultUtxoOptionsToJSONTyped(json, false);
}
function ImportVaultUtxoOptionsToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "default_address_derivation_path": value["defaultAddressDerivationPath"],
    "default_address_name": value["defaultAddressName"],
    "key_id": value["keyId"]
  };
}

// src/openapi/models/CreateUtxoVaultRequest.ts
function CreateUtxoVaultRequestToJSON(json) {
  return CreateUtxoVaultRequestToJSONTyped(json, false);
}
function CreateUtxoVaultRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "name": value["name"],
    "keyset_id": value["keysetId"],
    "end_user_id": value["endUserId"],
    "vault_group_id": value["vaultGroupId"],
    "type": value["type"],
    "chain": UtxoChainUniqueIdToJSON(value["chain"]),
    "import_vault": ImportVaultUtxoOptionsToJSON(value["importVault"])
  };
}

// src/openapi/models/CreateVaultRequest.ts
function CreateVaultRequestToJSON(json) {
  return CreateVaultRequestToJSONTyped(json, false);
}
function CreateVaultRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  switch (value["type"]) {
    case "aptos":
      return Object.assign({}, CreateAptosVaultRequestToJSON(value), { type: "aptos" });
    case "black_box":
      return Object.assign({}, CreateBlackBoxVaultRequestToJSON(value), { type: "black_box" });
    case "cosmos":
      return Object.assign({}, CreateCosmosVaultRequestToJSON(value), { type: "cosmos" });
    case "evm":
      return Object.assign({}, CreateEvmVaultRequestToJSON(value), { type: "evm" });
    case "solana":
      return Object.assign({}, CreateSolanaVaultRequestToJSON(value), { type: "solana" });
    case "stacks":
      return Object.assign({}, CreateStacksVaultRequestToJSON(value), { type: "stacks" });
    case "starknet":
      return Object.assign({}, CreateStarknetVaultRequestToJSON(value), { type: "starknet" });
    case "sui":
      return Object.assign({}, CreateSuiVaultRequestToJSON(value), { type: "sui" });
    case "ton":
      return Object.assign({}, CreateTonVaultRequestToJSON(value), { type: "ton" });
    case "tron":
      return Object.assign({}, CreateTronVaultRequestToJSON(value), { type: "tron" });
    case "utxo":
      return Object.assign({}, CreateUtxoVaultRequestToJSON(value), { type: "utxo" });
    default:
      throw new Error(`No variant of CreateVaultRequest exists with 'type=${value["type"]}'`);
  }
}

// src/openapi/models/CreateVaultResponse.ts
function CreateVaultResponseFromJSON(json) {
  return CreateVaultResponseFromJSONTyped(json, false);
}
function CreateVaultResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  switch (json["type"]) {
    case "aptos":
      return Object.assign({}, AptosVaultFromJSONTyped(json, true), { type: "aptos" });
    case "black_box":
      return Object.assign({}, BlackBoxVaultFromJSONTyped(json, true), { type: "black_box" });
    case "cosmos":
      return Object.assign({}, CosmosVaultFromJSONTyped(json, true), { type: "cosmos" });
    case "evm":
      return Object.assign({}, EvmVaultFromJSONTyped(json, true), { type: "evm" });
    case "exchange":
      return Object.assign({}, ExchangeVaultFromJSONTyped(json, true), { type: "exchange" });
    case "solana":
      return Object.assign({}, SolanaVaultFromJSONTyped(json, true), { type: "solana" });
    case "stacks":
      return Object.assign({}, StacksVaultFromJSONTyped(json, true), { type: "stacks" });
    case "starknet":
      return Object.assign({}, StarknetVaultFromJSONTyped(json, true), { type: "starknet" });
    case "sui":
      return Object.assign({}, SuiVaultFromJSONTyped(json, true), { type: "sui" });
    case "ton":
      return Object.assign({}, TonVaultFromJSONTyped(json, true), { type: "ton" });
    case "tron":
      return Object.assign({}, TronVaultFromJSONTyped(json, true), { type: "tron" });
    case "utxo":
      return Object.assign({}, UtxoVaultFromJSONTyped(json, true), { type: "utxo" });
    default:
      throw new Error(`No variant of CreateVaultResponse exists with 'type=${json["type"]}'`);
  }
}

// src/openapi/models/DynamicGasFields.ts
function DynamicGasFieldsFromJSON(json) {
  return DynamicGasFieldsFromJSONTyped(json, false);
}
function DynamicGasFieldsFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "maxPriorityFeePerGas": json["max_priority_fee_per_gas"],
    "maxFeePerGas": json["max_fee_per_gas"]
  };
}

// src/openapi/models/ErroneousItem.ts
function ErroneousItemFromJSON(json) {
  return ErroneousItemFromJSONTyped(json, false);
}
function ErroneousItemFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "id": json["id"]
  };
}

// src/openapi/models/EvmDynamicSuggestedFees.ts
function EvmDynamicSuggestedFeesFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "type": json["type"],
    "low": DynamicGasFieldsFromJSON(json["low"]),
    "medium": DynamicGasFieldsFromJSON(json["medium"]),
    "high": DynamicGasFieldsFromJSON(json["high"])
  };
}

// src/openapi/models/EvmGasEstimation.ts
function EvmGasEstimationFromJSON(json) {
  return EvmGasEstimationFromJSONTyped(json, false);
}
function EvmGasEstimationFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "gasLimit": json["gas_limit"],
    "fiatPrice": json["fiat_price"] == null ? void 0 : PriceFromJSON(json["fiat_price"])
  };
}

// src/openapi/models/LegacyGasFields.ts
function LegacyGasFieldsFromJSON(json) {
  return LegacyGasFieldsFromJSONTyped(json, false);
}
function LegacyGasFieldsFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "price": json["price"]
  };
}

// src/openapi/models/EvmLegacySuggestedFees.ts
function EvmLegacySuggestedFeesFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "type": json["type"],
    "low": LegacyGasFieldsFromJSON(json["low"]),
    "medium": LegacyGasFieldsFromJSON(json["medium"]),
    "high": LegacyGasFieldsFromJSON(json["high"])
  };
}

// src/openapi/models/EvmSuggestedFeesFees.ts
function EvmSuggestedFeesFeesFromJSON(json) {
  return EvmSuggestedFeesFeesFromJSONTyped(json, false);
}
function EvmSuggestedFeesFeesFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  switch (json["type"]) {
    case "dynamic":
      return Object.assign({}, EvmDynamicSuggestedFeesFromJSONTyped(json, true), { type: "dynamic" });
    case "legacy":
      return Object.assign({}, EvmLegacySuggestedFeesFromJSONTyped(json, true), { type: "legacy" });
    default:
      throw new Error(`No variant of EvmSuggestedFeesFees exists with 'type=${json["type"]}'`);
  }
}

// src/openapi/models/EvmSuggestedFees.ts
function EvmSuggestedFeesFromJSON(json) {
  return EvmSuggestedFeesFromJSONTyped(json, false);
}
function EvmSuggestedFeesFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "type": json["type"],
    "fees": EvmSuggestedFeesFeesFromJSON(json["fees"]),
    "chainUniqueId": json["chain_unique_id"]
  };
}

// src/openapi/models/ExportType.ts
function ExportTypeFromJSON(json) {
  return ExportTypeFromJSONTyped(json, false);
}
function ExportTypeFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// src/openapi/models/ExportState.ts
function ExportStateFromJSON(json) {
  return ExportStateFromJSONTyped(json, false);
}
function ExportStateFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// src/openapi/models/ExportedResource.ts
function ExportedResourceFromJSON(json) {
  return ExportedResourceFromJSONTyped(json, false);
}
function ExportedResourceFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// src/openapi/models/Export.ts
function ExportFromJSON(json) {
  return ExportFromJSONTyped(json, false);
}
function ExportFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "id": json["id"],
    "creationTime": new Date(json["creation_time"]),
    "type": ExportTypeFromJSON(json["type"]),
    "state": ExportStateFromJSON(json["state"]),
    "organizationId": json["organization_id"],
    "userId": json["user_id"],
    "resourceType": ExportedResourceFromJSON(json["resource_type"]),
    "successfulItemsCount": json["successful_items_count"],
    "failedItemsCount": json["failed_items_count"],
    "totalItemsCount": json["total_items_count"],
    "requestId": json["request_id"],
    "downloadUrl": json["download_url"],
    "expirationTime": new Date(json["expiration_time"])
  };
}

// src/openapi/models/FailedPurge.ts
function FailedPurgeFromJSON(json) {
  return FailedPurgeFromJSONTyped(json, false);
}
function FailedPurgeFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "vaultId": json["vault_id"],
    "error": json["error"]
  };
}

// src/openapi/models/PartialErrorResponseRequestId.ts
function PartialErrorResponseRequestIdFromJSON(json) {
  return PartialErrorResponseRequestIdFromJSONTyped(json, false);
}
function PartialErrorResponseRequestIdFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// src/openapi/models/PartialErrorResponse.ts
function PartialErrorResponseFromJSON(json) {
  return PartialErrorResponseFromJSONTyped(json, false);
}
function PartialErrorResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "errors": json["errors"].map(ErroneousItemFromJSON),
    "requestId": json["request_id"] == null ? void 0 : PartialErrorResponseRequestIdFromJSON(json["request_id"])
  };
}

// src/openapi/models/GetRpcEndpointsResponse.ts
function GetRpcEndpointsResponseFromJSON(json) {
  return GetRpcEndpointsResponseFromJSONTyped(json, false);
}
function GetRpcEndpointsResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "endpointsByChain": json["endpoints_by_chain"]
  };
}

// src/openapi/models/StarknetSuggestedFees.ts
function StarknetSuggestedFeesFromJSON(json) {
  return StarknetSuggestedFeesFromJSONTyped(json, false);
}
function StarknetSuggestedFeesFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "type": json["type"],
    "chainUniqueId": StarknetChainUniqueIdFromJSON(json["chain_unique_id"]),
    "gasPrice": json["gas_price"]
  };
}

// src/openapi/models/SuiSuggestedFees.ts
function SuiSuggestedFeesFromJSON(json) {
  return SuiSuggestedFeesFromJSONTyped(json, false);
}
function SuiSuggestedFeesFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "type": json["type"],
    "chainUniqueId": SuiChainUniqueIdFromJSON(json["chain_unique_id"])
  };
}

// src/openapi/models/TonSuggestedFees.ts
function TonSuggestedFeesFromJSON(json) {
  return TonSuggestedFeesFromJSONTyped(json, false);
}
function TonSuggestedFeesFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "type": json["type"],
    "chainUniqueId": TonChainUniqueIdFromJSON(json["chain_unique_id"]),
    "gasPrice": json["gas_price"]
  };
}

// src/openapi/models/UtxoSuggestedFees.ts
function UtxoSuggestedFeesFromJSON(json) {
  return UtxoSuggestedFeesFromJSONTyped(json, false);
}
function UtxoSuggestedFeesFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "type": json["type"],
    "low": json["low"],
    "medium": json["medium"],
    "high": json["high"],
    "chainUniqueId": UtxoChainUniqueIdFromJSON(json["chain_unique_id"])
  };
}

// src/openapi/models/SuggestedFees.ts
function SuggestedFeesFromJSON(json) {
  return SuggestedFeesFromJSONTyped(json, false);
}
function SuggestedFeesFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  switch (json["type"]) {
    case "aptos":
      return Object.assign({}, AptosSuggestedFeesFromJSONTyped(json, true), { type: "aptos" });
    case "cosmos":
      return Object.assign({}, CosmosSuggestedFeesFromJSONTyped(json, true), { type: "cosmos" });
    case "evm":
      return Object.assign({}, EvmSuggestedFeesFromJSONTyped(json, true), { type: "evm" });
    case "starknet":
      return Object.assign({}, StarknetSuggestedFeesFromJSONTyped(json, true), { type: "starknet" });
    case "sui":
      return Object.assign({}, SuiSuggestedFeesFromJSONTyped(json, true), { type: "sui" });
    case "ton":
      return Object.assign({}, TonSuggestedFeesFromJSONTyped(json, true), { type: "ton" });
    case "utxo":
      return Object.assign({}, UtxoSuggestedFeesFromJSONTyped(json, true), { type: "utxo" });
    default:
      throw new Error(`No variant of SuggestedFees exists with 'type=${json["type"]}'`);
  }
}

// src/openapi/models/GetSuggestedFeesResponse.ts
function GetSuggestedFeesResponseFromJSON(json) {
  return GetSuggestedFeesResponseFromJSONTyped(json, false);
}
function GetSuggestedFeesResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "suggestedFees": mapValues(json["suggested_fees"], SuggestedFeesFromJSON)
  };
}

// src/openapi/models/GetTransactionResponse.ts
function GetTransactionResponseFromJSON(json) {
  return GetTransactionResponseFromJSONTyped(json, false);
}
function GetTransactionResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  switch (json["type"]) {
    case "aptos_message":
      return Object.assign({}, AptosMessageFromJSONTyped(json, true), { type: "aptos_message" });
    case "aptos_transaction":
      return Object.assign({}, AptosTransactionFromJSONTyped(json, true), { type: "aptos_transaction" });
    case "black_box_signature":
      return Object.assign({}, BlackBoxSignatureFromJSONTyped(json, true), { type: "black_box_signature" });
    case "cosmos_message":
      return Object.assign({}, CosmosMessageFromJSONTyped(json, true), { type: "cosmos_message" });
    case "cosmos_transaction":
      return Object.assign({}, CosmosTransactionFromJSONTyped(json, true), { type: "cosmos_transaction" });
    case "evm_message":
      return Object.assign({}, EvmMessageFromJSONTyped(json, true), { type: "evm_message" });
    case "evm_transaction":
      return Object.assign({}, EvmTransactionFromJSONTyped(json, true), { type: "evm_transaction" });
    case "exchange_transaction":
      return Object.assign({}, ExchangeTransactionFromJSONTyped(json, true), { type: "exchange_transaction" });
    case "solana_message":
      return Object.assign({}, SolanaMessageFromJSONTyped(json, true), { type: "solana_message" });
    case "solana_transaction":
      return Object.assign({}, SolanaTransactionFromJSONTyped(json, true), { type: "solana_transaction" });
    case "stacks_transaction":
      return Object.assign({}, StacksTransactionFromJSONTyped(json, true), { type: "stacks_transaction" });
    case "starknet_message":
      return Object.assign({}, StarknetMessageFromJSONTyped(json, true), { type: "starknet_message" });
    case "starknet_transaction":
      return Object.assign({}, StarknetTransactionFromJSONTyped(json, true), { type: "starknet_transaction" });
    case "sui_message":
      return Object.assign({}, SuiMessageFromJSONTyped(json, true), { type: "sui_message" });
    case "sui_transaction":
      return Object.assign({}, SuiTransactionFromJSONTyped(json, true), { type: "sui_transaction" });
    case "ton_message":
      return Object.assign({}, TonMessageFromJSONTyped(json, true), { type: "ton_message" });
    case "ton_transaction":
      return Object.assign({}, TonTransactionFromJSONTyped(json, true), { type: "ton_transaction" });
    case "tron_transaction":
      return Object.assign({}, TronTransactionFromJSONTyped(json, true), { type: "tron_transaction" });
    case "utxo_message":
      return Object.assign({}, UtxoMessageFromJSONTyped(json, true), { type: "utxo_message" });
    case "utxo_transaction":
      return Object.assign({}, UtxoTransactionFromJSONTyped(json, true), { type: "utxo_transaction" });
    default:
      throw new Error(`No variant of GetTransactionResponse exists with 'type=${json["type"]}'`);
  }
}

// src/openapi/models/GetVaultResponse.ts
function GetVaultResponseFromJSON(json) {
  return GetVaultResponseFromJSONTyped(json, false);
}
function GetVaultResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  switch (json["type"]) {
    case "aptos":
      return Object.assign({}, AptosVaultFromJSONTyped(json, true), { type: "aptos" });
    case "black_box":
      return Object.assign({}, BlackBoxVaultFromJSONTyped(json, true), { type: "black_box" });
    case "cosmos":
      return Object.assign({}, CosmosVaultFromJSONTyped(json, true), { type: "cosmos" });
    case "evm":
      return Object.assign({}, EvmVaultFromJSONTyped(json, true), { type: "evm" });
    case "exchange":
      return Object.assign({}, ExchangeVaultFromJSONTyped(json, true), { type: "exchange" });
    case "solana":
      return Object.assign({}, SolanaVaultFromJSONTyped(json, true), { type: "solana" });
    case "stacks":
      return Object.assign({}, StacksVaultFromJSONTyped(json, true), { type: "stacks" });
    case "starknet":
      return Object.assign({}, StarknetVaultFromJSONTyped(json, true), { type: "starknet" });
    case "sui":
      return Object.assign({}, SuiVaultFromJSONTyped(json, true), { type: "sui" });
    case "ton":
      return Object.assign({}, TonVaultFromJSONTyped(json, true), { type: "ton" });
    case "tron":
      return Object.assign({}, TronVaultFromJSONTyped(json, true), { type: "tron" });
    case "utxo":
      return Object.assign({}, UtxoVaultFromJSONTyped(json, true), { type: "utxo" });
    default:
      throw new Error(`No variant of GetVaultResponse exists with 'type=${json["type"]}'`);
  }
}

// src/openapi/models/KeyDerivationArgs.ts
function KeyDerivationArgsFromJSON(json) {
  return KeyDerivationArgsFromJSONTyped(json, false);
}
function KeyDerivationArgsFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "keyType": KeyTypeFromJSON(json["key_type"]),
    "coinType": json["coin_type"] == null ? void 0 : json["coin_type"],
    "accountId": json["account_id"] == null ? void 0 : json["account_id"],
    "addressIndex": json["address_index"] == null ? void 0 : json["address_index"],
    "derivationPath": json["derivation_path"],
    "keyId": json["key_id"],
    "keysetId": json["keyset_id"],
    "adjustScalar": json["adjust_scalar"] == null ? void 0 : json["adjust_scalar"]
  };
}

// src/openapi/models/ListBlockchainsResponse.ts
function ListBlockchainsResponseFromJSON(json) {
  return ListBlockchainsResponseFromJSONTyped(json, false);
}
function ListBlockchainsResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "partialError": json["partial_error"] == null ? void 0 : PartialErrorResponseFromJSON(json["partial_error"]),
    "total": json["total"],
    "page": json["page"],
    "size": json["size"],
    "chains": json["chains"].map(EnrichedChainFromJSON)
  };
}

// src/openapi/models/ListDappsResponse.ts
function ListDappsResponseFromJSON(json) {
  return ListDappsResponseFromJSONTyped(json, false);
}
function ListDappsResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "partialError": json["partial_error"] == null ? void 0 : PartialErrorResponseFromJSON(json["partial_error"]),
    "total": json["total"],
    "page": json["page"],
    "size": json["size"],
    "dapps": json["dapps"].map(EnrichedDappFromJSON)
  };
}

// src/openapi/models/ListEIP712Domains.ts
function ListEIP712DomainsFromJSON(json) {
  return ListEIP712DomainsFromJSONTyped(json, false);
}
function ListEIP712DomainsFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "partialError": json["partial_error"] == null ? void 0 : PartialErrorResponseFromJSON(json["partial_error"]),
    "total": json["total"],
    "page": json["page"],
    "size": json["size"],
    "domains": json["domains"]
  };
}

// src/openapi/models/ListEIP712PrimaryTypes.ts
function ListEIP712PrimaryTypesFromJSON(json) {
  return ListEIP712PrimaryTypesFromJSONTyped(json, false);
}
function ListEIP712PrimaryTypesFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "partialError": json["partial_error"] == null ? void 0 : PartialErrorResponseFromJSON(json["partial_error"]),
    "total": json["total"],
    "page": json["page"],
    "size": json["size"],
    "primaryTypes": json["primary_types"]
  };
}

// src/openapi/models/ListOwnedAssetsResponse.ts
function ListOwnedAssetsResponseFromJSON(json) {
  return ListOwnedAssetsResponseFromJSONTyped(json, false);
}
function ListOwnedAssetsResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "partialError": json["partial_error"] == null ? void 0 : PartialErrorResponseFromJSON(json["partial_error"]),
    "total": json["total"],
    "page": json["page"],
    "size": json["size"],
    "ownedAssets": json["owned_assets"].map(OwnedAssetFromJSON)
  };
}

// src/openapi/models/Transaction.ts
function TransactionFromJSON(json) {
  return TransactionFromJSONTyped(json, false);
}
function TransactionFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  switch (json["type"]) {
    case "aptos_message":
      return Object.assign({}, AptosMessageFromJSONTyped(json, true), { type: "aptos_message" });
    case "aptos_transaction":
      return Object.assign({}, AptosTransactionFromJSONTyped(json, true), { type: "aptos_transaction" });
    case "black_box_signature":
      return Object.assign({}, BlackBoxSignatureFromJSONTyped(json, true), { type: "black_box_signature" });
    case "cosmos_message":
      return Object.assign({}, CosmosMessageFromJSONTyped(json, true), { type: "cosmos_message" });
    case "cosmos_transaction":
      return Object.assign({}, CosmosTransactionFromJSONTyped(json, true), { type: "cosmos_transaction" });
    case "evm_message":
      return Object.assign({}, EvmMessageFromJSONTyped(json, true), { type: "evm_message" });
    case "evm_transaction":
      return Object.assign({}, EvmTransactionFromJSONTyped(json, true), { type: "evm_transaction" });
    case "exchange_transaction":
      return Object.assign({}, ExchangeTransactionFromJSONTyped(json, true), { type: "exchange_transaction" });
    case "solana_message":
      return Object.assign({}, SolanaMessageFromJSONTyped(json, true), { type: "solana_message" });
    case "solana_transaction":
      return Object.assign({}, SolanaTransactionFromJSONTyped(json, true), { type: "solana_transaction" });
    case "stacks_transaction":
      return Object.assign({}, StacksTransactionFromJSONTyped(json, true), { type: "stacks_transaction" });
    case "starknet_message":
      return Object.assign({}, StarknetMessageFromJSONTyped(json, true), { type: "starknet_message" });
    case "starknet_transaction":
      return Object.assign({}, StarknetTransactionFromJSONTyped(json, true), { type: "starknet_transaction" });
    case "sui_message":
      return Object.assign({}, SuiMessageFromJSONTyped(json, true), { type: "sui_message" });
    case "sui_transaction":
      return Object.assign({}, SuiTransactionFromJSONTyped(json, true), { type: "sui_transaction" });
    case "ton_message":
      return Object.assign({}, TonMessageFromJSONTyped(json, true), { type: "ton_message" });
    case "ton_transaction":
      return Object.assign({}, TonTransactionFromJSONTyped(json, true), { type: "ton_transaction" });
    case "tron_transaction":
      return Object.assign({}, TronTransactionFromJSONTyped(json, true), { type: "tron_transaction" });
    case "utxo_message":
      return Object.assign({}, UtxoMessageFromJSONTyped(json, true), { type: "utxo_message" });
    case "utxo_transaction":
      return Object.assign({}, UtxoTransactionFromJSONTyped(json, true), { type: "utxo_transaction" });
    default:
      throw new Error(`No variant of Transaction exists with 'type=${json["type"]}'`);
  }
}

// src/openapi/models/ListTransactionResponse.ts
function ListTransactionResponseFromJSON(json) {
  return ListTransactionResponseFromJSONTyped(json, false);
}
function ListTransactionResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "partialError": json["partial_error"] == null ? void 0 : PartialErrorResponseFromJSON(json["partial_error"]),
    "total": json["total"],
    "page": json["page"],
    "size": json["size"],
    "transactions": json["transactions"].map(TransactionFromJSON)
  };
}

// src/openapi/models/ListVaultAddressesResponse.ts
function ListVaultAddressesResponseFromJSON(json) {
  return ListVaultAddressesResponseFromJSONTyped(json, false);
}
function ListVaultAddressesResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "partialError": json["partial_error"] == null ? void 0 : PartialErrorResponseFromJSON(json["partial_error"]),
    "total": json["total"],
    "page": json["page"],
    "size": json["size"],
    "addresses": json["addresses"].map(UtxoVaultAddressFromJSON)
  };
}

// src/openapi/models/Vault.ts
function VaultFromJSON(json) {
  return VaultFromJSONTyped(json, false);
}
function VaultFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  switch (json["type"]) {
    case "aptos":
      return Object.assign({}, AptosVaultFromJSONTyped(json, true), { type: "aptos" });
    case "black_box":
      return Object.assign({}, BlackBoxVaultFromJSONTyped(json, true), { type: "black_box" });
    case "cosmos":
      return Object.assign({}, CosmosVaultFromJSONTyped(json, true), { type: "cosmos" });
    case "evm":
      return Object.assign({}, EvmVaultFromJSONTyped(json, true), { type: "evm" });
    case "exchange":
      return Object.assign({}, ExchangeVaultFromJSONTyped(json, true), { type: "exchange" });
    case "solana":
      return Object.assign({}, SolanaVaultFromJSONTyped(json, true), { type: "solana" });
    case "stacks":
      return Object.assign({}, StacksVaultFromJSONTyped(json, true), { type: "stacks" });
    case "starknet":
      return Object.assign({}, StarknetVaultFromJSONTyped(json, true), { type: "starknet" });
    case "sui":
      return Object.assign({}, SuiVaultFromJSONTyped(json, true), { type: "sui" });
    case "ton":
      return Object.assign({}, TonVaultFromJSONTyped(json, true), { type: "ton" });
    case "tron":
      return Object.assign({}, TronVaultFromJSONTyped(json, true), { type: "tron" });
    case "utxo":
      return Object.assign({}, UtxoVaultFromJSONTyped(json, true), { type: "utxo" });
    default:
      throw new Error(`No variant of Vault exists with 'type=${json["type"]}'`);
  }
}

// src/openapi/models/ListVaultsResponse.ts
function ListVaultsResponseFromJSON(json) {
  return ListVaultsResponseFromJSONTyped(json, false);
}
function ListVaultsResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "partialError": json["partial_error"] == null ? void 0 : PartialErrorResponseFromJSON(json["partial_error"]),
    "total": json["total"],
    "page": json["page"],
    "size": json["size"],
    "vaults": json["vaults"].map(VaultFromJSON)
  };
}

// src/openapi/models/VaultWithAssets.ts
function VaultWithAssetsFromJSON(json) {
  return VaultWithAssetsFromJSONTyped(json, false);
}
function VaultWithAssetsFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "vaultInfo": VaultFromJSON(json["vault_info"]),
    "totalValue": FiatValueFromJSON(json["total_value"]),
    "hasMoreAssets": json["has_more_assets"],
    "ownedAssets": json["owned_assets"].map(OwnedAssetFromJSON),
    "chainsWithAssets": json["chains_with_assets"].map(ChainWithAssetsFromJSON),
    "ownedAssetsCount": json["owned_assets_count"]
  };
}

// src/openapi/models/ListVaultsWithAssetsResponse.ts
function ListVaultsWithAssetsResponseFromJSON(json) {
  return ListVaultsWithAssetsResponseFromJSONTyped(json, false);
}
function ListVaultsWithAssetsResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "partialError": json["partial_error"] == null ? void 0 : PartialErrorResponseFromJSON(json["partial_error"]),
    "total": json["total"],
    "page": json["page"],
    "size": json["size"],
    "vaults": json["vaults"].map(VaultWithAssetsFromJSON)
  };
}

// src/openapi/models/NextApiSignerTransactionRequestV3.ts
function NextApiSignerTransactionRequestV3ToJSON(json) {
  return NextApiSignerTransactionRequestV3ToJSONTyped(json, false);
}
function NextApiSignerTransactionRequestV3ToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "protocol_version": value["protocolVersion"],
    "session_seed": value["sessionSeed"]
  };
}

// src/openapi/models/NextApiSignerTransactionRequestV4.ts
function NextApiSignerTransactionRequestV4ToJSON(json) {
  return NextApiSignerTransactionRequestV4ToJSONTyped(json, false);
}
function NextApiSignerTransactionRequestV4ToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "protocol_version": value["protocolVersion"],
    "session_seed": value["sessionSeed"]
  };
}

// src/openapi/models/SignSession.ts
function SignSessionFromJSON(json) {
  return SignSessionFromJSONTyped(json, false);
}
function SignSessionFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "sessionId": json["session_id"],
    "payloadToSign": json["payload_to_sign"],
    "keyDerivationArgs": KeyDerivationArgsFromJSON(json["key_derivation_args"])
  };
}

// src/openapi/models/RegisterTransactionSignSessionResponse.ts
function RegisterTransactionSignSessionResponseFromJSON(json) {
  return RegisterTransactionSignSessionResponseFromJSONTyped(json, false);
}
function RegisterTransactionSignSessionResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "sessionId": json["session_id"],
    "hash": json["hash"],
    "timestampedSignature": json["timestamped_signature"] == null ? void 0 : TimestampedSignatureFromJSON(json["timestamped_signature"]),
    "timestampedSignatureV2": TimestampedSignatureFromJSON(json["timestamped_signature_v2"]),
    "keyDerivationArgs": KeyDerivationArgsFromJSON(json["key_derivation_args"]),
    "signSessions": json["sign_sessions"].map(SignSessionFromJSON),
    "dklsEnabled": json["dkls_enabled"] == null ? void 0 : json["dkls_enabled"]
  };
}

// src/openapi/models/NextApiSignerTransactionResponseV3Body.ts
function NextApiSignerTransactionResponseV3BodyFromJSON(json) {
  return NextApiSignerTransactionResponseV3BodyFromJSONTyped(json, false);
}
function NextApiSignerTransactionResponseV3BodyFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "transactionId": json["transaction_id"],
    "registerSignInfo": RegisterTransactionSignSessionResponseFromJSON(json["register_sign_info"])
  };
}

// src/openapi/models/NextApiSignerTransactionResponseV3.ts
function NextApiSignerTransactionResponseV3FromJSON(json) {
  return NextApiSignerTransactionResponseV3FromJSONTyped(json, false);
}
function NextApiSignerTransactionResponseV3FromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "body": json["body"] == null ? void 0 : NextApiSignerTransactionResponseV3BodyFromJSON(json["body"])
  };
}

// src/openapi/models/TransactionType.ts
function TransactionTypeFromJSON(json) {
  return TransactionTypeFromJSONTyped(json, false);
}
function TransactionTypeFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// src/openapi/models/NextApiSignerTransactionResponseV4Body.ts
function NextApiSignerTransactionResponseV4BodyFromJSON(json) {
  return NextApiSignerTransactionResponseV4BodyFromJSONTyped(json, false);
}
function NextApiSignerTransactionResponseV4BodyFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "transactionId": json["transaction_id"],
    "transactionType": TransactionTypeFromJSON(json["transaction_type"]),
    "registerSignInfo": json["register_sign_info"] == null ? void 0 : RegisterTransactionSignSessionResponseFromJSON(json["register_sign_info"])
  };
}

// src/openapi/models/NextApiSignerTransactionResponseV4.ts
function NextApiSignerTransactionResponseV4FromJSON(json) {
  return NextApiSignerTransactionResponseV4FromJSONTyped(json, false);
}
function NextApiSignerTransactionResponseV4FromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "body": json["body"] == null ? void 0 : NextApiSignerTransactionResponseV4BodyFromJSON(json["body"])
  };
}

// src/openapi/models/PredictAptosSerializedRawTransactionRequest.ts
function PredictAptosSerializedRawTransactionRequestToJSON(json) {
  return PredictAptosSerializedRawTransactionRequestToJSONTyped(json, false);
}
function PredictAptosSerializedRawTransactionRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "type": value["type"],
    "fail_on_prediction_failure": value["failOnPredictionFailure"],
    "gas_config": AptosGasConfigRequestToJSON(value["gasConfig"]),
    "chain": AptosChainUniqueIdToJSON(value["chain"]),
    "serialized_transaction_payload": value["serializedTransactionPayload"],
    "skip_simulation": value["skipSimulation"]
  };
}

// src/openapi/models/PredictAptosTransferRequest.ts
function PredictAptosTransferRequestToJSON(json) {
  return PredictAptosTransferRequestToJSONTyped(json, false);
}
function PredictAptosTransferRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "type": value["type"],
    "fail_on_prediction_failure": value["failOnPredictionFailure"],
    "gas_config": AptosGasConfigRequestToJSON(value["gasConfig"]),
    "to": CreateAptosTransferRequestToToJSON(value["to"]),
    "value": CreateAptosTransferRequestValueToJSON(value["value"]),
    "asset_identifier": AptosAssetIdentifierRequestToJSON(value["assetIdentifier"]),
    "skip_simulation": value["skipSimulation"]
  };
}

// src/openapi/models/SolanaSuggestedFees.ts
function SolanaSuggestedFeesFromJSON(json) {
  return SolanaSuggestedFeesFromJSONTyped(json, false);
}
function SolanaSuggestedFeesFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "type": json["type"],
    "chainUniqueId": SolanaChainUniqueIdFromJSON(json["chain_unique_id"]),
    "baseFee": json["base_fee"],
    "low": json["low"],
    "medium": json["medium"],
    "high": json["high"]
  };
}

// src/openapi/models/PredictedSolanaSpotSwapDetails.ts
function PredictedSolanaSpotSwapDetailsFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "type": json["type"],
    "slippageBps": json["slippage_bps"],
    "priceImpactPct": json["price_impact_pct"],
    "rate": json["rate"],
    "broadcastMode": SolanaSpotSwapBroadcastModeFromJSON(json["broadcast_mode"]),
    "inputAsset": AssetInfoFromJSON(json["input_asset"]),
    "outputAsset": AssetInfoFromJSON(json["output_asset"]),
    "recipients": json["recipients"].map(EnrichedSolanaAddressFromJSON),
    "jitoSuggestedFees": SolanaSuggestedFeesFromJSON(json["jito_suggested_fees"])
  };
}

// src/openapi/models/PredictedSolanaTransactionSolanaTransactionTypeDetails.ts
function PredictedSolanaTransactionSolanaTransactionTypeDetailsFromJSON(json) {
  return PredictedSolanaTransactionSolanaTransactionTypeDetailsFromJSONTyped(json, false);
}
function PredictedSolanaTransactionSolanaTransactionTypeDetailsFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  switch (json["type"]) {
    case "native_transfer":
      return Object.assign({}, SolanaNativeTransferDetailsFromJSONTyped(json, true), { type: "native_transfer" });
    case "raw_transaction":
      return Object.assign({}, SolanaRawTransactionDetailsFromJSONTyped(json, true), { type: "raw_transaction" });
    case "spot_swap":
      return Object.assign({}, PredictedSolanaSpotSwapDetailsFromJSONTyped(json, true), { type: "spot_swap" });
    case "token_transfer":
      return Object.assign({}, SolanaTokenTransferDetailsFromJSONTyped(json, true), { type: "token_transfer" });
    default:
      throw new Error(`No variant of PredictedSolanaTransactionSolanaTransactionTypeDetails exists with 'type=${json["type"]}'`);
  }
}

// src/openapi/models/PredictedSolanaTransaction.ts
function PredictedSolanaTransactionFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "amlPolicyMatch": json["aml_policy_match"] == null ? void 0 : AmlPolicyMatchOutgoingFromJSON(json["aml_policy_match"]),
    "policyMatch": PolicyMatchFromJSON(json["policy_match"]),
    "approvalRequest": json["approval_request"] == null ? void 0 : ApprovalRequestFromJSON(json["approval_request"]),
    "risks": json["risks"].map(TransactionRiskFromJSON),
    "note": json["note"] == null ? void 0 : json["note"],
    "amlResults": json["aml_results"] == null ? void 0 : AmlResultsFromJSON(json["aml_results"]),
    "type": json["type"],
    "expectedResult": SolanaTransactionResultFromJSON(json["expected_result"]),
    "chain": EnrichedSolanaChainFromJSON(json["chain"]),
    "simulationStatusResult": SimulationStatusResultFromJSON(json["simulation_status_result"]),
    "solanaTransactionTypeDetails": PredictedSolanaTransactionSolanaTransactionTypeDetailsFromJSON(json["solana_transaction_type_details"]),
    "sender": EnrichedSolanaAddressFromJSON(json["sender"]),
    "suggestedFees": SolanaSuggestedFeesFromJSON(json["suggested_fees"]),
    "instructions": json["instructions"].map(SolanaCompiledInstructionFromJSON),
    "rawTransaction": json["raw_transaction"] == null ? void 0 : json["raw_transaction"],
    "wasFeeSetInRequest": json["was_fee_set_in_request"]
  };
}

// src/openapi/models/PredictStacksTransactionRequest.ts
function PredictStacksTransactionRequestToJSON(json) {
  return PredictStacksTransactionRequestToJSONTyped(json, false);
}
function PredictStacksTransactionRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "vault_id": value["vaultId"],
    "note": value["note"],
    "type": value["type"],
    "details": CreateStacksTransactionRequestDetailsToJSON(value["details"])
  };
}

// src/openapi/models/PredictStarknetMessageRequest.ts
function PredictStarknetMessageRequestToJSON(json) {
  return PredictStarknetMessageRequestToJSONTyped(json, false);
}
function PredictStarknetMessageRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "vault_id": value["vaultId"],
    "note": value["note"],
    "type": value["type"],
    "details": StarknetTypedMessageRequestToJSON(value["details"])
  };
}

// src/openapi/models/PredictStarknetTransactionRequest.ts
function PredictStarknetTransactionRequestToJSON(json) {
  return PredictStarknetTransactionRequestToJSONTyped(json, false);
}
function PredictStarknetTransactionRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "vault_id": value["vaultId"],
    "note": value["note"],
    "type": value["type"],
    "details": CreateStarknetTransactionRequestDetailsToJSON(value["details"])
  };
}

// src/openapi/models/PredictTonSerializedRawTransactionRequest.ts
function PredictTonSerializedRawTransactionRequestToJSON(json) {
  return PredictTonSerializedRawTransactionRequestToJSONTyped(json, false);
}
function PredictTonSerializedRawTransactionRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "type": value["type"],
    "fail_on_prediction_failure": value["failOnPredictionFailure"],
    "push_mode": PushModeToJSON(value["pushMode"]),
    "chain": TonChainUniqueIdToJSON(value["chain"]),
    "transaction_payload": TonTransactionPayloadToJSON(value["transactionPayload"]),
    "skip_simulation": value["skipSimulation"]
  };
}

// src/openapi/models/PredictTonTransferRequest.ts
function PredictTonTransferRequestToJSON(json) {
  return PredictTonTransferRequestToJSONTyped(json, false);
}
function PredictTonTransferRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "type": value["type"],
    "fail_on_prediction_failure": value["failOnPredictionFailure"],
    "push_mode": PushModeToJSON(value["pushMode"]),
    "to": CreateTonTransferRequestToToJSON(value["to"]),
    "value": CreateAptosTransferRequestValueToJSON(value["value"]),
    "asset_identifier": TonAssetIdentifierRequestToJSON(value["assetIdentifier"]),
    "comment": value["comment"],
    "skip_simulation": value["skipSimulation"]
  };
}

// src/openapi/models/TransactionPredictAptosMessageRequest.ts
function TransactionPredictAptosMessageRequestToJSON(json) {
  return TransactionPredictAptosMessageRequestToJSONTyped(json, false);
}
function TransactionPredictAptosMessageRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "vault_id": value["vaultId"],
    "note": value["note"],
    "type": value["type"],
    "details": AptosPersonalMessageRequestToJSON(value["details"])
  };
}

// src/openapi/models/TransactionPredictAptosTransactionRequestDetails.ts
function TransactionPredictAptosTransactionRequestDetailsToJSON(json) {
  return TransactionPredictAptosTransactionRequestDetailsToJSONTyped(json, false);
}
function TransactionPredictAptosTransactionRequestDetailsToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  switch (value["type"]) {
    case "aptos_serialized_entry_point_payload":
      return Object.assign({}, PredictAptosSerializedRawTransactionRequestToJSON(value), { type: "aptos_serialized_entry_point_payload" });
    case "aptos_transfer":
      return Object.assign({}, PredictAptosTransferRequestToJSON(value), { type: "aptos_transfer" });
    default:
      throw new Error(`No variant of TransactionPredictAptosTransactionRequestDetails exists with 'type=${value["type"]}'`);
  }
}

// src/openapi/models/TransactionPredictAptosTransactionRequest.ts
function TransactionPredictAptosTransactionRequestToJSON(json) {
  return TransactionPredictAptosTransactionRequestToJSONTyped(json, false);
}
function TransactionPredictAptosTransactionRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "vault_id": value["vaultId"],
    "note": value["note"],
    "type": value["type"],
    "details": TransactionPredictAptosTransactionRequestDetailsToJSON(value["details"])
  };
}

// src/openapi/models/TransactionPredictCosmosMessageRequest.ts
function TransactionPredictCosmosMessageRequestToJSON(json) {
  return TransactionPredictCosmosMessageRequestToJSONTyped(json, false);
}
function TransactionPredictCosmosMessageRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "vault_id": value["vaultId"],
    "note": value["note"],
    "type": value["type"],
    "details": CosmosArbitraryMessageRequestToJSON(value["details"])
  };
}

// src/openapi/models/TransactionPredictCosmosTransactionRequest.ts
function TransactionPredictCosmosTransactionRequestToJSON(json) {
  return TransactionPredictCosmosTransactionRequestToJSONTyped(json, false);
}
function TransactionPredictCosmosTransactionRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "vault_id": value["vaultId"],
    "note": value["note"],
    "type": value["type"],
    "details": CreateCosmosTransactionRequestDetailsToJSON(value["details"])
  };
}

// src/openapi/models/TransactionDetailsEvmPersonalMessageRequest.ts
function TransactionDetailsEvmPersonalMessageRequestToJSON(json) {
  return TransactionDetailsEvmPersonalMessageRequestToJSONTyped(json, false);
}
function TransactionDetailsEvmPersonalMessageRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "type": value["type"],
    "chain": EvmChainRequestToJSON(value["chain"]),
    "raw_data": value["rawData"]
  };
}

// src/openapi/models/TransactionDetailsEvmTypedMessageRequest.ts
function TransactionDetailsEvmTypedMessageRequestToJSON(json) {
  return TransactionDetailsEvmTypedMessageRequestToJSONTyped(json, false);
}
function TransactionDetailsEvmTypedMessageRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "type": value["type"],
    "chain": EvmChainRequestToJSON(value["chain"]),
    "raw_data": value["rawData"]
  };
}

// src/openapi/models/TransactionDetailsEvmTypedV1MessageRequest.ts
function TransactionDetailsEvmTypedV1MessageRequestToJSON(json) {
  return TransactionDetailsEvmTypedV1MessageRequestToJSONTyped(json, false);
}
function TransactionDetailsEvmTypedV1MessageRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "type": value["type"],
    "chain": EvmChainRequestToJSON(value["chain"]),
    "raw_data": value["rawData"]
  };
}

// src/openapi/models/TransactionPredictEvmMessageRequestDetails.ts
function TransactionPredictEvmMessageRequestDetailsToJSON(json) {
  return TransactionPredictEvmMessageRequestDetailsToJSONTyped(json, false);
}
function TransactionPredictEvmMessageRequestDetailsToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  switch (value["type"]) {
    case "personal_message_type":
      return Object.assign({}, TransactionDetailsEvmPersonalMessageRequestToJSON(value), { type: "personal_message_type" });
    case "typed_message_type":
      return Object.assign({}, TransactionDetailsEvmTypedMessageRequestToJSON(value), { type: "typed_message_type" });
    case "typed_message_type_v1":
      return Object.assign({}, TransactionDetailsEvmTypedV1MessageRequestToJSON(value), { type: "typed_message_type_v1" });
    default:
      throw new Error(`No variant of TransactionPredictEvmMessageRequestDetails exists with 'type=${value["type"]}'`);
  }
}

// src/openapi/models/TransactionPredictEvmMessageRequest.ts
function TransactionPredictEvmMessageRequestToJSON(json) {
  return TransactionPredictEvmMessageRequestToJSONTyped(json, false);
}
function TransactionPredictEvmMessageRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "vault_id": value["vaultId"],
    "note": value["note"],
    "type": value["type"],
    "details": TransactionPredictEvmMessageRequestDetailsToJSON(value["details"])
  };
}

// src/openapi/models/TransactionPredictEvmRawTransactionRequest.ts
function TransactionPredictEvmRawTransactionRequestToJSON(json) {
  return TransactionPredictEvmRawTransactionRequestToJSONTyped(json, false);
}
function TransactionPredictEvmRawTransactionRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "type": value["type"],
    "gas": CreateEvmRawTransactionRequestGasToJSON(value["gas"]),
    "fail_on_prediction_failure": value["failOnPredictionFailure"],
    "skip_simulation": value["skipSimulation"],
    "chain": EvmChainRequestToJSON(value["chain"]),
    "to": value["to"],
    "value": value["value"],
    "data": EvmDataRequestToJSON(value["data"])
  };
}

// src/openapi/models/TransactionPredictEvmRevokeAllowanceRequest.ts
function TransactionPredictEvmRevokeAllowanceRequestToJSON(json) {
  return TransactionPredictEvmRevokeAllowanceRequestToJSONTyped(json, false);
}
function TransactionPredictEvmRevokeAllowanceRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "type": value["type"],
    "gas": CreateEvmRawTransactionRequestGasToJSON(value["gas"]),
    "fail_on_prediction_failure": value["failOnPredictionFailure"],
    "skip_simulation": value["skipSimulation"],
    "chain": EvmChainRequestToJSON(value["chain"]),
    "token": value["token"],
    "spender": value["spender"]
  };
}

// src/openapi/models/TransactionPredictEvmTransferRequest.ts
function TransactionPredictEvmTransferRequestToJSON(json) {
  return TransactionPredictEvmTransferRequestToJSONTyped(json, false);
}
function TransactionPredictEvmTransferRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "type": value["type"],
    "gas": CreateEvmRawTransactionRequestGasToJSON(value["gas"]),
    "fail_on_prediction_failure": value["failOnPredictionFailure"],
    "skip_simulation": value["skipSimulation"],
    "to": CreateEvmTransferRequestToToJSON(value["to"]),
    "asset_identifier": EvmAssetIdentifierRequestToJSON(value["assetIdentifier"]),
    "value": CreateAptosTransferRequestValueToJSON(value["value"])
  };
}

// src/openapi/models/TransactionPredictEvmTransactionRequestDetails.ts
function TransactionPredictEvmTransactionRequestDetailsToJSON(json) {
  return TransactionPredictEvmTransactionRequestDetailsToJSONTyped(json, false);
}
function TransactionPredictEvmTransactionRequestDetailsToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  switch (value["type"]) {
    case "evm_raw_transaction":
      return Object.assign({}, TransactionPredictEvmRawTransactionRequestToJSON(value), { type: "evm_raw_transaction" });
    case "evm_revoke_allowance":
      return Object.assign({}, TransactionPredictEvmRevokeAllowanceRequestToJSON(value), { type: "evm_revoke_allowance" });
    case "evm_transfer":
      return Object.assign({}, TransactionPredictEvmTransferRequestToJSON(value), { type: "evm_transfer" });
    default:
      throw new Error(`No variant of TransactionPredictEvmTransactionRequestDetails exists with 'type=${value["type"]}'`);
  }
}

// src/openapi/models/TransactionPredictEvmTransactionRequest.ts
function TransactionPredictEvmTransactionRequestToJSON(json) {
  return TransactionPredictEvmTransactionRequestToJSONTyped(json, false);
}
function TransactionPredictEvmTransactionRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "vault_id": value["vaultId"],
    "note": value["note"],
    "type": value["type"],
    "details": TransactionPredictEvmTransactionRequestDetailsToJSON(value["details"])
  };
}

// src/openapi/models/TransactionPredictExchangeTransactionRequest.ts
function TransactionPredictExchangeTransactionRequestToJSON(json) {
  return TransactionPredictExchangeTransactionRequestToJSONTyped(json, false);
}
function TransactionPredictExchangeTransactionRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "vault_id": value["vaultId"],
    "note": value["note"],
    "type": value["type"],
    "details": CreateExchangeTransactionRequestDetailsToJSON(value["details"])
  };
}

// src/openapi/models/TransactionPredictSolanaMessageRequest.ts
function TransactionPredictSolanaMessageRequestToJSON(json) {
  return TransactionPredictSolanaMessageRequestToJSONTyped(json, false);
}
function TransactionPredictSolanaMessageRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "vault_id": value["vaultId"],
    "note": value["note"],
    "type": value["type"],
    "details": SolanaPersonalMessageRequestToJSON(value["details"])
  };
}

// src/openapi/models/TransactionDetailsSolanaRawTransactionRequest.ts
function TransactionDetailsSolanaRawTransactionRequestToJSON(json) {
  return TransactionDetailsSolanaRawTransactionRequestToJSONTyped(json, false);
}
function TransactionDetailsSolanaRawTransactionRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "version": SolanaMessageVersionToJSON(value["version"]),
    "instructions": value["instructions"].map(SolanaCompiledInstructionRequestToJSON),
    "accounts": value["accounts"].map(SolanaTransactionAccountRequestToJSON),
    "address_table_lookups": value["addressTableLookups"].map(SolanaMessageAddressTableLookupRequestToJSON),
    "signatures": value["signatures"] == null ? void 0 : value["signatures"].map(SolanaTransactionSignaturesRequestToJSON),
    "recent_blockhash": value["recentBlockhash"],
    "fee": BatchSolanaTransactionRequestDetailsFeeToJSON(value["fee"]),
    "type": value["type"],
    "fail_on_prediction_failure": value["failOnPredictionFailure"],
    "skip_simulation": value["skipSimulation"],
    "chain": SolanaChainUniqueIdToJSON(value["chain"])
  };
}

// src/openapi/models/TransactionDetailsSolanaSpotSwapTransactionRequest.ts
function TransactionDetailsSolanaSpotSwapTransactionRequestToJSON(json) {
  return TransactionDetailsSolanaSpotSwapTransactionRequestToJSONTyped(json, false);
}
function TransactionDetailsSolanaSpotSwapTransactionRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "quote_id": value["quoteId"],
    "input_asset_identifier": SolanaAssetIdentifierRequestToJSON(value["inputAssetIdentifier"]),
    "output_asset_identifier": SolanaAssetIdentifierRequestToJSON(value["outputAssetIdentifier"]),
    "amount": value["amount"],
    "fee": CreateSolanaSpotSwapRequestFeeToJSON(value["fee"]),
    "slippage_bps": value["slippageBps"],
    "type": value["type"],
    "fail_on_prediction_failure": value["failOnPredictionFailure"],
    "skip_simulation": value["skipSimulation"]
  };
}

// src/openapi/models/TransactionPredictSolanaSerializedTransactionMessageRequest.ts
function TransactionPredictSolanaSerializedTransactionMessageRequestToJSON(json) {
  return TransactionPredictSolanaSerializedTransactionMessageRequestToJSONTyped(json, false);
}
function TransactionPredictSolanaSerializedTransactionMessageRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "fee": BatchSolanaTransactionRequestDetailsFeeToJSON(value["fee"]),
    "type": value["type"],
    "fail_on_prediction_failure": value["failOnPredictionFailure"],
    "skip_simulation": value["skipSimulation"],
    "chain": SolanaChainUniqueIdToJSON(value["chain"]),
    "data": value["data"],
    "signatures": value["signatures"] == null ? void 0 : value["signatures"].map(SolanaTransactionSignaturesRequestToJSON),
    "ephemeral_keys": value["ephemeralKeys"] == null ? void 0 : value["ephemeralKeys"].map(SolanaSecretKeyRequestToJSON)
  };
}

// src/openapi/models/TransactionPredictSolanaTransferRequest.ts
function TransactionPredictSolanaTransferRequestToJSON(json) {
  return TransactionPredictSolanaTransferRequestToJSONTyped(json, false);
}
function TransactionPredictSolanaTransferRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "fee": BatchSolanaTransactionRequestDetailsFeeToJSON(value["fee"]),
    "type": value["type"],
    "fail_on_prediction_failure": value["failOnPredictionFailure"],
    "skip_simulation": value["skipSimulation"],
    "to": CreateSolanaTransferRequestToToJSON(value["to"]),
    "value": CreateAptosTransferRequestValueToJSON(value["value"]),
    "asset_identifier": SolanaAssetIdentifierRequestToJSON(value["assetIdentifier"])
  };
}

// src/openapi/models/TransactionPredictSolanaTransactionRequestDetails.ts
function TransactionPredictSolanaTransactionRequestDetailsToJSON(json) {
  return TransactionPredictSolanaTransactionRequestDetailsToJSONTyped(json, false);
}
function TransactionPredictSolanaTransactionRequestDetailsToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  switch (value["type"]) {
    case "solana_raw_transaction":
      return Object.assign({}, TransactionDetailsSolanaRawTransactionRequestToJSON(value), { type: "solana_raw_transaction" });
    case "solana_serialized_transaction_message":
      return Object.assign({}, TransactionPredictSolanaSerializedTransactionMessageRequestToJSON(value), { type: "solana_serialized_transaction_message" });
    case "solana_spot_swap":
      return Object.assign({}, TransactionDetailsSolanaSpotSwapTransactionRequestToJSON(value), { type: "solana_spot_swap" });
    case "solana_transfer":
      return Object.assign({}, TransactionPredictSolanaTransferRequestToJSON(value), { type: "solana_transfer" });
    default:
      throw new Error(`No variant of TransactionPredictSolanaTransactionRequestDetails exists with 'type=${value["type"]}'`);
  }
}

// src/openapi/models/TransactionPredictSolanaTransactionRequest.ts
function TransactionPredictSolanaTransactionRequestToJSON(json) {
  return TransactionPredictSolanaTransactionRequestToJSONTyped(json, false);
}
function TransactionPredictSolanaTransactionRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "vault_id": value["vaultId"],
    "note": value["note"],
    "type": value["type"],
    "details": TransactionPredictSolanaTransactionRequestDetailsToJSON(value["details"])
  };
}

// src/openapi/models/TransactionPredictSuiMessageRequest.ts
function TransactionPredictSuiMessageRequestToJSON(json) {
  return TransactionPredictSuiMessageRequestToJSONTyped(json, false);
}
function TransactionPredictSuiMessageRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "vault_id": value["vaultId"],
    "note": value["note"],
    "type": value["type"],
    "details": SuiPersonalMessageRequestToJSON(value["details"])
  };
}

// src/openapi/models/TransactionDetailsSuiProgrammableTransactionBlockRequest.ts
function TransactionDetailsSuiProgrammableTransactionBlockRequestToJSON(json) {
  return TransactionDetailsSuiProgrammableTransactionBlockRequestToJSONTyped(json, false);
}
function TransactionDetailsSuiProgrammableTransactionBlockRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "type": value["type"],
    "fail_on_prediction_failure": value["failOnPredictionFailure"],
    "skip_simulation": value["skipSimulation"],
    "chain": SuiChainUniqueIdToJSON(value["chain"]),
    "gas_config": SuiGasConfigToJSON(value["gasConfig"]),
    "inputs": value["inputs"].map(SuiInputToJSON),
    "commands": value["commands"].map(SuiCommandToJSON)
  };
}

// src/openapi/models/TransactionPredictSuiTransferRequest.ts
function TransactionPredictSuiTransferRequestToJSON(json) {
  return TransactionPredictSuiTransferRequestToJSONTyped(json, false);
}
function TransactionPredictSuiTransferRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "type": value["type"],
    "fail_on_prediction_failure": value["failOnPredictionFailure"],
    "skip_simulation": value["skipSimulation"],
    "to": CreateSuiTransferRequestToToJSON(value["to"]),
    "value": CreateAptosTransferRequestValueToJSON(value["value"]),
    "asset_identifier": SuiAssetIdentifierRequestToJSON(value["assetIdentifier"]),
    "gas_config": SuiGasConfigToJSON(value["gasConfig"])
  };
}

// src/openapi/models/TransactionPredictSuiTransactionRequestDetails.ts
function TransactionPredictSuiTransactionRequestDetailsToJSON(json) {
  return TransactionPredictSuiTransactionRequestDetailsToJSONTyped(json, false);
}
function TransactionPredictSuiTransactionRequestDetailsToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  switch (value["type"]) {
    case "sui_programmable_transaction_block":
      return Object.assign({}, TransactionDetailsSuiProgrammableTransactionBlockRequestToJSON(value), { type: "sui_programmable_transaction_block" });
    case "sui_transfer":
      return Object.assign({}, TransactionPredictSuiTransferRequestToJSON(value), { type: "sui_transfer" });
    default:
      throw new Error(`No variant of TransactionPredictSuiTransactionRequestDetails exists with 'type=${value["type"]}'`);
  }
}

// src/openapi/models/TransactionPredictSuiTransactionRequest.ts
function TransactionPredictSuiTransactionRequestToJSON(json) {
  return TransactionPredictSuiTransactionRequestToJSONTyped(json, false);
}
function TransactionPredictSuiTransactionRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "vault_id": value["vaultId"],
    "note": value["note"],
    "type": value["type"],
    "details": TransactionPredictSuiTransactionRequestDetailsToJSON(value["details"])
  };
}

// src/openapi/models/TransactionPredictTonMessageRequest.ts
function TransactionPredictTonMessageRequestToJSON(json) {
  return TransactionPredictTonMessageRequestToJSONTyped(json, false);
}
function TransactionPredictTonMessageRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "vault_id": value["vaultId"],
    "note": value["note"],
    "type": value["type"],
    "details": TonProofMessageRequestToJSON(value["details"])
  };
}

// src/openapi/models/TransactionPredictTonTransactionRequestDetails.ts
function TransactionPredictTonTransactionRequestDetailsToJSON(json) {
  return TransactionPredictTonTransactionRequestDetailsToJSONTyped(json, false);
}
function TransactionPredictTonTransactionRequestDetailsToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  switch (value["type"]) {
    case "ton_raw_transaction":
      return Object.assign({}, PredictTonSerializedRawTransactionRequestToJSON(value), { type: "ton_raw_transaction" });
    case "ton_transfer":
      return Object.assign({}, PredictTonTransferRequestToJSON(value), { type: "ton_transfer" });
    default:
      throw new Error(`No variant of TransactionPredictTonTransactionRequestDetails exists with 'type=${value["type"]}'`);
  }
}

// src/openapi/models/TransactionPredictTonTransactionRequest.ts
function TransactionPredictTonTransactionRequestToJSON(json) {
  return TransactionPredictTonTransactionRequestToJSONTyped(json, false);
}
function TransactionPredictTonTransactionRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "vault_id": value["vaultId"],
    "note": value["note"],
    "type": value["type"],
    "details": TransactionPredictTonTransactionRequestDetailsToJSON(value["details"])
  };
}

// src/openapi/models/TransactionPredictTronTransactionRequest.ts
function TransactionPredictTronTransactionRequestToJSON(json) {
  return TransactionPredictTronTransactionRequestToJSONTyped(json, false);
}
function TransactionPredictTronTransactionRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "vault_id": value["vaultId"],
    "note": value["note"],
    "type": value["type"],
    "details": CreateTronTransactionRequestDetailsToJSON(value["details"])
  };
}

// src/openapi/models/TransactionPredictUtxoMessageRequest.ts
function TransactionPredictUtxoMessageRequestToJSON(json) {
  return TransactionPredictUtxoMessageRequestToJSONTyped(json, false);
}
function TransactionPredictUtxoMessageRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "vault_id": value["vaultId"],
    "note": value["note"],
    "type": value["type"],
    "details": UtxoMessageDetailsToJSON(value["details"])
  };
}

// src/openapi/models/TransactionPredictUtxoTransactionRequest.ts
function TransactionPredictUtxoTransactionRequestToJSON(json) {
  return TransactionPredictUtxoTransactionRequestToJSONTyped(json, false);
}
function TransactionPredictUtxoTransactionRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "vault_id": value["vaultId"],
    "note": value["note"],
    "type": value["type"],
    "details": CreateUtxoTransactionRequestDetailsToJSON(value["details"])
  };
}

// src/openapi/models/PredictTransactionRequest.ts
function PredictTransactionRequestToJSON(json) {
  return PredictTransactionRequestToJSONTyped(json, false);
}
function PredictTransactionRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  switch (value["type"]) {
    case "aptos_message":
      return Object.assign({}, TransactionPredictAptosMessageRequestToJSON(value), { type: "aptos_message" });
    case "aptos_transaction":
      return Object.assign({}, TransactionPredictAptosTransactionRequestToJSON(value), { type: "aptos_transaction" });
    case "cosmos_message":
      return Object.assign({}, TransactionPredictCosmosMessageRequestToJSON(value), { type: "cosmos_message" });
    case "cosmos_transaction":
      return Object.assign({}, TransactionPredictCosmosTransactionRequestToJSON(value), { type: "cosmos_transaction" });
    case "evm_message":
      return Object.assign({}, TransactionPredictEvmMessageRequestToJSON(value), { type: "evm_message" });
    case "evm_transaction":
      return Object.assign({}, TransactionPredictEvmTransactionRequestToJSON(value), { type: "evm_transaction" });
    case "exchange_transaction":
      return Object.assign({}, TransactionPredictExchangeTransactionRequestToJSON(value), { type: "exchange_transaction" });
    case "solana_message":
      return Object.assign({}, TransactionPredictSolanaMessageRequestToJSON(value), { type: "solana_message" });
    case "solana_transaction":
      return Object.assign({}, TransactionPredictSolanaTransactionRequestToJSON(value), { type: "solana_transaction" });
    case "stacks_transaction":
      return Object.assign({}, PredictStacksTransactionRequestToJSON(value), { type: "stacks_transaction" });
    case "starknet_message":
      return Object.assign({}, PredictStarknetMessageRequestToJSON(value), { type: "starknet_message" });
    case "starknet_transaction":
      return Object.assign({}, PredictStarknetTransactionRequestToJSON(value), { type: "starknet_transaction" });
    case "sui_message":
      return Object.assign({}, TransactionPredictSuiMessageRequestToJSON(value), { type: "sui_message" });
    case "sui_transaction":
      return Object.assign({}, TransactionPredictSuiTransactionRequestToJSON(value), { type: "sui_transaction" });
    case "ton_message":
      return Object.assign({}, TransactionPredictTonMessageRequestToJSON(value), { type: "ton_message" });
    case "ton_transaction":
      return Object.assign({}, TransactionPredictTonTransactionRequestToJSON(value), { type: "ton_transaction" });
    case "tron_transaction":
      return Object.assign({}, TransactionPredictTronTransactionRequestToJSON(value), { type: "tron_transaction" });
    case "utxo_message":
      return Object.assign({}, TransactionPredictUtxoMessageRequestToJSON(value), { type: "utxo_message" });
    case "utxo_transaction":
      return Object.assign({}, TransactionPredictUtxoTransactionRequestToJSON(value), { type: "utxo_transaction" });
    default:
      throw new Error(`No variant of PredictTransactionRequest exists with 'type=${value["type"]}'`);
  }
}

// src/openapi/models/PredictedAptosMessage.ts
function PredictedAptosMessageFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "amlPolicyMatch": json["aml_policy_match"] == null ? void 0 : AmlPolicyMatchOutgoingFromJSON(json["aml_policy_match"]),
    "policyMatch": PolicyMatchFromJSON(json["policy_match"]),
    "approvalRequest": json["approval_request"] == null ? void 0 : ApprovalRequestFromJSON(json["approval_request"]),
    "risks": json["risks"].map(TransactionRiskFromJSON),
    "note": json["note"] == null ? void 0 : json["note"],
    "type": json["type"],
    "chain": EnrichedAptosChainFromJSON(json["chain"]),
    "sender": EnrichedAptosAddressFromJSON(json["sender"]),
    "aptosMessageType": AptosMessageTypeFromJSON(json["aptos_message_type"]),
    "messageToDisplay": json["message_to_display"]
  };
}

// src/openapi/models/PredictedAptosTransaction.ts
function PredictedAptosTransactionFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "amlPolicyMatch": json["aml_policy_match"] == null ? void 0 : AmlPolicyMatchOutgoingFromJSON(json["aml_policy_match"]),
    "policyMatch": PolicyMatchFromJSON(json["policy_match"]),
    "approvalRequest": json["approval_request"] == null ? void 0 : ApprovalRequestFromJSON(json["approval_request"]),
    "risks": json["risks"].map(TransactionRiskFromJSON),
    "note": json["note"] == null ? void 0 : json["note"],
    "amlResults": json["aml_results"] == null ? void 0 : AmlResultsFromJSON(json["aml_results"]),
    "type": json["type"],
    "expectedResult": AptosTransactionResultFromJSON(json["expected_result"]),
    "chain": EnrichedAptosChainFromJSON(json["chain"]),
    "simulationStatusResult": SimulationStatusResultFromJSON(json["simulation_status_result"]),
    "payload": AptosTransactionPayloadFromJSON(json["payload"]),
    "aptosTransactionTypeDetails": AptosTransactionAptosTransactionTypeDetailsFromJSON(json["aptos_transaction_type_details"]),
    "suggestedFees": AptosSuggestedFeesFromJSON(json["suggested_fees"]),
    "gasSubmitted": AptosGasDataFromJSON(json["gas_submitted"]),
    "sender": EnrichedAptosAddressFromJSON(json["sender"])
  };
}

// src/openapi/models/PredictedCosmosMessage.ts
function PredictedCosmosMessageFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "amlPolicyMatch": json["aml_policy_match"] == null ? void 0 : AmlPolicyMatchOutgoingFromJSON(json["aml_policy_match"]),
    "policyMatch": PolicyMatchFromJSON(json["policy_match"]),
    "approvalRequest": json["approval_request"] == null ? void 0 : ApprovalRequestFromJSON(json["approval_request"]),
    "risks": json["risks"].map(TransactionRiskFromJSON),
    "note": json["note"] == null ? void 0 : json["note"],
    "type": json["type"],
    "chain": EnrichedCosmosChainFromJSON(json["chain"]),
    "sender": EnrichedCosmosBechAddressFromJSON(json["sender"]),
    "cosmosMessageType": CosmosMessageTypeFromJSON(json["cosmos_message_type"]),
    "messageToDisplay": json["message_to_display"]
  };
}

// src/openapi/models/PredictedCosmosTransaction.ts
function PredictedCosmosTransactionFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "amlPolicyMatch": json["aml_policy_match"] == null ? void 0 : AmlPolicyMatchOutgoingFromJSON(json["aml_policy_match"]),
    "policyMatch": PolicyMatchFromJSON(json["policy_match"]),
    "approvalRequest": json["approval_request"] == null ? void 0 : ApprovalRequestFromJSON(json["approval_request"]),
    "risks": json["risks"].map(TransactionRiskFromJSON),
    "note": json["note"] == null ? void 0 : json["note"],
    "amlResults": json["aml_results"] == null ? void 0 : AmlResultsFromJSON(json["aml_results"]),
    "type": json["type"],
    "expectedResult": CosmosTransactionResultFromJSON(json["expected_result"]),
    "chain": EnrichedCosmosChainFromJSON(json["chain"]),
    "cosmosTransactionTypeDetails": CosmosTransactionTypeDetailsFromJSON(json["cosmos_transaction_type_details"]),
    "memo": json["memo"] == null ? void 0 : json["memo"],
    "sender": EnrichedCosmosBechAddressFromJSON(json["sender"]),
    "suggestedFees": CosmosSuggestedFeesFromJSON(json["suggested_fees"])
  };
}

// src/openapi/models/PredictedEvmMessage.ts
function PredictedEvmMessageFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "amlPolicyMatch": json["aml_policy_match"] == null ? void 0 : AmlPolicyMatchOutgoingFromJSON(json["aml_policy_match"]),
    "policyMatch": PolicyMatchFromJSON(json["policy_match"]),
    "approvalRequest": json["approval_request"] == null ? void 0 : ApprovalRequestFromJSON(json["approval_request"]),
    "risks": json["risks"].map(TransactionRiskFromJSON),
    "note": json["note"] == null ? void 0 : json["note"],
    "type": json["type"],
    "chain": EnrichedEvmChainFromJSON(json["chain"]),
    "sender": EnrichedEvmAddressFromJSON(json["sender"]),
    "evmMessageType": EvmMessageTypeFromJSON(json["evm_message_type"]),
    "typedData": json["typed_data"] == null ? void 0 : EvmMessageTypedDataFromJSON(json["typed_data"]),
    "messageToDisplay": json["message_to_display"]
  };
}

// src/openapi/models/PredictedEvmTransaction.ts
function PredictedEvmTransactionFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "amlPolicyMatch": json["aml_policy_match"] == null ? void 0 : AmlPolicyMatchOutgoingFromJSON(json["aml_policy_match"]),
    "policyMatch": PolicyMatchFromJSON(json["policy_match"]),
    "approvalRequest": json["approval_request"] == null ? void 0 : ApprovalRequestFromJSON(json["approval_request"]),
    "risks": json["risks"].map(TransactionRiskFromJSON),
    "note": json["note"] == null ? void 0 : json["note"],
    "amlResults": json["aml_results"] == null ? void 0 : AmlResultsFromJSON(json["aml_results"]),
    "type": json["type"],
    "expectedResult": EvmTransactionResultFromJSON(json["expected_result"]),
    "chain": EnrichedEvmChainFromJSON(json["chain"]),
    "simulationStatusResult": SimulationStatusResultFromJSON(json["simulation_status_result"]),
    "evmTransactionTypeDetails": EvmTransactionEvmTransactionTypeDetailsFromJSON(json["evm_transaction_type_details"]),
    "parsedData": EvmTransactionParsedDataFromJSON(json["parsed_data"]),
    "gasEstimation": json["gas_estimation"] == null ? void 0 : EvmGasEstimationFromJSON(json["gas_estimation"]),
    "suggestedFees": EvmSuggestedFeesFromJSON(json["suggested_fees"]),
    "sender": EnrichedEvmAddressFromJSON(json["sender"]),
    "to": EnrichedEvmAddressFromJSON(json["to"]),
    "hexData": json["hex_data"] == null ? void 0 : json["hex_data"],
    "gasSubmitted": EvmTransactionGasSubmittedFromJSON(json["gas_submitted"])
  };
}

// src/openapi/models/PredictedExchangeTransaction.ts
function PredictedExchangeTransactionFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "amlPolicyMatch": json["aml_policy_match"] == null ? void 0 : AmlPolicyMatchOutgoingFromJSON(json["aml_policy_match"]),
    "policyMatch": PolicyMatchFromJSON(json["policy_match"]),
    "approvalRequest": json["approval_request"] == null ? void 0 : ApprovalRequestFromJSON(json["approval_request"]),
    "risks": json["risks"].map(TransactionRiskFromJSON),
    "note": json["note"] == null ? void 0 : json["note"],
    "type": json["type"],
    "expectedResult": ExchangeTransactionResultFromJSON(json["expected_result"]),
    "simulationStatusResult": SimulationStatusResultFromJSON(json["simulation_status_result"]),
    "exchangeTransactionTypeDetails": ExchangeTransactionExchangeTransactionTypeDetailsFromJSON(json["exchange_transaction_type_details"])
  };
}

// src/openapi/models/PredictedSolanaMessage.ts
function PredictedSolanaMessageFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "amlPolicyMatch": json["aml_policy_match"] == null ? void 0 : AmlPolicyMatchOutgoingFromJSON(json["aml_policy_match"]),
    "policyMatch": PolicyMatchFromJSON(json["policy_match"]),
    "approvalRequest": json["approval_request"] == null ? void 0 : ApprovalRequestFromJSON(json["approval_request"]),
    "risks": json["risks"].map(TransactionRiskFromJSON),
    "note": json["note"] == null ? void 0 : json["note"],
    "type": json["type"],
    "chain": EnrichedSolanaChainFromJSON(json["chain"]),
    "sender": EnrichedSolanaAddressFromJSON(json["sender"]),
    "solanaMessageType": SolanaMessageTypeFromJSON(json["solana_message_type"]),
    "messageToDisplay": json["message_to_display"]
  };
}

// src/openapi/models/StacksSuggestedFees.ts
function StacksSuggestedFeesFromJSON(json) {
  return StacksSuggestedFeesFromJSONTyped(json, false);
}
function StacksSuggestedFeesFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "type": json["type"],
    "low": json["low"],
    "medium": json["medium"],
    "high": json["high"],
    "chainUniqueId": StacksChainUniqueIdFromJSON(json["chain_unique_id"])
  };
}

// src/openapi/models/PredictedStacksTransaction.ts
function PredictedStacksTransactionFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "amlPolicyMatch": json["aml_policy_match"] == null ? void 0 : AmlPolicyMatchOutgoingFromJSON(json["aml_policy_match"]),
    "policyMatch": PolicyMatchFromJSON(json["policy_match"]),
    "approvalRequest": json["approval_request"] == null ? void 0 : ApprovalRequestFromJSON(json["approval_request"]),
    "risks": json["risks"].map(TransactionRiskFromJSON),
    "note": json["note"] == null ? void 0 : json["note"],
    "amlResults": json["aml_results"] == null ? void 0 : AmlResultsFromJSON(json["aml_results"]),
    "type": json["type"],
    "postConditions": StacksPostConditionsFromJSON(json["post_conditions"]),
    "expectedResult": StacksTransactionResultFromJSON(json["expected_result"]),
    "chain": EnrichedStacksChainFromJSON(json["chain"]),
    "simulationStatusResult": SimulationStatusResultFromJSON(json["simulation_status_result"]),
    "stacksTransactionTypeDetails": PredictedStacksTransactionStacksTransactionTypeDetailsFromJSON(json["stacks_transaction_type_details"]),
    "serializedPayload": json["serialized_payload"],
    "memo": json["memo"] == null ? void 0 : json["memo"],
    "suggestedFees": StacksSuggestedFeesFromJSON(json["suggested_fees"]),
    "sender": EnrichedStacksAddressFromJSON(json["sender"])
  };
}

// src/openapi/models/PredictedStarknetMessage.ts
function PredictedStarknetMessageFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "amlPolicyMatch": json["aml_policy_match"] == null ? void 0 : AmlPolicyMatchOutgoingFromJSON(json["aml_policy_match"]),
    "policyMatch": PolicyMatchFromJSON(json["policy_match"]),
    "approvalRequest": json["approval_request"] == null ? void 0 : ApprovalRequestFromJSON(json["approval_request"]),
    "risks": json["risks"].map(TransactionRiskFromJSON),
    "note": json["note"] == null ? void 0 : json["note"],
    "type": json["type"],
    "chain": EnrichedStarknetChainFromJSON(json["chain"]),
    "sender": EnrichedStarknetAddressFromJSON(json["sender"]),
    "starknetMessageType": StarknetMessageTypeFromJSON(json["starknet_message_type"]),
    "messageToDisplay": json["message_to_display"]
  };
}

// src/openapi/models/PredictedStarknetTransaction.ts
function PredictedStarknetTransactionFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "amlPolicyMatch": json["aml_policy_match"] == null ? void 0 : AmlPolicyMatchOutgoingFromJSON(json["aml_policy_match"]),
    "policyMatch": PolicyMatchFromJSON(json["policy_match"]),
    "approvalRequest": json["approval_request"] == null ? void 0 : ApprovalRequestFromJSON(json["approval_request"]),
    "risks": json["risks"].map(TransactionRiskFromJSON),
    "note": json["note"] == null ? void 0 : json["note"],
    "amlResults": json["aml_results"] == null ? void 0 : AmlResultsFromJSON(json["aml_results"]),
    "type": json["type"],
    "expectedResult": StarknetTransactionResultFromJSON(json["expected_result"]),
    "chain": EnrichedStarknetChainFromJSON(json["chain"]),
    "simulationStatusResult": SimulationStatusResultFromJSON(json["simulation_status_result"]),
    "starknetTransactionTypeDetails": PredictedStarknetTransactionStarknetTransactionTypeDetailsFromJSON(json["starknet_transaction_type_details"]),
    "suggestedFees": StarknetSuggestedFeesFromJSON(json["suggested_fees"]),
    "sender": EnrichedStarknetAddressFromJSON(json["sender"]),
    "callData": json["call_data"].map(StarknetCallDataFromJSON)
  };
}

// src/openapi/models/PredictedSuiMessage.ts
function PredictedSuiMessageFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "amlPolicyMatch": json["aml_policy_match"] == null ? void 0 : AmlPolicyMatchOutgoingFromJSON(json["aml_policy_match"]),
    "policyMatch": PolicyMatchFromJSON(json["policy_match"]),
    "approvalRequest": json["approval_request"] == null ? void 0 : ApprovalRequestFromJSON(json["approval_request"]),
    "risks": json["risks"].map(TransactionRiskFromJSON),
    "note": json["note"] == null ? void 0 : json["note"],
    "type": json["type"],
    "chain": EnrichedSuiChainFromJSON(json["chain"]),
    "sender": EnrichedSuiAddressFromJSON(json["sender"]),
    "suiMessageType": SuiMessageTypeFromJSON(json["sui_message_type"]),
    "messageToDisplay": json["message_to_display"]
  };
}

// src/openapi/models/PredictedSuiTransaction.ts
function PredictedSuiTransactionFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "amlPolicyMatch": json["aml_policy_match"] == null ? void 0 : AmlPolicyMatchOutgoingFromJSON(json["aml_policy_match"]),
    "policyMatch": PolicyMatchFromJSON(json["policy_match"]),
    "approvalRequest": json["approval_request"] == null ? void 0 : ApprovalRequestFromJSON(json["approval_request"]),
    "risks": json["risks"].map(TransactionRiskFromJSON),
    "note": json["note"] == null ? void 0 : json["note"],
    "amlResults": json["aml_results"] == null ? void 0 : AmlResultsFromJSON(json["aml_results"]),
    "type": json["type"],
    "expectedResult": SuiTransactionResultFromJSON(json["expected_result"]),
    "chain": EnrichedSuiChainFromJSON(json["chain"]),
    "simulationStatusResult": SimulationStatusResultFromJSON(json["simulation_status_result"]),
    "suiTransactionTypeDetails": PredictedSuiTransactionSuiTransactionTypeDetailsFromJSON(json["sui_transaction_type_details"]),
    "gasSubmitted": SuiGasConfigFromJSON(json["gas_submitted"]),
    "decodedTxBytes": json["decoded_tx_bytes"] == null ? void 0 : json["decoded_tx_bytes"],
    "sender": EnrichedSuiAddressFromJSON(json["sender"]),
    "suggestedFees": SuiSuggestedFeesFromJSON(json["suggested_fees"])
  };
}

// src/openapi/models/PredictedTonMessage.ts
function PredictedTonMessageFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "amlPolicyMatch": json["aml_policy_match"] == null ? void 0 : AmlPolicyMatchOutgoingFromJSON(json["aml_policy_match"]),
    "policyMatch": PolicyMatchFromJSON(json["policy_match"]),
    "approvalRequest": json["approval_request"] == null ? void 0 : ApprovalRequestFromJSON(json["approval_request"]),
    "risks": json["risks"].map(TransactionRiskFromJSON),
    "note": json["note"] == null ? void 0 : json["note"],
    "type": json["type"],
    "chain": EnrichedTonChainFromJSON(json["chain"]),
    "sender": EnrichedTonAddressFromJSON(json["sender"]),
    "tonMessageType": TonMessageTypeFromJSON(json["ton_message_type"]),
    "messageToDisplay": json["message_to_display"]
  };
}

// src/openapi/models/PredictedTonTransaction.ts
function PredictedTonTransactionFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "amlPolicyMatch": json["aml_policy_match"] == null ? void 0 : AmlPolicyMatchOutgoingFromJSON(json["aml_policy_match"]),
    "policyMatch": PolicyMatchFromJSON(json["policy_match"]),
    "approvalRequest": json["approval_request"] == null ? void 0 : ApprovalRequestFromJSON(json["approval_request"]),
    "risks": json["risks"].map(TransactionRiskFromJSON),
    "note": json["note"] == null ? void 0 : json["note"],
    "amlResults": json["aml_results"] == null ? void 0 : AmlResultsFromJSON(json["aml_results"]),
    "type": json["type"],
    "expectedResult": TonTransactionResultFromJSON(json["expected_result"]),
    "chain": EnrichedTonChainFromJSON(json["chain"]),
    "simulationStatusResult": SimulationStatusResultFromJSON(json["simulation_status_result"]),
    "payload": TonTransactionPayloadFromJSON(json["payload"]),
    "tonTransactionTypeDetails": PredictedTonTransactionTonTransactionTypeDetailsFromJSON(json["ton_transaction_type_details"]),
    "suggestedFees": TonSuggestedFeesFromJSON(json["suggested_fees"]),
    "sender": EnrichedTonAddressFromJSON(json["sender"])
  };
}

// src/openapi/models/PredictedTronTransaction.ts
function PredictedTronTransactionFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "amlPolicyMatch": json["aml_policy_match"] == null ? void 0 : AmlPolicyMatchOutgoingFromJSON(json["aml_policy_match"]),
    "policyMatch": PolicyMatchFromJSON(json["policy_match"]),
    "approvalRequest": json["approval_request"] == null ? void 0 : ApprovalRequestFromJSON(json["approval_request"]),
    "risks": json["risks"].map(TransactionRiskFromJSON),
    "note": json["note"] == null ? void 0 : json["note"],
    "amlResults": json["aml_results"] == null ? void 0 : AmlResultsFromJSON(json["aml_results"]),
    "type": json["type"],
    "expectedResult": TronTransactionResultFromJSON(json["expected_result"]),
    "chain": EnrichedTronChainFromJSON(json["chain"]),
    "simulationStatusResult": SimulationStatusResultFromJSON(json["simulation_status_result"]),
    "tronTransactionTypeDetails": PredictedTronTransactionTronTransactionTypeDetailsFromJSON(json["tron_transaction_type_details"]),
    "memo": json["memo"] == null ? void 0 : json["memo"],
    "sender": EnrichedTronAddressFromJSON(json["sender"])
  };
}

// src/openapi/models/PredictedUtxoMessage.ts
function PredictedUtxoMessageFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "amlPolicyMatch": json["aml_policy_match"] == null ? void 0 : AmlPolicyMatchOutgoingFromJSON(json["aml_policy_match"]),
    "policyMatch": PolicyMatchFromJSON(json["policy_match"]),
    "approvalRequest": json["approval_request"] == null ? void 0 : ApprovalRequestFromJSON(json["approval_request"]),
    "risks": json["risks"].map(TransactionRiskFromJSON),
    "note": json["note"] == null ? void 0 : json["note"],
    "type": json["type"],
    "chain": EnrichedUtxoChainFromJSON(json["chain"]),
    "sender": EnrichedUtxoAddressFromJSON(json["sender"]),
    "utxoMessageType": UtxoMessageTypeFromJSON(json["utxo_message_type"]),
    "messageToDisplay": json["message_to_display"]
  };
}

// src/openapi/models/PredictedUtxoTransaction.ts
function PredictedUtxoTransactionFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "amlPolicyMatch": json["aml_policy_match"] == null ? void 0 : AmlPolicyMatchOutgoingFromJSON(json["aml_policy_match"]),
    "policyMatch": PolicyMatchFromJSON(json["policy_match"]),
    "approvalRequest": json["approval_request"] == null ? void 0 : ApprovalRequestFromJSON(json["approval_request"]),
    "risks": json["risks"].map(TransactionRiskFromJSON),
    "note": json["note"] == null ? void 0 : json["note"],
    "amlResults": json["aml_results"] == null ? void 0 : AmlResultsFromJSON(json["aml_results"]),
    "type": json["type"],
    "chain": EnrichedUtxoChainFromJSON(json["chain"]),
    "expectedResult": UtxoTransactionResultFromJSON(json["expected_result"]),
    "utxoTransactionTypeDetails": PredictedUtxoTransactionUtxoTransactionTypeDetailsFromJSON(json["utxo_transaction_type_details"]),
    "suggestedFees": UtxoSuggestedFeesFromJSON(json["suggested_fees"])
  };
}

// src/openapi/models/PredictTransactionResponse.ts
function PredictTransactionResponseFromJSON(json) {
  return PredictTransactionResponseFromJSONTyped(json, false);
}
function PredictTransactionResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  switch (json["type"]) {
    case "aptos_message":
      return Object.assign({}, PredictedAptosMessageFromJSONTyped(json, true), { type: "aptos_message" });
    case "aptos_transaction":
      return Object.assign({}, PredictedAptosTransactionFromJSONTyped(json, true), { type: "aptos_transaction" });
    case "cosmos_message":
      return Object.assign({}, PredictedCosmosMessageFromJSONTyped(json, true), { type: "cosmos_message" });
    case "cosmos_transaction":
      return Object.assign({}, PredictedCosmosTransactionFromJSONTyped(json, true), { type: "cosmos_transaction" });
    case "evm_message":
      return Object.assign({}, PredictedEvmMessageFromJSONTyped(json, true), { type: "evm_message" });
    case "evm_transaction":
      return Object.assign({}, PredictedEvmTransactionFromJSONTyped(json, true), { type: "evm_transaction" });
    case "exchange_transaction":
      return Object.assign({}, PredictedExchangeTransactionFromJSONTyped(json, true), { type: "exchange_transaction" });
    case "solana_message":
      return Object.assign({}, PredictedSolanaMessageFromJSONTyped(json, true), { type: "solana_message" });
    case "solana_transaction":
      return Object.assign({}, PredictedSolanaTransactionFromJSONTyped(json, true), { type: "solana_transaction" });
    case "stacks_transaction":
      return Object.assign({}, PredictedStacksTransactionFromJSONTyped(json, true), { type: "stacks_transaction" });
    case "starknet_message":
      return Object.assign({}, PredictedStarknetMessageFromJSONTyped(json, true), { type: "starknet_message" });
    case "starknet_transaction":
      return Object.assign({}, PredictedStarknetTransactionFromJSONTyped(json, true), { type: "starknet_transaction" });
    case "sui_message":
      return Object.assign({}, PredictedSuiMessageFromJSONTyped(json, true), { type: "sui_message" });
    case "sui_transaction":
      return Object.assign({}, PredictedSuiTransactionFromJSONTyped(json, true), { type: "sui_transaction" });
    case "ton_message":
      return Object.assign({}, PredictedTonMessageFromJSONTyped(json, true), { type: "ton_message" });
    case "ton_transaction":
      return Object.assign({}, PredictedTonTransactionFromJSONTyped(json, true), { type: "ton_transaction" });
    case "tron_transaction":
      return Object.assign({}, PredictedTronTransactionFromJSONTyped(json, true), { type: "tron_transaction" });
    case "utxo_message":
      return Object.assign({}, PredictedUtxoMessageFromJSONTyped(json, true), { type: "utxo_message" });
    case "utxo_transaction":
      return Object.assign({}, PredictedUtxoTransactionFromJSONTyped(json, true), { type: "utxo_transaction" });
    default:
      throw new Error(`No variant of PredictTransactionResponse exists with 'type=${json["type"]}'`);
  }
}

// src/openapi/models/PurgeImportedVaultsRequest.ts
function PurgeImportedVaultsRequestToJSON(json) {
  return PurgeImportedVaultsRequestToJSONTyped(json, false);
}
function PurgeImportedVaultsRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "organization_id": value["organizationId"],
    "vault_ids": value["vaultIds"],
    "purge_all": value["purgeAll"]
  };
}

// src/openapi/models/PurgeImportedVaultsResponse.ts
function PurgeImportedVaultsResponseFromJSON(json) {
  return PurgeImportedVaultsResponseFromJSONTyped(json, false);
}
function PurgeImportedVaultsResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "failedPurges": json["failed_purges"].map(FailedPurgeFromJSON)
  };
}

// src/openapi/models/UtxoPushData.ts
function UtxoPushDataToJSON(json) {
  return UtxoPushDataToJSONTyped(json, false);
}
function UtxoPushDataToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "type": value["type"],
    "psbt_raw_data": value["psbtRawData"]
  };
}

// src/openapi/models/PushTransactionByDataRequest.ts
function PushTransactionByDataRequestToJSON(json) {
  return PushTransactionByDataRequestToJSONTyped(json, false);
}
function PushTransactionByDataRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "push_data": UtxoPushDataToJSON(value["pushData"])
  };
}

// src/openapi/models/PushTransactionByDataResponse.ts
function PushTransactionByDataResponseFromJSON(json) {
  return PushTransactionByDataResponseFromJSONTyped(json, false);
}
function PushTransactionByDataResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  switch (json["type"]) {
    case "aptos_message":
      return Object.assign({}, AptosMessageFromJSONTyped(json, true), { type: "aptos_message" });
    case "aptos_transaction":
      return Object.assign({}, AptosTransactionFromJSONTyped(json, true), { type: "aptos_transaction" });
    case "black_box_signature":
      return Object.assign({}, BlackBoxSignatureFromJSONTyped(json, true), { type: "black_box_signature" });
    case "cosmos_message":
      return Object.assign({}, CosmosMessageFromJSONTyped(json, true), { type: "cosmos_message" });
    case "cosmos_transaction":
      return Object.assign({}, CosmosTransactionFromJSONTyped(json, true), { type: "cosmos_transaction" });
    case "evm_message":
      return Object.assign({}, EvmMessageFromJSONTyped(json, true), { type: "evm_message" });
    case "evm_transaction":
      return Object.assign({}, EvmTransactionFromJSONTyped(json, true), { type: "evm_transaction" });
    case "exchange_transaction":
      return Object.assign({}, ExchangeTransactionFromJSONTyped(json, true), { type: "exchange_transaction" });
    case "solana_message":
      return Object.assign({}, SolanaMessageFromJSONTyped(json, true), { type: "solana_message" });
    case "solana_transaction":
      return Object.assign({}, SolanaTransactionFromJSONTyped(json, true), { type: "solana_transaction" });
    case "stacks_transaction":
      return Object.assign({}, StacksTransactionFromJSONTyped(json, true), { type: "stacks_transaction" });
    case "starknet_message":
      return Object.assign({}, StarknetMessageFromJSONTyped(json, true), { type: "starknet_message" });
    case "starknet_transaction":
      return Object.assign({}, StarknetTransactionFromJSONTyped(json, true), { type: "starknet_transaction" });
    case "sui_message":
      return Object.assign({}, SuiMessageFromJSONTyped(json, true), { type: "sui_message" });
    case "sui_transaction":
      return Object.assign({}, SuiTransactionFromJSONTyped(json, true), { type: "sui_transaction" });
    case "ton_message":
      return Object.assign({}, TonMessageFromJSONTyped(json, true), { type: "ton_message" });
    case "ton_transaction":
      return Object.assign({}, TonTransactionFromJSONTyped(json, true), { type: "ton_transaction" });
    case "tron_transaction":
      return Object.assign({}, TronTransactionFromJSONTyped(json, true), { type: "tron_transaction" });
    case "utxo_message":
      return Object.assign({}, UtxoMessageFromJSONTyped(json, true), { type: "utxo_message" });
    case "utxo_transaction":
      return Object.assign({}, UtxoTransactionFromJSONTyped(json, true), { type: "utxo_transaction" });
    default:
      throw new Error(`No variant of PushTransactionByDataResponse exists with 'type=${json["type"]}'`);
  }
}

// src/openapi/models/PushTransactionRequest.ts
function PushTransactionRequestToJSON(json) {
  return PushTransactionRequestToJSONTyped(json, false);
}
function PushTransactionRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "push_data": CosmosPushDataToJSON(value["pushData"])
  };
}

// src/openapi/models/PushTransactionResponse.ts
function PushTransactionResponseFromJSON(json) {
  return PushTransactionResponseFromJSONTyped(json, false);
}
function PushTransactionResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  switch (json["type"]) {
    case "aptos_message":
      return Object.assign({}, AptosMessageFromJSONTyped(json, true), { type: "aptos_message" });
    case "aptos_transaction":
      return Object.assign({}, AptosTransactionFromJSONTyped(json, true), { type: "aptos_transaction" });
    case "black_box_signature":
      return Object.assign({}, BlackBoxSignatureFromJSONTyped(json, true), { type: "black_box_signature" });
    case "cosmos_message":
      return Object.assign({}, CosmosMessageFromJSONTyped(json, true), { type: "cosmos_message" });
    case "cosmos_transaction":
      return Object.assign({}, CosmosTransactionFromJSONTyped(json, true), { type: "cosmos_transaction" });
    case "evm_message":
      return Object.assign({}, EvmMessageFromJSONTyped(json, true), { type: "evm_message" });
    case "evm_transaction":
      return Object.assign({}, EvmTransactionFromJSONTyped(json, true), { type: "evm_transaction" });
    case "exchange_transaction":
      return Object.assign({}, ExchangeTransactionFromJSONTyped(json, true), { type: "exchange_transaction" });
    case "solana_message":
      return Object.assign({}, SolanaMessageFromJSONTyped(json, true), { type: "solana_message" });
    case "solana_transaction":
      return Object.assign({}, SolanaTransactionFromJSONTyped(json, true), { type: "solana_transaction" });
    case "stacks_transaction":
      return Object.assign({}, StacksTransactionFromJSONTyped(json, true), { type: "stacks_transaction" });
    case "starknet_message":
      return Object.assign({}, StarknetMessageFromJSONTyped(json, true), { type: "starknet_message" });
    case "starknet_transaction":
      return Object.assign({}, StarknetTransactionFromJSONTyped(json, true), { type: "starknet_transaction" });
    case "sui_message":
      return Object.assign({}, SuiMessageFromJSONTyped(json, true), { type: "sui_message" });
    case "sui_transaction":
      return Object.assign({}, SuiTransactionFromJSONTyped(json, true), { type: "sui_transaction" });
    case "ton_message":
      return Object.assign({}, TonMessageFromJSONTyped(json, true), { type: "ton_message" });
    case "ton_transaction":
      return Object.assign({}, TonTransactionFromJSONTyped(json, true), { type: "ton_transaction" });
    case "tron_transaction":
      return Object.assign({}, TronTransactionFromJSONTyped(json, true), { type: "tron_transaction" });
    case "utxo_message":
      return Object.assign({}, UtxoMessageFromJSONTyped(json, true), { type: "utxo_message" });
    case "utxo_transaction":
      return Object.assign({}, UtxoTransactionFromJSONTyped(json, true), { type: "utxo_transaction" });
    default:
      throw new Error(`No variant of PushTransactionResponse exists with 'type=${json["type"]}'`);
  }
}

// src/openapi/models/RefreshTransactionResponse.ts
function RefreshTransactionResponseFromJSON(json) {
  return RefreshTransactionResponseFromJSONTyped(json, false);
}
function RefreshTransactionResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  switch (json["type"]) {
    case "aptos_message":
      return Object.assign({}, AptosMessageFromJSONTyped(json, true), { type: "aptos_message" });
    case "aptos_transaction":
      return Object.assign({}, AptosTransactionFromJSONTyped(json, true), { type: "aptos_transaction" });
    case "black_box_signature":
      return Object.assign({}, BlackBoxSignatureFromJSONTyped(json, true), { type: "black_box_signature" });
    case "cosmos_message":
      return Object.assign({}, CosmosMessageFromJSONTyped(json, true), { type: "cosmos_message" });
    case "cosmos_transaction":
      return Object.assign({}, CosmosTransactionFromJSONTyped(json, true), { type: "cosmos_transaction" });
    case "evm_message":
      return Object.assign({}, EvmMessageFromJSONTyped(json, true), { type: "evm_message" });
    case "evm_transaction":
      return Object.assign({}, EvmTransactionFromJSONTyped(json, true), { type: "evm_transaction" });
    case "exchange_transaction":
      return Object.assign({}, ExchangeTransactionFromJSONTyped(json, true), { type: "exchange_transaction" });
    case "solana_message":
      return Object.assign({}, SolanaMessageFromJSONTyped(json, true), { type: "solana_message" });
    case "solana_transaction":
      return Object.assign({}, SolanaTransactionFromJSONTyped(json, true), { type: "solana_transaction" });
    case "stacks_transaction":
      return Object.assign({}, StacksTransactionFromJSONTyped(json, true), { type: "stacks_transaction" });
    case "starknet_message":
      return Object.assign({}, StarknetMessageFromJSONTyped(json, true), { type: "starknet_message" });
    case "starknet_transaction":
      return Object.assign({}, StarknetTransactionFromJSONTyped(json, true), { type: "starknet_transaction" });
    case "sui_message":
      return Object.assign({}, SuiMessageFromJSONTyped(json, true), { type: "sui_message" });
    case "sui_transaction":
      return Object.assign({}, SuiTransactionFromJSONTyped(json, true), { type: "sui_transaction" });
    case "ton_message":
      return Object.assign({}, TonMessageFromJSONTyped(json, true), { type: "ton_message" });
    case "ton_transaction":
      return Object.assign({}, TonTransactionFromJSONTyped(json, true), { type: "ton_transaction" });
    case "tron_transaction":
      return Object.assign({}, TronTransactionFromJSONTyped(json, true), { type: "tron_transaction" });
    case "utxo_message":
      return Object.assign({}, UtxoMessageFromJSONTyped(json, true), { type: "utxo_message" });
    case "utxo_transaction":
      return Object.assign({}, UtxoTransactionFromJSONTyped(json, true), { type: "utxo_transaction" });
    default:
      throw new Error(`No variant of RefreshTransactionResponse exists with 'type=${json["type"]}'`);
  }
}

// src/openapi/models/RegisterTransactionSignSessionRequest.ts
function RegisterTransactionSignSessionRequestToJSON(json) {
  return RegisterTransactionSignSessionRequestToJSONTyped(json, false);
}
function RegisterTransactionSignSessionRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "protocol_version": value["protocolVersion"],
    "session_seed": value["sessionSeed"]
  };
}

// src/openapi/models/ReleaseType.ts
function ReleaseTypeToJSON(value) {
  return value;
}

// src/openapi/models/ReleaseEvmTransactionRequestGas.ts
function ReleaseEvmTransactionRequestGasToJSON(json) {
  return ReleaseEvmTransactionRequestGasToJSONTyped(json, false);
}
function ReleaseEvmTransactionRequestGasToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  switch (value["type"]) {
    case "custom":
      return Object.assign({}, CustomGasRequestToJSON(value), { type: "custom" });
    default:
      throw new Error(`No variant of ReleaseEvmTransactionRequestGas exists with 'type=${value["type"]}'`);
  }
}

// src/openapi/models/ReleaseEvmTransactionRequest.ts
function ReleaseEvmTransactionRequestToJSON(json) {
  return ReleaseEvmTransactionRequestToJSONTyped(json, false);
}
function ReleaseEvmTransactionRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "type": value["type"],
    "release_type": ReleaseTypeToJSON(value["releaseType"]),
    "signer_type": SignerTypeToJSON(value["signerType"]),
    "fail_on_prediction_failure": value["failOnPredictionFailure"],
    "note": value["note"],
    "gas": ReleaseEvmTransactionRequestGasToJSON(value["gas"])
  };
}

// src/openapi/models/ReleaseTransactionRequest.ts
function ReleaseTransactionRequestToJSON(json) {
  return ReleaseTransactionRequestToJSONTyped(json, false);
}
function ReleaseTransactionRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  switch (value["type"]) {
    case "evm_transaction":
      return Object.assign({}, ReleaseEvmTransactionRequestToJSON(value), { type: "evm_transaction" });
    default:
      throw new Error(`No variant of ReleaseTransactionRequest exists with 'type=${value["type"]}'`);
  }
}

// src/openapi/models/ReleaseTransactionResponse.ts
function ReleaseTransactionResponseFromJSON(json) {
  return ReleaseTransactionResponseFromJSONTyped(json, false);
}
function ReleaseTransactionResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  switch (json["type"]) {
    case "aptos_message":
      return Object.assign({}, AptosMessageFromJSONTyped(json, true), { type: "aptos_message" });
    case "aptos_transaction":
      return Object.assign({}, AptosTransactionFromJSONTyped(json, true), { type: "aptos_transaction" });
    case "black_box_signature":
      return Object.assign({}, BlackBoxSignatureFromJSONTyped(json, true), { type: "black_box_signature" });
    case "cosmos_message":
      return Object.assign({}, CosmosMessageFromJSONTyped(json, true), { type: "cosmos_message" });
    case "cosmos_transaction":
      return Object.assign({}, CosmosTransactionFromJSONTyped(json, true), { type: "cosmos_transaction" });
    case "evm_message":
      return Object.assign({}, EvmMessageFromJSONTyped(json, true), { type: "evm_message" });
    case "evm_transaction":
      return Object.assign({}, EvmTransactionFromJSONTyped(json, true), { type: "evm_transaction" });
    case "exchange_transaction":
      return Object.assign({}, ExchangeTransactionFromJSONTyped(json, true), { type: "exchange_transaction" });
    case "solana_message":
      return Object.assign({}, SolanaMessageFromJSONTyped(json, true), { type: "solana_message" });
    case "solana_transaction":
      return Object.assign({}, SolanaTransactionFromJSONTyped(json, true), { type: "solana_transaction" });
    case "stacks_transaction":
      return Object.assign({}, StacksTransactionFromJSONTyped(json, true), { type: "stacks_transaction" });
    case "starknet_message":
      return Object.assign({}, StarknetMessageFromJSONTyped(json, true), { type: "starknet_message" });
    case "starknet_transaction":
      return Object.assign({}, StarknetTransactionFromJSONTyped(json, true), { type: "starknet_transaction" });
    case "sui_message":
      return Object.assign({}, SuiMessageFromJSONTyped(json, true), { type: "sui_message" });
    case "sui_transaction":
      return Object.assign({}, SuiTransactionFromJSONTyped(json, true), { type: "sui_transaction" });
    case "ton_message":
      return Object.assign({}, TonMessageFromJSONTyped(json, true), { type: "ton_message" });
    case "ton_transaction":
      return Object.assign({}, TonTransactionFromJSONTyped(json, true), { type: "ton_transaction" });
    case "tron_transaction":
      return Object.assign({}, TronTransactionFromJSONTyped(json, true), { type: "tron_transaction" });
    case "utxo_message":
      return Object.assign({}, UtxoMessageFromJSONTyped(json, true), { type: "utxo_message" });
    case "utxo_transaction":
      return Object.assign({}, UtxoTransactionFromJSONTyped(json, true), { type: "utxo_transaction" });
    default:
      throw new Error(`No variant of ReleaseTransactionResponse exists with 'type=${json["type"]}'`);
  }
}

// src/openapi/models/RenameVaultRequest.ts
function RenameVaultRequestToJSON(json) {
  return RenameVaultRequestToJSONTyped(json, false);
}
function RenameVaultRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "name": value["name"]
  };
}

// src/openapi/models/TestEvmChainRequest.ts
function TestEvmChainRequestToJSON(json) {
  return TestEvmChainRequestToJSONTyped(json, false);
}
function TestEvmChainRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "rpc_url": value["rpcUrl"],
    "chain_type": value["chainType"],
    "chain_id": value["chainId"]
  };
}

// src/openapi/models/TestChainRequest.ts
function TestChainRequestToJSON(json) {
  return TestChainRequestToJSONTyped(json, false);
}
function TestChainRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  switch (value["chainType"]) {
    case "evm":
      return Object.assign({}, TestEvmChainRequestToJSON(value), { chainType: "evm" });
    default:
      throw new Error(`No variant of TestChainRequest exists with 'chainType=${value["chainType"]}'`);
  }
}

// src/openapi/models/TriggerAutoProtectionRequest.ts
function TriggerAutoProtectionRequestToJSON(json) {
  return TriggerAutoProtectionRequestToJSONTyped(json, false);
}
function TriggerAutoProtectionRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "account": MultiChainAccountToJSON(value["account"]),
    "note": value["note"]
  };
}

// src/openapi/models/UpdateEvmChainRequest.ts
function UpdateEvmChainRequestToJSON(json) {
  return UpdateEvmChainRequestToJSONTyped(json, false);
}
function UpdateEvmChainRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "chain_type": value["chainType"],
    "chain_id": value["chainId"],
    "chain_name": value["chainName"],
    "rpc_url": value["rpcUrl"],
    "blockchain_explorer_url": value["blockchainExplorerUrl"]
  };
}

// src/openapi/models/UpdateChainRequest.ts
function UpdateChainRequestToJSON(json) {
  return UpdateChainRequestToJSONTyped(json, false);
}
function UpdateChainRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  switch (value["chainType"]) {
    case "evm":
      return Object.assign({}, UpdateEvmChainRequestToJSON(value), { chainType: "evm" });
    default:
      throw new Error(`No variant of UpdateChainRequest exists with 'chainType=${value["chainType"]}'`);
  }
}

// src/openapi/models/UpdateTransactionForSigningResponse.ts
function UpdateTransactionForSigningResponseFromJSON(json) {
  return UpdateTransactionForSigningResponseFromJSONTyped(json, false);
}
function UpdateTransactionForSigningResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  switch (json["type"]) {
    case "aptos_message":
      return Object.assign({}, AptosMessageFromJSONTyped(json, true), { type: "aptos_message" });
    case "aptos_transaction":
      return Object.assign({}, AptosTransactionFromJSONTyped(json, true), { type: "aptos_transaction" });
    case "black_box_signature":
      return Object.assign({}, BlackBoxSignatureFromJSONTyped(json, true), { type: "black_box_signature" });
    case "cosmos_message":
      return Object.assign({}, CosmosMessageFromJSONTyped(json, true), { type: "cosmos_message" });
    case "cosmos_transaction":
      return Object.assign({}, CosmosTransactionFromJSONTyped(json, true), { type: "cosmos_transaction" });
    case "evm_message":
      return Object.assign({}, EvmMessageFromJSONTyped(json, true), { type: "evm_message" });
    case "evm_transaction":
      return Object.assign({}, EvmTransactionFromJSONTyped(json, true), { type: "evm_transaction" });
    case "exchange_transaction":
      return Object.assign({}, ExchangeTransactionFromJSONTyped(json, true), { type: "exchange_transaction" });
    case "solana_message":
      return Object.assign({}, SolanaMessageFromJSONTyped(json, true), { type: "solana_message" });
    case "solana_transaction":
      return Object.assign({}, SolanaTransactionFromJSONTyped(json, true), { type: "solana_transaction" });
    case "stacks_transaction":
      return Object.assign({}, StacksTransactionFromJSONTyped(json, true), { type: "stacks_transaction" });
    case "starknet_message":
      return Object.assign({}, StarknetMessageFromJSONTyped(json, true), { type: "starknet_message" });
    case "starknet_transaction":
      return Object.assign({}, StarknetTransactionFromJSONTyped(json, true), { type: "starknet_transaction" });
    case "sui_message":
      return Object.assign({}, SuiMessageFromJSONTyped(json, true), { type: "sui_message" });
    case "sui_transaction":
      return Object.assign({}, SuiTransactionFromJSONTyped(json, true), { type: "sui_transaction" });
    case "ton_message":
      return Object.assign({}, TonMessageFromJSONTyped(json, true), { type: "ton_message" });
    case "ton_transaction":
      return Object.assign({}, TonTransactionFromJSONTyped(json, true), { type: "ton_transaction" });
    case "tron_transaction":
      return Object.assign({}, TronTransactionFromJSONTyped(json, true), { type: "tron_transaction" });
    case "utxo_message":
      return Object.assign({}, UtxoMessageFromJSONTyped(json, true), { type: "utxo_message" });
    case "utxo_transaction":
      return Object.assign({}, UtxoTransactionFromJSONTyped(json, true), { type: "utxo_transaction" });
    default:
      throw new Error(`No variant of UpdateTransactionForSigningResponse exists with 'type=${json["type"]}'`);
  }
}

// src/openapi/models/UpdateTransactionSpamStateRequest.ts
function UpdateTransactionSpamStateRequestToJSON(json) {
  return UpdateTransactionSpamStateRequestToJSONTyped(json, false);
}
function UpdateTransactionSpamStateRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "is_spam": value["isSpam"]
  };
}

// src/openapi/models/UpdateVaultMetadataRequest.ts
function UpdateVaultMetadataRequestToJSON(json) {
  return UpdateVaultMetadataRequestToJSONTyped(json, false);
}
function UpdateVaultMetadataRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "metadata": value["metadata"] == null ? void 0 : mapValues(value["metadata"], AptosVaultMetadataValueToJSON)
  };
}

// src/openapi/models/VaultMetadata.ts
function VaultMetadataFromJSON(json) {
  return VaultMetadataFromJSONTyped(json, false);
}
function VaultMetadataFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "masterKeyId": json["master_key_id"],
    "derivationPath": json["derivation_path"]
  };
}

// src/openapi/apis/BlockchainsApi.ts
var BlockchainsApi = class extends BaseAPI {
  /**
   * add a new custom chain.
   * Add Chain
   */
  async addChainApiV1BlockchainsPostRaw(requestParameters, initOverrides) {
    if (requestParameters["addChainRequest"] == null) {
      throw new RequiredError(
        "addChainRequest",
        'Required parameter "addChainRequest" was null or undefined when calling addChainApiV1BlockchainsPost().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token("bearerAuth", []);
      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request({
      path: `/api/v1/blockchains`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: AddChainRequestToJSON(requestParameters["addChainRequest"])
    }, initOverrides);
    if (this.isJsonMime(response.headers.get("content-type"))) {
      return new JSONApiResponse(response);
    } else {
      return new TextApiResponse(response);
    }
  }
  /**
   * add a new custom chain.
   * Add Chain
   */
  async addChainApiV1BlockchainsPost(requestParameters, initOverrides) {
    const response = await this.addChainApiV1BlockchainsPostRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Issue a custom rpc command.
   * Custom Chain Rpc
   */
  async customChainRpcApiV1BlockchainsRpcEvmCustomChainRpcOrganizationIdChainIdPostRaw(requestParameters, initOverrides) {
    if (requestParameters["chainId"] == null) {
      throw new RequiredError(
        "chainId",
        'Required parameter "chainId" was null or undefined when calling customChainRpcApiV1BlockchainsRpcEvmCustomChainRpcOrganizationIdChainIdPost().'
      );
    }
    if (requestParameters["organizationId"] == null) {
      throw new RequiredError(
        "organizationId",
        'Required parameter "organizationId" was null or undefined when calling customChainRpcApiV1BlockchainsRpcEvmCustomChainRpcOrganizationIdChainIdPost().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token("bearerAuth", []);
      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request({
      path: `/api/v1/blockchains/rpc/evm/custom-chain-rpc/{organization_id}/{chain_id}`.replace(`{${"chain_id"}}`, encodeURIComponent(String(requestParameters["chainId"]))).replace(`{${"organization_id"}}`, encodeURIComponent(String(requestParameters["organizationId"]))),
      method: "POST",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    if (this.isJsonMime(response.headers.get("content-type"))) {
      return new JSONApiResponse(response);
    } else {
      return new TextApiResponse(response);
    }
  }
  /**
   * Issue a custom rpc command.
   * Custom Chain Rpc
   */
  async customChainRpcApiV1BlockchainsRpcEvmCustomChainRpcOrganizationIdChainIdPost(requestParameters, initOverrides) {
    const response = await this.customChainRpcApiV1BlockchainsRpcEvmCustomChainRpcOrganizationIdChainIdPostRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Disable a blockchain for the organization.
   * Disable Blockchain
   */
  async disableBlockchainApiV1BlockchainsChainDisablePostRaw(requestParameters, initOverrides) {
    if (requestParameters["chain"] == null) {
      throw new RequiredError(
        "chain",
        'Required parameter "chain" was null or undefined when calling disableBlockchainApiV1BlockchainsChainDisablePost().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token("bearerAuth", []);
      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request({
      path: `/api/v1/blockchains/{chain}/disable`.replace(`{${"chain"}}`, encodeURIComponent(String(requestParameters["chain"]))),
      method: "POST",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new VoidApiResponse(response);
  }
  /**
   * Disable a blockchain for the organization.
   * Disable Blockchain
   */
  async disableBlockchainApiV1BlockchainsChainDisablePost(requestParameters, initOverrides) {
    await this.disableBlockchainApiV1BlockchainsChainDisablePostRaw(requestParameters, initOverrides);
  }
  /**
   * Enable a blockchain for the organization.
   * Enable Blockchain
   */
  async enableBlockchainApiV1BlockchainsChainEnablePostRaw(requestParameters, initOverrides) {
    if (requestParameters["chain"] == null) {
      throw new RequiredError(
        "chain",
        'Required parameter "chain" was null or undefined when calling enableBlockchainApiV1BlockchainsChainEnablePost().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token("bearerAuth", []);
      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request({
      path: `/api/v1/blockchains/{chain}/enable`.replace(`{${"chain"}}`, encodeURIComponent(String(requestParameters["chain"]))),
      method: "POST",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new VoidApiResponse(response);
  }
  /**
   * Enable a blockchain for the organization.
   * Enable Blockchain
   */
  async enableBlockchainApiV1BlockchainsChainEnablePost(requestParameters, initOverrides) {
    await this.enableBlockchainApiV1BlockchainsChainEnablePostRaw(requestParameters, initOverrides);
  }
  /**
   * Get the suggested fees in a specific network.
   * Get Rpc Endpoints
   */
  async getRpcEndpointsApiV1BlockchainsRpcEndpointsGetRaw(initOverrides) {
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token("bearerAuth", []);
      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request({
      path: `/api/v1/blockchains/rpc-endpoints`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => GetRpcEndpointsResponseFromJSON(jsonValue));
  }
  /**
   * Get the suggested fees in a specific network.
   * Get Rpc Endpoints
   */
  async getRpcEndpointsApiV1BlockchainsRpcEndpointsGet(initOverrides) {
    const response = await this.getRpcEndpointsApiV1BlockchainsRpcEndpointsGetRaw(initOverrides);
    return await response.value();
  }
  /**
   * Get the suggested fees in a specific network.
   * Get Suggested Fees
   */
  async getSuggestedFeesApiV1BlockchainsSuggestedFeesGetRaw(requestParameters, initOverrides) {
    const queryParameters = {};
    if (requestParameters["chains"] != null) {
      queryParameters["chains"] = requestParameters["chains"];
    }
    if (requestParameters["chainTypes"] != null) {
      queryParameters["chain_types"] = requestParameters["chainTypes"];
    }
    const headerParameters = {};
    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token("bearerAuth", []);
      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request({
      path: `/api/v1/blockchains/suggested-fees`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => GetSuggestedFeesResponseFromJSON(jsonValue));
  }
  /**
   * Get the suggested fees in a specific network.
   * Get Suggested Fees
   */
  async getSuggestedFeesApiV1BlockchainsSuggestedFeesGet(requestParameters = {}, initOverrides) {
    const response = await this.getSuggestedFeesApiV1BlockchainsSuggestedFeesGetRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Get a list of supported blockchains.
   * List Chains
   */
  async listChainsApiV1BlockchainsGetRaw(requestParameters, initOverrides) {
    const queryParameters = {};
    if (requestParameters["page"] != null) {
      queryParameters["page"] = requestParameters["page"];
    }
    if (requestParameters["size"] != null) {
      queryParameters["size"] = requestParameters["size"];
    }
    if (requestParameters["responseType"] != null) {
      queryParameters["response_type"] = requestParameters["responseType"];
    }
    if (requestParameters["chainTypes"] != null) {
      queryParameters["chain_types"] = requestParameters["chainTypes"];
    }
    if (requestParameters["sources"] != null) {
      queryParameters["sources"] = requestParameters["sources"];
    }
    if (requestParameters["onlyInteractedWith"] != null) {
      queryParameters["only_interacted_with"] = requestParameters["onlyInteractedWith"];
    }
    if (requestParameters["search"] != null) {
      queryParameters["search"] = requestParameters["search"];
    }
    if (requestParameters["includeMainnets"] != null) {
      queryParameters["include_mainnets"] = requestParameters["includeMainnets"];
    }
    if (requestParameters["includeTestnets"] != null) {
      queryParameters["include_testnets"] = requestParameters["includeTestnets"];
    }
    if (requestParameters["includeExchanges"] != null) {
      queryParameters["include_exchanges"] = requestParameters["includeExchanges"];
    }
    if (requestParameters["showAll"] != null) {
      queryParameters["show_all"] = requestParameters["showAll"];
    }
    const headerParameters = {};
    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token("bearerAuth", []);
      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request({
      path: `/api/v1/blockchains`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => ListBlockchainsResponseFromJSON(jsonValue));
  }
  /**
   * Get a list of supported blockchains.
   * List Chains
   */
  async listChainsApiV1BlockchainsGet(requestParameters = {}, initOverrides) {
    const response = await this.listChainsApiV1BlockchainsGetRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Get a list of all supported dapps.
   * List Dapps
   */
  async listDappsApiV1BlockchainsDappsGetRaw(requestParameters, initOverrides) {
    const queryParameters = {};
    if (requestParameters["page"] != null) {
      queryParameters["page"] = requestParameters["page"];
    }
    if (requestParameters["size"] != null) {
      queryParameters["size"] = requestParameters["size"];
    }
    if (requestParameters["responseType"] != null) {
      queryParameters["response_type"] = requestParameters["responseType"];
    }
    if (requestParameters["search"] != null) {
      queryParameters["search"] = requestParameters["search"];
    }
    if (requestParameters["dappIds"] != null) {
      queryParameters["dapp_ids"] = requestParameters["dappIds"];
    }
    const headerParameters = {};
    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token("bearerAuth", []);
      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request({
      path: `/api/v1/blockchains/dapps`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => ListDappsResponseFromJSON(jsonValue));
  }
  /**
   * Get a list of all supported dapps.
   * List Dapps
   */
  async listDappsApiV1BlockchainsDappsGet(requestParameters = {}, initOverrides) {
    const response = await this.listDappsApiV1BlockchainsDappsGetRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Get a list of all interacted eip712 domains.
   * List Interacted Eip712 Domains
   */
  async listInteractedEip712DomainsApiV1BlockchainsEip712DomainsGetRaw(requestParameters, initOverrides) {
    const queryParameters = {};
    if (requestParameters["page"] != null) {
      queryParameters["page"] = requestParameters["page"];
    }
    if (requestParameters["size"] != null) {
      queryParameters["size"] = requestParameters["size"];
    }
    if (requestParameters["responseType"] != null) {
      queryParameters["response_type"] = requestParameters["responseType"];
    }
    if (requestParameters["search"] != null) {
      queryParameters["search"] = requestParameters["search"];
    }
    if (requestParameters["primaryTypes"] != null) {
      queryParameters["primary_types"] = requestParameters["primaryTypes"];
    }
    const headerParameters = {};
    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token("bearerAuth", []);
      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request({
      path: `/api/v1/blockchains/eip712-domains`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => ListEIP712DomainsFromJSON(jsonValue));
  }
  /**
   * Get a list of all interacted eip712 domains.
   * List Interacted Eip712 Domains
   */
  async listInteractedEip712DomainsApiV1BlockchainsEip712DomainsGet(requestParameters = {}, initOverrides) {
    const response = await this.listInteractedEip712DomainsApiV1BlockchainsEip712DomainsGetRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Get a list of all interacted eip712 primary types.
   * List Interacted Eip712 Primary Types
   */
  async listInteractedEip712PrimaryTypesApiV1BlockchainsEip712PrimaryTypesGetRaw(requestParameters, initOverrides) {
    const queryParameters = {};
    if (requestParameters["page"] != null) {
      queryParameters["page"] = requestParameters["page"];
    }
    if (requestParameters["size"] != null) {
      queryParameters["size"] = requestParameters["size"];
    }
    if (requestParameters["responseType"] != null) {
      queryParameters["response_type"] = requestParameters["responseType"];
    }
    if (requestParameters["search"] != null) {
      queryParameters["search"] = requestParameters["search"];
    }
    if (requestParameters["domains"] != null) {
      queryParameters["domains"] = requestParameters["domains"];
    }
    const headerParameters = {};
    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token("bearerAuth", []);
      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request({
      path: `/api/v1/blockchains/eip712-primary-types`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => ListEIP712PrimaryTypesFromJSON(jsonValue));
  }
  /**
   * Get a list of all interacted eip712 primary types.
   * List Interacted Eip712 Primary Types
   */
  async listInteractedEip712PrimaryTypesApiV1BlockchainsEip712PrimaryTypesGet(requestParameters = {}, initOverrides) {
    const response = await this.listInteractedEip712PrimaryTypesApiV1BlockchainsEip712PrimaryTypesGetRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Test the RPC connection to a custom chain.
   * Test Rpc
   */
  async testRpcApiV1BlockchainsTestRpcPostRaw(requestParameters, initOverrides) {
    if (requestParameters["testChainRequest"] == null) {
      throw new RequiredError(
        "testChainRequest",
        'Required parameter "testChainRequest" was null or undefined when calling testRpcApiV1BlockchainsTestRpcPost().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token("bearerAuth", []);
      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request({
      path: `/api/v1/blockchains/test-rpc`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: TestChainRequestToJSON(requestParameters["testChainRequest"])
    }, initOverrides);
    return new VoidApiResponse(response);
  }
  /**
   * Test the RPC connection to a custom chain.
   * Test Rpc
   */
  async testRpcApiV1BlockchainsTestRpcPost(requestParameters, initOverrides) {
    await this.testRpcApiV1BlockchainsTestRpcPostRaw(requestParameters, initOverrides);
  }
  /**
   * update a custom chain.
   * Update Chain
   */
  async updateChainApiV1BlockchainsPutRaw(requestParameters, initOverrides) {
    if (requestParameters["updateChainRequest"] == null) {
      throw new RequiredError(
        "updateChainRequest",
        'Required parameter "updateChainRequest" was null or undefined when calling updateChainApiV1BlockchainsPut().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token("bearerAuth", []);
      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request({
      path: `/api/v1/blockchains`,
      method: "PUT",
      headers: headerParameters,
      query: queryParameters,
      body: UpdateChainRequestToJSON(requestParameters["updateChainRequest"])
    }, initOverrides);
    if (this.isJsonMime(response.headers.get("content-type"))) {
      return new JSONApiResponse(response);
    } else {
      return new TextApiResponse(response);
    }
  }
  /**
   * update a custom chain.
   * Update Chain
   */
  async updateChainApiV1BlockchainsPut(requestParameters, initOverrides) {
    const response = await this.updateChainApiV1BlockchainsPutRaw(requestParameters, initOverrides);
    return await response.value();
  }
};

// src/openapi/apis/TransactionsApi.ts
var TransactionsApi = class extends BaseAPI {
  /**
   * Abort a transaction.  Abort is possible only for a transaction that is in one of the following states:    <ul>    <li>Waiting for approval    <li>Approved    </ul>  The aborting user must be one of the following: <ul> <li>The user who created the transaction <li>An admin <li>A legitimate approver </ul>  API users can abort only the transactions they created.
   * Abort Transaction
   */
  async abortTransactionApiV1TransactionsIdAbortPostRaw(requestParameters, initOverrides) {
    if (requestParameters["id"] == null) {
      throw new RequiredError(
        "id",
        'Required parameter "id" was null or undefined when calling abortTransactionApiV1TransactionsIdAbortPost().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token("bearerAuth", []);
      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request({
      path: `/api/v1/transactions/{id}/abort`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters["id"]))),
      method: "POST",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new VoidApiResponse(response);
  }
  /**
   * Abort a transaction.  Abort is possible only for a transaction that is in one of the following states:    <ul>    <li>Waiting for approval    <li>Approved    </ul>  The aborting user must be one of the following: <ul> <li>The user who created the transaction <li>An admin <li>A legitimate approver </ul>  API users can abort only the transactions they created.
   * Abort Transaction
   */
  async abortTransactionApiV1TransactionsIdAbortPost(requestParameters, initOverrides) {
    await this.abortTransactionApiV1TransactionsIdAbortPostRaw(requestParameters, initOverrides);
  }
  /**
   * Approve a transaction.  A transaction awaits approval when the caller API user has been specified as a potential approver in the policy and the transaction is in the `waiting_for_approval` state.
   * Approve Transaction
   */
  async approveTransactionApiV1TransactionsIdApprovePostRaw(requestParameters, initOverrides) {
    if (requestParameters["id"] == null) {
      throw new RequiredError(
        "id",
        'Required parameter "id" was null or undefined when calling approveTransactionApiV1TransactionsIdApprovePost().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token("bearerAuth", []);
      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request({
      path: `/api/v1/transactions/{id}/approve`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters["id"]))),
      method: "POST",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new VoidApiResponse(response);
  }
  /**
   * Approve a transaction.  A transaction awaits approval when the caller API user has been specified as a potential approver in the policy and the transaction is in the `waiting_for_approval` state.
   * Approve Transaction
   */
  async approveTransactionApiV1TransactionsIdApprovePost(requestParameters, initOverrides) {
    await this.approveTransactionApiV1TransactionsIdApprovePostRaw(requestParameters, initOverrides);
  }
  /**
   * Create a new transaction and wait until transaction reaches given state.
   * Create Transaction And Wait
   */
  async createTransactionAndWaitApiV1TransactionsCreateAndWaitPostRaw(requestParameters, initOverrides) {
    if (requestParameters["createTransactionWithWaitRequest"] == null) {
      throw new RequiredError(
        "createTransactionWithWaitRequest",
        'Required parameter "createTransactionWithWaitRequest" was null or undefined when calling createTransactionAndWaitApiV1TransactionsCreateAndWaitPost().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (requestParameters["xSignature"] != null) {
      headerParameters["x-signature"] = String(requestParameters["xSignature"]);
    }
    if (requestParameters["xTimestamp"] != null) {
      headerParameters["x-timestamp"] = String(requestParameters["xTimestamp"]);
    }
    if (requestParameters["xIdempotenceId"] != null) {
      headerParameters["x-idempotence-id"] = String(requestParameters["xIdempotenceId"]);
    }
    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token("bearerAuth", []);
      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request({
      path: `/api/v1/transactions/create-and-wait`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: CreateTransactionWithWaitRequestToJSON(requestParameters["createTransactionWithWaitRequest"])
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => CreateTransactionWithWaitResponseFromJSON(jsonValue));
  }
  /**
   * Create a new transaction and wait until transaction reaches given state.
   * Create Transaction And Wait
   */
  async createTransactionAndWaitApiV1TransactionsCreateAndWaitPost(requestParameters, initOverrides) {
    const response = await this.createTransactionAndWaitApiV1TransactionsCreateAndWaitPostRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Create a new transaction.
   * Create Transaction
   */
  async createTransactionApiV1TransactionsPostRaw(requestParameters, initOverrides) {
    if (requestParameters["createTransactionRequest"] == null) {
      throw new RequiredError(
        "createTransactionRequest",
        'Required parameter "createTransactionRequest" was null or undefined when calling createTransactionApiV1TransactionsPost().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (requestParameters["xSignature"] != null) {
      headerParameters["x-signature"] = String(requestParameters["xSignature"]);
    }
    if (requestParameters["xTimestamp"] != null) {
      headerParameters["x-timestamp"] = String(requestParameters["xTimestamp"]);
    }
    if (requestParameters["xIdempotenceId"] != null) {
      headerParameters["x-idempotence-id"] = String(requestParameters["xIdempotenceId"]);
    }
    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token("bearerAuth", []);
      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request({
      path: `/api/v1/transactions`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: CreateTransactionRequestToJSON(requestParameters["createTransactionRequest"])
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => CreateTransactionResponseFromJSON(jsonValue));
  }
  /**
   * Create a new transaction.
   * Create Transaction
   */
  async createTransactionApiV1TransactionsPost(requestParameters, initOverrides) {
    const response = await this.createTransactionApiV1TransactionsPostRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Start the export process for filtered transactions
   * Export Transactions
   */
  async exportTransactionsApiV1TransactionsExportGetRaw(requestParameters, initOverrides) {
    const queryParameters = {};
    if (requestParameters["limit"] != null) {
      queryParameters["limit"] = requestParameters["limit"];
    }
    if (requestParameters["createdBefore"] != null) {
      queryParameters["created_before"] = requestParameters["createdBefore"].toISOString();
    }
    if (requestParameters["createdAfter"] != null) {
      queryParameters["created_after"] = requestParameters["createdAfter"].toISOString();
    }
    if (requestParameters["modifiedAfter"] != null) {
      queryParameters["modified_after"] = requestParameters["modifiedAfter"].toISOString();
    }
    if (requestParameters["vaultIds"] != null) {
      queryParameters["vault_ids"] = requestParameters["vaultIds"];
    }
    if (requestParameters["chains"] != null) {
      queryParameters["chains"] = requestParameters["chains"];
    }
    if (requestParameters["initiatorIds"] != null) {
      queryParameters["initiator_ids"] = requestParameters["initiatorIds"];
    }
    if (requestParameters["types"] != null) {
      queryParameters["types"] = requestParameters["types"];
    }
    if (requestParameters["subTypes"] != null) {
      queryParameters["sub_types"] = requestParameters["subTypes"];
    }
    if (requestParameters["signerTypes"] != null) {
      queryParameters["signer_types"] = requestParameters["signerTypes"];
    }
    if (requestParameters["transactionIds"] != null) {
      queryParameters["transaction_ids"] = requestParameters["transactionIds"];
    }
    if (requestParameters["endUserIds"] != null) {
      queryParameters["end_user_ids"] = requestParameters["endUserIds"];
    }
    if (requestParameters["assetIds"] != null) {
      queryParameters["asset_ids"] = requestParameters["assetIds"];
    }
    if (requestParameters["direction"] != null) {
      queryParameters["direction"] = requestParameters["direction"];
    }
    if (requestParameters["transactionHashes"] != null) {
      queryParameters["transaction_hashes"] = requestParameters["transactionHashes"];
    }
    if (requestParameters["search"] != null) {
      queryParameters["search"] = requestParameters["search"];
    }
    const headerParameters = {};
    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token("bearerAuth", []);
      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request({
      path: `/api/v1/transactions/export`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => ExportFromJSON(jsonValue));
  }
  /**
   * Start the export process for filtered transactions
   * Export Transactions
   */
  async exportTransactionsApiV1TransactionsExportGet(requestParameters = {}, initOverrides) {
    const response = await this.exportTransactionsApiV1TransactionsExportGetRaw(requestParameters, initOverrides);
    switch (response.raw.status) {
      case 200:
        return await response.value();
      case 204:
        return null;
      default:
        return await response.value();
    }
  }
  /**
   * Retrieve transaction details.
   * Get Transaction
   */
  async getTransactionApiV1TransactionsIdGetRaw(requestParameters, initOverrides) {
    if (requestParameters["id"] == null) {
      throw new RequiredError(
        "id",
        'Required parameter "id" was null or undefined when calling getTransactionApiV1TransactionsIdGet().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token("bearerAuth", []);
      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request({
      path: `/api/v1/transactions/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters["id"]))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => GetTransactionResponseFromJSON(jsonValue));
  }
  /**
   * Retrieve transaction details.
   * Get Transaction
   */
  async getTransactionApiV1TransactionsIdGet(requestParameters, initOverrides) {
    const response = await this.getTransactionApiV1TransactionsIdGetRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Get a list of all transactions in an organization.
   * List Transactions
   */
  async listTransactionsApiV1TransactionsGetRaw(requestParameters, initOverrides) {
    const queryParameters = {};
    if (requestParameters["page"] != null) {
      queryParameters["page"] = requestParameters["page"];
    }
    if (requestParameters["size"] != null) {
      queryParameters["size"] = requestParameters["size"];
    }
    if (requestParameters["responseType"] != null) {
      queryParameters["response_type"] = requestParameters["responseType"];
    }
    if (requestParameters["createdBefore"] != null) {
      queryParameters["created_before"] = requestParameters["createdBefore"].toISOString();
    }
    if (requestParameters["createdAfter"] != null) {
      queryParameters["created_after"] = requestParameters["createdAfter"].toISOString();
    }
    if (requestParameters["modifiedAfter"] != null) {
      queryParameters["modified_after"] = requestParameters["modifiedAfter"].toISOString();
    }
    if (requestParameters["vaultIds"] != null) {
      queryParameters["vault_ids"] = requestParameters["vaultIds"];
    }
    if (requestParameters["chains"] != null) {
      queryParameters["chains"] = requestParameters["chains"];
    }
    if (requestParameters["initiatorIds"] != null) {
      queryParameters["initiator_ids"] = requestParameters["initiatorIds"];
    }
    if (requestParameters["types"] != null) {
      queryParameters["types"] = requestParameters["types"];
    }
    if (requestParameters["subTypes"] != null) {
      queryParameters["sub_types"] = requestParameters["subTypes"];
    }
    if (requestParameters["signerTypes"] != null) {
      queryParameters["signer_types"] = requestParameters["signerTypes"];
    }
    if (requestParameters["transactionIds"] != null) {
      queryParameters["transaction_ids"] = requestParameters["transactionIds"];
    }
    if (requestParameters["endUserIds"] != null) {
      queryParameters["end_user_ids"] = requestParameters["endUserIds"];
    }
    if (requestParameters["assetIds"] != null) {
      queryParameters["asset_ids"] = requestParameters["assetIds"];
    }
    if (requestParameters["direction"] != null) {
      queryParameters["direction"] = requestParameters["direction"];
    }
    if (requestParameters["transactionHashes"] != null) {
      queryParameters["transaction_hashes"] = requestParameters["transactionHashes"];
    }
    if (requestParameters["search"] != null) {
      queryParameters["search"] = requestParameters["search"];
    }
    if (requestParameters["states"] != null) {
      queryParameters["states"] = requestParameters["states"];
    }
    if (requestParameters["isHidden"] != null) {
      queryParameters["is_hidden"] = requestParameters["isHidden"];
    }
    if (requestParameters["includeFullResponse"] != null) {
      queryParameters["include_full_response"] = requestParameters["includeFullResponse"];
    }
    if (requestParameters["batchIds"] != null) {
      queryParameters["batch_ids"] = requestParameters["batchIds"];
    }
    if (requestParameters["includeBlackbox"] != null) {
      queryParameters["include_blackbox"] = requestParameters["includeBlackbox"];
    }
    if (requestParameters["sortBy"] != null) {
      queryParameters["sort_by"] = requestParameters["sortBy"];
    }
    const headerParameters = {};
    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token("bearerAuth", []);
      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request({
      path: `/api/v1/transactions`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => ListTransactionResponseFromJSON(jsonValue));
  }
  /**
   * Get a list of all transactions in an organization.
   * List Transactions
   */
  async listTransactionsApiV1TransactionsGet(requestParameters = {}, initOverrides) {
    const response = await this.listTransactionsApiV1TransactionsGetRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Simulate the transaction and changes in token balances, in addition to the fee estimation.
   * Predict Transaction
   */
  async predictTransactionApiV1TransactionsPredictPostRaw(requestParameters, initOverrides) {
    if (requestParameters["predictTransactionRequest"] == null) {
      throw new RequiredError(
        "predictTransactionRequest",
        'Required parameter "predictTransactionRequest" was null or undefined when calling predictTransactionApiV1TransactionsPredictPost().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token("bearerAuth", []);
      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request({
      path: `/api/v1/transactions/predict`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: PredictTransactionRequestToJSON(requestParameters["predictTransactionRequest"])
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => PredictTransactionResponseFromJSON(jsonValue));
  }
  /**
   * Simulate the transaction and changes in token balances, in addition to the fee estimation.
   * Predict Transaction
   */
  async predictTransactionApiV1TransactionsPredictPost(requestParameters, initOverrides) {
    const response = await this.predictTransactionApiV1TransactionsPredictPostRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Get the first transaction ready for signing by api-signer while it already registered for signing.
   * Process Next Api Signer Transaction V3
   */
  async processNextApiSignerTransactionV3ApiV1TransactionsNextApiSignerTransactionV3PostRaw(requestParameters, initOverrides) {
    if (requestParameters["nextApiSignerTransactionRequestV3"] == null) {
      throw new RequiredError(
        "nextApiSignerTransactionRequestV3",
        'Required parameter "nextApiSignerTransactionRequestV3" was null or undefined when calling processNextApiSignerTransactionV3ApiV1TransactionsNextApiSignerTransactionV3Post().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token("bearerAuth", []);
      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request({
      path: `/api/v1/transactions/next_api_signer_transaction_v3`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: NextApiSignerTransactionRequestV3ToJSON(requestParameters["nextApiSignerTransactionRequestV3"])
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => NextApiSignerTransactionResponseV3FromJSON(jsonValue));
  }
  /**
   * Get the first transaction ready for signing by api-signer while it already registered for signing.
   * Process Next Api Signer Transaction V3
   */
  async processNextApiSignerTransactionV3ApiV1TransactionsNextApiSignerTransactionV3Post(requestParameters, initOverrides) {
    const response = await this.processNextApiSignerTransactionV3ApiV1TransactionsNextApiSignerTransactionV3PostRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Get the first transaction ready for signing by api-signer while it already registered for signing.
   * Process Next Api Signer Transaction V4
   */
  async processNextApiSignerTransactionV4ApiV1TransactionsNextApiSignerTransactionV4PostRaw(requestParameters, initOverrides) {
    if (requestParameters["nextApiSignerTransactionRequestV4"] == null) {
      throw new RequiredError(
        "nextApiSignerTransactionRequestV4",
        'Required parameter "nextApiSignerTransactionRequestV4" was null or undefined when calling processNextApiSignerTransactionV4ApiV1TransactionsNextApiSignerTransactionV4Post().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token("bearerAuth", []);
      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request({
      path: `/api/v1/transactions/next_api_signer_transaction_v4`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: NextApiSignerTransactionRequestV4ToJSON(requestParameters["nextApiSignerTransactionRequestV4"])
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => NextApiSignerTransactionResponseV4FromJSON(jsonValue));
  }
  /**
   * Get the first transaction ready for signing by api-signer while it already registered for signing.
   * Process Next Api Signer Transaction V4
   */
  async processNextApiSignerTransactionV4ApiV1TransactionsNextApiSignerTransactionV4Post(requestParameters, initOverrides) {
    const response = await this.processNextApiSignerTransactionV4ApiV1TransactionsNextApiSignerTransactionV4PostRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Push an existing signed transaction to the chain. The transaction must have been previously created with a `push_mode: manual` flag and must now be in state `signed`.
   * Push Transaction
   */
  async pushTransactionApiV1TransactionsIdPushPostRaw(requestParameters, initOverrides) {
    if (requestParameters["id"] == null) {
      throw new RequiredError(
        "id",
        'Required parameter "id" was null or undefined when calling pushTransactionApiV1TransactionsIdPushPost().'
      );
    }
    if (requestParameters["pushTransactionRequest"] == null) {
      throw new RequiredError(
        "pushTransactionRequest",
        'Required parameter "pushTransactionRequest" was null or undefined when calling pushTransactionApiV1TransactionsIdPushPost().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token("bearerAuth", []);
      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request({
      path: `/api/v1/transactions/{id}/push`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters["id"]))),
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: PushTransactionRequestToJSON(requestParameters["pushTransactionRequest"])
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => PushTransactionResponseFromJSON(jsonValue));
  }
  /**
   * Push an existing signed transaction to the chain. The transaction must have been previously created with a `push_mode: manual` flag and must now be in state `signed`.
   * Push Transaction
   */
  async pushTransactionApiV1TransactionsIdPushPost(requestParameters, initOverrides) {
    const response = await this.pushTransactionApiV1TransactionsIdPushPostRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Push a transaction to the chain, the transaction is identified by its data.
   * Push Transaction By Data
   */
  async pushTransactionByDataApiV1TransactionsPushByDataPostRaw(requestParameters, initOverrides) {
    if (requestParameters["pushTransactionByDataRequest"] == null) {
      throw new RequiredError(
        "pushTransactionByDataRequest",
        'Required parameter "pushTransactionByDataRequest" was null or undefined when calling pushTransactionByDataApiV1TransactionsPushByDataPost().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token("bearerAuth", []);
      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request({
      path: `/api/v1/transactions/push-by-data`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: PushTransactionByDataRequestToJSON(requestParameters["pushTransactionByDataRequest"])
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => PushTransactionByDataResponseFromJSON(jsonValue));
  }
  /**
   * Push a transaction to the chain, the transaction is identified by its data.
   * Push Transaction By Data
   */
  async pushTransactionByDataApiV1TransactionsPushByDataPost(requestParameters, initOverrides) {
    const response = await this.pushTransactionByDataApiV1TransactionsPushByDataPostRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Refresh a transaction.
   * Refresh Transaction
   */
  async refreshTransactionApiV1TransactionsIdRefreshPostRaw(requestParameters, initOverrides) {
    if (requestParameters["id"] == null) {
      throw new RequiredError(
        "id",
        'Required parameter "id" was null or undefined when calling refreshTransactionApiV1TransactionsIdRefreshPost().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token("bearerAuth", []);
      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request({
      path: `/api/v1/transactions/{id}/refresh`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters["id"]))),
      method: "POST",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => RefreshTransactionResponseFromJSON(jsonValue));
  }
  /**
   * Refresh a transaction.
   * Refresh Transaction
   */
  async refreshTransactionApiV1TransactionsIdRefreshPost(requestParameters, initOverrides) {
    const response = await this.refreshTransactionApiV1TransactionsIdRefreshPostRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Register a sign-session for a transaction.
   * Register Transaction Sign Session
   */
  async registerTransactionSignSessionApiV1TransactionsIdRegisterSignSessionPostRaw(requestParameters, initOverrides) {
    if (requestParameters["id"] == null) {
      throw new RequiredError(
        "id",
        'Required parameter "id" was null or undefined when calling registerTransactionSignSessionApiV1TransactionsIdRegisterSignSessionPost().'
      );
    }
    if (requestParameters["registerTransactionSignSessionRequest"] == null) {
      throw new RequiredError(
        "registerTransactionSignSessionRequest",
        'Required parameter "registerTransactionSignSessionRequest" was null or undefined when calling registerTransactionSignSessionApiV1TransactionsIdRegisterSignSessionPost().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token("bearerAuth", []);
      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request({
      path: `/api/v1/transactions/{id}/register-sign-session`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters["id"]))),
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: RegisterTransactionSignSessionRequestToJSON(requestParameters["registerTransactionSignSessionRequest"])
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => RegisterTransactionSignSessionResponseFromJSON(jsonValue));
  }
  /**
   * Register a sign-session for a transaction.
   * Register Transaction Sign Session
   */
  async registerTransactionSignSessionApiV1TransactionsIdRegisterSignSessionPost(requestParameters, initOverrides) {
    const response = await this.registerTransactionSignSessionApiV1TransactionsIdRegisterSignSessionPostRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Release a transaction.
   * Release Transaction
   */
  async releaseTransactionApiV1TransactionsIdReleasePostRaw(requestParameters, initOverrides) {
    if (requestParameters["id"] == null) {
      throw new RequiredError(
        "id",
        'Required parameter "id" was null or undefined when calling releaseTransactionApiV1TransactionsIdReleasePost().'
      );
    }
    if (requestParameters["releaseTransactionRequest"] == null) {
      throw new RequiredError(
        "releaseTransactionRequest",
        'Required parameter "releaseTransactionRequest" was null or undefined when calling releaseTransactionApiV1TransactionsIdReleasePost().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (requestParameters["xSignature"] != null) {
      headerParameters["x-signature"] = String(requestParameters["xSignature"]);
    }
    if (requestParameters["xTimestamp"] != null) {
      headerParameters["x-timestamp"] = String(requestParameters["xTimestamp"]);
    }
    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token("bearerAuth", []);
      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request({
      path: `/api/v1/transactions/{id}/release`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters["id"]))),
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: ReleaseTransactionRequestToJSON(requestParameters["releaseTransactionRequest"])
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => ReleaseTransactionResponseFromJSON(jsonValue));
  }
  /**
   * Release a transaction.
   * Release Transaction
   */
  async releaseTransactionApiV1TransactionsIdReleasePost(requestParameters, initOverrides) {
    const response = await this.releaseTransactionApiV1TransactionsIdReleasePostRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Submit transaction to exchange.
   * Submit To Exchange
   */
  async submitToExchangeApiV1TransactionsIdSubmitToExchangePostRaw(requestParameters, initOverrides) {
    if (requestParameters["id"] == null) {
      throw new RequiredError(
        "id",
        'Required parameter "id" was null or undefined when calling submitToExchangeApiV1TransactionsIdSubmitToExchangePost().'
      );
    }
    if (requestParameters["body"] == null) {
      throw new RequiredError(
        "body",
        'Required parameter "body" was null or undefined when calling submitToExchangeApiV1TransactionsIdSubmitToExchangePost().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token("bearerAuth", []);
      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request({
      path: `/api/v1/transactions/{id}/submit-to-exchange`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters["id"]))),
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters["body"]
    }, initOverrides);
    if (this.isJsonMime(response.headers.get("content-type"))) {
      return new JSONApiResponse(response);
    } else {
      return new TextApiResponse(response);
    }
  }
  /**
   * Submit transaction to exchange.
   * Submit To Exchange
   */
  async submitToExchangeApiV1TransactionsIdSubmitToExchangePost(requestParameters, initOverrides) {
    const response = await this.submitToExchangeApiV1TransactionsIdSubmitToExchangePostRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Submit a signature for a transaction.
   * Submit Transaction Signature
   */
  async submitTransactionSignatureApiV1TransactionsIdSubmitSignaturePostRaw(requestParameters, initOverrides) {
    if (requestParameters["id"] == null) {
      throw new RequiredError(
        "id",
        'Required parameter "id" was null or undefined when calling submitTransactionSignatureApiV1TransactionsIdSubmitSignaturePost().'
      );
    }
    if (requestParameters["body"] == null) {
      throw new RequiredError(
        "body",
        'Required parameter "body" was null or undefined when calling submitTransactionSignatureApiV1TransactionsIdSubmitSignaturePost().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token("bearerAuth", []);
      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request({
      path: `/api/v1/transactions/{id}/submit-signature`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters["id"]))),
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters["body"]
    }, initOverrides);
    if (this.isJsonMime(response.headers.get("content-type"))) {
      return new JSONApiResponse(response);
    } else {
      return new TextApiResponse(response);
    }
  }
  /**
   * Submit a signature for a transaction.
   * Submit Transaction Signature
   */
  async submitTransactionSignatureApiV1TransactionsIdSubmitSignaturePost(requestParameters, initOverrides) {
    const response = await this.submitTransactionSignatureApiV1TransactionsIdSubmitSignaturePostRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Trigger transaction auto revoke protection.
   * Trigger Auto Revoke Protection
   */
  async triggerAutoRevokeProtectionApiV1TransactionsTriggerAutoRevokeProtectionPostRaw(requestParameters, initOverrides) {
    if (requestParameters["triggerAutoProtectionRequest"] == null) {
      throw new RequiredError(
        "triggerAutoProtectionRequest",
        'Required parameter "triggerAutoProtectionRequest" was null or undefined when calling triggerAutoRevokeProtectionApiV1TransactionsTriggerAutoRevokeProtectionPost().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token("bearerAuth", []);
      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request({
      path: `/api/v1/transactions/trigger-auto-revoke-protection`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: TriggerAutoProtectionRequestToJSON(requestParameters["triggerAutoProtectionRequest"])
    }, initOverrides);
    return new VoidApiResponse(response);
  }
  /**
   * Trigger transaction auto revoke protection.
   * Trigger Auto Revoke Protection
   */
  async triggerAutoRevokeProtectionApiV1TransactionsTriggerAutoRevokeProtectionPost(requestParameters, initOverrides) {
    await this.triggerAutoRevokeProtectionApiV1TransactionsTriggerAutoRevokeProtectionPostRaw(requestParameters, initOverrides);
  }
  /**
   * Trigger transaction signing.
   * Trigger Transaction Signing
   */
  async triggerTransactionSigningApiV1TransactionsIdTriggerSigningPostRaw(requestParameters, initOverrides) {
    if (requestParameters["id"] == null) {
      throw new RequiredError(
        "id",
        'Required parameter "id" was null or undefined when calling triggerTransactionSigningApiV1TransactionsIdTriggerSigningPost().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token("bearerAuth", []);
      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request({
      path: `/api/v1/transactions/{id}/trigger-signing`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters["id"]))),
      method: "POST",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new VoidApiResponse(response);
  }
  /**
   * Trigger transaction signing.
   * Trigger Transaction Signing
   */
  async triggerTransactionSigningApiV1TransactionsIdTriggerSigningPost(requestParameters, initOverrides) {
    await this.triggerTransactionSigningApiV1TransactionsIdTriggerSigningPostRaw(requestParameters, initOverrides);
  }
  /**
   * Update a transaction before signing it.
   * Update Transaction For Signing
   */
  async updateTransactionForSigningApiV1TransactionsIdUpdateForSigningPostRaw(requestParameters, initOverrides) {
    if (requestParameters["id"] == null) {
      throw new RequiredError(
        "id",
        'Required parameter "id" was null or undefined when calling updateTransactionForSigningApiV1TransactionsIdUpdateForSigningPost().'
      );
    }
    if (requestParameters["body"] == null) {
      throw new RequiredError(
        "body",
        'Required parameter "body" was null or undefined when calling updateTransactionForSigningApiV1TransactionsIdUpdateForSigningPost().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token("bearerAuth", []);
      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request({
      path: `/api/v1/transactions/{id}/update-for-signing`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters["id"]))),
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters["body"]
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => UpdateTransactionForSigningResponseFromJSON(jsonValue));
  }
  /**
   * Update a transaction before signing it.
   * Update Transaction For Signing
   */
  async updateTransactionForSigningApiV1TransactionsIdUpdateForSigningPost(requestParameters, initOverrides) {
    const response = await this.updateTransactionForSigningApiV1TransactionsIdUpdateForSigningPostRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Update transaction\'s spam state.
   * Update Transaction Spam State
   */
  async updateTransactionSpamStateApiV1TransactionsIdUpdateSpamStatePutRaw(requestParameters, initOverrides) {
    if (requestParameters["id"] == null) {
      throw new RequiredError(
        "id",
        'Required parameter "id" was null or undefined when calling updateTransactionSpamStateApiV1TransactionsIdUpdateSpamStatePut().'
      );
    }
    if (requestParameters["updateTransactionSpamStateRequest"] == null) {
      throw new RequiredError(
        "updateTransactionSpamStateRequest",
        'Required parameter "updateTransactionSpamStateRequest" was null or undefined when calling updateTransactionSpamStateApiV1TransactionsIdUpdateSpamStatePut().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token("bearerAuth", []);
      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request({
      path: `/api/v1/transactions/{id}/update-spam-state`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters["id"]))),
      method: "PUT",
      headers: headerParameters,
      query: queryParameters,
      body: UpdateTransactionSpamStateRequestToJSON(requestParameters["updateTransactionSpamStateRequest"])
    }, initOverrides);
    return new VoidApiResponse(response);
  }
  /**
   * Update transaction\'s spam state.
   * Update Transaction Spam State
   */
  async updateTransactionSpamStateApiV1TransactionsIdUpdateSpamStatePut(requestParameters, initOverrides) {
    await this.updateTransactionSpamStateApiV1TransactionsIdUpdateSpamStatePutRaw(requestParameters, initOverrides);
  }
};

// src/openapi/apis/VaultsApi.ts
var VaultsApi = class extends BaseAPI {
  /**
   * Add a specific asset to a vault.
   * Add Vault Asset
   */
  async addVaultAssetApiV1VaultsIdAssetsAssetIdPostRaw(requestParameters, initOverrides) {
    if (requestParameters["id"] == null) {
      throw new RequiredError(
        "id",
        'Required parameter "id" was null or undefined when calling addVaultAssetApiV1VaultsIdAssetsAssetIdPost().'
      );
    }
    if (requestParameters["assetId"] == null) {
      throw new RequiredError(
        "assetId",
        'Required parameter "assetId" was null or undefined when calling addVaultAssetApiV1VaultsIdAssetsAssetIdPost().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token("bearerAuth", []);
      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request({
      path: `/api/v1/vaults/{id}/assets/{asset_id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters["id"]))).replace(`{${"asset_id"}}`, encodeURIComponent(String(requestParameters["assetId"]))),
      method: "POST",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => OwnedAssetFromJSON(jsonValue));
  }
  /**
   * Add a specific asset to a vault.
   * Add Vault Asset
   */
  async addVaultAssetApiV1VaultsIdAssetsAssetIdPost(requestParameters, initOverrides) {
    const response = await this.addVaultAssetApiV1VaultsIdAssetsAssetIdPostRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Archive an existing vault.
   * Archive Vault
   */
  async archiveVaultApiV1VaultsIdArchivePostRaw(requestParameters, initOverrides) {
    if (requestParameters["id"] == null) {
      throw new RequiredError(
        "id",
        'Required parameter "id" was null or undefined when calling archiveVaultApiV1VaultsIdArchivePost().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token("bearerAuth", []);
      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request({
      path: `/api/v1/vaults/{id}/archive`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters["id"]))),
      method: "POST",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new VoidApiResponse(response);
  }
  /**
   * Archive an existing vault.
   * Archive Vault
   */
  async archiveVaultApiV1VaultsIdArchivePost(requestParameters, initOverrides) {
    await this.archiveVaultApiV1VaultsIdArchivePostRaw(requestParameters, initOverrides);
  }
  /**
   * Create a new address.
   * Create Address
   */
  async createAddressApiV1VaultsIdAddressesPostRaw(requestParameters, initOverrides) {
    if (requestParameters["id"] == null) {
      throw new RequiredError(
        "id",
        'Required parameter "id" was null or undefined when calling createAddressApiV1VaultsIdAddressesPost().'
      );
    }
    if (requestParameters["body"] == null) {
      throw new RequiredError(
        "body",
        'Required parameter "body" was null or undefined when calling createAddressApiV1VaultsIdAddressesPost().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token("bearerAuth", []);
      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request({
      path: `/api/v1/vaults/{id}/addresses`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters["id"]))),
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters["body"]
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => UtxoVaultAddressFromJSON(jsonValue));
  }
  /**
   * Create a new address.
   * Create Address
   */
  async createAddressApiV1VaultsIdAddressesPost(requestParameters, initOverrides) {
    const response = await this.createAddressApiV1VaultsIdAddressesPostRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Create a new vault.
   * Create Vault
   */
  async createVaultApiV1VaultsPostRaw(requestParameters, initOverrides) {
    if (requestParameters["createVaultRequest"] == null) {
      throw new RequiredError(
        "createVaultRequest",
        'Required parameter "createVaultRequest" was null or undefined when calling createVaultApiV1VaultsPost().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token("bearerAuth", []);
      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request({
      path: `/api/v1/vaults`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: CreateVaultRequestToJSON(requestParameters["createVaultRequest"])
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => CreateVaultResponseFromJSON(jsonValue));
  }
  /**
   * Create a new vault.
   * Create Vault
   */
  async createVaultApiV1VaultsPost(requestParameters, initOverrides) {
    const response = await this.createVaultApiV1VaultsPostRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Get a CSV-format list of balances of all vaults and their assets.
   * Export Vaults With Assets
   */
  async exportVaultsWithAssetsApiV1VaultsExportGetRaw(requestParameters, initOverrides) {
    const queryParameters = {};
    if (requestParameters["vaultsIds"] != null) {
      queryParameters["vaults_ids"] = requestParameters["vaultsIds"];
    }
    if (requestParameters["vaultTypes"] != null) {
      queryParameters["vault_types"] = requestParameters["vaultTypes"];
    }
    const headerParameters = {};
    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token("bearerAuth", []);
      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request({
      path: `/api/v1/vaults/export`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    if (this.isJsonMime(response.headers.get("content-type"))) {
      return new JSONApiResponse(response);
    } else {
      return new TextApiResponse(response);
    }
  }
  /**
   * Get a CSV-format list of balances of all vaults and their assets.
   * Export Vaults With Assets
   */
  async exportVaultsWithAssetsApiV1VaultsExportGet(requestParameters = {}, initOverrides) {
    const response = await this.exportVaultsWithAssetsApiV1VaultsExportGetRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Retrieve vault details.
   * Get Vault
   */
  async getVaultApiV1VaultsIdGetRaw(requestParameters, initOverrides) {
    if (requestParameters["id"] == null) {
      throw new RequiredError(
        "id",
        'Required parameter "id" was null or undefined when calling getVaultApiV1VaultsIdGet().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token("bearerAuth", []);
      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request({
      path: `/api/v1/vaults/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters["id"]))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => GetVaultResponseFromJSON(jsonValue));
  }
  /**
   * Retrieve vault details.
   * Get Vault
   */
  async getVaultApiV1VaultsIdGet(requestParameters, initOverrides) {
    const response = await this.getVaultApiV1VaultsIdGetRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Get a specific asset in a vault.
   * Get Vault Asset
   */
  async getVaultAssetApiV1VaultsIdAssetsAssetIdGetRaw(requestParameters, initOverrides) {
    if (requestParameters["id"] == null) {
      throw new RequiredError(
        "id",
        'Required parameter "id" was null or undefined when calling getVaultAssetApiV1VaultsIdAssetsAssetIdGet().'
      );
    }
    if (requestParameters["assetId"] == null) {
      throw new RequiredError(
        "assetId",
        'Required parameter "assetId" was null or undefined when calling getVaultAssetApiV1VaultsIdAssetsAssetIdGet().'
      );
    }
    const queryParameters = {};
    if (requestParameters["page"] != null) {
      queryParameters["page"] = requestParameters["page"];
    }
    if (requestParameters["size"] != null) {
      queryParameters["size"] = requestParameters["size"];
    }
    if (requestParameters["responseType"] != null) {
      queryParameters["response_type"] = requestParameters["responseType"];
    }
    const headerParameters = {};
    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token("bearerAuth", []);
      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request({
      path: `/api/v1/vaults/{id}/assets/{asset_id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters["id"]))).replace(`{${"asset_id"}}`, encodeURIComponent(String(requestParameters["assetId"]))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => OwnedAssetFromJSON(jsonValue));
  }
  /**
   * Get a specific asset in a vault.
   * Get Vault Asset
   */
  async getVaultAssetApiV1VaultsIdAssetsAssetIdGet(requestParameters, initOverrides) {
    const response = await this.getVaultAssetApiV1VaultsIdAssetsAssetIdGetRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Get a list of all assets in a vault.
   * Get Vault Assets
   */
  async getVaultAssetsApiV1VaultsIdAssetsGetRaw(requestParameters, initOverrides) {
    if (requestParameters["id"] == null) {
      throw new RequiredError(
        "id",
        'Required parameter "id" was null or undefined when calling getVaultAssetsApiV1VaultsIdAssetsGet().'
      );
    }
    const queryParameters = {};
    if (requestParameters["page"] != null) {
      queryParameters["page"] = requestParameters["page"];
    }
    if (requestParameters["size"] != null) {
      queryParameters["size"] = requestParameters["size"];
    }
    if (requestParameters["responseType"] != null) {
      queryParameters["response_type"] = requestParameters["responseType"];
    }
    if (requestParameters["chains"] != null) {
      queryParameters["chains"] = requestParameters["chains"];
    }
    if (requestParameters["assetIds"] != null) {
      queryParameters["asset_ids"] = requestParameters["assetIds"];
    }
    if (requestParameters["isHidden"] != null) {
      queryParameters["is_hidden"] = requestParameters["isHidden"];
    }
    if (requestParameters["search"] != null) {
      queryParameters["search"] = requestParameters["search"];
    }
    if (requestParameters["isTransferrable"] != null) {
      queryParameters["is_transferrable"] = requestParameters["isTransferrable"];
    }
    if (requestParameters["sortBy"] != null) {
      queryParameters["sort_by"] = requestParameters["sortBy"];
    }
    const headerParameters = {};
    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token("bearerAuth", []);
      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request({
      path: `/api/v1/vaults/{id}/assets`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters["id"]))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => ListOwnedAssetsResponseFromJSON(jsonValue));
  }
  /**
   * Get a list of all assets in a vault.
   * Get Vault Assets
   */
  async getVaultAssetsApiV1VaultsIdAssetsGet(requestParameters, initOverrides) {
    const response = await this.getVaultAssetsApiV1VaultsIdAssetsGetRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Retrieve extra vault details.
   * Get Vault Metadata
   */
  async getVaultMetadataApiV1VaultsIdMetadataGetRaw(requestParameters, initOverrides) {
    if (requestParameters["id"] == null) {
      throw new RequiredError(
        "id",
        'Required parameter "id" was null or undefined when calling getVaultMetadataApiV1VaultsIdMetadataGet().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token("bearerAuth", []);
      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request({
      path: `/api/v1/vaults/{id}/metadata`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters["id"]))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => VaultMetadataFromJSON(jsonValue));
  }
  /**
   * Retrieve extra vault details.
   * Get Vault Metadata
   */
  async getVaultMetadataApiV1VaultsIdMetadataGet(requestParameters, initOverrides) {
    const response = await this.getVaultMetadataApiV1VaultsIdMetadataGetRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Get a list of all addresses in a vault.
   * List Vault Addresses
   */
  async listVaultAddressesApiV1VaultsIdAddressesGetRaw(requestParameters, initOverrides) {
    if (requestParameters["id"] == null) {
      throw new RequiredError(
        "id",
        'Required parameter "id" was null or undefined when calling listVaultAddressesApiV1VaultsIdAddressesGet().'
      );
    }
    const queryParameters = {};
    if (requestParameters["sortBy"] != null) {
      queryParameters["sort_by"] = requestParameters["sortBy"];
    }
    if (requestParameters["page"] != null) {
      queryParameters["page"] = requestParameters["page"];
    }
    if (requestParameters["size"] != null) {
      queryParameters["size"] = requestParameters["size"];
    }
    if (requestParameters["responseType"] != null) {
      queryParameters["response_type"] = requestParameters["responseType"];
    }
    if (requestParameters["search"] != null) {
      queryParameters["search"] = requestParameters["search"];
    }
    if (requestParameters["addresses"] != null) {
      queryParameters["addresses"] = requestParameters["addresses"];
    }
    if (requestParameters["addressTypes"] != null) {
      queryParameters["address_types"] = requestParameters["addressTypes"];
    }
    const headerParameters = {};
    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token("bearerAuth", []);
      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request({
      path: `/api/v1/vaults/{id}/addresses`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters["id"]))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => ListVaultAddressesResponseFromJSON(jsonValue));
  }
  /**
   * Get a list of all addresses in a vault.
   * List Vault Addresses
   */
  async listVaultAddressesApiV1VaultsIdAddressesGet(requestParameters, initOverrides) {
    const response = await this.listVaultAddressesApiV1VaultsIdAddressesGetRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Get a list of all vaults in an organization.
   * List Vaults
   */
  async listVaultsApiV1VaultsGetRaw(requestParameters, initOverrides) {
    const queryParameters = {};
    if (requestParameters["sortBy"] != null) {
      queryParameters["sort_by"] = requestParameters["sortBy"];
    }
    if (requestParameters["page"] != null) {
      queryParameters["page"] = requestParameters["page"];
    }
    if (requestParameters["size"] != null) {
      queryParameters["size"] = requestParameters["size"];
    }
    if (requestParameters["responseType"] != null) {
      queryParameters["response_type"] = requestParameters["responseType"];
    }
    if (requestParameters["vaultIds"] != null) {
      queryParameters["vault_ids"] = requestParameters["vaultIds"];
    }
    if (requestParameters["search"] != null) {
      queryParameters["search"] = requestParameters["search"];
    }
    if (requestParameters["names"] != null) {
      queryParameters["names"] = requestParameters["names"];
    }
    if (requestParameters["vaultTypes"] != null) {
      queryParameters["vault_types"] = requestParameters["vaultTypes"];
    }
    if (requestParameters["vaultStates"] != null) {
      queryParameters["vault_states"] = requestParameters["vaultStates"];
    }
    if (requestParameters["keysetIds"] != null) {
      queryParameters["keyset_ids"] = requestParameters["keysetIds"];
    }
    if (requestParameters["keyHolderIds"] != null) {
      queryParameters["key_holder_ids"] = requestParameters["keyHolderIds"];
    }
    if (requestParameters["vaultGroupIds"] != null) {
      queryParameters["vault_group_ids"] = requestParameters["vaultGroupIds"];
    }
    if (requestParameters["excludeVaultGroupIds"] != null) {
      queryParameters["exclude_vault_group_ids"] = requestParameters["excludeVaultGroupIds"];
    }
    if (requestParameters["originType"] != null) {
      queryParameters["origin_type"] = requestParameters["originType"];
    }
    if (requestParameters["accountAddresses"] != null) {
      queryParameters["account_addresses"] = requestParameters["accountAddresses"];
    }
    const headerParameters = {};
    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token("bearerAuth", []);
      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request({
      path: `/api/v1/vaults`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => ListVaultsResponseFromJSON(jsonValue));
  }
  /**
   * Get a list of all vaults in an organization.
   * List Vaults
   */
  async listVaultsApiV1VaultsGet(requestParameters = {}, initOverrides) {
    const response = await this.listVaultsApiV1VaultsGetRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Get a list of all vaults and their assets in an organization.
   * List Vaults With Assets
   */
  async listVaultsWithAssetsApiV1VaultsBalancesGetRaw(requestParameters, initOverrides) {
    const queryParameters = {};
    if (requestParameters["includeAssetsInfo"] != null) {
      queryParameters["include_assets_info"] = requestParameters["includeAssetsInfo"];
    }
    if (requestParameters["page"] != null) {
      queryParameters["page"] = requestParameters["page"];
    }
    if (requestParameters["size"] != null) {
      queryParameters["size"] = requestParameters["size"];
    }
    if (requestParameters["responseType"] != null) {
      queryParameters["response_type"] = requestParameters["responseType"];
    }
    if (requestParameters["vaultIds"] != null) {
      queryParameters["vault_ids"] = requestParameters["vaultIds"];
    }
    if (requestParameters["chains"] != null) {
      queryParameters["chains"] = requestParameters["chains"];
    }
    if (requestParameters["search"] != null) {
      queryParameters["search"] = requestParameters["search"];
    }
    if (requestParameters["vaultTypes"] != null) {
      queryParameters["vault_types"] = requestParameters["vaultTypes"];
    }
    if (requestParameters["vaultStates"] != null) {
      queryParameters["vault_states"] = requestParameters["vaultStates"];
    }
    if (requestParameters["utxoVaultSubTypes"] != null) {
      queryParameters["utxo_vault_sub_types"] = requestParameters["utxoVaultSubTypes"];
    }
    if (requestParameters["keyHolderIds"] != null) {
      queryParameters["key_holder_ids"] = requestParameters["keyHolderIds"];
    }
    if (requestParameters["hideEmpty"] != null) {
      queryParameters["hide_empty"] = requestParameters["hideEmpty"];
    }
    if (requestParameters["vaultGroupIds"] != null) {
      queryParameters["vault_group_ids"] = requestParameters["vaultGroupIds"];
    }
    if (requestParameters["assetIds"] != null) {
      queryParameters["asset_ids"] = requestParameters["assetIds"];
    }
    if (requestParameters["exchangeDepositEnabledForBlockchainAssetId"] != null) {
      queryParameters["exchange_deposit_enabled_for_blockchain_asset_id"] = requestParameters["exchangeDepositEnabledForBlockchainAssetId"];
    }
    if (requestParameters["exchangeDepositEnabledForExchangeAssetId"] != null) {
      queryParameters["exchange_deposit_enabled_for_exchange_asset_id"] = requestParameters["exchangeDepositEnabledForExchangeAssetId"];
    }
    if (requestParameters["exchangeDepositEnabledOnChain"] != null) {
      queryParameters["exchange_deposit_enabled_on_chain"] = requestParameters["exchangeDepositEnabledOnChain"];
    }
    if (requestParameters["exchangeTypes"] != null) {
      queryParameters["exchange_types"] = requestParameters["exchangeTypes"];
    }
    if (requestParameters["originType"] != null) {
      queryParameters["origin_type"] = requestParameters["originType"];
    }
    if (requestParameters["sortBy"] != null) {
      queryParameters["sort_by"] = requestParameters["sortBy"];
    }
    const headerParameters = {};
    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token("bearerAuth", []);
      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request({
      path: `/api/v1/vaults/balances`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => ListVaultsWithAssetsResponseFromJSON(jsonValue));
  }
  /**
   * Get a list of all vaults and their assets in an organization.
   * List Vaults With Assets
   */
  async listVaultsWithAssetsApiV1VaultsBalancesGet(requestParameters = {}, initOverrides) {
    const response = await this.listVaultsWithAssetsApiV1VaultsBalancesGetRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Purge imported vaults.
   * Purge Imported Vaults
   */
  async purgeImportedVaultsApiV1VaultsPurgeImportedVaultsPostRaw(requestParameters, initOverrides) {
    if (requestParameters["purgeImportedVaultsRequest"] == null) {
      throw new RequiredError(
        "purgeImportedVaultsRequest",
        'Required parameter "purgeImportedVaultsRequest" was null or undefined when calling purgeImportedVaultsApiV1VaultsPurgeImportedVaultsPost().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token("bearerAuth", []);
      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request({
      path: `/api/v1/vaults/purge-imported-vaults`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: PurgeImportedVaultsRequestToJSON(requestParameters["purgeImportedVaultsRequest"])
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => PurgeImportedVaultsResponseFromJSON(jsonValue));
  }
  /**
   * Purge imported vaults.
   * Purge Imported Vaults
   */
  async purgeImportedVaultsApiV1VaultsPurgeImportedVaultsPost(requestParameters, initOverrides) {
    const response = await this.purgeImportedVaultsApiV1VaultsPurgeImportedVaultsPostRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Rename an existing vault address.
   * Rename Vault Address
   */
  async renameVaultAddressApiV1VaultsAddressesIdNamePutRaw(requestParameters, initOverrides) {
    if (requestParameters["id"] == null) {
      throw new RequiredError(
        "id",
        'Required parameter "id" was null or undefined when calling renameVaultAddressApiV1VaultsAddressesIdNamePut().'
      );
    }
    if (requestParameters["renameVaultRequest"] == null) {
      throw new RequiredError(
        "renameVaultRequest",
        'Required parameter "renameVaultRequest" was null or undefined when calling renameVaultAddressApiV1VaultsAddressesIdNamePut().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token("bearerAuth", []);
      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request({
      path: `/api/v1/vaults/addresses/{id}/name`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters["id"]))),
      method: "PUT",
      headers: headerParameters,
      query: queryParameters,
      body: RenameVaultRequestToJSON(requestParameters["renameVaultRequest"])
    }, initOverrides);
    return new VoidApiResponse(response);
  }
  /**
   * Rename an existing vault address.
   * Rename Vault Address
   */
  async renameVaultAddressApiV1VaultsAddressesIdNamePut(requestParameters, initOverrides) {
    await this.renameVaultAddressApiV1VaultsAddressesIdNamePutRaw(requestParameters, initOverrides);
  }
  /**
   * Rename an existing vault.
   * Rename Vault
   */
  async renameVaultApiV1VaultsIdNamePutRaw(requestParameters, initOverrides) {
    if (requestParameters["id"] == null) {
      throw new RequiredError(
        "id",
        'Required parameter "id" was null or undefined when calling renameVaultApiV1VaultsIdNamePut().'
      );
    }
    if (requestParameters["renameVaultRequest"] == null) {
      throw new RequiredError(
        "renameVaultRequest",
        'Required parameter "renameVaultRequest" was null or undefined when calling renameVaultApiV1VaultsIdNamePut().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token("bearerAuth", []);
      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request({
      path: `/api/v1/vaults/{id}/name`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters["id"]))),
      method: "PUT",
      headers: headerParameters,
      query: queryParameters,
      body: RenameVaultRequestToJSON(requestParameters["renameVaultRequest"])
    }, initOverrides);
    return new VoidApiResponse(response);
  }
  /**
   * Rename an existing vault.
   * Rename Vault
   */
  async renameVaultApiV1VaultsIdNamePut(requestParameters, initOverrides) {
    await this.renameVaultApiV1VaultsIdNamePutRaw(requestParameters, initOverrides);
  }
  /**
   * Restore an archived vault.
   * Restore Vault
   */
  async restoreVaultApiV1VaultsIdRestorePostRaw(requestParameters, initOverrides) {
    if (requestParameters["id"] == null) {
      throw new RequiredError(
        "id",
        'Required parameter "id" was null or undefined when calling restoreVaultApiV1VaultsIdRestorePost().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token("bearerAuth", []);
      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request({
      path: `/api/v1/vaults/{id}/restore`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters["id"]))),
      method: "POST",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new VoidApiResponse(response);
  }
  /**
   * Restore an archived vault.
   * Restore Vault
   */
  async restoreVaultApiV1VaultsIdRestorePost(requestParameters, initOverrides) {
    await this.restoreVaultApiV1VaultsIdRestorePostRaw(requestParameters, initOverrides);
  }
  /**
   * Sync assets of a vault.
   * Sync Vault
   */
  async syncVaultApiV1VaultsIdSyncPutRaw(requestParameters, initOverrides) {
    if (requestParameters["id"] == null) {
      throw new RequiredError(
        "id",
        'Required parameter "id" was null or undefined when calling syncVaultApiV1VaultsIdSyncPut().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token("bearerAuth", []);
      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request({
      path: `/api/v1/vaults/{id}/sync`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters["id"]))),
      method: "PUT",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new VoidApiResponse(response);
  }
  /**
   * Sync assets of a vault.
   * Sync Vault
   */
  async syncVaultApiV1VaultsIdSyncPut(requestParameters, initOverrides) {
    await this.syncVaultApiV1VaultsIdSyncPutRaw(requestParameters, initOverrides);
  }
  /**
   * Update vault metadata details.
   * Update Vault Metadata
   */
  async updateVaultMetadataApiV1VaultsIdMetadataPutRaw(requestParameters, initOverrides) {
    if (requestParameters["id"] == null) {
      throw new RequiredError(
        "id",
        'Required parameter "id" was null or undefined when calling updateVaultMetadataApiV1VaultsIdMetadataPut().'
      );
    }
    if (requestParameters["updateVaultMetadataRequest"] == null) {
      throw new RequiredError(
        "updateVaultMetadataRequest",
        'Required parameter "updateVaultMetadataRequest" was null or undefined when calling updateVaultMetadataApiV1VaultsIdMetadataPut().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token("bearerAuth", []);
      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request({
      path: `/api/v1/vaults/{id}/metadata`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters["id"]))),
      method: "PUT",
      headers: headerParameters,
      query: queryParameters,
      body: UpdateVaultMetadataRequestToJSON(requestParameters["updateVaultMetadataRequest"])
    }, initOverrides);
    return new VoidApiResponse(response);
  }
  /**
   * Update vault metadata details.
   * Update Vault Metadata
   */
  async updateVaultMetadataApiV1VaultsIdMetadataPut(requestParameters, initOverrides) {
    await this.updateVaultMetadataApiV1VaultsIdMetadataPutRaw(requestParameters, initOverrides);
  }
};

// src/api/api-client.ts
var import_viem2 = require("viem");

// src/constants.ts
var FORDEFI_API_BASE_URL_PROD = "https://api.fordefi.com";
var CURRENT_FORDEFI_API_VERSION = "v1.83.14";

// src/utils/wait-for.ts
var waitFor = (ms) => new Promise((resolve) => setTimeout(resolve, ms));
var waitForEmittedEvent = (eventEmitter) => {
  const waitForEvent = async (event, timeoutMs = 3e3) => {
    return new Promise((_resolve, _reject) => {
      let timeout;
      let resolve;
      const reject = () => {
        eventEmitter.removeListener(event, resolve);
        _reject(`Timeout waiting for event '${event}'`);
      };
      timeout = setTimeout(reject, timeoutMs);
      resolve = (...args) => {
        clearTimeout(timeout);
        _resolve(...args);
      };
      eventEmitter.on(event, resolve);
    });
  };
  return waitForEvent;
};

// src/utils/signatures.ts
var import_viem = require("viem");

// src/utils/base64.ts
var base64ToBytes = (base64) => Buffer.from(base64, "base64");
var base64ToBinary = (base64) => base64ToBytes(base64).toString("binary");
var isValidBase64 = (maybeBase64) => {
  try {
    return base64ToBytes(maybeBase64).toString("base64") === maybeBase64;
  } catch {
    return false;
  }
};

// src/utils/signatures.ts
var base64SignatureToHex = (base64) => {
  const binaryString = base64ToBinary(base64);
  const bytes = new Uint8Array(binaryString.length);
  for (let i = 0; i < binaryString.length; i++) {
    bytes[i] = binaryString.charCodeAt(i);
  }
  return (0, import_viem.bytesToHex)(bytes);
};

// src/utils/time.ts
var ONE_SECOND_MS = 1e3;
var ONE_MINUTE_MS = 60 * ONE_SECOND_MS;
var ONE_HOUR_MS = 60 * ONE_MINUTE_MS;
var ONE_DAY_MS = 24 * ONE_HOUR_MS;
var DEFAULT_POLLING_INTERVAL = 5 * ONE_SECOND_MS;
var DEFAULT_TIMEOUT_DURATION = ONE_DAY_MS;
var getRenderTimeDurationParts = (durationMs) => {
  if (durationMs < ONE_MINUTE_MS) {
    return [durationMs / ONE_SECOND_MS, "s"];
  }
  if (durationMs < ONE_HOUR_MS) {
    return [durationMs / ONE_MINUTE_MS, "m"];
  }
  return [durationMs / ONE_HOUR_MS, "h"];
};
var renderTimeDuration = (durationMs) => {
  const [durationInUnits, units] = getRenderTimeDurationParts(durationMs);
  return [Number.isInteger(durationInUnits) ? durationInUnits : durationInUnits.toFixed(1), units].join("");
};

// src/api/request-body-sign.ts
var crypto = __toESM(require("crypto"));
var dashes = "-----";
var pemBeginClause = `${dashes}BEGIN EC PRIVATE KEY${dashes}`;
var pemEndClause = `${dashes}END EC PRIVATE KEY${dashes}`;
var endpointRequiresSignature = "/api/v1/transactions";
var signApiRequestBody = async (body, pem, date = /* @__PURE__ */ new Date()) => {
  const timestamp = date.getTime().toString();
  const payloadToSign = [endpointRequiresSignature, timestamp, JSON.stringify(body)].join("|");
  const privateKey = crypto.createPrivateKey(toValidPem(pem));
  const sign = crypto.createSign("SHA256").update(payloadToSign, "utf8").end();
  const signature = sign.sign(privateKey, "base64");
  return {
    timestamp,
    signature
  };
};
var toValidPem = (pem) => {
  const base64 = pem.replace(pemBeginClause, "").replace(pemEndClause, "").replace(/\s/g, "");
  if (base64.includes(dashes)) {
    throw new Error(
      `Invalid PEM format: the header and footer indicate the key was not generated properly. Expected header to be ${pemBeginClause} and footer to be ${pemEndClause}.`
    );
  }
  if (!base64 || !isValidBase64(base64)) {
    throw new Error("Invalid PEM format: expected base64 encoded string.");
  }
  return [pemBeginClause, base64, pemEndClause].join("\n");
};

// src/api/headers.ts
var middlewareAddRequestSigningHeaders = (apiPayloadSignKeyBase64) => async (context) => {
  const signedBodyParams = await signApiRequestBody(context.init.body, apiPayloadSignKeyBase64);
  return {
    headers: {
      ...context.init.headers,
      ...signatureToHeaders(signedBodyParams)
    }
  };
};
var signatureToHeaders = ({ timestamp, signature }) => ({
  ["X-Timestamp" /* Timestamp */]: timestamp,
  ["X-Signature" /* Signature */]: signature
});
var getStaticHeaders = () => ({
  ["User-Agent" /* UserAgent */]: `Fordefi Web3 Provider/${CURRENT_FORDEFI_API_VERSION}`
});

// src/api/api-client.ts
var httpStatusToErrorClass = {
  [400 /* BadRequest */]: import_viem2.InvalidParamsRpcError,
  [401 /* Unauthorized */]: import_viem2.UnauthorizedProviderError,
  [403 /* Forbidden */]: import_viem2.UnauthorizedProviderError,
  [404 /* NotFound */]: import_viem2.ResourceNotFoundRpcError,
  [503 /* ServiceUnavailable */]: import_viem2.InternalRpcError,
  [429 /* TooManyRequests */]: import_viem2.LimitExceededRpcError,
  [500 /* InternalServerError */]: import_viem2.InternalRpcError
};
var ApiClient = class {
  constructor(providerConfig) {
    const { apiBaseUrl, apiUserToken } = providerConfig;
    const config = new Configuration({
      basePath: apiBaseUrl ?? FORDEFI_API_BASE_URL_PROD,
      accessToken: apiUserToken,
      headers: getStaticHeaders(),
      middleware: [
        {
          post: async (context) => {
            if (context.response?.status < 400) {
              return;
            }
            const payload = await context.response?.clone().json().catch(() => "Failed to parse error response body").then(JSON.stringify);
            const status = context.response?.status;
            const error = new Error(payload);
            const ErrorClass = httpStatusToErrorClass[status] ?? import_viem2.InternalRpcError;
            throw new ErrorClass(error);
          }
        }
      ]
    });
    this.vaults = new VaultsApi(config);
    this.blockchains = new BlockchainsApi(config);
    this.transactions = new TransactionsApi(config);
  }
};

// src/utils/transactions.ts
var import_viem3 = require("viem");
var toFordefiTransactionNumericValue = (value) => {
  if (value === void 0) {
    throw new Error("value cannot be undefined");
  }
  if (typeof value === "string") {
    if (value.trim() === "") {
      throw new Error("value cannot be an empty string");
    }
    if (value.startsWith("-")) {
      throw new Error("value provided as a string cannot be negative");
    }
    if ((0, import_viem3.isHex)(value, { strict: true })) {
      return (0, import_viem3.hexToBigInt)(value).toString();
    }
    if (value.match(/^\d+$/)) {
      return value;
    }
    throw new Error("value provided as a string must be a valid decimal or hex string");
  }
  if (typeof value === "number") {
    if (isNaN(value)) {
      throw new Error("value is NaN");
    }
    if (!Number.isSafeInteger(value)) {
      throw new Error("value of type number is not a safe integer, use a bigint instead");
    }
    if (value < 0) {
      throw new Error("value must be a non-negative number");
    }
    return BigInt(value).toString();
  }
  if (typeof value === "bigint") {
    if (value < 0) {
      throw new Error("value must be a non-negative number");
    }
    return value.toString();
  }
  throw new Error("value must be a valid number");
};
var parseTransactionRequestValueField = (value) => {
  if (value === void 0) {
    return "0";
  }
  try {
    return toFordefiTransactionNumericValue(value);
  } catch (parseError) {
    throw new import_viem3.InvalidParamsRpcError(new Error(`invalid "value": ${parseError.message}`));
  }
};
var parseTransactionRequestGasField = (fieldName, value) => {
  try {
    return toFordefiTransactionNumericValue(value);
  } catch (parseError) {
    throw new import_viem3.InvalidParamsRpcError(new Error(`invalid ${fieldName}: ${parseError.message}`));
  }
};
var buildSignTransactionRequest = (vaultId, chainId, messageType, rawData) => ({
  type: CreateEvmMessageRequestTypeEnum.evmMessage,
  signerType: SignerType.apiSigner,
  vaultId,
  details: {
    type: messageType,
    chain: chainId,
    rawData
  }
});
var toFordefiEvmGas = ({
  maxPriorityFeePerGas,
  maxFeePerGas,
  gasPrice,
  gas
}) => {
  const gasLimit = gas !== void 0 && gas !== null ? parseTransactionRequestGasField("gas", gas) : void 0;
  if (maxPriorityFeePerGas !== void 0 && maxFeePerGas !== void 0) {
    return {
      type: CustomGasRequestTypeEnum.custom,
      gasLimit,
      details: {
        type: DynamicGasRequestTypeEnum.dynamic,
        maxPriorityFeePerGas: parseTransactionRequestGasField("maxPriorityFeePerGas", maxPriorityFeePerGas),
        maxFeePerGas: parseTransactionRequestGasField("maxFeePerGas", maxFeePerGas)
      }
    };
  }
  if (gasPrice !== void 0) {
    return {
      type: CustomGasRequestTypeEnum.custom,
      gasLimit,
      details: {
        type: LegacyGasTypeEnum.legacy,
        price: parseTransactionRequestGasField("gasPrice", gasPrice)
      }
    };
  }
  return {
    type: GasPriorityRequestTypeEnum.priority,
    gasLimit,
    priorityLevel: GasPriorityLevelRequest.medium
  };
};
var buildEvmRawTransactionRequest = ({
  transaction,
  chain,
  vault,
  pushMode,
  skipPrediction = true
}) => {
  const { value, from, to, data } = transaction;
  if (from && !(0, import_viem3.isAddressEqual)(from, vault.address)) {
    throw new import_viem3.InvalidParamsRpcError(
      new Error('Transaction "from" does not match the address managed by this provider')
    );
  }
  if (to && !(0, import_viem3.isAddress)(to)) {
    throw new import_viem3.InvalidParamsRpcError(new Error('Transaction "to" is not a valid address'));
  }
  return {
    type: CreateEvmTransactionRequestTypeEnum.evmTransaction,
    vaultId: vault.id,
    signerType: SignerType.apiSigner,
    details: {
      type: CreateEvmRawTransactionRequestTypeEnum.evmRawTransaction,
      gas: toFordefiEvmGas(transaction),
      skipPrediction,
      pushMode,
      chain: chain.chainId,
      value: parseTransactionRequestValueField(value),
      to: to ?? void 0,
      data: data ? {
        type: EvmDataRequestHexTypeEnum.hex,
        hexData: data
      } : void 0
    }
  };
};
var waitForTransactionState = async ({
  transaction: { id: transactionId },
  desiredState,
  apiClient,
  timeoutDurationMs,
  pollingIntervalMs
}) => {
  console.debug(
    `waiting for transaction state change to '${desiredState}' with timeout of ${renderTimeDuration(timeoutDurationMs)}`
  );
  let attemptStartTimeMs = Date.now();
  const timeoutTimeMs = attemptStartTimeMs + timeoutDurationMs;
  while ((attemptStartTimeMs = Date.now()) < timeoutTimeMs) {
    const transaction = await apiClient.transactions.getTransactionApiV1TransactionsIdGet({
      id: transactionId
    });
    if (isErrorState(transaction.state)) {
      throw new import_viem3.InternalRpcError(new Error(`Transaction failed with state '${transaction.state}'`));
    }
    if (didStateAlreadyOccur(transaction.state, desiredState)) {
      console.debug(
        `transaction reached desired state '${desiredState}'${desiredState !== transaction.state ? ` and is now '${transaction.state}'` : ""}`
      );
      return transaction;
    }
    console.debug(
      `[${(/* @__PURE__ */ new Date()).toISOString()}] transaction state is '${transaction.state}', waiting for '${desiredState}'...`
    );
    const timeSinceAttemptStartMs = Date.now() - attemptStartTimeMs;
    const remainingWaitTimeMs = pollingIntervalMs - timeSinceAttemptStartMs;
    if (remainingWaitTimeMs > 0) {
      await waitFor(remainingWaitTimeMs);
    }
  }
  throw new import_viem3.InternalRpcError(new Error(`Timeout while waiting for transaction status to change to '${desiredState}'`));
};
var parseTypedDataParams = (params) => {
  const [_maybeFromAddress, _maybeTypedData] = params;
  const [fromAddress, _typedData] = (0, import_viem3.isAddress)(_maybeFromAddress) ? [_maybeFromAddress, _maybeTypedData] : [_maybeTypedData, _maybeFromAddress];
  const typedData = typeof _typedData === "string" ? _typedData : JSON.stringify(_typedData);
  return { typedData, fromAddress };
};
var orderedTransactionStates = [
  PushableTransactionState.waitingForApproval,
  PushableTransactionState.approved,
  PushableTransactionState.signed,
  PushableTransactionState.queued,
  PushableTransactionState.pushedToBlockchain,
  PushableTransactionState.stuck,
  PushableTransactionState.mined,
  PushableTransactionState.completed
];
var errorTransactionStates = [
  PushableTransactionState.errorSigning,
  PushableTransactionState.errorPushingToBlockchain,
  PushableTransactionState.aborted,
  PushableTransactionState.stuck,
  PushableTransactionState.cancelled
];
var didStateAlreadyOccur = (currentState, desiredState) => orderedTransactionStates.indexOf(currentState) >= orderedTransactionStates.indexOf(desiredState);
var isErrorState = (state) => errorTransactionStates.includes(state);

// src/utils/types.ts
var assertUnreachable = (x) => {
  throw new Error("Unreachable");
};

// src/provider/provider.types.ts
var fordefiMethods = [
  "eth_sendTransaction",
  "eth_signTransaction",
  "eth_accounts",
  "eth_requestAccounts",
  "eth_chainId",
  "personal_sign",
  "eth_signTypedData",
  "eth_signTypedData_v3",
  "eth_signTypedData_v4"
];
var isFordefiMethod = (args) => {
  return fordefiMethods.includes(args.method);
};

// src/provider/provider.ts
var FordefiWeb3Provider = class {
  constructor(config) {
    const configWithDefaults = this.validateConfig(config);
    this.config = configWithDefaults;
    this.apiClient = new ApiClient(configWithDefaults);
    const eventEmitter = new import_events.EventEmitter();
    this.on = eventEmitter.on.bind(eventEmitter);
    this.removeListener = eventEmitter.removeListener.bind(eventEmitter);
    this.eventEmitter = eventEmitter;
    this.waitForEmittedEvent = waitForEmittedEvent(eventEmitter);
    this.status = "disconnected";
    this.connect().catch();
  }
  validateConfig(config) {
    const { pollingIntervalMs, timeoutDurationMs } = config;
    if (pollingIntervalMs && pollingIntervalMs < 500) {
      throw new Error("FordefiProviderConfig.pollingIntervalMs must be at least 500.");
    }
    return {
      ...config,
      pollingIntervalMs: pollingIntervalMs ?? DEFAULT_POLLING_INTERVAL,
      timeoutDurationMs: timeoutDurationMs ?? DEFAULT_TIMEOUT_DURATION
    };
  }
  /**
   * Handles a JSON-RPC request
   *
   * @param args JSON-RPC request payload
   * @returns A promise with a response
   *
   * @throws RpcError with error codes defined in {@link RpcErrorCode} and {@link ProviderRpcErrorCode}
   */
  async request(args) {
    let result;
    if (isFordefiMethod(args)) {
      switch (args.method) {
        // EIP-1474
        case "eth_sendTransaction":
          result = this.ethSendTransaction(args);
          break;
        case "eth_signTransaction":
          result = this.ethSignTransaction(args);
          break;
        case "eth_accounts":
          result = this.ethAccounts();
          break;
        // EIP-1102
        case "eth_requestAccounts":
          result = this.ethAccounts();
          break;
        // EIP-695
        case "eth_chainId":
          result = this.ethChainId();
          break;
        // EIP-191
        case "personal_sign":
          result = this.personalSign(args);
          break;
        // EIP-712
        case "eth_signTypedData":
        case "eth_signTypedData_v3":
        case "eth_signTypedData_v4":
          result = this.ethSignTypedData(args);
          break;
        default:
          assertUnreachable(args);
      }
    } else {
      result = this.jsonRpcHttpRequestFn(args);
    }
    return result;
  }
  jsonRpcHttpRequestFn(args) {
    if (!this.config.rpcUrl) {
      throw new import_viem4.UnsupportedProviderMethodError(
        new Error(
          "RPC method not supported by Fordefi provider. Construct the provider with `rpcUrl` to fallback to an external JSON RPC provider."
        )
      );
    }
    return (0, import_viem4.http)(this.config.rpcUrl)({}).request(args);
  }
  async ethChainId() {
    if (this.chain) {
      return (0, import_viem4.numberToHex)(this.chain.chainId);
    }
    const { chains } = await this.apiClient.blockchains.listChainsApiV1BlockchainsGet({ chainTypes: [ChainType.evm] });
    const chain = chains.find((chain2) => {
      const matchedProperty = typeof this.config.chainId === "string" ? "uniqueId" : "chainId";
      return chain2[matchedProperty] === this.config.chainId;
    });
    if (!chain) {
      throw new import_viem4.InvalidParamsRpcError(new Error(`Unsupported chain id ${this.config.chainId}`));
    }
    this.chain = chain;
    const chainId = (0, import_viem4.numberToHex)(chain.chainId);
    this.eventEmitter.emit("chainChanged", chainId);
    return chainId;
  }
  async ethAccounts() {
    if (this.vault) {
      return [this.vault.address];
    }
    const response = await this.apiClient.vaults.listVaultsApiV1VaultsGet({
      vaultTypes: [VaultType.evm],
      accountAddresses: [this.config.address]
    });
    const { vaults } = response;
    const vault = vaults[0];
    if (!vault) {
      throw new import_viem4.InvalidInputRpcError(new Error(`Vault with address ${this.config.address} not found`));
    }
    this.vault = vault;
    const accounts = [vault.address];
    this.eventEmitter.emit("accountsChanged", accounts);
    return accounts;
  }
  async ethSendTransaction({ params }) {
    const [transaction] = params;
    const { vault, chain } = this._getFordefiChainVault();
    const { hash } = await this._invokeCreateTransaction(
      buildEvmRawTransactionRequest({
        transaction,
        chain,
        vault,
        pushMode: PushMode.auto,
        skipPrediction: this.config.skipPrediction
      })
    );
    if (!hash || !(0, import_viem4.isHex)(hash)) {
      throw new import_viem4.InternalRpcError(new Error("Missing transaction hash in create transaction response"));
    }
    return hash;
  }
  async ethSignTransaction({ params }) {
    const [transaction] = params;
    const { vault, chain } = this._getFordefiChainVault();
    const { rawTransaction } = await this._invokeCreateTransaction(
      buildEvmRawTransactionRequest({
        transaction,
        chain,
        vault,
        pushMode: PushMode.manual,
        skipPrediction: this.config.skipPrediction
      })
    );
    if (!rawTransaction) {
      throw new import_viem4.InternalRpcError(new Error("Missing raw transaction in create transaction response"));
    }
    return rawTransaction;
  }
  async personalSign({ params }) {
    const [rawData, signingAddress] = params;
    const { chain, vault } = this._getFordefiChainVault();
    if (!(0, import_viem4.isAddressEqual)(signingAddress, vault.address)) {
      throw new import_viem4.InvalidParamsRpcError(
        new Error(`Address ${signingAddress} does not match this provider's managed address ${vault.address}.`)
      );
    }
    return this._createEvmMessageTransaction(
      buildSignTransactionRequest(
        vault.id,
        chain.chainId,
        CreateEvmPersonalMessageRequestTypeEnum.personalMessageType,
        rawData
      )
    );
  }
  async ethSignTypedData({
    params
  }) {
    const { typedData, fromAddress } = parseTypedDataParams(params);
    const { chain, vault } = this._getFordefiChainVault();
    if (!(0, import_viem4.isAddressEqual)(fromAddress, vault.address)) {
      throw new import_viem4.InvalidParamsRpcError(
        new Error(`Address ${fromAddress} does not match given provider's address ${vault.address}`)
      );
    }
    return this._createEvmMessageTransaction(
      buildSignTransactionRequest(
        vault.id,
        chain.chainId,
        CreateEvmTypedMessageRequestTypeEnum.typedMessageType,
        typedData
      )
    );
  }
  async _createEvmMessageTransaction(createTransactionRequest) {
    const { signatures } = await this._invokeCreateTransaction(createTransactionRequest);
    if (signatures.length === 0) {
      throw new import_viem4.InternalRpcError(new Error("No signatures found in create transaction response"));
    }
    return base64SignatureToHex(signatures[0].data);
  }
  async _invokeCreateTransaction(createTransactionRequest) {
    const transaction = await this.apiClient.transactions.createTransactionApiV1TransactionsPost(
      { createTransactionRequest },
      middlewareAddRequestSigningHeaders(this.config.apiPayloadSignKey)
    );
    if (transaction.type !== createTransactionRequest.type) {
      throw new import_viem4.InternalRpcError(
        new Error(
          `Created transaction has unexpected type ${transaction.type} while transaction type in the request was ${createTransactionRequest.type}`
        )
      );
    }
    const { timeoutDurationMs, pollingIntervalMs } = this.config;
    return waitForTransactionState({
      transaction,
      desiredState: PushableTransactionState.signed,
      apiClient: this.apiClient,
      timeoutDurationMs,
      pollingIntervalMs
    });
  }
  _getFordefiChainVault() {
    this._throwIfNotConnected();
    if (!this.chain || !this.vault) {
      throw new import_viem4.InternalRpcError(new Error("Unexpected state: provider is connected but chain or vault is missing"));
    }
    return { chain: this.chain, vault: this.vault };
  }
  _throwIfNotConnected() {
    if (this.getStatus() !== "connected") {
      throw this._onDisconnect();
    }
  }
  /**
   * Connects the provider to Fordefi and emits a 'connect' event.
   * - If already connected, it does nothing.
   * - If connecting, waits for the connection to be established.
   *
   * @returns A promise that resolves once connected.
   */
  async connect() {
    if (this.status === "connected") {
      return Promise.resolve();
    }
    if (this.status === "connecting") {
      await this.waitForEmittedEvent("connect");
    }
    this.status = "connecting";
    const re = await this.request({ method: "eth_accounts" });
    await Promise.all([this.request({ method: "eth_accounts" }), this.request({ method: "eth_chainId" })]).then(
      ([_address, chainId]) => {
        if (this.status === "connecting") {
          this.status = "connected";
          this.eventEmitter.emit("connect", { chainId });
        }
      }
    );
  }
  /**
   * Disconnects the provider and emits a 'disconnect' event.
   */
  disconnect() {
    if (this.status === "disconnected") {
      return;
    }
    this.chain = void 0;
    this.vault = void 0;
    this.status = "disconnected";
    this._onDisconnect();
  }
  _onDisconnect() {
    const error = new import_viem4.ProviderDisconnectedError(new Error("Provider got disconnected"));
    this.eventEmitter.emit("disconnect", error);
    return error;
  }
  /**
   * Returns the current status of the provider.
   *
   * @returns 'connected' if the provider is connected, 'connecting' if trying to connect, 'disconnected' otherwise.
   */
  getStatus() {
    return this.status;
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  EIP1193EventMap,
  FordefiWeb3Provider
});
