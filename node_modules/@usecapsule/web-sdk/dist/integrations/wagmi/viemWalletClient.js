var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { createWalletClient, hashMessage, serializeTransaction, hashTypedData, } from 'viem';
import * as viemChains from 'viem/chains';
import { hexStringToBase64, hexToSignature } from '../../utils/formattingUtils';
export function createCapsuleAccount(capsule, walletAddress) {
    let currentWallet;
    if (walletAddress) {
        currentWallet = Object.values(capsule.getWallets()).find(wallet => wallet.address.toLowerCase() === walletAddress.toLowerCase());
    }
    else {
        currentWallet = Object.values(capsule.getWallets())[0];
    }
    return {
        address: currentWallet.address,
        publicKey: currentWallet.publicKey || '0x',
        source: 'custom',
        type: 'local',
        signMessage: ({ message }) => __awaiter(this, void 0, void 0, function* () {
            const hashedMessage = hashMessage(message);
            const res = yield capsule.signMessage(currentWallet.id, hexStringToBase64(hashedMessage));
            const signature = res.signature;
            return `0x${signature}`;
        }),
        signTransaction: (transaction, args) => __awaiter(this, void 0, void 0, function* () {
            let { serializer } = args || {};
            if (!serializer) {
                serializer = serializeTransaction;
            }
            const serializedTx = serializer(transaction, {
                r: '0x',
                s: '0x',
                v: BigInt(0),
            });
            const res = yield capsule.signTransaction(currentWallet.id, hexStringToBase64(serializedTx.substring(2)), `${transaction.chainId}`);
            const signature = res.signature;
            const formattedSig = hexToSignature(`0x${signature}`);
            formattedSig.v += BigInt(27);
            return serializer(transaction, formattedSig);
        }),
        signTypedData: (typedData) => __awaiter(this, void 0, void 0, function* () {
            const res = yield capsule.signMessage(currentWallet.id, hexStringToBase64(hashTypedData(typedData)));
            const signature = res.signature;
            return `0x${signature}`;
        }),
    };
}
export function getViemChain(chainId) {
    const chainIdNum = Number(chainId);
    for (const chain of Object.values(viemChains)) {
        if (chain.id === chainIdNum) {
            return chain;
        }
    }
    throw new Error(`chain with id ${chainId} not found`);
}
export function createCapsuleViemClient(capsule, params, opts) {
    return createWalletClient(Object.assign({ account: (opts === null || opts === void 0 ? void 0 : opts.noAccount) ? undefined : createCapsuleAccount(capsule) }, params));
}
