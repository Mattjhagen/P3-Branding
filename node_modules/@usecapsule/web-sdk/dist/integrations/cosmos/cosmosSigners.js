var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { encodeSecp256k1Signature, rawSecp256k1PubkeyToRawAddress, serializeSignDoc } from '@cosmjs/amino';
import { toBech32 } from '@cosmjs/encoding';
import { Secp256k1, Sha256, sha256, ExtendedSecp256k1Signature } from '@cosmjs/crypto';
import { makeSignBytes } from '@cosmjs/proto-signing';
import { hexToSignature, hexToUint8Array } from '../../utils/formattingUtils';
class CapsuleCosmosSigner {
    constructor(capsule, prefix = 'cosmos', currentWalletId) {
        this.capsule = capsule;
        this.prefix = prefix;
        this._currentWalletId = currentWalletId;
    }
    get publicKey() {
        const wallet = this.capsule.getWallets()[this.currentWalletId];
        const uncompressedPublicKey = hexToUint8Array(wallet.publicKey);
        const compressedPublicKey = Secp256k1.compressPubkey(uncompressedPublicKey);
        return compressedPublicKey;
    }
    set currentWalletId(walletId) {
        this._currentWalletId = walletId;
    }
    get currentWalletId() {
        var _a;
        return this._currentWalletId || ((_a = Object.values(this.capsule.getWallets())[0]) === null || _a === void 0 ? void 0 : _a.id);
    }
    get address() {
        return toBech32(this.prefix, rawSecp256k1PubkeyToRawAddress(this.publicKey));
    }
    getAccounts() {
        return __awaiter(this, void 0, void 0, function* () {
            return [
                {
                    algo: 'secp256k1',
                    address: this.address,
                    pubkey: this.publicKey,
                },
            ];
        });
    }
}
export class CapsuleProtoSigner extends CapsuleCosmosSigner {
    signDirect(address, signDoc) {
        return __awaiter(this, void 0, void 0, function* () {
            const signBytes = makeSignBytes(signDoc);
            if (address !== this.address) {
                throw new Error(`Address ${address} not found in wallet`);
            }
            const hashedMessage = sha256(signBytes);
            const res = yield this.capsule.signMessage(this.currentWalletId, Buffer.from(hashedMessage.buffer).toString('base64'));
            const signature = hexToSignature(`0x${res.signature}`);
            const extendedSignature = new ExtendedSecp256k1Signature(hexToUint8Array(signature.r), hexToUint8Array(signature.s), Number(signature.v));
            const signatureBytes = new Uint8Array([...extendedSignature.r(32), ...extendedSignature.s(32)]);
            return {
                signed: signDoc,
                signature: encodeSecp256k1Signature(this.publicKey, signatureBytes),
            };
        });
    }
}
export class CapsuleAminoSigner extends CapsuleCosmosSigner {
    signAmino(signerAddress, signDoc) {
        return __awaiter(this, void 0, void 0, function* () {
            if (signerAddress !== this.address) {
                throw new Error(`Address ${signerAddress} not found in wallet`);
            }
            const hashedMessage = new Sha256(serializeSignDoc(signDoc)).digest();
            const res = yield this.capsule.signMessage(this.currentWalletId, Buffer.from(hashedMessage.buffer).toString('base64'));
            const signature = hexToSignature(`0x${res.signature}`);
            const extendedSignature = new ExtendedSecp256k1Signature(hexToUint8Array(signature.r), hexToUint8Array(signature.s), Number(signature.v));
            const signatureBytes = new Uint8Array([...extendedSignature.r(32), ...extendedSignature.s(32)]);
            return {
                signed: signDoc,
                signature: encodeSecp256k1Signature(this.publicKey, signatureBytes),
            };
        });
    }
}
