var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { PublicKeyStatus, PublicKeyType, } from '@usecapsule/user-management-client';
import { pki, jsbn } from 'node-forge';
import { decryptWithKeyPair, getAsymmetricKeyPair, getPublicKeyHex, } from './core/cryptography/utils';
import { keygen } from './wallet/keygen';
import { sendTransaction, signTransaction, signMessage } from './wallet/signing';
import { getPortalBaseURL } from './core/definitions';
import { Environment } from './core/definitions';
import { initClient } from './core/external/capsuleClient';
import * as mpcComputationClient from './core/external/mpcComputationClient';
import { distributeNewShare } from './core/shares/shareDistribution';
import { openPopup } from './modal/utils';
import * as transmissionUtils from './core/transmission/transmissionUtils';
// amount of time in ms that a web auth session lasts
const BIOMETRIC_VERIFICATION_TIME_MS = 30 * 60 * 1000;
const DEV_BIOMETRIC_VERIFICATION_TIME_MS = 60 * 60 * 1000;
var WalletScheme;
(function (WalletScheme) {
    WalletScheme["CGGMP"] = "CGGMP";
    WalletScheme["DKLS"] = "DKLS";
})(WalletScheme || (WalletScheme = {}));
// Make sure to keep this in sync with capsule-org/src/entities/recoveryAttemptEntity.ts
export var RecoveryStatus;
(function (RecoveryStatus) {
    RecoveryStatus["INITIATED"] = "INITIATED";
    RecoveryStatus["READY"] = "READY";
    RecoveryStatus["EXPIRED"] = "EXPIRED";
    RecoveryStatus["FINISHED"] = "FINISHED";
    RecoveryStatus["CANCELLED"] = "CANCELLED";
})(RecoveryStatus || (RecoveryStatus = {}));
const PREFIX = '@CAPSULE/';
const LOCAL_STORAGE_EMAIL = `${PREFIX}e-mail`;
const LOCAL_STORAGE_USER_ID = `${PREFIX}userId`;
const LOCAL_STORAGE_WALLETS = `${PREFIX}wallets`;
const SESSION_STORAGE_LOGIN_ENCRYPTION_KEY_PAIR = `${PREFIX}loginEncryptionKeyPair`;
const SESSION_STORAGE_SESSION_COOKIE = `${PREFIX}sessionCookie`;
function biometricVerifiedRecently(ctx, verifiedAt) {
    if (ctx.env !== Environment.PROD) {
        return Date.now() - verifiedAt <= DEV_BIOMETRIC_VERIFICATION_TIME_MS;
    }
    return Date.now() - verifiedAt <= BIOMETRIC_VERIFICATION_TIME_MS;
}
/**
 * Main entry point class.
 *
 * Deprecated. Use `CapsuleWeb` instead.
 * @internal
 **/
export class Capsule {
    convertBigInt(bigInt) {
        const convertedBigInt = new jsbn.BigInteger(null);
        convertedBigInt.data = bigInt.data;
        convertedBigInt.s = bigInt.s;
        convertedBigInt.t = bigInt.t;
        return convertedBigInt;
    }
    convertEncryptionKeyPair(jsonKeyPair) {
        return {
            privateKey: pki.setRsaPrivateKey(this.convertBigInt(jsonKeyPair.privateKey.n), this.convertBigInt(jsonKeyPair.privateKey.e), this.convertBigInt(jsonKeyPair.privateKey.d), this.convertBigInt(jsonKeyPair.privateKey.p), this.convertBigInt(jsonKeyPair.privateKey.q), this.convertBigInt(jsonKeyPair.privateKey.dP), this.convertBigInt(jsonKeyPair.privateKey.dQ), this.convertBigInt(jsonKeyPair.privateKey.qInv)),
            publicKey: pki.setRsaPublicKey(this.convertBigInt(jsonKeyPair.publicKey.n), this.convertBigInt(jsonKeyPair.publicKey.e)),
        };
    }
    requireApiKey() {
        if (!this.ctx.apiKey) {
            throw new Error(`in order to create a wallet or user with Capsule, you
          must provide an API key to the capsule instance`);
        }
    }
    // TODO: consider using sessionStorage instead of localStorage
    constructor(env, apiKey, opts) {
        this.localStorageGetItem = (key) => __awaiter(this, void 0, void 0, function* () {
            return localStorage.getItem(key);
        });
        this.localStorageSetItem = (key, value) => __awaiter(this, void 0, void 0, function* () {
            return localStorage.setItem(key, value);
        });
        this.sessionStorageGetItem = (key) => __awaiter(this, void 0, void 0, function* () {
            return sessionStorage.getItem(key);
        });
        this.sessionStorageSetItem = (key, value) => __awaiter(this, void 0, void 0, function* () {
            return sessionStorage.setItem(key, value);
        });
        this.sessionStorageRemoveItem = (key) => __awaiter(this, void 0, void 0, function* () {
            return sessionStorage.removeItem(key);
        });
        this.retrieveSessionCookie = () => {
            return this.sessionCookie;
        };
        this.persistSessionCookie = (cookie) => {
            this.sessionCookie = cookie;
            this.sessionStorageSetItem(SESSION_STORAGE_SESSION_COOKIE, cookie);
        };
        // remove all local storage and session storage prefixed for capsule
        this.clearStorage = () => __awaiter(this, void 0, void 0, function* () {
            for (let i = 0; i < localStorage.length; i++) {
                const key = localStorage.key(i);
                if (key && key.startsWith(PREFIX)) {
                    localStorage.removeItem(key);
                    i--;
                }
            }
            for (let j = 0; j < sessionStorage.length; j++) {
                const key = sessionStorage.key(j);
                if (key && key.startsWith(PREFIX)) {
                    sessionStorage.removeItem(key);
                    j--;
                }
            }
        });
        if (!opts)
            opts = {};
        this.ctx = {
            env,
            apiKey,
            capsuleClient: initClient(env, apiKey, opts.disableWorkers, this.retrieveSessionCookie, this.persistSessionCookie),
            disableWorkers: opts.disableWorkers,
            offloadMPCComputationURL: opts.offloadMPCComputationURL,
            useLocalFiles: opts.useLocalFiles,
            useDKLS: opts.useDKLSForCreation || !opts.offloadMPCComputationURL,
        };
        if (opts.offloadMPCComputationURL) {
            this.ctx.mpcComputationClient = mpcComputationClient.initClient(opts.offloadMPCComputationURL, opts.disableWorkers);
        }
        this.portalBackgroundColor = opts.portalBackgroundColor;
        this.portalPrimaryButtonColor = opts.portalPrimaryButtonColor;
        this.portalTextColor = opts.portalTextColor;
        this.portalPrimaryButtonTextColor = opts.portalPrimaryButtonTextColor;
        if (opts.useStorageOverrides) {
            this.localStorageGetItem = opts.localStorageGetItemOverride;
            this.localStorageSetItem = opts.localStorageSetItemOverride;
            this.sessionStorageGetItem = opts.sessionStorageGetItemOverride;
            this.sessionStorageSetItem = opts.sessionStorageSetItemOverride;
            this.sessionStorageRemoveItem = opts.sessionStorageRemoveItemOverride;
            this.clearStorage = opts.clearStorageOverride;
            return;
        }
        this.email = localStorage.getItem(LOCAL_STORAGE_EMAIL) || undefined;
        this.userId = localStorage.getItem(LOCAL_STORAGE_USER_ID) || undefined;
        this.wallets = JSON.parse(localStorage.getItem(LOCAL_STORAGE_WALLETS) || '{}');
        this.sessionCookie = sessionStorage.getItem(SESSION_STORAGE_SESSION_COOKIE) || undefined;
        if (sessionStorage.getItem(SESSION_STORAGE_LOGIN_ENCRYPTION_KEY_PAIR) &&
            sessionStorage.getItem(SESSION_STORAGE_LOGIN_ENCRYPTION_KEY_PAIR) !==
                'undefined') {
            this.loginEncryptionKeyPair = this.convertEncryptionKeyPair(JSON.parse(sessionStorage.getItem(SESSION_STORAGE_LOGIN_ENCRYPTION_KEY_PAIR)));
        }
    }
    init() {
        return __awaiter(this, void 0, void 0, function* () {
            this.email = (yield this.localStorageGetItem(LOCAL_STORAGE_EMAIL)) || undefined;
            this.userId = (yield this.localStorageGetItem(LOCAL_STORAGE_USER_ID)) || undefined;
            this.wallets = JSON.parse((yield this.localStorageGetItem(LOCAL_STORAGE_WALLETS)) || '{}');
            this.sessionCookie = (yield this.sessionStorageGetItem(SESSION_STORAGE_SESSION_COOKIE)) || undefined;
            if ((yield this.sessionStorageGetItem(SESSION_STORAGE_LOGIN_ENCRYPTION_KEY_PAIR)) &&
                (yield this.sessionStorageGetItem(SESSION_STORAGE_LOGIN_ENCRYPTION_KEY_PAIR)) !==
                    'undefined') {
                this.loginEncryptionKeyPair = this.convertEncryptionKeyPair(JSON.parse(yield this.sessionStorageGetItem(SESSION_STORAGE_LOGIN_ENCRYPTION_KEY_PAIR)));
            }
        });
    }
    generatePaillierKey() {
        return __awaiter(this, void 0, void 0, function* () {
            return;
        });
    }
    setEmail(email) {
        return __awaiter(this, void 0, void 0, function* () {
            this.email = email;
            yield this.localStorageSetItem(LOCAL_STORAGE_EMAIL, email);
        });
    }
    setUserId(userId) {
        return __awaiter(this, void 0, void 0, function* () {
            this.userId = userId;
            yield this.localStorageSetItem(LOCAL_STORAGE_USER_ID, userId);
        });
    }
    setWallets(wallets) {
        return __awaiter(this, void 0, void 0, function* () {
            this.wallets = wallets;
            yield this.localStorageSetItem(LOCAL_STORAGE_WALLETS, JSON.stringify(wallets));
        });
    }
    setLoginEncryptionKeyPair(keyPair) {
        return __awaiter(this, void 0, void 0, function* () {
            this.loginEncryptionKeyPair = keyPair;
            yield this.sessionStorageSetItem(SESSION_STORAGE_LOGIN_ENCRYPTION_KEY_PAIR, JSON.stringify(keyPair));
        });
    }
    deleteLoginEncryptionKeyPair() {
        return __awaiter(this, void 0, void 0, function* () {
            this.loginEncryptionKeyPair = undefined;
            yield this.sessionStorageRemoveItem(SESSION_STORAGE_LOGIN_ENCRYPTION_KEY_PAIR);
        });
    }
    getEmail() {
        return this.email;
    }
    getWallets() {
        return this.wallets;
    }
    getPartnerURL(partnerId) {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this.ctx.capsuleClient.getPartner(partnerId);
            return res.data.partner.portalUrl;
        });
    }
    getPortalURL(partnerId) {
        return __awaiter(this, void 0, void 0, function* () {
            return (partnerId && (yield this.getPartnerURL(partnerId))) || getPortalBaseURL(this.ctx);
        });
    }
    getWebAuthURLForCreate(webAuthId, partnerId, isForNewDevice) {
        return __awaiter(this, void 0, void 0, function* () {
            const partnerIdQueryParam = partnerId ? `&partnerId=${partnerId}` : '';
            const portalBackgroundColorQueryParam = this.portalBackgroundColor ? `&portalBackgroundColor=${encodeURIComponent(this.portalBackgroundColor)}` : '';
            const portalPrimaryButtonColorQueryParam = this.portalPrimaryButtonColor ? `&portalPrimaryButtonColor=${encodeURIComponent(this.portalPrimaryButtonColor)}` : '';
            const portalTextColorQueryParam = this.portalTextColor ? `&portalTextColor=${encodeURIComponent(this.portalTextColor)}` : '';
            const portalPrimaryButtonTextColorQueryParam = this.portalPrimaryButtonTextColor ? `&portalPrimaryButtonTextColor=${encodeURIComponent(this.portalPrimaryButtonTextColor)}` : '';
            const isForNewDeviceQueryParam = isForNewDevice ? `&isForNewDevice=${isForNewDevice}` : '';
            return `${(partnerId && (yield this.getPartnerURL(partnerId))) || getPortalBaseURL(this.ctx)}/web/users/${this.userId}/biometrics/${webAuthId}?email=${encodeURIComponent(this.email)}${partnerIdQueryParam}${portalBackgroundColorQueryParam}${portalPrimaryButtonColorQueryParam}${portalTextColorQueryParam}${isForNewDeviceQueryParam}${portalPrimaryButtonTextColorQueryParam}`;
        });
    }
    getShortUrl(compressedUrl) {
        return `${getPortalBaseURL(this.ctx)}/short/${compressedUrl}`;
    }
    shortenLoginLink(link) {
        return __awaiter(this, void 0, void 0, function* () {
            const url = yield transmissionUtils.upload(link, this.ctx.capsuleClient);
            return this.getShortUrl(url);
        });
    }
    getWebAuthURLForLogin(sessionId, loginEncryptionPublicKey, partnerId, newDeviceSessionId, newDeviceEncryptionKey) {
        return __awaiter(this, void 0, void 0, function* () {
            const partnerIdQueryParam = partnerId ? `&partnerId=${partnerId}` : '';
            const portalBackgroundColorQueryParam = this.portalBackgroundColor ? `&portalBackgroundColor=${encodeURIComponent(this.portalBackgroundColor)}` : '';
            const portalPrimaryButtonColorQueryParam = this.portalPrimaryButtonColor ? `&portalPrimaryButtonColor=${encodeURIComponent(this.portalPrimaryButtonColor)}` : '';
            const portalTextColorQueryParam = this.portalTextColor ? `&portalTextColor=${encodeURIComponent(this.portalTextColor)}` : '';
            const portalPrimaryButtonTextColorQueryParam = this.portalPrimaryButtonTextColor ? `&portalPrimaryButtonTextColor=${encodeURIComponent(this.portalPrimaryButtonTextColor)}` : '';
            const newDeviceSessionIdQueryParam = newDeviceSessionId ? `&newDeviceSessionId=${newDeviceSessionId}` : '';
            const newDeviceEncryptionKeyQueryParam = newDeviceEncryptionKey ? `&newDeviceEncryptionKey=${newDeviceEncryptionKey}` : '';
            return `${(partnerId && (yield this.getPartnerURL(partnerId))) || getPortalBaseURL(this.ctx)}/web/biometrics/login?email=${encodeURIComponent(this.email)}&sessionId=${sessionId}&encryptionKey=${loginEncryptionPublicKey}${partnerIdQueryParam}${portalBackgroundColorQueryParam}${portalPrimaryButtonColorQueryParam}${portalTextColorQueryParam}${newDeviceSessionIdQueryParam}${newDeviceEncryptionKeyQueryParam}${portalPrimaryButtonTextColorQueryParam}`;
        });
    }
    fetchWallets() {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this.ctx.capsuleClient.getWallets(this.userId);
            return res.data.wallets;
        });
    }
    populateWalletAddresses() {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this.ctx.capsuleClient.getWallets(this.userId);
            const wallets = res.data.wallets;
            wallets.forEach((wallet) => {
                if (this.wallets[wallet.id]) {
                    this.wallets[wallet.id].address = wallet.address;
                    this.wallets[wallet.id].publicKey = wallet.publicKey;
                    this.wallets[wallet.id].scheme = wallet.scheme;
                }
            });
            yield this.setWallets(this.wallets);
        });
    }
    checkIfUserExists(email) {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this.ctx.capsuleClient.checkUserExists(email);
            return res.data.exists;
        });
    }
    createUser(email) {
        return __awaiter(this, void 0, void 0, function* () {
            this.requireApiKey();
            yield this.setEmail(email);
            const { userId } = yield this.ctx.capsuleClient.createUser({
                email: this.email,
            });
            yield this.setUserId(userId);
        });
    }
    // returns web auth url for creating a new credential
    verifyEmail(verificationCode) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.ctx.capsuleClient.verifyEmail(this.userId, { verificationCode });
            return this.getSetUpBiometricsURL(false);
        });
    }
    verify2FA(email, verificationCode) {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this.ctx.capsuleClient.verify2FA(email, verificationCode);
            return {
                address: res.data.address,
                initiatedAt: res.data.initiatedAt,
                status: res.data.status,
                userId: res.data.userId,
                walletId: res.data.walletId,
            };
        });
    }
    setup2FA() {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this.ctx.capsuleClient.setup2FA(this.userId);
            return {
                uri: res.data.uri,
            };
        });
    }
    enable2FA(verificationCode) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.ctx.capsuleClient.enable2FA(this.userId, verificationCode);
        });
    }
    check2FAStatus() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.userId) {
                return { isSetup: false };
            }
            const res = yield this.ctx.capsuleClient.check2FAStatus(this.userId);
            return {
                isSetup: res.data.isSetup
            };
        });
    }
    resendVerificationCode() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.ctx.capsuleClient.resendVerificationCode(this.userId);
        });
    }
    // returns web auth url for creating a new credential
    getSetUpBiometricsURL(isForNewDevice) {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this.ctx.capsuleClient.addSessionPublicKey(this.userId, {
                status: PublicKeyStatus.PENDING,
                type: PublicKeyType.WEB,
            });
            return this.getWebAuthURLForCreate(res.data.id, res.data.partnerId, isForNewDevice);
        });
    }
    // TODO: consider changing this to just hit a new endpoint that returns
    //   true/false if session is active
    isSessionActive() {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this.ctx.capsuleClient.touchSession();
            return (res.data.biometricVerifiedAt &&
                biometricVerifiedRecently(this.ctx, res.data.biometricVerifiedAt));
        });
    }
    isFullyLoggedIn() {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            const isSessionActive = yield this.isSessionActive();
            const walletAddress = (_b = (_a = this.getWallets()) === null || _a === void 0 ? void 0 : _a[Object.keys(this.getWallets())[0]]) === null || _b === void 0 ? void 0 : _b.address;
            return isSessionActive && !!walletAddress;
        });
    }
    // returns web auth url for logging in
    initiateUserLogin(email) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.setEmail(email);
            const res = yield this.ctx.capsuleClient.touchSession(true);
            if (!this.loginEncryptionKeyPair) {
                const keyPair = yield getAsymmetricKeyPair(this.ctx);
                yield this.setLoginEncryptionKeyPair(keyPair);
            }
            return this.getWebAuthURLForLogin(res.data.sessionId, getPublicKeyHex(this.loginEncryptionKeyPair), res.data.partnerId);
        });
    }
    refreshSession(shouldOpenPopup) {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this.ctx.capsuleClient.touchSession(true);
            if (!this.loginEncryptionKeyPair) {
                const keyPair = yield getAsymmetricKeyPair(this.ctx);
                yield this.setLoginEncryptionKeyPair(keyPair);
            }
            const link = yield this.getWebAuthURLForLogin(res.data.sessionId, getPublicKeyHex(this.loginEncryptionKeyPair));
            if (shouldOpenPopup) {
                openPopup(link);
            }
            return link;
        });
    }
    userSetupAfterLogin() {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this.ctx.capsuleClient.touchSession();
            yield this.setUserId(res.data.userId);
        });
    }
    getTransmissionKeyShares(isForNewDevice) {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this.ctx.capsuleClient.touchSession();
            const sessionLookupId = isForNewDevice ?
                `${res.data.sessionLookupId}-new-device` :
                res.data.sessionLookupId;
            return this.ctx.capsuleClient.getTransmissionKeyshares(this.userId, sessionLookupId);
        });
    }
    setupAfterLogin(temporaryShares) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!temporaryShares) {
                temporaryShares = (yield this.getTransmissionKeyShares()).data.temporaryShares;
            }
            temporaryShares.forEach((share) => {
                this.wallets[share.walletId] = {
                    id: share.walletId,
                    signer: decryptWithKeyPair(this.loginEncryptionKeyPair, share.encryptedShare, share.encryptedKey),
                };
            });
            yield this.deleteLoginEncryptionKeyPair();
            yield this.populateWalletAddresses();
            yield this.ctx.capsuleClient.touchSession(true);
        });
    }
    distributeNewWalletShare(walletId, userShare) {
        return __awaiter(this, void 0, void 0, function* () {
            const recoveryShare = yield distributeNewShare(this.ctx, this.userId, walletId, userShare);
            return recoveryShare;
        });
    }
    createWallet(skipDistribute = false, customFunction) {
        return __awaiter(this, void 0, void 0, function* () {
            this.requireApiKey();
            const { signer, walletId, recoveryShare } = yield keygen(this.ctx, this.userId, null, skipDistribute, customFunction, this.retrieveSessionCookie());
            this.wallets[walletId] = {
                id: walletId,
                signer,
            };
            yield this.populateWalletAddresses();
            yield this.setWallets(this.wallets);
            return [this.wallets[walletId], recoveryShare];
        });
    }
    getTransactionReviewUrl(transactionId) {
        return `${getPortalBaseURL(this.ctx)}/web/users/${this.userId}/transaction-review/${transactionId}?email=${encodeURIComponent(this.email)}`;
    }
    // pass in base64 encoding of exact message that should be signed
    // if you want to sign the keccak256 hash of a message, hash the message first and then pass in the base64 encoded hash
    signMessage(walletId, messageBase64) {
        return __awaiter(this, void 0, void 0, function* () {
            const wallet = this.wallets[walletId];
            const res = yield signMessage(this.ctx, this.userId, walletId, this.wallets[walletId].signer, messageBase64, this.retrieveSessionCookie(), wallet.scheme === WalletScheme.DKLS);
            if (res.pendingTransactionId) {
                console.log(this.getTransactionReviewUrl(res.pendingTransactionId));
                return Object.assign(Object.assign({}, res), { transactionReviewUrl: this.getTransactionReviewUrl(res.pendingTransactionId) });
            }
            return res;
        });
    }
    signTransaction(walletId, rlpEncodedTxBase64, chainId) {
        return __awaiter(this, void 0, void 0, function* () {
            const wallet = this.wallets[walletId];
            const res = yield signTransaction(this.ctx, this.userId, walletId, this.wallets[walletId].signer, rlpEncodedTxBase64, chainId, this.retrieveSessionCookie(), wallet.scheme === WalletScheme.DKLS);
            if (res.pendingTransactionId) {
                console.log(this.getTransactionReviewUrl(res.pendingTransactionId));
                return Object.assign(Object.assign({}, res), { transactionReviewUrl: this.getTransactionReviewUrl(res.pendingTransactionId) });
            }
            return res;
        });
    }
    // pass in rlp encoded tx as base64 string
    sendTransaction(walletId, rlpEncodedTxBase64, chainId) {
        return __awaiter(this, void 0, void 0, function* () {
            const wallet = this.wallets[walletId];
            const res = yield sendTransaction(this.ctx, this.userId, walletId, this.wallets[walletId].signer, rlpEncodedTxBase64, chainId, this.retrieveSessionCookie(), wallet.scheme === WalletScheme.DKLS);
            if (res.pendingTransactionId) {
                console.log(this.getTransactionReviewUrl(res.pendingTransactionId));
                return Object.assign(Object.assign({}, res), { transactionReviewUrl: this.getTransactionReviewUrl(res.pendingTransactionId) });
            }
            return res;
        });
    }
    logout() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.ctx.capsuleClient.logout();
            yield this.clearStorage();
            this.wallets = {};
            this.loginEncryptionKeyPair = undefined;
            this.email = undefined;
            this.userId = undefined;
        });
    }
    // remove sensitive data when logging this class
    // doesn't work for all types of logging
    toString() {
        const redactedWallets = Object.keys(this.wallets).reduce((acc, walletId) => (Object.assign(Object.assign({}, acc), { [walletId]: {
                id: walletId,
                address: this.wallets[walletId].address,
                signer: this.wallets[walletId].signer ? '[REDACTED]' : undefined,
            } })), {});
        const obj = {
            email: this.email,
            userId: this.userId,
            wallets: redactedWallets,
            loginEncryptionKeyPair: this.loginEncryptionKeyPair
                ? '[REDACTED]'
                : undefined,
        };
        return `Capsule ${JSON.stringify(obj)}`;
    }
}
