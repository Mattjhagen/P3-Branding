var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import { useEffect, useRef, useState } from 'react';
import { Box, Button, ChakraProvider, Flex, HStack, Modal, ModalBody, ModalContent, ModalOverlay, Text, Tooltip, VStack, } from '@chakra-ui/react';
import { ModalStep, ModalStepNumber } from './steps';
import { EmailCollectionStep } from './EmailCollectionStep';
import { BiometricLoginStep } from './BiometricLoginStep';
import { AwaitingWalletCreationStep } from './AwaitingWalletCreationStep';
import { AccountCreationDoneStep } from './AccountCreationDoneStep';
import { LoginDoneStep } from './LoginDoneStep';
import { BiometricCreationStep } from './BiometricCreationStep';
import { VerificationCodeStep } from './VerificationCodeStep';
import { darkTheme, lightTheme, newTheme } from './theme';
import CapsuleSmall from './assets/capsuleSmall';
import { Header } from './Header';
import { Footer } from './Footer';
import { truncateEthAddress } from './utils';
import { Setup2FA } from './Setup2FA';
import { CoreCapsule } from '../core/CoreCapsule';
import { RecoverySecretStep } from './RecoverySecretStep';
import './css/modal.css';
import FlowContext from './FlowContext';
const themeResolve = {
    dark: darkTheme,
    light: lightTheme,
};
const POLLING_INTERVAL_MS = 2000;
const STORAGE_PREFIX = '@CAPSULE/';
export const CapsuleModal = ({ capsule, isOpen, onClose, theme = 'dark', appName, onRampCurrency = 'ARBITRUM_ETH', rampNetworkApiKey = '7t45dxm7yhho7fr9u4b9k8nv9gvczansfu8zt9pm', // staging
onRampAvailable = false, }) => {
    const resolvedTheme = typeof theme === 'string' ? themeResolve[theme] : theme;
    const [email, setEmail] = useState(capsule.getEmail());
    const [walletCreated, setWalletCreated] = useState(false);
    const [walletCreationInProgress, setWalletCreationInProgress] = useState(false);
    const [webAuthURLForLogin, setWebAuthURLForLoginState] = useState(sessionStorage.getItem(`${STORAGE_PREFIX}webAuthURLForLogin`) || '');
    const setWebAuthURLForLogin = (value) => {
        setWebAuthURLForLoginState(value);
        sessionStorage.setItem(`${STORAGE_PREFIX}webAuthURLForLogin`, value);
    };
    const [isCreateAccountType, setIsCreateAccountTypeState] = useState(sessionStorage.getItem(`${STORAGE_PREFIX}isCreateAccountType`) === 'true');
    const setIsCreateAccountType = (value) => {
        setIsCreateAccountTypeState(value);
        sessionStorage.setItem(`${STORAGE_PREFIX}isCreateAccountType`, value.toString());
    };
    const [distributeDone, setDistributeDone] = useState(false);
    const [isFullyLoggedIn, setIsFullyLoggedInState] = useState(sessionStorage.getItem(`${STORAGE_PREFIX}isFullyLoggedIn`) === 'true');
    const setIsFullyLoggedIn = (value) => {
        setIsFullyLoggedInState(value);
        sessionStorage.setItem(`${STORAGE_PREFIX}isFullyLoggedIn`, value.toString());
    };
    const [webAuthURLForCreate, setWebAuthURLForCreateState] = useState(sessionStorage.getItem(`${STORAGE_PREFIX}webAuthURLForCreate`) || '');
    const setWebAuthURLForCreate = (value) => {
        setWebAuthURLForCreateState(value);
        sessionStorage.setItem(`${STORAGE_PREFIX}webAuthURLForCreate`, value);
    };
    const [currentStep, setCurrentStepState] = useState(sessionStorage.getItem(`${STORAGE_PREFIX}currentStep`) || ModalStep.EMAIL_COLLECTION);
    const setCurrentStep = (value) => {
        setCurrentStepState(value);
        sessionStorage.setItem(`${STORAGE_PREFIX}currentStep`, value);
    };
    const [createWalletRes, setCreateWalletRes] = useState(null);
    const [recoveryShare, setRecoveryShare] = useState(null);
    const createAccountTimeout = useRef();
    const loginTimeout = useRef();
    const [percentKeygenDone, setPercentKeygenDone] = useState(0);
    const [isLogin, setIsLogin] = useState(false);
    const is2FASetup = () => __awaiter(void 0, void 0, void 0, function* () {
        try {
            const { isSetup } = yield capsule.check2FAStatus();
            return isSetup;
        }
        catch (error) {
            console.error('An error occurred while checking 2FA:', error);
            return false;
        }
    });
    useEffect(() => {
        if (!isOpen && [ModalStep.LOGIN_DONE, ModalStep.ACCOUNT_CREATION_DONE].includes(currentStep)) {
            setCurrentStep(ModalStep.EMAIL_COLLECTION);
            setIsFullyLoggedIn(false);
            setDistributeDone(false);
            setIsCreateAccountType(false);
            setWebAuthURLForLogin('');
            setWebAuthURLForLogin('');
            setWebAuthURLForCreate('');
            setWalletCreated(false);
            setPercentKeygenDone(0);
            setCreateWalletRes(null);
            setRecoveryShare(null);
        }
    }, [isOpen]);
    // function should be called a total of 5 times
    function keygenStatusFunction() {
        setPercentKeygenDone((percentKeygenDone) => percentKeygenDone + 15);
    }
    // generate wallet once we know it's account creation
    useEffect(() => {
        if ((!isCreateAccountType && currentStep !== ModalStep.AWAITING_WALLET_CREATION_AFTER_LOGIN) ||
            walletCreated ||
            walletCreationInProgress) {
            return;
        }
        function genWallet() {
            return __awaiter(this, void 0, void 0, function* () {
                setWalletCreationInProgress(true);
                const createWalletRes = yield capsule.createWallet(true, keygenStatusFunction);
                setCreateWalletRes(createWalletRes);
                setWalletCreated(true);
                setWalletCreationInProgress(false);
            });
        }
        genWallet();
    }, [isCreateAccountType, currentStep]);
    // distribute share once we know keygen is done
    useEffect(() => {
        if (distributeDone || !isFullyLoggedIn || !walletCreated) {
            return;
        }
        function distributeShare() {
            return __awaiter(this, void 0, void 0, function* () {
                const result = yield capsule.distributeNewWalletShare(createWalletRes[0].id, createWalletRes[0].signer);
                setRecoveryShare(result);
                setDistributeDone(true);
                if (currentStep === ModalStep.AWAITING_WALLET_CREATION_AFTER_LOGIN) {
                    if (yield is2FASetup()) {
                        setCurrentStep(ModalStep.LOGIN_DONE);
                    }
                    else {
                        setCurrentStep(ModalStep.SETUP_2FA);
                    }
                }
                else {
                    setCurrentStep(ModalStep.SECRET);
                }
            });
        }
        distributeShare();
    }, [isFullyLoggedIn, walletCreated, createWalletRes]);
    function awaitWalletCreationTransition() {
        return __awaiter(this, void 0, void 0, function* () {
            if (capsule instanceof CoreCapsule) {
                yield capsule.waitForAccountCreation();
                setIsFullyLoggedIn(true);
                setWebAuthURLForCreate('');
                setCurrentStep(ModalStep.AWAITING_WALLET_CREATION);
                return;
            }
            try {
                if (yield capsule.isSessionActive()) {
                    setIsFullyLoggedIn(true);
                    setWebAuthURLForCreate('');
                    setCurrentStep(ModalStep.AWAITING_WALLET_CREATION);
                    return;
                }
            }
            catch (err) {
                // want to continue polling on error and still set timeout
                console.error(err);
            }
            createAccountTimeout.current = window.setTimeout(awaitWalletCreationTransition, POLLING_INTERVAL_MS);
        });
    }
    // wait for biometric to be added to move on to next step
    useEffect(() => {
        if (webAuthURLForCreate) {
            createAccountTimeout.current = window.setTimeout(awaitWalletCreationTransition, POLLING_INTERVAL_MS);
        }
        return () => clearTimeout(createAccountTimeout.current);
    }, [webAuthURLForCreate]);
    function awaitLoginTransition() {
        return __awaiter(this, void 0, void 0, function* () {
            if (capsule instanceof CoreCapsule) {
                const { needsWallet } = yield capsule.waitForLoginAndSetup();
                setIsFullyLoggedIn(true);
                setWebAuthURLForLogin('');
                if (needsWallet) {
                    setCurrentStep(ModalStep.AWAITING_WALLET_CREATION_AFTER_LOGIN);
                }
                else {
                    if (yield is2FASetup()) {
                        setCurrentStep(ModalStep.LOGIN_DONE);
                    }
                    else {
                        setCurrentStep(ModalStep.SETUP_2FA);
                    }
                }
                return;
            }
            try {
                const isActive = yield capsule.isSessionActive();
                if (!isActive) {
                    loginTimeout.current = window.setTimeout(awaitLoginTransition, POLLING_INTERVAL_MS);
                    return;
                }
                yield capsule.userSetupAfterLogin();
                const fetchedWallets = (yield capsule.fetchWallets()).filter(wallet => !!wallet.address);
                const tempSharesRes = yield capsule.getTransmissionKeyShares();
                // need this check for the case where user has logged in but temp encrypted shares
                // haven't been sent to the backend yet
                if (tempSharesRes.data.temporaryShares.length === fetchedWallets.length) {
                    yield capsule.setupAfterLogin(tempSharesRes.data.temporaryShares);
                    setIsFullyLoggedIn(true);
                    setWebAuthURLForLogin('');
                    if (Object.values(capsule.getWallets()).length === 0) {
                        setCurrentStep(ModalStep.AWAITING_WALLET_CREATION_AFTER_LOGIN);
                        return;
                    }
                    if (yield is2FASetup()) {
                        setCurrentStep(ModalStep.LOGIN_DONE);
                    }
                    else {
                        setCurrentStep(ModalStep.SETUP_2FA);
                    }
                    return;
                }
            }
            catch (err) {
                // want to continue polling on error and still set timeout
                console.error(err);
            }
            loginTimeout.current = window.setTimeout(awaitLoginTransition, POLLING_INTERVAL_MS);
        });
    }
    // wait for login auth to do post login setup
    useEffect(() => {
        if (webAuthURLForLogin) {
            loginTimeout.current = window.setTimeout(awaitLoginTransition, POLLING_INTERVAL_MS);
        }
        return () => clearTimeout(loginTimeout.current);
    }, [webAuthURLForLogin]);
    return (_jsx(FlowContext.Provider, { value: { isLogin, setIsLogin }, children: _jsx(ChakraProvider, { theme: resolvedTheme, children: _jsxs(Modal, { isOpen: isOpen, onClose: onClose, children: [_jsx(ModalOverlay, {}), _jsx(ModalContent, { backgroundColor: 'brand.background', width: "356px", height: "632px", children: _jsxs(ModalBody, { padding: 0, display: "flex", flexDirection: "column", children: [_jsx(Header, { step: ModalStepNumber[currentStep], onClose: onClose }), _jsxs(VStack, { alignItems: "center", display: "flex", flex: 1, margin: "22px 22px 0px", className: 'font-hanken', children: [_jsx(EmailCollectionStep, { setWebAuthURLForLogin: setWebAuthURLForLogin, setCurrentStep: setCurrentStep, setEmail: setEmail, email: email, capsule: capsule, setIsCreateAccountType: setIsCreateAccountType, currentStep: currentStep, appName: appName }), _jsx(VerificationCodeStep, { setCurrentStep: setCurrentStep, currentStep: currentStep, setWebAuthURLForCreate: setWebAuthURLForCreate, capsule: capsule, email: email }), _jsx(BiometricCreationStep, { currentStep: currentStep, webAuthURLForCreate: webAuthURLForCreate }), _jsx(BiometricLoginStep, { capsule: capsule, currentStep: currentStep, webAuthURLForLogin: webAuthURLForLogin }), _jsx(AwaitingWalletCreationStep, { currentStep: currentStep, percentKeygenDone: percentKeygenDone }), _jsx(AccountCreationDoneStep, { currentStep: currentStep, appName: appName, onClose: onClose, capsule: capsule, rampNetworkApiKey: rampNetworkApiKey, defaultAsset: onRampCurrency, onRampAvailable: onRampAvailable }), _jsx(RecoverySecretStep, { recoveryShare: recoveryShare, currentStep: currentStep, email: email, setCurrentStep: setCurrentStep }), currentStep === ModalStep.LOGIN_DONE && _jsx(LoginDoneStep, { onClose: onClose, appName: appName }), currentStep === ModalStep.SETUP_2FA && _jsx(Setup2FA, { setCurrentStep: setCurrentStep, capsule: capsule })] }), _jsx(Footer, {})] }) })] }) }) }));
};
function Helper() {
    return (_jsxs(Box, { w: "300px", h: "158px", backgroundColor: "brand.background", padding: "18px", display: 'flex', flexDirection: 'column', children: [_jsx(Text, { fontSize: "18px", color: "brand.content", children: "What is Connect?" }), _jsxs(HStack, { flex: 1, children: [_jsx(Box, { width: "60px", children: _jsx(CapsuleSmall, { w: 27, h: 48 }) }), _jsxs(Flex, { flexDirection: "column", alignItems: "left", justifyContent: "center", children: [_jsx(Text, { fontSize: "xs", color: "brand.content", children: "A New Way to Log In" }), _jsx(Text, { fontSize: "xs", color: "brand.dimmed2", children: "Get started and create a wallet or log in, powered by Capsule." })] })] })] }));
}
export function CapsuleButton({ capsule, appName, }) {
    var _a, _b;
    const [modalIsOpen, setModalIsOpen] = useState(false);
    const [address, setAddress] = useState((_b = (_a = Object.values(capsule.getWallets())) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.address);
    const [isSessionActive, setIsSessionActive] = useState(false);
    useEffect(() => {
        function checkSession() {
            return __awaiter(this, void 0, void 0, function* () {
                setIsSessionActive(yield capsule.isSessionActive());
            });
        }
        checkSession();
    }, []);
    return (_jsxs(ChakraProvider, { theme: newTheme, children: [_jsx(CapsuleModal, { appName: appName, isOpen: modalIsOpen, onClose: () => __awaiter(this, void 0, void 0, function* () {
                    var _c, _d;
                    if (yield capsule.isSessionActive()) {
                        const newAddress = (_d = (_c = Object.values(capsule.getWallets())) === null || _c === void 0 ? void 0 : _c[0]) === null || _d === void 0 ? void 0 : _d.address;
                        setAddress(newAddress);
                        setIsSessionActive(true);
                    }
                    setModalIsOpen(false);
                }), theme: newTheme, capsule: capsule }), _jsxs(HStack, { children: [(isSessionActive && address) ? (_jsx(Text, { textColor: 'brand.addressColor', children: truncateEthAddress(address) })) : null, _jsx(Tooltip, { isDisabled: !!(isSessionActive && address), label: _jsx(Helper, {}), backgroundColor: 'brand.background', borderRadius: "4px", children: _jsxs(Button, { width: '163px', height: '50px', backgroundColor: 'brand.background', color: 'white', onClick: () => {
                                if (isSessionActive && address) {
                                    capsule.logout().then(() => {
                                        setAddress(undefined);
                                        setIsSessionActive(false);
                                    });
                                }
                                else {
                                    setModalIsOpen(true);
                                }
                            }, children: [_jsx(Text, { size: "18px", marginRight: "9px", children: (isSessionActive && address) ? 'Logout' : 'Connect' }), _jsx(CapsuleSmall, {})] }) })] })] }));
}
