var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { ethers } from 'ethers';
import { TransactionReviewError } from '../../errors';
import { hexStringToBase64 } from '../../utils/formattingUtils';
export class CapsuleEthersSigner extends ethers.AbstractSigner {
    constructor(capsule, provider) {
        super(provider);
        this.capsule = capsule;
    }
    setCurrentWalletId(walletId) {
        if (!this.capsule.getWallets()[walletId]) {
            throw new Error(`no wallet exists with id ${walletId}`);
        }
        this.currentWalletId = walletId;
    }
    getCurrentWalletId() {
        var _a;
        const id = this.currentWalletId || ((_a = Object.values(this.capsule.getWallets())[0]) === null || _a === void 0 ? void 0 : _a.id);
        if (!id) {
            throw new Error(`no wallet available`);
        }
        if (!this.capsule.getWallets()[id]) {
            throw new Error(`no wallet exists with id ${id}`);
        }
        return id;
    }
    getAddress() {
        return __awaiter(this, void 0, void 0, function* () {
            const walletId = this.getCurrentWalletId();
            if (!walletId) {
                throw new Error('no wallet available');
            }
            return this.capsule.getWallets()[walletId].address;
        });
    }
    connect(provider) {
        return new CapsuleEthersSigner(this.capsule, provider);
    }
    signMessage(message) {
        return __awaiter(this, void 0, void 0, function* () {
            const hashedMessage = ethers.hashMessage(message);
            const base64HashedMessage = hexStringToBase64(hashedMessage);
            const res = yield this.capsule.signMessage(this.getCurrentWalletId(), base64HashedMessage);
            if (res.transactionReviewUrl) {
                throw new TransactionReviewError(res.transactionReviewUrl);
            }
            const signature = res.signature;
            return `0x${signature}`;
        });
    }
    validateTx(tx) {
        return __awaiter(this, void 0, void 0, function* () {
            const { to, from } = yield ethers.resolveProperties({
                to: (tx.to ? ethers.resolveAddress(tx.to, this.provider) : undefined),
                from: (tx.from ? ethers.resolveAddress(tx.from, this.provider) : undefined)
            });
            if (to) {
                tx.to = to;
            }
            if (from) {
                tx.from = from;
            }
            if (tx.from) {
                ethers.assertArgument(ethers.getAddress((tx.from)).toLowerCase() === (yield this.getAddress()).toLowerCase(), "transaction from address mismatch", "tx.from", tx.from);
                delete tx.from;
            }
            return ethers.Transaction.from(tx);
        });
    }
    signTransaction(tx) {
        return __awaiter(this, void 0, void 0, function* () {
            const txObj = yield this.validateTx(tx);
            txObj.signature = {
                r: "0x0",
                s: "0x0",
                v: 0,
            };
            const res = yield this.capsule.signTransaction(this.getCurrentWalletId(), hexStringToBase64(txObj.serialized), `${txObj.chainId}`);
            if (res.transactionReviewUrl) {
                throw new TransactionReviewError(res.transactionReviewUrl);
            }
            const signature = res.signature;
            const btx = ethers.Transaction.from(tx);
            btx.signature = `0x${signature}`;
            return btx.serialized;
        });
    }
    signTypedData(domain, types, value) {
        return __awaiter(this, void 0, void 0, function* () {
            const populated = yield ethers.TypedDataEncoder.resolveNames(domain, types, value, (name) => __awaiter(this, void 0, void 0, function* () {
                ethers.assert(this.provider != null, "cannot resolve ENS names without a provider", "UNSUPPORTED_OPERATION", {
                    operation: "resolveName",
                    info: { name }
                });
                const address = yield this.provider.resolveName(name);
                ethers.assert(address != null, "unconfigured ENS name", "UNCONFIGURED_NAME", {
                    value: name
                });
                return address;
            }));
            const res = yield this.capsule.signMessage(this.getCurrentWalletId(), hexStringToBase64(ethers.TypedDataEncoder.hash(populated.domain, types, populated.value)));
            if (res.transactionReviewUrl) {
                throw new TransactionReviewError(res.transactionReviewUrl);
            }
            const signature = res.signature;
            return `0x${signature}`;
        });
    }
}
