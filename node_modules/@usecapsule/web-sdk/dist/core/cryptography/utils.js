var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import base64url from 'base64url';
import forge from 'node-forge';
import { getPortalBaseURL } from '../definitions';
const rsa = forge.pki.rsa;
const RSA_ENCRYPTION_SCHEME = 'RSA-OAEP';
// iv can be constant only because every key is only ever used to encrypt one message
const CONSTANT_IV = '794241bc819a125a7b78ea313decc0bc';
export function getSHA256HashHex(str) {
    const md = forge.md.sha256.create();
    md.update(str);
    return md.digest().toHex();
}
export function getPublicKeyHex(keyPair) {
    const pem = forge.pki.publicKeyToRSAPublicKeyPem(keyPair.publicKey);
    return Buffer.from(pem, 'utf-8').toString('hex');
}
function publicKeyHexToPem(publicKeyHex) {
    return Buffer.from(publicKeyHex, 'hex').toString('utf-8');
}
export function getAsymmetricKeyPair(ctx, seedValue) {
    return __awaiter(this, void 0, void 0, function* () {
        const prng = forge.random.createInstance();
        if (seedValue) {
            prng.seedFileSync = (_n) => seedValue;
            prng.seedFile = (_n, cb) => {
                cb(null, seedValue);
            };
        }
        const options = {
            bits: 2048,
            e: 65537,
            prng,
        };
        if (!ctx.disableWorkers) {
            options.workLoad = 100;
            // only using 1 web worker as more makes the call non-deterministic
            // -1 uses optimal amount of web workers
            options.workers = seedValue ? 1 : -1;
            const workerRes = yield fetch(`${getPortalBaseURL(ctx)}/static/js/prime.worker.min.js`);
            const workerBlob = new Blob([yield workerRes.text()], { type: 'application/javascript' });
            options.workerScript = URL.createObjectURL(workerBlob);
        }
        return new Promise((resolve, reject) => rsa.generateKeyPair(options, (err, keypair) => {
            if (err) {
                reject(err);
            }
            resolve(keypair);
        }));
    });
}
export function getPublicKeyFromSignature(ctx, userHandle) {
    return __awaiter(this, void 0, void 0, function* () {
        const encodedUserHandle = base64url.encode(userHandle);
        const keyPair = yield getAsymmetricKeyPair(ctx, encodedUserHandle);
        return getPublicKeyHex(keyPair);
    });
}
// only use for one time key encryptions as iv is constant
export function symmetricKeyEncryptMessage(message) {
    const key = forge.random.getBytesSync(16);
    const cipher = forge.cipher.createCipher('AES-CBC', key);
    // iv can be constant only because every key is only ever used to encrypt one message
    cipher.start({ iv: CONSTANT_IV });
    cipher.update(forge.util.createBuffer(message));
    cipher.finish();
    const encryptedMessageHex = cipher.output.toHex();
    return { key, encryptedMessageHex };
}
export function decryptWithKeyPair(keyPair, encryptedMessageHex, encryptedKeyHex) {
    const encryptedKey = Buffer.from(encryptedKeyHex, 'hex').toString('utf-8');
    const key = keyPair.privateKey.decrypt(encryptedKey, RSA_ENCRYPTION_SCHEME);
    const decipher = forge.cipher.createDecipher('AES-CBC', key);
    // iv can be constant only because every key is only ever used to encrypt one message
    decipher.start({ iv: CONSTANT_IV });
    decipher.update(forge.util.createBuffer(forge.util.hexToBytes(encryptedMessageHex)));
    decipher.finish();
    return decipher.output.toString();
}
function decryptWithDerivedPrivateKey(ctx, seedValue, encryptedMessageHex, encryptedKeyHex) {
    return __awaiter(this, void 0, void 0, function* () {
        const keyPair = yield getAsymmetricKeyPair(ctx, seedValue);
        return decryptWithKeyPair(keyPair, encryptedMessageHex, encryptedKeyHex);
    });
}
export function getDerivedPrivateKeyAndDecrypt(ctx, seedValue, encryptedShares) {
    return __awaiter(this, void 0, void 0, function* () {
        return Promise.all(encryptedShares.map((share) => __awaiter(this, void 0, void 0, function* () {
            return ({
                walletId: share.walletId,
                signer: yield decryptWithDerivedPrivateKey(ctx, seedValue, share.encryptedShare, share.encryptedKey),
            });
        })));
    });
}
export function encryptWithDerivedPublicKey(publicKeyHex, message) {
    const { key, encryptedMessageHex } = symmetricKeyEncryptMessage(message);
    const publicKeyPem = publicKeyHexToPem(publicKeyHex);
    const publicKey = forge.pki.publicKeyFromPem(publicKeyPem);
    const encryptedKey = publicKey.encrypt(key, RSA_ENCRYPTION_SCHEME);
    const encryptedKeyHex = Buffer.from(encryptedKey, 'utf-8').toString('hex');
    return { encryptedMessageHex, encryptedKeyHex };
}
