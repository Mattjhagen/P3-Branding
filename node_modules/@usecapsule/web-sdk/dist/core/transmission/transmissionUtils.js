var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { randomBytes } from 'crypto';
import { ec as EC } from 'elliptic';
import { Encrypt as ECIESEncrypt } from '@celo/utils/lib/ecies';
import { Buffer } from 'buffer';
import { ECIESDecrypt } from '../shares/KeyContainer';
export function upload(message, userManagementClient) {
    return __awaiter(this, void 0, void 0, function* () {
        const secret = randomBytes(32).toString('hex');
        const ec = new EC('secp256k1');
        const privKey = ec.keyFromPrivate(Buffer.from(secret, 'hex'));
        const pubKey = privKey.getPublic(false, 'hex');
        const publicKey = Buffer.from(pubKey, 'hex');
        const pubkey = Buffer.from(ec.keyFromPublic(publicKey).getPublic(false, 'hex'), 'hex').subarray(1);
        const data = ECIESEncrypt(Buffer.from(pubkey), Buffer.from(message, 'ucs2')).toString('base64');
        const { data: { id }, } = yield userManagementClient.tempTrasmissionInit(data);
        return encodeURIComponent(id + '|' + secret);
    });
}
export function retrieve(uriEncodedMessage, userManagementClient) {
    return __awaiter(this, void 0, void 0, function* () {
        const [id, secret] = decodeURIComponent(uriEncodedMessage).split('|');
        const response = yield userManagementClient.tempTrasmission(id);
        const data = response.data.message;
        const buf = Buffer.from(data, 'base64');
        const res = ECIESDecrypt(Buffer.from(secret, 'hex'), buf).toString('ucs2');
        return res;
    });
}
