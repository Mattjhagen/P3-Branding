var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { PublicKeyStatus, PublicKeyType, } from '@usecapsule/user-management-client';
import { pki, jsbn } from 'node-forge';
import { decryptWithKeyPair, getAsymmetricKeyPair, getPublicKeyHex, } from './cryptography/utils';
import { getPortalBaseURL } from './definitions';
import { Environment } from './definitions';
import { initClient } from './external/capsuleClient';
import * as mpcComputationClient from './external/mpcComputationClient';
import { distributeNewShare } from './shares/shareDistribution';
import * as transmissionUtils from './transmission/transmissionUtils';
// amount of time in ms that a web auth session lasts
const BIOMETRIC_VERIFICATION_TIME_MS = 30 * 60 * 1000;
const DEV_BIOMETRIC_VERIFICATION_TIME_MS = 60 * 60 * 1000;
var WalletScheme;
(function (WalletScheme) {
    WalletScheme["CGGMP"] = "CGGMP";
    WalletScheme["DKLS"] = "DKLS";
})(WalletScheme || (WalletScheme = {}));
// Make sure to keep this in sync with capsule-org/src/entities/recoveryAttemptEntity.ts
export var RecoveryStatus;
(function (RecoveryStatus) {
    RecoveryStatus["INITIATED"] = "INITIATED";
    RecoveryStatus["READY"] = "READY";
    RecoveryStatus["EXPIRED"] = "EXPIRED";
    RecoveryStatus["FINISHED"] = "FINISHED";
    RecoveryStatus["CANCELLED"] = "CANCELLED";
})(RecoveryStatus || (RecoveryStatus = {}));
const PREFIX = '@CAPSULE/';
const LOCAL_STORAGE_EMAIL = `${PREFIX}e-mail`;
const LOCAL_STORAGE_USER_ID = `${PREFIX}userId`;
const LOCAL_STORAGE_WALLETS = `${PREFIX}wallets`;
const SESSION_STORAGE_LOGIN_ENCRYPTION_KEY_PAIR = `${PREFIX}loginEncryptionKeyPair`;
const SESSION_STORAGE_SESSION_COOKIE = `${PREFIX}sessionCookie`;
const POLLING_INTERVAL_MS = 2000;
const SHORT_POLLING_INTERVAL_MS = 1000;
function biometricVerifiedRecently(ctx, verifiedAt) {
    if (ctx.env !== Environment.PROD) {
        return Date.now() - verifiedAt <= DEV_BIOMETRIC_VERIFICATION_TIME_MS;
    }
    return Date.now() - verifiedAt <= BIOMETRIC_VERIFICATION_TIME_MS;
}
export class CoreCapsule {
    convertBigInt(bigInt) {
        const convertedBigInt = new jsbn.BigInteger(null);
        convertedBigInt.data = bigInt.data;
        convertedBigInt.s = bigInt.s;
        convertedBigInt.t = bigInt.t;
        return convertedBigInt;
    }
    convertEncryptionKeyPair(jsonKeyPair) {
        return {
            privateKey: pki.setRsaPrivateKey(this.convertBigInt(jsonKeyPair.privateKey.n), this.convertBigInt(jsonKeyPair.privateKey.e), this.convertBigInt(jsonKeyPair.privateKey.d), this.convertBigInt(jsonKeyPair.privateKey.p), this.convertBigInt(jsonKeyPair.privateKey.q), this.convertBigInt(jsonKeyPair.privateKey.dP), this.convertBigInt(jsonKeyPair.privateKey.dQ), this.convertBigInt(jsonKeyPair.privateKey.qInv)),
            publicKey: pki.setRsaPublicKey(this.convertBigInt(jsonKeyPair.publicKey.n), this.convertBigInt(jsonKeyPair.publicKey.e)),
        };
    }
    requireApiKey() {
        if (!this.ctx.apiKey) {
            throw new Error(`in order to create a wallet or user with Capsule, you
        must provide an API key to the capsule instance`);
        }
    }
    /**
     * Constructs a new `CoreCapsule` instance.
     * @param env - `Environment` to use.
     * @param apiKey - API key to use.
     * @param opts - Additional constructor options; see `ConstructorOpts`.
     * @returns - A new CoreCapsule instance.
     */
    constructor(env, apiKey, opts) {
        this.localStorageGetItem = (key) => {
            return this.platformUtils.localStorage.get(key);
        };
        this.localStorageSetItem = (key, value) => {
            return this.platformUtils.localStorage.set(key, value);
        };
        this.sessionStorageGetItem = (key) => {
            return this.platformUtils.sessionStorage.get(key);
        };
        this.sessionStorageSetItem = (key, value) => {
            return this.platformUtils.sessionStorage.set(key, value);
        };
        this.sessionStorageRemoveItem = (key) => {
            return this.platformUtils.sessionStorage.removeItem(key);
        };
        this.retrieveSessionCookie = () => {
            return this.sessionCookie;
        };
        this.persistSessionCookie = (cookie) => {
            this.sessionCookie = cookie;
            this.sessionStorageSetItem(SESSION_STORAGE_SESSION_COOKIE, cookie);
        };
        /**
         * Remove all local storage and prefixed session storage.
         */
        this.clearStorage = () => __awaiter(this, void 0, void 0, function* () {
            this.platformUtils.localStorage.clear(PREFIX);
            this.platformUtils.sessionStorage.clear(PREFIX);
            if (this.platformUtils.secureStorage) {
                this.platformUtils.secureStorage.clear(PREFIX);
            }
        });
        // TODO: consider using sessionStorage instead of localStorage
        if (!opts)
            opts = {};
        this.ctx = {
            env,
            apiKey,
            capsuleClient: initClient(env, apiKey, opts.disableWorkers, this.retrieveSessionCookie, this.persistSessionCookie),
            disableWorkers: opts.disableWorkers,
            offloadMPCComputationURL: opts.offloadMPCComputationURL,
            useLocalFiles: opts.useLocalFiles,
            useDKLS: opts.useDKLSForCreation || !opts.offloadMPCComputationURL,
        };
        if (opts.offloadMPCComputationURL) {
            this.ctx.mpcComputationClient = mpcComputationClient.initClient(opts.offloadMPCComputationURL, opts.disableWorkers);
        }
        this.portalBackgroundColor = opts.portalBackgroundColor;
        this.portalPrimaryButtonColor = opts.portalPrimaryButtonColor;
        this.portalTextColor = opts.portalTextColor;
        this.portalPrimaryButtonTextColor = opts.portalPrimaryButtonTextColor;
        this.platformUtils = this.getPlatformUtils();
        this.disableProviderModal = this.platformUtils.disableProviderModal;
        if (opts.useStorageOverrides) {
            this.localStorageGetItem = opts.localStorageGetItemOverride;
            this.localStorageSetItem = opts.localStorageSetItemOverride;
            this.sessionStorageGetItem = opts.sessionStorageGetItemOverride;
            this.sessionStorageSetItem = opts.sessionStorageSetItemOverride;
            this.sessionStorageRemoveItem = opts.sessionStorageRemoveItemOverride;
            this.clearStorage = opts.clearStorageOverride;
            return;
        }
        if (!this.platformUtils.isSyncStorage) {
            return;
        }
        this.email = this.localStorageGetItem(LOCAL_STORAGE_EMAIL) || undefined;
        this.userId = this.localStorageGetItem(LOCAL_STORAGE_USER_ID) || undefined;
        this.sessionCookie = this.sessionStorageGetItem(SESSION_STORAGE_SESSION_COOKIE) || undefined;
        const stringWallets = this.platformUtils.secureStorage ?
            this.platformUtils.secureStorage.get(LOCAL_STORAGE_WALLETS) :
            this.localStorageGetItem(LOCAL_STORAGE_WALLETS);
        this.wallets = JSON.parse(stringWallets || '{}');
        const loginEncryptionKey = this.sessionStorageGetItem(SESSION_STORAGE_LOGIN_ENCRYPTION_KEY_PAIR);
        if (loginEncryptionKey && loginEncryptionKey !== 'undefined') {
            this.loginEncryptionKeyPair = this.convertEncryptionKeyPair(JSON.parse(loginEncryptionKey));
        }
    }
    /**
     * Initialize storage relating to a `CoreCapsule` instance.
     *
     * Init only needs to be called for storage that is async.
     */
    init() {
        return __awaiter(this, void 0, void 0, function* () {
            this.email = (yield this.localStorageGetItem(LOCAL_STORAGE_EMAIL)) || undefined;
            this.userId = (yield this.localStorageGetItem(LOCAL_STORAGE_USER_ID)) || undefined;
            this.sessionCookie = (yield this.sessionStorageGetItem(SESSION_STORAGE_SESSION_COOKIE)) || undefined;
            const stringWallets = this.platformUtils.secureStorage ?
                yield this.platformUtils.secureStorage.get(LOCAL_STORAGE_WALLETS) :
                yield this.localStorageGetItem(LOCAL_STORAGE_WALLETS);
            this.wallets = JSON.parse(stringWallets || '{}');
            const loginEncryptionKey = yield this.sessionStorageGetItem(SESSION_STORAGE_LOGIN_ENCRYPTION_KEY_PAIR);
            if (loginEncryptionKey && loginEncryptionKey !== 'undefined') {
                this.loginEncryptionKeyPair = this.convertEncryptionKeyPair(JSON.parse(loginEncryptionKey));
            }
        });
    }
    /**
     * Sets the email associated with the `CoreCapsule` instance.
     * @param email - Email to set.
     */
    setEmail(email) {
        return __awaiter(this, void 0, void 0, function* () {
            this.email = email;
            yield this.localStorageSetItem(LOCAL_STORAGE_EMAIL, email);
        });
    }
    /**
     * Sets the user id associated with the `CoreCapsule` instance.
     * @param userId - User id to set.
     */
    setUserId(userId) {
        return __awaiter(this, void 0, void 0, function* () {
            this.userId = userId;
            yield this.localStorageSetItem(LOCAL_STORAGE_USER_ID, userId);
        });
    }
    /**
     * Sets the wallets associated with the `CoreCapsule` instance.
     * @param wallets - Wallets to set.
     */
    setWallets(wallets) {
        return __awaiter(this, void 0, void 0, function* () {
            this.wallets = wallets;
            if (this.platformUtils.secureStorage) {
                yield this.platformUtils.secureStorage.set(LOCAL_STORAGE_WALLETS, JSON.stringify(wallets));
                return;
            }
            yield this.localStorageSetItem(LOCAL_STORAGE_WALLETS, JSON.stringify(wallets));
        });
    }
    /**
     * Sets the login encryption key pair associated with the `CoreCapsule` instance.
     * @param keyPair - Encryption key pair generated from loginEncryptionKey.
     */
    setLoginEncryptionKeyPair(keyPair) {
        return __awaiter(this, void 0, void 0, function* () {
            this.loginEncryptionKeyPair = keyPair;
            yield this.sessionStorageSetItem(SESSION_STORAGE_LOGIN_ENCRYPTION_KEY_PAIR, JSON.stringify(keyPair));
        });
    }
    deleteLoginEncryptionKeyPair() {
        return __awaiter(this, void 0, void 0, function* () {
            this.loginEncryptionKeyPair = undefined;
            yield this.sessionStorageRemoveItem(SESSION_STORAGE_LOGIN_ENCRYPTION_KEY_PAIR);
        });
    }
    /**
     * Gets the email associated with the `CoreCapsule` instance.
     * @returns - email associated with the `CoreCapsule` instance.
     */
    getEmail() {
        return this.email;
    }
    /**
     * Gets the wallets associated with the `CoreCapsule` instance.
     * @returns - wallets associated with the `CoreCapsule` instance.
     */
    getWallets() {
        return this.wallets;
    }
    getPartnerURL(partnerId) {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this.ctx.capsuleClient.getPartner(partnerId);
            return res.data.partner.portalUrl;
        });
    }
    /**
     * URL of the portal, which can be associated with a partner id
     * @param partnerId - id of the partner to get the portal URL for
     * @returns - portal URL
     */
    getPortalURL(partnerId) {
        return __awaiter(this, void 0, void 0, function* () {
            return (partnerId && (yield this.getPartnerURL(partnerId))) || getPortalBaseURL(this.ctx);
        });
    }
    getWebAuthURLForCreate(webAuthId, partnerId, isForNewDevice) {
        return __awaiter(this, void 0, void 0, function* () {
            const partnerIdQueryParam = partnerId ? `&partnerId=${partnerId}` : '';
            const portalBackgroundColorQueryParam = this.portalBackgroundColor ? `&portalBackgroundColor=${encodeURIComponent(this.portalBackgroundColor)}` : '';
            const portalPrimaryButtonColorQueryParam = this.portalPrimaryButtonColor ? `&portalPrimaryButtonColor=${encodeURIComponent(this.portalPrimaryButtonColor)}` : '';
            const portalTextColorQueryParam = this.portalTextColor ? `&portalTextColor=${encodeURIComponent(this.portalTextColor)}` : '';
            const portalPrimaryButtonTextColorQueryParam = this.portalPrimaryButtonTextColor ? `&portalPrimaryButtonTextColor=${encodeURIComponent(this.portalPrimaryButtonTextColor)}` : '';
            const isForNewDeviceQueryParam = isForNewDevice ? `&isForNewDevice=${isForNewDevice}` : '';
            return `${(partnerId && (yield this.getPartnerURL(partnerId))) || getPortalBaseURL(this.ctx)}/web/users/${this.userId}/biometrics/${webAuthId}?email=${encodeURIComponent(this.email)}${partnerIdQueryParam}${portalBackgroundColorQueryParam}${portalPrimaryButtonColorQueryParam}${portalTextColorQueryParam}${isForNewDeviceQueryParam}${portalPrimaryButtonTextColorQueryParam}`;
        });
    }
    getShortUrl(compressedUrl) {
        return `${getPortalBaseURL(this.ctx)}/short/${compressedUrl}`;
    }
    shortenLoginLink(link) {
        return __awaiter(this, void 0, void 0, function* () {
            const url = yield transmissionUtils.upload(link, this.ctx.capsuleClient);
            return this.getShortUrl(url);
        });
    }
    /**
     * Generates a URL that can be used to perform web auth
     * for creating a new credential.
     * @param sessionId - id of the session to use for web auth
     * @param loginEncryptionPublicKey - public key to use for encrypting the login encryption key
     * @param partnerId - id of the partner to get the portal URL for
     * @param newDeviceSessionId - id of the session to use for web auth for a new device
     * @param newDeviceEncryptionKey - public key to use for encrypting the login encryption key for a new device
     * @returns - web auth url
     */
    getWebAuthURLForLogin(sessionId, loginEncryptionPublicKey, partnerId, newDeviceSessionId, newDeviceEncryptionKey) {
        return __awaiter(this, void 0, void 0, function* () {
            const partnerIdQueryParam = partnerId ? `&partnerId=${partnerId}` : '';
            const portalBackgroundColorQueryParam = this.portalBackgroundColor ? `&portalBackgroundColor=${encodeURIComponent(this.portalBackgroundColor)}` : '';
            const portalPrimaryButtonColorQueryParam = this.portalPrimaryButtonColor ? `&portalPrimaryButtonColor=${encodeURIComponent(this.portalPrimaryButtonColor)}` : '';
            const portalTextColorQueryParam = this.portalTextColor ? `&portalTextColor=${encodeURIComponent(this.portalTextColor)}` : '';
            const portalPrimaryButtonTextColorQueryParam = this.portalPrimaryButtonTextColor ? `&portalPrimaryButtonTextColor=${encodeURIComponent(this.portalPrimaryButtonTextColor)}` : '';
            const newDeviceSessionIdQueryParam = newDeviceSessionId ? `&newDeviceSessionId=${newDeviceSessionId}` : '';
            const newDeviceEncryptionKeyQueryParam = newDeviceEncryptionKey ? `&newDeviceEncryptionKey=${newDeviceEncryptionKey}` : '';
            return `${(partnerId && (yield this.getPartnerURL(partnerId))) || getPortalBaseURL(this.ctx)}/web/biometrics/login?email=${encodeURIComponent(this.email)}&sessionId=${sessionId}&encryptionKey=${loginEncryptionPublicKey}${partnerIdQueryParam}${portalBackgroundColorQueryParam}${portalPrimaryButtonColorQueryParam}${portalTextColorQueryParam}${newDeviceSessionIdQueryParam}${newDeviceEncryptionKeyQueryParam}${portalPrimaryButtonTextColorQueryParam}`;
        });
    }
    /**
     * Fetches the wallets associated with the user.
     * @returns - wallets that were fetched.
     */
    fetchWallets() {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this.ctx.capsuleClient.getWallets(this.userId);
            return res.data.wallets;
        });
    }
    populateWalletAddresses() {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this.ctx.capsuleClient.getWallets(this.userId);
            const wallets = res.data.wallets;
            wallets.forEach((wallet) => {
                if (this.wallets[wallet.id]) {
                    this.wallets[wallet.id].address = wallet.address;
                    this.wallets[wallet.id].publicKey = wallet.publicKey;
                    this.wallets[wallet.id].scheme = wallet.scheme;
                }
            });
            yield this.setWallets(this.wallets);
        });
    }
    /**
     * Checks if a user exists.
     * @returns - true if user exists, false otherwise.
     */
    checkIfUserExists(email) {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this.ctx.capsuleClient.checkUserExists(email);
            return res.data.exists;
        });
    }
    /**
     * Creates a new user.
     * @param email - email to use for creating the user.
     */
    createUser(email) {
        return __awaiter(this, void 0, void 0, function* () {
            this.requireApiKey();
            yield this.setEmail(email);
            const { userId } = yield this.ctx.capsuleClient.createUser({
                email: this.email,
            });
            yield this.setUserId(userId);
        });
    }
    /**
     * Passes the email code obtained from the user for verification.
     * @param verificationCode
     * @returns - web auth url for creating a new credential
     */
    verifyEmail(verificationCode) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.ctx.capsuleClient.verifyEmail(this.userId, { verificationCode });
            return this.getSetUpBiometricsURL(false);
        });
    }
    /**
     * Performs 2FA verification.
     * @param email - email to use for performing a 2FA verification.
     * @param verificationCode - verification code to received via 2FA.
     * @returns { address, initiatedAt, status, userId, walletId }
     */
    verify2FA(email, verificationCode) {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this.ctx.capsuleClient.verify2FA(email, verificationCode);
            return {
                address: res.data.address,
                initiatedAt: res.data.initiatedAt,
                status: res.data.status,
                userId: res.data.userId,
                walletId: res.data.walletId,
            };
        });
    }
    /**
     * Sets up 2FA.
     * @returns uri - uri to use for setting up 2FA
     * */
    setup2FA() {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this.ctx.capsuleClient.setup2FA(this.userId);
            return {
                uri: res.data.uri,
            };
        });
    }
    /**
     * Enables 2FA.
     * @param verificationCode - verification code received via 2FA.
     */
    enable2FA(verificationCode) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.ctx.capsuleClient.enable2FA(this.userId, verificationCode);
        });
    }
    /**
     * Determines if 2FA has been set up.
     * @returns { isSetup } - true if 2FA is setup, false otherwise
     */
    check2FAStatus() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.userId) {
                return { isSetup: false };
            }
            const res = yield this.ctx.capsuleClient.check2FAStatus(this.userId);
            return {
                isSetup: res.data.isSetup
            };
        });
    }
    resendVerificationCode() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.ctx.capsuleClient.resendVerificationCode(this.userId);
        });
    }
    // returns web auth url for creating a new credential
    getSetUpBiometricsURL(isForNewDevice) {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this.ctx.capsuleClient.addSessionPublicKey(this.userId, {
                status: PublicKeyStatus.PENDING,
                type: PublicKeyType.WEB,
            });
            return this.getWebAuthURLForCreate(res.data.id, res.data.partnerId, isForNewDevice);
        });
    }
    // TODO: consider changing this to just hit a new endpoint that returns
    //   true/false if session is active
    isSessionActive() {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this.ctx.capsuleClient.touchSession();
            return (res.data.biometricVerifiedAt &&
                biometricVerifiedRecently(this.ctx, res.data.biometricVerifiedAt));
        });
    }
    /**
     * Checks if a session is active and a wallet exists.
     *
     * @returns - true if session is active and a wallet exists.
     **/
    isFullyLoggedIn() {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            const isSessionActive = yield this.isSessionActive();
            const walletAddress = (_b = (_a = this.getWallets()) === null || _a === void 0 ? void 0 : _a[Object.keys(this.getWallets())[0]]) === null || _b === void 0 ? void 0 : _b.address;
            return isSessionActive && !!walletAddress;
        });
    }
    /**
     * Initiates a login.
     * @param email - the email to login with
     * @param useShortURL - whether to shorten the link
     * @returns - web auth url for logging in
     **/
    initiateUserLogin(email, useShortURL) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.setEmail(email);
            const res = yield this.ctx.capsuleClient.touchSession(true);
            if (!this.loginEncryptionKeyPair) {
                const keyPair = yield getAsymmetricKeyPair(this.ctx);
                yield this.setLoginEncryptionKeyPair(keyPair);
            }
            const webAuthLoginURL = yield this.getWebAuthURLForLogin(res.data.sessionId, getPublicKeyHex(this.loginEncryptionKeyPair), res.data.partnerId);
            if (!useShortURL) {
                return webAuthLoginURL;
            }
            return this.shortenLoginLink(webAuthLoginURL);
        });
    }
    /**
     * Waits for the session to be active.
     **/
    waitForAccountCreation() {
        return __awaiter(this, void 0, void 0, function* () {
            // eslint-disable-next-line no-constant-condition
            while (true) {
                try {
                    yield new Promise(resolve => setTimeout(resolve, POLLING_INTERVAL_MS));
                    if (yield this.isSessionActive()) {
                        return;
                    }
                }
                catch (err) {
                    // want to continue polling on error
                    console.error(err);
                }
            }
        });
    }
    /**
     * Waits for the session to be active and sets up the user.
     * @returns { needsWallet } - whether a wallet needs to be created
     **/
    waitForLoginAndSetup() {
        return __awaiter(this, void 0, void 0, function* () {
            // eslint-disable-next-line no-constant-condition
            while (true) {
                try {
                    yield new Promise(resolve => setTimeout(resolve, POLLING_INTERVAL_MS));
                    if (!(yield this.isSessionActive())) {
                        continue;
                    }
                    yield this.userSetupAfterLogin();
                    const fetchedWallets = (yield this.fetchWallets()).filter(wallet => !!wallet.address);
                    const tempSharesRes = yield this.getTransmissionKeyShares();
                    // need this check for the case where user has logged in but temp encrypted shares
                    // haven't been sent to the backend yet
                    if (tempSharesRes.data.temporaryShares.length === fetchedWallets.length) {
                        yield this.setupAfterLogin(tempSharesRes.data.temporaryShares);
                        return { needsWallet: Object.values(this.getWallets()).length === 0 };
                    }
                }
                catch (err) {
                    // want to continue polling on error
                    console.error(err);
                }
            }
        });
    }
    /**
     * Updates the session with the user management server, possibly
     * opening a popup to refresh the session.
     *
     * @param shouldOpenPopup - true if you want to open the popup automatically
     * @returns - web auth url for refreshing session
     **/
    refreshSession(shouldOpenPopup) {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this.ctx.capsuleClient.touchSession(true);
            if (!this.loginEncryptionKeyPair) {
                const keyPair = yield getAsymmetricKeyPair(this.ctx);
                yield this.setLoginEncryptionKeyPair(keyPair);
            }
            const link = yield this.getWebAuthURLForLogin(res.data.sessionId, getPublicKeyHex(this.loginEncryptionKeyPair));
            if (shouldOpenPopup) {
                this.platformUtils.openPopup(link);
            }
            return link;
        });
    }
    /**
     * Call this method after login to ensure that the user ID is set
     * internally.
     **/
    userSetupAfterLogin() {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this.ctx.capsuleClient.touchSession();
            yield this.setUserId(res.data.userId);
        });
    }
    /**
     * Get transmission shares associated with session.
     *
     * @param isForNewDevice - true if this device is registering.
     * @returns - transmission keyshares.
     **/
    getTransmissionKeyShares(isForNewDevice) {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this.ctx.capsuleClient.touchSession();
            const sessionLookupId = isForNewDevice ?
                `${res.data.sessionLookupId}-new-device` :
                res.data.sessionLookupId;
            return this.ctx.capsuleClient.getTransmissionKeyshares(this.userId, sessionLookupId);
        });
    }
    /**
     * Call this method after login to perform setup.
     *
     * @param temporaryShares - optional temporary shares to use for decryption.
     **/
    setupAfterLogin(temporaryShares) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!temporaryShares) {
                temporaryShares = (yield this.getTransmissionKeyShares()).data.temporaryShares;
            }
            temporaryShares.forEach((share) => {
                this.wallets[share.walletId] = {
                    id: share.walletId,
                    signer: decryptWithKeyPair(this.loginEncryptionKeyPair, share.encryptedShare, share.encryptedKey),
                };
            });
            yield this.deleteLoginEncryptionKeyPair();
            yield this.populateWalletAddresses();
            yield this.ctx.capsuleClient.touchSession(true);
        });
    }
    /**
     * Distributes a new wallet recovery share.
     *
     * @param walletId - the wallet to distribute the recovery share for.
     * @param userShare - the user share generate the recovery share from.
     * @returns - recovery share.
     **/
    distributeNewWalletShare(walletId, userShare) {
        return __awaiter(this, void 0, void 0, function* () {
            const recoveryShare = yield distributeNewShare(this.ctx, this.userId, walletId, userShare);
            return recoveryShare;
        });
    }
    waitForWalletAddress(walletId) {
        return __awaiter(this, void 0, void 0, function* () {
            let maxPolls = 0;
            // eslint-disable-next-line no-constant-condition
            while (true) {
                try {
                    if (maxPolls === 10) {
                        break;
                    }
                    ++maxPolls;
                    const res = yield this.ctx.capsuleClient.getWallets(this.userId);
                    const wallet = res.data.wallets.find((w) => w.id === walletId);
                    if (wallet && wallet.address) {
                        return;
                    }
                    yield new Promise(resolve => setTimeout(resolve, SHORT_POLLING_INTERVAL_MS));
                }
                catch (err) {
                    // want to continue polling on error
                    console.error(err);
                }
            }
            throw new Error('timed out waiting for wallet address');
        });
    }
    /**
     * Creates a new wallet.
     *
     * @param skipDistribute - if true, recovery share will not be distributed.
     * @param customFunction - method called when createWallet is done.
     * @returns [wallet, recoveryShare]
     **/
    createWallet(skipDistribute = false, customFunction) {
        return __awaiter(this, void 0, void 0, function* () {
            this.requireApiKey();
            const { signer, walletId } = yield this.platformUtils.keygen(this.ctx, this.userId, null, customFunction, this.retrieveSessionCookie());
            this.wallets[walletId] = {
                id: walletId,
                signer,
            };
            yield this.waitForWalletAddress(walletId);
            yield this.populateWalletAddresses();
            let recoveryShare = null;
            if (!skipDistribute) {
                recoveryShare = yield distributeNewShare(this.ctx, this.userId, walletId, signer);
            }
            yield this.setWallets(this.wallets);
            return [this.wallets[walletId], recoveryShare];
        });
    }
    getTransactionReviewUrl(transactionId) {
        return `${getPortalBaseURL(this.ctx)}/web/users/${this.userId}/transaction-review/${transactionId}?email=${encodeURIComponent(this.email)}`;
    }
    /**
     * Signs a message.
     *
     * If you want to sign the keccak256 hash of a message, hash the
     * message first and then pass in the base64 encoded hash.
     * @param walletId - id of the wallet to sign with.
     * @param messageBase64 - base64 encoding of exact message that should be signed
     **/
    signMessage(walletId, messageBase64) {
        return __awaiter(this, void 0, void 0, function* () {
            const wallet = this.wallets[walletId];
            const res = yield this.platformUtils.signMessage(this.ctx, this.userId, walletId, this.wallets[walletId].signer, messageBase64, this.retrieveSessionCookie(), wallet.scheme === WalletScheme.DKLS);
            if (res.pendingTransactionId) {
                return Object.assign(Object.assign({}, res), { transactionReviewUrl: this.getTransactionReviewUrl(res.pendingTransactionId) });
            }
            return res;
        });
    }
    /**
     * Signs a transaction.
     * @param walletId - id of the wallet to sign the transaction from.
     * @param rlpEncodedTxBase64 - rlp encoded tx as base64 string
     * @param chainId - chain id of the chain the transaction is being sent on.
     **/
    signTransaction(walletId, rlpEncodedTxBase64, chainId) {
        return __awaiter(this, void 0, void 0, function* () {
            const wallet = this.wallets[walletId];
            const res = yield this.platformUtils.signTransaction(this.ctx, this.userId, walletId, this.wallets[walletId].signer, rlpEncodedTxBase64, chainId, this.retrieveSessionCookie(), wallet.scheme === WalletScheme.DKLS);
            if (res.pendingTransactionId) {
                return Object.assign(Object.assign({}, res), { transactionReviewUrl: this.getTransactionReviewUrl(res.pendingTransactionId) });
            }
            return res;
        });
    }
    /**
     * Sends a transaction.
     * @param walletId - id of the wallet to send the transaction from.
     * @param rlpEncodedTxBase64 - rlp encoded tx as base64 string
     * @param chainId - chain id of the chain the transaction is being sent on.
     **/
    sendTransaction(walletId, rlpEncodedTxBase64, chainId) {
        return __awaiter(this, void 0, void 0, function* () {
            const wallet = this.wallets[walletId];
            const res = yield this.platformUtils.sendTransaction(this.ctx, this.userId, walletId, this.wallets[walletId].signer, rlpEncodedTxBase64, chainId, this.retrieveSessionCookie(), wallet.scheme === WalletScheme.DKLS);
            if (res.pendingTransactionId) {
                return Object.assign(Object.assign({}, res), { transactionReviewUrl: this.getTransactionReviewUrl(res.pendingTransactionId) });
            }
            return res;
        });
    }
    isProviderModalDisabled() {
        return !!this.disableProviderModal;
    }
    exportSession() {
        const sessionInfo = {
            email: this.email,
            userId: this.userId,
            wallets: this.wallets,
            sessionCookie: this.sessionCookie,
        };
        return Buffer.from(JSON.stringify(sessionInfo)).toString('base64');
    }
    importSession(serializedInstanceBase64) {
        return __awaiter(this, void 0, void 0, function* () {
            const serializedInstance = Buffer.from(serializedInstanceBase64, 'base64').toString('utf8');
            const sessionInfo = JSON.parse(serializedInstance);
            yield this.setEmail(sessionInfo.email);
            yield this.setUserId(sessionInfo.userId);
            yield this.setWallets(sessionInfo.wallets);
            this.persistSessionCookie(sessionInfo.sessionCookie);
        });
    }
    /**
     * Logs the user out.
     **/
    logout() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.ctx.capsuleClient.logout();
            yield this.clearStorage();
            this.wallets = {};
            this.loginEncryptionKeyPair = undefined;
            this.email = undefined;
            this.userId = undefined;
            this.sessionCookie = undefined;
        });
    }
    /**
     * Converts to a string, removing sensitive data when logging this class.
     *
     * Doesn't work for all types of logging.
     **/
    toString() {
        const redactedWallets = Object.keys(this.wallets).reduce((acc, walletId) => (Object.assign(Object.assign({}, acc), { [walletId]: {
                id: walletId,
                address: this.wallets[walletId].address,
                signer: this.wallets[walletId].signer ? '[REDACTED]' : undefined,
            } })), {});
        const obj = {
            email: this.email,
            userId: this.userId,
            wallets: redactedWallets,
            loginEncryptionKeyPair: this.loginEncryptionKeyPair
                ? '[REDACTED]'
                : undefined,
        };
        return `Capsule ${JSON.stringify(obj)}`;
    }
}
