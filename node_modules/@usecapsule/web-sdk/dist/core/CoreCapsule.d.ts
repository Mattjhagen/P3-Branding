import { pki } from 'node-forge';
import { Ctx } from './definitions';
import { Environment } from './definitions';
import { FullSignatureRes } from './types/walletTypes';
import { PlatformUtils } from './PlatformUtils';
declare enum WalletScheme {
    CGGMP = "CGGMP",
    DKLS = "DKLS"
}
export declare enum RecoveryStatus {
    INITIATED = "INITIATED",
    READY = "READY",
    EXPIRED = "EXPIRED",
    FINISHED = "FINISHED",
    CANCELLED = "CANCELLED"
}
export interface Wallet {
    id: string;
    signer: string;
    address?: string;
    publicKey?: string;
    scheme?: WalletScheme;
}
export interface ConstructorOpts {
    useStorageOverrides?: boolean;
    disableWorkers?: boolean;
    offloadMPCComputationURL?: string;
    useLocalFiles?: boolean;
    localStorageGetItemOverride?: (key: string) => Promise<string | null>;
    localStorageSetItemOverride?: (key: string, value: string) => Promise<void>;
    sessionStorageGetItemOverride?: (key: string) => Promise<string | null>;
    sessionStorageSetItemOverride?: (key: string, value: string) => Promise<void>;
    sessionStorageRemoveItemOverride?: (key: string) => Promise<void>;
    clearStorageOverride?: () => Promise<void>;
    portalBackgroundColor?: string;
    portalPrimaryButtonColor?: string;
    portalTextColor?: string;
    portalPrimaryButtonTextColor?: string;
    useDKLSForCreation?: boolean;
}
export declare abstract class CoreCapsule {
    ctx: Ctx;
    private email?;
    private userId?;
    private wallets?;
    private sessionCookie?;
    /**
     * Encryption key pair generated from loginEncryptionKey.
     */
    loginEncryptionKeyPair?: pki.rsa.KeyPair;
    /**
     * Hex color to use in the portal for the background color.
     */
    portalBackgroundColor?: string;
    /**
     * Hex color to use in the portal for the primary button.
     */
    portalPrimaryButtonColor?: string;
    /**
     * Hex text color to use in the portal.
     */
    portalTextColor?: string;
    /**
     * Hex color to use in the portal for the primary button text.
     */
    portalPrimaryButtonTextColor?: string;
    private disableProviderModal?;
    private platformUtils;
    private localStorageGetItem;
    private localStorageSetItem;
    private sessionStorageGetItem;
    private sessionStorageSetItem;
    private sessionStorageRemoveItem;
    retrieveSessionCookie: () => string | undefined;
    persistSessionCookie: (cookie: string) => void;
    /**
     * Remove all local storage and prefixed session storage.
     */
    clearStorage: () => Promise<void>;
    private convertBigInt;
    private convertEncryptionKeyPair;
    private requireApiKey;
    protected abstract getPlatformUtils(): PlatformUtils;
    /**
     * Constructs a new `CoreCapsule` instance.
     * @param env - `Environment` to use.
     * @param apiKey - API key to use.
     * @param opts - Additional constructor options; see `ConstructorOpts`.
     * @returns - A new CoreCapsule instance.
     */
    constructor(env: Environment, apiKey?: string, opts?: ConstructorOpts);
    /**
     * Initialize storage relating to a `CoreCapsule` instance.
     *
     * Init only needs to be called for storage that is async.
     */
    init(): Promise<void>;
    /**
     * Sets the email associated with the `CoreCapsule` instance.
     * @param email - Email to set.
     */
    setEmail(email: string): Promise<void>;
    /**
     * Sets the user id associated with the `CoreCapsule` instance.
     * @param userId - User id to set.
     */
    setUserId(userId: string): Promise<void>;
    /**
     * Sets the wallets associated with the `CoreCapsule` instance.
     * @param wallets - Wallets to set.
     */
    setWallets(wallets: Record<string, Wallet>): Promise<void>;
    /**
     * Sets the login encryption key pair associated with the `CoreCapsule` instance.
     * @param keyPair - Encryption key pair generated from loginEncryptionKey.
     */
    setLoginEncryptionKeyPair(keyPair: pki.rsa.KeyPair): Promise<void>;
    private deleteLoginEncryptionKeyPair;
    /**
     * Gets the email associated with the `CoreCapsule` instance.
     * @returns - email associated with the `CoreCapsule` instance.
     */
    getEmail(): string | undefined;
    /**
     * Gets the wallets associated with the `CoreCapsule` instance.
     * @returns - wallets associated with the `CoreCapsule` instance.
     */
    getWallets(): Record<string, Wallet>;
    private getPartnerURL;
    /**
     * URL of the portal, which can be associated with a partner id
     * @param partnerId - id of the partner to get the portal URL for
     * @returns - portal URL
     */
    getPortalURL(partnerId?: string): Promise<string>;
    private getWebAuthURLForCreate;
    private getShortUrl;
    shortenLoginLink(link: string): Promise<string>;
    /**
     * Generates a URL that can be used to perform web auth
     * for creating a new credential.
     * @param sessionId - id of the session to use for web auth
     * @param loginEncryptionPublicKey - public key to use for encrypting the login encryption key
     * @param partnerId - id of the partner to get the portal URL for
     * @param newDeviceSessionId - id of the session to use for web auth for a new device
     * @param newDeviceEncryptionKey - public key to use for encrypting the login encryption key for a new device
     * @returns - web auth url
     */
    getWebAuthURLForLogin(sessionId: string, loginEncryptionPublicKey: string, partnerId?: string, newDeviceSessionId?: string, newDeviceEncryptionKey?: string): Promise<string>;
    /**
     * Fetches the wallets associated with the user.
     * @returns - wallets that were fetched.
     */
    fetchWallets(): Promise<any[]>;
    private populateWalletAddresses;
    /**
     * Checks if a user exists.
     * @returns - true if user exists, false otherwise.
     */
    checkIfUserExists(email: string): Promise<boolean>;
    /**
     * Creates a new user.
     * @param email - email to use for creating the user.
     */
    createUser(email: string): Promise<void>;
    /**
     * Passes the email code obtained from the user for verification.
     * @param verificationCode
     * @returns - web auth url for creating a new credential
     */
    verifyEmail(verificationCode: string): Promise<string>;
    /**
     * Performs 2FA verification.
     * @param email - email to use for performing a 2FA verification.
     * @param verificationCode - verification code to received via 2FA.
     * @returns { address, initiatedAt, status, userId, walletId }
     */
    verify2FA(email: string, verificationCode: string): Promise<{
        address?: string;
        initiatedAt?: Date;
        status?: RecoveryStatus;
        userId: string;
        walletId: string;
    }>;
    /**
     * Sets up 2FA.
     * @returns uri - uri to use for setting up 2FA
     * */
    setup2FA(): Promise<{
        uri?: string;
    }>;
    /**
     * Enables 2FA.
     * @param verificationCode - verification code received via 2FA.
     */
    enable2FA(verificationCode: string): Promise<void>;
    /**
     * Determines if 2FA has been set up.
     * @returns { isSetup } - true if 2FA is setup, false otherwise
     */
    check2FAStatus(): Promise<{
        isSetup: boolean;
    }>;
    resendVerificationCode(): Promise<void>;
    getSetUpBiometricsURL(isForNewDevice: boolean): Promise<string>;
    isSessionActive(): Promise<boolean>;
    /**
     * Checks if a session is active and a wallet exists.
     *
     * @returns - true if session is active and a wallet exists.
     **/
    isFullyLoggedIn(): Promise<boolean>;
    /**
     * Initiates a login.
     * @param email - the email to login with
     * @param useShortURL - whether to shorten the link
     * @returns - web auth url for logging in
     **/
    initiateUserLogin(email: string, useShortURL?: boolean): Promise<string>;
    /**
     * Waits for the session to be active.
     **/
    waitForAccountCreation(): Promise<void>;
    /**
     * Waits for the session to be active and sets up the user.
     * @returns { needsWallet } - whether a wallet needs to be created
     **/
    waitForLoginAndSetup(): Promise<{
        needsWallet: boolean;
    }>;
    /**
     * Updates the session with the user management server, possibly
     * opening a popup to refresh the session.
     *
     * @param shouldOpenPopup - true if you want to open the popup automatically
     * @returns - web auth url for refreshing session
     **/
    refreshSession(shouldOpenPopup: boolean): Promise<string>;
    /**
     * Call this method after login to ensure that the user ID is set
     * internally.
     **/
    userSetupAfterLogin(): Promise<void>;
    /**
     * Get transmission shares associated with session.
     *
     * @param isForNewDevice - true if this device is registering.
     * @returns - transmission keyshares.
     **/
    getTransmissionKeyShares(isForNewDevice?: boolean): Promise<any>;
    /**
     * Call this method after login to perform setup.
     *
     * @param temporaryShares - optional temporary shares to use for decryption.
     **/
    setupAfterLogin(temporaryShares?: any[]): Promise<void>;
    /**
     * Distributes a new wallet recovery share.
     *
     * @param walletId - the wallet to distribute the recovery share for.
     * @param userShare - the user share generate the recovery share from.
     * @returns - recovery share.
     **/
    distributeNewWalletShare(walletId: string, userShare: string): Promise<string>;
    private waitForWalletAddress;
    /**
     * Creates a new wallet.
     *
     * @param skipDistribute - if true, recovery share will not be distributed.
     * @param customFunction - method called when createWallet is done.
     * @returns [wallet, recoveryShare]
     **/
    createWallet(skipDistribute: boolean, customFunction: (params?: any) => void): Promise<[Wallet, string | null]>;
    private getTransactionReviewUrl;
    /**
     * Signs a message.
     *
     * If you want to sign the keccak256 hash of a message, hash the
     * message first and then pass in the base64 encoded hash.
     * @param walletId - id of the wallet to sign with.
     * @param messageBase64 - base64 encoding of exact message that should be signed
     **/
    signMessage(walletId: string, messageBase64: string): Promise<FullSignatureRes>;
    /**
     * Signs a transaction.
     * @param walletId - id of the wallet to sign the transaction from.
     * @param rlpEncodedTxBase64 - rlp encoded tx as base64 string
     * @param chainId - chain id of the chain the transaction is being sent on.
     **/
    signTransaction(walletId: string, rlpEncodedTxBase64: string, chainId: string): Promise<FullSignatureRes>;
    /**
     * Sends a transaction.
     * @param walletId - id of the wallet to send the transaction from.
     * @param rlpEncodedTxBase64 - rlp encoded tx as base64 string
     * @param chainId - chain id of the chain the transaction is being sent on.
     **/
    sendTransaction(walletId: string, rlpEncodedTxBase64: string, chainId: string): Promise<FullSignatureRes>;
    isProviderModalDisabled(): boolean;
    exportSession(): string;
    importSession(serializedInstanceBase64: string): Promise<void>;
    /**
     * Logs the user out.
     **/
    logout(): Promise<void>;
    /**
     * Converts to a string, removing sensitive data when logging this class.
     *
     * Doesn't work for all types of logging.
     **/
    toString(): string;
}
export {};
