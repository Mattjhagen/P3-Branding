export declare const USER_NOT_VERIFIED = "user must verify biometrics";
export declare const USER_NOT_AUTHENTICATED_ERROR = "user must be authenticated";
export declare const USER_NOT_MATCHING_ERROR = "route param userId must match session userId";
interface ConfigOpts {
    useFetchAdapter?: boolean;
}
type ClientConfig = {
    userManagementHost: string;
    apiKey?: string;
    opts?: ConfigOpts;
    retrieveSessionCookie?: () => string | undefined;
    persistSessionCookie?: (cookie: string) => void;
};
export interface createUserBody {
    email: string;
}
export interface createUserIdRes {
    protocolId: string;
    userId: string;
}
export interface verifyEmailBody {
    verificationCode: string;
}
export declare enum PublicKeyStatus {
    PENDING = "PENDING",
    COMPLETE = "COMPLETE"
}
export declare enum PublicKeyType {
    MOBILE = "MOBILE",
    WEB = "WEB"
}
interface sessionPublicKeyBody {
    publicKey?: string;
    sigDerivedPublicKey?: string;
    status?: PublicKeyStatus;
    type?: PublicKeyType;
    cosePublicKey?: string;
    clientDataJSON?: string;
}
interface WebSignature {
    clientDataJSON: string;
    authenticatorData: string;
    signature: string;
}
interface MobileSignature {
    r: string;
    s: string;
    recoveryParam: number;
}
interface verifyWebChallengeBody {
    email: string;
    sessionLookupId?: string;
    signature: WebSignature;
    publicKey?: string;
    newDeviceSessionLookupId?: string;
}
interface verifySessionChallengeBody {
    signature: MobileSignature | WebSignature;
    publicKey?: string;
}
export declare enum SignatureScheme {
    DKLS = "DKLS",
    CGGMP = "CGGMP"
}
interface createWalletBody {
    useTwoSigners?: boolean;
    scheme: SignatureScheme;
}
interface createWalletRes {
    protocolId: string;
    walletId: string;
}
interface signTransactionBody {
    transaction: string;
    chainId: string;
}
export declare enum Chain {
    ETH = "ETH",
    CELO = "CELO",
    MATIC = "MATIC"
}
interface sendTransactionBody {
    transaction: string;
    chain?: Chain;
    chainId?: string;
}
interface AcceptScopesBody {
    scopeIds: string[];
    partnerId: string;
}
export interface encryptedKeyshare {
    encryptedShare: string;
    encryptedKey?: string;
    type: (typeof KeyType)[keyof typeof KeyType];
    biometricPublicKey?: string;
    encryptor: (typeof EncryptorType)[keyof typeof EncryptorType];
}
export declare enum EncryptorType {
    USER = "USER",
    RECOVERY = "RECOVERY",
    BIOMETRICS = "BIOMETRICS"
}
export declare const KeyType: {
    readonly USER: "USER";
    readonly RECOVERY: "RECOVERY";
};
declare class Client {
    private baseRequest;
    constructor({ userManagementHost, apiKey, opts, retrieveSessionCookie, persistSessionCookie }: ClientConfig);
    createUser: (body: createUserBody) => Promise<createUserIdRes>;
    checkUserExists: (email: string) => Promise<any>;
    verifyEmail: (userId: string, body: verifyEmailBody) => Promise<any>;
    addSessionPublicKey: (userId: string, body: sessionPublicKeyBody) => Promise<any>;
    getSessionPublicKeys: (userId: string) => Promise<any>;
    getSessionPublicKey: (userId: string, biometricId: string) => Promise<any>;
    patchSessionPublicKey: (userId: string, biometricId: string, body: sessionPublicKeyBody) => Promise<any>;
    getWebChallenge: (email: string, publicKey?: string) => Promise<any>;
    touchSession: (regenerate?: boolean) => Promise<any>;
    verifyWebChallenge: (body: verifyWebChallengeBody) => Promise<any>;
    getSessionChallenge: (userId: string) => Promise<any>;
    verifySessionChallenge: (userId: string, body: verifySessionChallengeBody) => Promise<any>;
    createWallet: (userId: string, body?: createWalletBody) => Promise<createWalletRes>;
    sendTransaction: (userId: string, walletId: string, body: sendTransactionBody) => Promise<any>;
    signTransaction: (userId: string, walletId: string, body: signTransactionBody) => Promise<any>;
    refreshKeys: (userId: string, walletId: string) => Promise<any>;
    updateWallet: (userId: string, walletId: string) => Promise<any>;
    getWallets: (userId: string) => Promise<any>;
    login: (email: string) => Promise<any>;
    verifyLogin: (verificationCode: string) => Promise<any>;
    logout: () => Promise<any>;
    recoveryVerification: (email: string, verificationCode: string) => Promise<any>;
    recoveryInit: (email: string) => Promise<any>;
    preSignMessage: (userId: string, walletId: string, tx: string) => Promise<any>;
    uploadKeyshares(userId: string, walletId: string, encryptedKeyshares: encryptedKeyshare[]): Promise<any>;
    uploadUserKeyShares(userId: string, encryptedKeyshares: (encryptedKeyshare & {
        walletId: string;
    })[]): Promise<any>;
    getKeyshare(userId: string, walletId: string, type: (typeof KeyType)[keyof typeof KeyType], encryptor?: (typeof EncryptorType)[keyof typeof EncryptorType]): Promise<any>;
    getBiometricKeyshares(userId: string, biometricPublicKey: string): Promise<any>;
    uploadTransmissionKeyshares(userId: string, shares: {
        walletId: string;
        encryptedShare: string;
        encryptedKey?: string;
        sessionLookupId: string;
    }[]): Promise<any>;
    getTransmissionKeyshares(userId: string, sessionLookupId: string): Promise<any>;
    getCapsuleShare(userId: string, walletId: string): Promise<import("axios").AxiosResponse<any, any>>;
    resendVerificationCode(userId: string): Promise<import("axios").AxiosResponse<any, any>>;
    cancelRecoveryAttempt(email: string): Promise<import("axios").AxiosResponse<any, any>>;
    check2FAStatus(userId: string): Promise<import("axios").AxiosResponse<any, any>>;
    enable2FA(userId: string, verificationCode: string): Promise<import("axios").AxiosResponse<any, any>>;
    setup2FA(userId: string): Promise<import("axios").AxiosResponse<any, any>>;
    initializeRecovery(email: string): Promise<import("axios").AxiosResponse<any, any>>;
    finalizeRecovery(userId: string, walletId: string): Promise<import("axios").AxiosResponse<any, any>>;
    recoverUserShare(userId: string, walletId: string): Promise<import("axios").AxiosResponse<any, any>>;
    verifyEmailForRecovery(email: string, verificationCode: string): Promise<import("axios").AxiosResponse<any, any>>;
    verify2FA(email: string, verificationCode: string): Promise<import("axios").AxiosResponse<any, any>>;
    tempTrasmissionInit(message: string, userId?: string): Promise<import("axios").AxiosResponse<any, any>>;
    tempTrasmission(id: string): Promise<import("axios").AxiosResponse<any, any>>;
    getPartner(partnerId: string): Promise<import("axios").AxiosResponse<any, any>>;
    acceptScopes(userId: string, body: AcceptScopesBody): Promise<import("axios").AxiosResponse<any, any>>;
    getPendingTransaction(userId: string, pendingTransactionid: string): Promise<import("axios").AxiosResponse<any, any>>;
    acceptPendingTransaction(userId: string, pendingTransactionId: string): Promise<import("axios").AxiosResponse<any, any>>;
    getPolicyPermissions(userId: string, policyId: string): Promise<import("axios").AxiosResponse<any, any>>;
    distributeCapsuleShare(userId: string, walletId: string, useDKLS: boolean): Promise<import("axios").AxiosResponse<any, any>>;
}
export default Client;
