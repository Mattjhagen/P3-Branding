import axios, { AxiosInstance, AxiosRequestHeaders, AxiosResponseHeaders } from 'axios';
import { AxiosRequestConfig } from 'axios';
import { AxiosAdapter } from 'axios';

export const USER_NOT_VERIFIED = 'user must verify biometrics'
export const USER_NOT_AUTHENTICATED_ERROR = 'user must be authenticated'
export const USER_NOT_MATCHING_ERROR = 'route param userId must match session userId'

interface ConfigOpts {
  useFetchAdapter?: boolean
}

type ClientConfig = {
  userManagementHost: string
  apiKey?: string
  opts?: ConfigOpts
  retrieveSessionCookie?: () => string | undefined
  persistSessionCookie?: (cookie: string) => void
}

export interface createUserBody {
  email: string
}

export interface createUserIdRes {
  protocolId: string
  userId: string
}

export interface verifyEmailBody {
  verificationCode: string
}

export enum PublicKeyStatus {
  PENDING = 'PENDING',
  COMPLETE = 'COMPLETE',
}

export enum PublicKeyType {
  MOBILE = 'MOBILE',
  WEB = 'WEB',
}

interface sessionPublicKeyBody {
  publicKey?: string // only not included when status is PENDING
  sigDerivedPublicKey?: string // only include for type 'WEB'
  status?: PublicKeyStatus
  type?: PublicKeyType
  cosePublicKey?: string
  clientDataJSON?: string
}

interface WebSignature {
  clientDataJSON: string
  authenticatorData: string
  signature: string
}

interface MobileSignature {
  r: string
  s: string
  recoveryParam: number
}

interface verifyWebChallengeBody {
  email: string
  sessionLookupId?: string
  signature: WebSignature
  publicKey?: string
  newDeviceSessionLookupId?: string
}

interface verifySessionChallengeBody {
  signature: MobileSignature | WebSignature
  publicKey?: string
}

interface verifySessionChallengeRes {
  sessionChallenge: string
}

export enum SignatureScheme {
  DKLS = 'DKLS',
  CGGMP = 'CGGMP',
}

interface createWalletBody {
  useTwoSigners?: boolean
  scheme: SignatureScheme
}

interface createWalletRes {
  protocolId: string
  walletId: string
}

interface signTransactionBody {
  transaction: string
  chainId: string
}

export enum Chain {
  ETH = 'ETH',
  CELO = 'CELO',
  MATIC = 'MATIC',
}

// TODO: delete chain field and make chainId required
interface sendTransactionBody {
  transaction: string,
  chain?: Chain,
  chainId?: string,
}

interface AcceptScopesBody {
  scopeIds: string[]
  partnerId: string
}

export interface encryptedKeyshare {
  encryptedShare: string,
  encryptedKey?: string,
  type: (typeof KeyType)[keyof typeof KeyType],
  biometricPublicKey?: string,
  encryptor: (typeof EncryptorType)[keyof typeof EncryptorType],
}

export enum EncryptorType {
  USER = 'USER',
  RECOVERY = 'RECOVERY',
  BIOMETRICS = 'BIOMETRICS',
}

export const KeyType = {
  USER: 'USER',
  RECOVERY: 'RECOVERY',
} as const;

const SESSION_COOKIE_HEADER_NAME = 'x-capsule-sid';

class Client {
  private baseRequest: AxiosInstance;
  constructor({ userManagementHost, apiKey, opts, retrieveSessionCookie, persistSessionCookie }: ClientConfig) {
    // TODO remove after this is not optional anymore
    const headers = apiKey ? { "X-External-API-Key": apiKey } : undefined
    const axiosConfig = {
      baseURL: userManagementHost,
      withCredentials: true,
      headers,
    } as AxiosRequestConfig;

    if (retrieveSessionCookie) {
      const defaultTransformRequest = Array.isArray(axios.defaults.transformRequest) ?
        axios.defaults.transformRequest :
        [axios.defaults.transformRequest];

      axiosConfig.transformRequest = [
        function (data: any, headers?: AxiosRequestHeaders): any {
          if (!headers) {
            headers = {};
          }

          const currentSessionCookie = retrieveSessionCookie();
          if (currentSessionCookie) {
            headers[SESSION_COOKIE_HEADER_NAME] = currentSessionCookie;
          }

          return data;
        },
        ...defaultTransformRequest,
      ];
    }

    if (persistSessionCookie) {
      const defaultTransformResponse = Array.isArray(axios.defaults.transformResponse) ?
        axios.defaults.transformResponse :
        [axios.defaults.transformResponse];

      axiosConfig.transformResponse = [
        ...defaultTransformResponse,
        function (data: any, headers?: AxiosResponseHeaders): any {
          if (headers?.[SESSION_COOKIE_HEADER_NAME]) {
            persistSessionCookie(headers[SESSION_COOKIE_HEADER_NAME]);
          }

          return data;
        },
      ];
    }

    this.baseRequest = axios.create(axiosConfig);

    if (opts?.useFetchAdapter) {
      axios.defaults.adapter = function(config: AxiosRequestConfig) {
        return fetch(config.baseURL + config.url.substring(1), {
          method: config.method,
          headers: config.headers as HeadersInit,
          body: config.data,
          credentials: config.withCredentials ? 'include' : undefined
        }).then(response =>
          response.text().then(text => ({
            data: text,
            status: response.status,
            statusText: response.statusText,
            headers: response.headers,
            config: config,
            request: fetch
          }))
        ).catch(function(reason) {
          throw reason;
        });
      } as any;
    }
  }

  createUser = async (body: createUserBody): Promise<createUserIdRes> => {
    const res = await this.baseRequest.post<createUserIdRes>(`/users`, body);
    return res.data;
  }

  checkUserExists = async (email: string): Promise<any> => {
    const res = await this.baseRequest.get<any>(`/users/exists?email=${encodeURIComponent(email)}`);
    return res;
  }

  // POST /users/:userId/verify-email
  verifyEmail = async (userId: string, body: verifyEmailBody): Promise<any> => {
    const res = await this.baseRequest.post<any>(`/users/${userId}/verify-email`, body);
    return res;
  }

  // POST /users/:userId/biometrics/key
  addSessionPublicKey = async (userId: string, body: sessionPublicKeyBody): Promise<any> => {
    const res = await this.baseRequest.post<any>(`/users/${userId}/biometrics/key`, body);
    return res;
  }

  // GET /users/:userId/biometrics/keys
  getSessionPublicKeys = async (userId: string): Promise<any> => {
    const res = await this.baseRequest.get<any>(`/users/${userId}/biometrics/keys`);
    return res;
  }

  // GET /users/:userId/biometrics/:biometricId
  getSessionPublicKey = async (userId: string, biometricId: string): Promise<any> => {
    const res = await this.baseRequest.get<any>(`/users/${userId}/biometrics/${biometricId}`);
    return res;
  }

  // PATCH /users/:userId/biometrics/:biometricId
  patchSessionPublicKey = async (userId: string, biometricId: string, body: sessionPublicKeyBody): Promise<any> => {
    const res = await this.baseRequest.patch<any>(`/users/${userId}/biometrics/${biometricId}`, body);
    return res;
  }

  // GET /biometrics/challenge?email&publicKey
  getWebChallenge = async (email: string, publicKey?: string): Promise<any> => {
    const res = await this.baseRequest.get<any>(`/biometrics/challenge?email=${email}${publicKey ? `&publicKey=${publicKey}` : ''}`);
    return res;
  }

  // POST /touch
  touchSession = async (regenerate?: boolean): Promise<any> => {
    const res = await this.baseRequest.post<{ userId?: string, sessionLookupId: string, biometricVerifiedAt?: number }>(`/touch?regenerate=${!!regenerate}`);
    return res;
  }

  // POST /biometrics/verify
  verifyWebChallenge = async (body: verifyWebChallengeBody): Promise<any> => {
    const res = await this.baseRequest.post<{}>(`/biometrics/verify`, body);
    return res;
  }

  // GET /users/:userId/biometrics/challenge
  getSessionChallenge = async (userId: string): Promise<any> => {
    const res = await this.baseRequest.get<any>(`/users/${userId}/biometrics/challenge`);
    return res;
  }

  // POST /users/:userId/biometrics/verify
  verifySessionChallenge = async (userId: string, body: verifySessionChallengeBody): Promise<any> => {
    const res = await this.baseRequest.post<verifySessionChallengeRes>(`/users/${userId}/biometrics/verify`, body);
    return res;
  }

  // POST /users/:userId/wallets
  createWallet = async (userId: string, body?: createWalletBody): Promise<createWalletRes> => {
    const res = await this.baseRequest.post<createWalletRes>(`/users/${userId}/wallets`, body);
    return res.data;
  }

  // POST /users/:userId/wallets/:walletId/transactions/send
  sendTransaction = async (userId: string, walletId: string, body: sendTransactionBody): Promise<any> => {
    const res = await this.baseRequest.post<any>(`/users/${userId}/wallets/${walletId}/transactions/send`, body);
    return res;
  }

  // functionality changed to only sign transactions and not send them
  // POST /users/:userId/wallets/:walletId/transactions/sign
  signTransaction = async (userId: string, walletId: string, body: signTransactionBody): Promise<any> => {
    const res = await this.baseRequest.post<any>(`/users/${userId}/wallets/${walletId}/transactions/sign`, body);
    return res;
  }

  // POST /users/:userId/wallets/:walletId/refresh
  refreshKeys = async (userId: string, walletId: string): Promise<any> => {
    const res = await this.baseRequest.post<any>(`/users/${userId}/wallets/${walletId}/refresh`);
    return res;
  }

  // PATCH /users/:userId/wallets/:walletId
  updateWallet = async (userId: string, walletId: string): Promise<any> => {
    const res = await this.baseRequest.post<any>(`/users/${userId}/wallets/${walletId}`);
    return res;
  }

  // GET /users/:userId/wallets
  getWallets = async (userId: string): Promise<any> => {
    const res = await this.baseRequest.get<any>(`/users/${userId}/wallets`);
    return res;
  }

  // POST /login
  login = async (email: string): Promise<any> => {
    const body = { email }

    const res = await this.baseRequest.post<any>('/login', body);
    return res;
  }

  // POST /login
  verifyLogin = async (verificationCode: string): Promise<any> => {
    const body = { verificationCode }
    const res = await this.baseRequest.post<any>('/login/verify-email', body);
    return res;
  }

  // GET /logout
  logout = async (): Promise<any> => {
    const res = await this.baseRequest.get<any>('/logout');
    return res;
  }

  // POST /recovery/verification
  recoveryVerification = async (email: string, verificationCode: string): Promise<any> => {
    const body = { email, verificationCode }
    const res = await this.baseRequest.post<any>('/recovery/verification', body);
    return res;
  }

  // POST /recovery
  recoveryInit = async (email: string): Promise<any> => {
    const body = { email }
    const res = await this.baseRequest.post<any>('/recovery', body);
    return res;
  }

  preSignMessage = async (userId: string, walletId: string, tx: string): Promise<any> => {
    const body = { message: tx }
    const res = await this.baseRequest.post<any>(
        `/users/${userId}/wallets/${walletId}/messages/sign`,
        body
    )
    return res.data
  }

  // DEPRECATED: use uploadUserKeyShares instead
  // POST /users/:userId/wallets/:walletId/key-shares
  async uploadKeyshares(
      userId: string,
      walletId: string,
      encryptedKeyshares: encryptedKeyshare[]
      ): Promise<any> {
    const body = { keyShares: encryptedKeyshares }
    const res = await this.baseRequest.post<any>(
      `/users/${userId}/wallets/${walletId}/key-shares`,
        body);
    return res;
  }

  // POST /users/:userId/wallets/:walletId/key-shares
  async uploadUserKeyShares(
    userId: string,
    encryptedKeyshares: (encryptedKeyshare & { walletId: string })[]
  ): Promise<any> {
    const body = { keyShares: encryptedKeyshares }
    const res = await this.baseRequest.post<any>(
      `/users/${userId}/key-shares`,
        body);
    return res;
  }

  // GET /users/:userId/wallets/:walletId/key-shares
  async getKeyshare(userId: string, walletId: string, type: (typeof KeyType)[keyof typeof KeyType], encryptor?: (typeof EncryptorType)[keyof typeof EncryptorType]): Promise<any> {
    const res = await this.baseRequest.get<any>(
      `/users/${userId}/wallets/${walletId}/key-shares?type=${type}${encryptor ? `&encryptor=${encryptor}` : ''}`);
    return res;
  }

  // GET /users/:userId/biometrics/key-shares
  async getBiometricKeyshares(userId: string, biometricPublicKey: string): Promise<any> {
    const res = await this.baseRequest.get<any>(
      `/users/${userId}/biometrics/key-shares?publicKey=${biometricPublicKey}`);
    return res;
  }

  // POST '/users/:userId/temporary-shares',
  async uploadTransmissionKeyshares(userId: string, shares: { walletId: string, encryptedShare: string, encryptedKey?: string; sessionLookupId: string }[]): Promise<any> {
    const body = { shares }
    const res = await this.baseRequest.post<any>(
      `/users/${userId}/temporary-shares`,
      body);
    return res;
  }

  // GET /users/:userId/temporary-shares returns { temporaryShares: { userId: string, walletId: string, encryptedShare: string, encryptedKey?: string }[] }
  async getTransmissionKeyshares(userId: string, sessionLookupId: string): Promise<any> {
    const res = await this.baseRequest.get<any>(`/users/${userId}/temporary-shares?sessionLookupId=${sessionLookupId}`)
    return res;
  }

  // get /users/:userId/wallets/:walletId/capsule-share
  async getCapsuleShare(userId: string, walletId: string) {
    const res = await this.baseRequest.get<any>(
        `/users/${userId}/wallets/${walletId}/capsule-share`);
    return res;
  }

  // POST '/users/:userId/resend-verification-code
  async resendVerificationCode(userId: string) {
    const res = await this.baseRequest.post<any>(
      `/users/${userId}/resend-verification-code`
    );
    return res;
  }

  // POST recovery/cancel
  async cancelRecoveryAttempt(email: string) {
    const res = await this.baseRequest.post<any>(
      `recovery/cancel`,
      { email }
    );
    return res;
  }

  // GET '/2fa/users/:userId/check-status'
  async check2FAStatus(userId: string) {
    const res = await this.baseRequest.get<any>(
      `/2fa/users/${userId}/check-status`
    );
    return res;
  }

  // POST '/2fa/users/:userId/enable'
  async enable2FA(userId: string, verificationCode: string) {
    const res = await this.baseRequest.post<any>(
      `/2fa/users/${userId}/enable`,
      { verificationCode },
    );
    return res;
  }

  // POST '/2fa/users/:userId/setup'
  async setup2FA(userId: string) {
    const res = await this.baseRequest.post<any>(
      `/2fa/users/${userId}/setup`,
    );
    return res;
  }

  // POST /recovery/init
  async initializeRecovery(email: string) {
    const res = await this.baseRequest.post<any>(
      `/recovery/init`,
      { email },
    );
    return res;
  }

  // POST /recovery/users/:userId/wallets/:walletId/finish
  async finalizeRecovery(userId: string, walletId: string) {
    const res = await this.baseRequest.post<any>(
      `/recovery/users/${userId}/wallets/${walletId}/finish`
    );
    return res;
  }

  // GET /recovery/users/:userId/wallets/:walletId/key-shares
  async recoverUserShare(userId: string, walletId: string) {
    const res = await this.baseRequest.get<any>(
      `/recovery/users/${userId}/wallets/${walletId}/key-shares?type=USER&encryptor=RECOVERY`,
    );
    return res;
  }

  // POST /recovery/verify-email
  async verifyEmailForRecovery(email: string, verificationCode: string) {
    const body = { email, verificationCode }
    const res = await this.baseRequest.post<any>(
      `/recovery/verify-email`,
      body
    );
    return res;
  }

  // POST /2fa/verify
  async verify2FA(email: string, verificationCode: string) {
    const body = { email, verificationCode };
    const res = await this.baseRequest.post<any>(
      '/2fa/verify',
      body
    );
    return res;
  }

  async tempTrasmissionInit(message: string, userId?: string) {
    const body = { message, userId }
    const res = await this.baseRequest.post<any>('/temporary-transmissions', body);
    return res;
  }

  async tempTrasmission(id: string) {
    const res = await this.baseRequest.get<any>(`/temporary-transmissions/${id}`);
    return res;
  }

  async getPartner(partnerId: string) {
    const res = await this.baseRequest.get<any>(`/partners/${partnerId}`);
    return res;
  }

  async acceptScopes(userId: string, body: AcceptScopesBody) {
    const res = await this.baseRequest.post<any>(`/users/${userId}/scopes/accept`, body);
    return res;
  }

  async getPendingTransaction(userId: string, pendingTransactionid: string) {
    const res = await this.baseRequest.get<any>(`/users/${userId}/pending-transactions/${pendingTransactionid}`);
    return res;
  }

  async acceptPendingTransaction(userId: string, pendingTransactionId: string) {
    const res = await this.baseRequest.post<any>(`/users/${userId}/pending-transactions/${pendingTransactionId}/accept`);
    return res;
  }

  async getPolicyPermissions(userId: string, policyId: string) {
    const res = await this.baseRequest.get<any>(`/users/${userId}/policies/${policyId}/permissions`);
    return res;
  }

  async distributeCapsuleShare(userId: string, walletId: string, useDKLS: boolean) {
    const body = { useDKLS };
    const res = await this.baseRequest.post<any>(`/users/${userId}/wallets/${walletId}/capsule-share/distribute`, body);
    return res;
  }
}

export default Client

// GET /users/:userId/wallets/:walletId/send (NOTE: endpoint not found in server)

// NOT USED IN DEMO

// POST /users/:userId/wallets/:walletId/presign
// POST /users/:userId/wallets/:walletId/presign-online
// POST /auth/signup/web
// GET /logout
// POST /users/:userId/wallets/:walletId/key
// GET /users/:userId/wallets/:walletId/key
// GET /users/:userId/configurations
// POST /users/:userId/permissions
// GET /
